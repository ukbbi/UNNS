<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Many-Faces Theorem Interactive Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 10px 10px 0;
        }

        .tab-button {
            background: white;
            border: 2px solid #dee2e6;
            border-bottom: none;
            padding: 12px 20px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 10px 10px 0 0;
            transition: all 0.3s;
            font-weight: 500;
            color: #495057;
        }

        .tab-button:hover {
            background: #f1f3f5;
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: white;
            color: #667eea;
            border-color: #667eea;
            transform: translateY(2px);
            box-shadow: 0 -3px 10px rgba(102, 126, 234, 0.2);
        }

        .tab-content {
            padding: 30px;
            display: none;
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        input[type="number"], select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.3s, box-shadow 0.3s;
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        canvas {
            border: 2px solid #dee2e6;
            border-radius: 10px;
            margin: 20px 0;
            display: block;
            background: white;
        }

        .result-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #2196f3;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
        }

        .table td {
            padding: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .table tr:hover {
            background: #f8f9fa;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .prime-yes {
            color: #28a745;
            font-weight: bold;
        }

        .prime-no {
            color: #6c757d;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted #999;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        #facesMap {
            width: 100%;
            height: 500px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            background: white;
        }

        .proof-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }

        .formula {
            font-family: 'Courier New', monospace;
            background: #e8eaf6;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîÆ UNNS Many-Faces Theorem Explorer</h1>
            <p>Interactive exploration of Unbounded Nested Number Sequences across multiple mathematical domains</p>
        </div>

        <div class="tabs">
            <button class="tab-button active" onclick="showTab('guide')">üìñ Guide</button>
            <button class="tab-button" onclick="showTab('attractor')">üåÄ Attractors</button>
            <button class="tab-button" onclick="showTab('prime')">üî¢ Primes</button>
            <button class="tab-button" onclick="showTab('entropy')">üìä Entropy</button>
            <button class="tab-button" onclick="showTab('mappings')">üîÑ Mappings</button>
            <button class="tab-button" onclick="showTab('detector')">üîç Detector</button>
            <button class="tab-button" onclick="showTab('proof')">üìê Proofs</button>
            <button class="tab-button" onclick="showTab('faces')">üé≠ Faces Map</button>
        </div>

        <div id="guide" class="tab-content active">
            <h2>Welcome to the UNNS Explorer</h2>
            <div class="grid">
                <div class="card">
                    <h3>üöÄ Getting Started</h3>
                    <p>The UNNS framework unifies various linear recurrence sequences through a common mathematical substrate. Each tab explores a different "face" of the theorem.</p>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>Start with the Attractor Visualizer to see geometric patterns</li>
                        <li>Explore prime distributions in sequences</li>
                        <li>Analyze entropy and randomness properties</li>
                        <li>Discover mappings between sequences</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>üìö Theoretical Background</h3>
                    <p>The Many-Faces Theorem states that UNNS systems can:</p>
                    <ol style="margin-left: 20px; margin-top: 10px;">
                        <li>Embed any linear recurrence</li>
                        <li>Generate dominant-root attractors</li>
                        <li>Partition into modular domains</li>
                        <li>Support cross-domain homomorphisms</li>
                        <li>Achieve computational completeness</li>
                    </ol>
                </div>
                <div class="card">
                    <h3>üéØ Key Sequences</h3>
                    <p>This tool implements four classical sequences:</p>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><b>Fibonacci:</b> F(n) = F(n-1) + F(n-2), ratio ‚Üí œÜ ‚âà 1.618</li>
                        <li><b>Pell:</b> P(n) = 2P(n-1) + P(n-2), ratio ‚Üí 1+‚àö2 ‚âà 2.414</li>
                        <li><b>Tribonacci:</b> T(n) = T(n-1) + T(n-2) + T(n-3), ratio ‚Üí ‚âà 1.839</li>
                        <li><b>Padovan:</b> P(n) = P(n-2) + P(n-3), ratio ‚Üí ‚âà 1.325</li>
                    </ul>
                </div>
            </div>
        </div>

        <div id="attractor" class="tab-content">
            <h2>üåÄ Attractor Visualizer</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence Type:</label>
                        <select id="attractorSequence">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="pell">Pell</option>
                            <option value="tribonacci">Tribonacci</option>
                            <option value="padovan">Padovan</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Number of Terms:</label>
                        <input type="number" id="attractorTerms" value="50" min="10" max="200">
                    </div>
                    <div class="control-group">
                        <label>Visualization Type:</label>
                        <select id="vizType">
                            <option value="spiral">Spiral</option>
                            <option value="ratio">Ratio Convergence</option>
                            <option value="both">Both</option>
                        </select>
                    </div>
                </div>
                <button onclick="generateAttractor()">Generate Visualization</button>
            </div>
            <canvas id="attractorCanvas" width="800" height="400"></canvas>
            <div id="attractorResult" class="result-box"></div>
        </div>

        <div id="prime" class="tab-content">
            <h2>üî¢ Prime Analysis Module</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence Type:</label>
                        <select id="primeSequence">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="pell">Pell</option>
                            <option value="tribonacci">Tribonacci</option>
                            <option value="padovan">Padovan</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Terms to Analyze:</label>
                        <input type="number" id="primeTerms" value="30" min="10" max="100">
                    </div>
                </div>
                <button onclick="analyzePrimes()">Analyze Primes</button>
            </div>
            <canvas id="primeCanvas" width="800" height="400"></canvas>
            <div id="primeTable"></div>
        </div>

        <div id="entropy" class="tab-content">
            <h2>üìä Entropy & Randomness Analyzer</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence Type:</label>
                        <select id="entropySequence">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="pell">Pell</option>
                            <option value="tribonacci">Tribonacci</option>
                            <option value="padovan">Padovan</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Modulus:</label>
                        <input type="number" id="entropyModulus" value="7" min="2" max="20">
                    </div>
                    <div class="control-group">
                        <label>Sample Size:</label>
                        <input type="number" id="entropySamples" value="100" min="50" max="500">
                    </div>
                </div>
                <button onclick="analyzeEntropy()">Analyze Entropy</button>
            </div>
            <canvas id="entropyCanvas" width="800" height="400"></canvas>
            <div id="entropyResult" class="result-box"></div>
        </div>

        <div id="mappings" class="tab-content">
            <h2>üîÑ Cross-Sequence Mappings</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Source Sequence:</label>
                        <select id="sourceSeq">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="pell">Pell</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Target Sequence:</label>
                        <select id="targetSeq">
                            <option value="tribonacci">Tribonacci</option>
                            <option value="padovan">Padovan</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Mapping Terms:</label>
                        <input type="number" id="mappingTerms" value="20" min="10" max="50">
                    </div>
                </div>
                <button onclick="generateMapping()">Generate Mapping</button>
            </div>
            <canvas id="mappingCanvas" width="800" height="400"></canvas>
            <div id="mappingResult" class="result-box"></div>
        </div>

        <div id="detector" class="tab-content">
            <h2>üîç Sequence Detector Module</h2>
            <div class="control-panel">
                <div class="control-group">
                    <label>Enter Sequence (comma-separated):</label>
                    <textarea id="inputSequence" rows="3" placeholder="Example: 0,1,1,2,3,5,8,13,21,34"></textarea>
                </div>
                <button onclick="detectSequence()">Detect Pattern</button>
            </div>
            <div id="detectorResult" class="result-box"></div>
        </div>

        <div id="proof" class="tab-content">
            <h2>üìê Proof Explorer</h2>
            <div class="grid">
                <div class="card" onclick="showProof('fibonacci')">
                    <h3>Fibonacci Embedding</h3>
                    <p>Click to explore the proof that Fibonacci sequences are embeddable in UNNS</p>
                </div>
                <div class="card" onclick="showProof('pell')">
                    <h3>Pell Convergence</h3>
                    <p>Click to explore the Pell sequence convergence proof</p>
                </div>
                <div class="card" onclick="showProof('tribonacci')">
                    <h3>Tribonacci Properties</h3>
                    <p>Click to explore Tribonacci sequence properties</p>
                </div>
                <div class="card" onclick="showProof('general')">
                    <h3>General Theorem</h3>
                    <p>Click to explore the general Many-Faces Theorem</p>
                </div>
            </div>
            <div id="proofContent"></div>
        </div>

        <div id="faces" class="tab-content">
            <h2>üé≠ Interactive Faces Map</h2>
            <p>Click on different regions to explore the many faces of UNNS</p>
            <canvas id="facesCanvas" width="800" height="600"></canvas>
            <div id="faceDescription" class="result-box"></div>
        </div>
    </div>

    <script>
        // Sequence generators
        const sequences = {
            fibonacci: { 
                combinator: (a, b) => a + b, 
                seeds: [0, 1], 
                constant: (1 + Math.sqrt(5))/2,
                name: "Fibonacci"
            },
            pell: { 
                combinator: (a, b) => 2*b + a, 
                seeds: [0, 1], 
                constant: 1 + Math.sqrt(2),
                name: "Pell"
            },
            tribonacci: { 
                combinator: (a, b, c) => a + b + c, 
                seeds: [0, 0, 1], 
                constant: 1.839286755214161,
                name: "Tribonacci"
            },
            padovan: { 
                combinator: (a, b, c) => a + b, 
                seeds: [1, 1, 1], 
                constant: 1.324717957244746,
                name: "Padovan"
            }
        };

        function generateSequence(type, n) {
            const seq = sequences[type].seeds.slice();
            const comb = sequences[type].combinator;
            const seedLength = sequences[type].seeds.length;
            
            while (seq.length < n) {
                const args = seq.slice(-seedLength);
                seq.push(comb(...args));
            }
            return seq;
        }

        function showTab(tabId) {
            const tabs = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }

        function generateAttractor() {
            const type = document.getElementById('attractorSequence').value;
            const n = parseInt(document.getElementById('attractorTerms').value);
            const vizType = document.getElementById('vizType').value;
            const seq = generateSequence(type, n);
            const constant = sequences[type].constant;
            
            const canvas = document.getElementById('attractorCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (vizType === 'spiral' || vizType === 'both') {
                // Draw spiral
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let cx = vizType === 'both' ? 200 : 400;
                let cy = 200;
                
                for (let i = 0; i < n; i++) {
                    const r = Math.log(seq[i] + 1) * 20;
                    const theta = i * (2 * Math.PI / constant);
                    const x = cx + r * Math.cos(theta);
                    const y = cy + r * Math.sin(theta);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    
                    // Draw points
                    ctx.fillStyle = `hsl(${(i * 360 / n)}, 70%, 50%)`;
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                }
                ctx.stroke();
            }
            
            if (vizType === 'ratio' || vizType === 'both') {
                // Draw ratio convergence
                const startX = vizType === 'both' ? 450 : 50;
                ctx.strokeStyle = '#764ba2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const ratios = [];
                for (let i = 1; i < n; i++) {
                    if (seq[i-1] !== 0) {
                        ratios.push(seq[i] / seq[i-1]);
                    }
                }
                
                const maxRatio = Math.max(...ratios);
                const minRatio = Math.min(...ratios);
                const range = maxRatio - minRatio;
                
                ratios.forEach((ratio, i) => {
                    const x = startX + (i * 300 / ratios.length);
                    const y = 350 - ((ratio - minRatio) / range * 300);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Draw target ratio line
                ctx.strokeStyle = '#28a745';
                ctx.setLineDash([5, 5]);
                const targetY = 350 - ((constant - minRatio) / range * 300);
                ctx.beginPath();
                ctx.moveTo(startX, targetY);
                ctx.lineTo(startX + 300, targetY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            const lastRatio = seq[n-1] / seq[n-2];
            document.getElementById('attractorResult').innerHTML = `
                <h3>Results for ${sequences[type].name} Sequence</h3>
                <p><b>Target Constant:</b> ${constant.toFixed(6)}</p>
                <p><b>Last Ratio:</b> ${lastRatio.toFixed(6)}</p>
                <p><b>Convergence Error:</b> ${Math.abs(lastRatio - constant).toExponential(3)}</p>
                <p><b>Last Value:</b> ${seq[n-1]}</p>
            `;
        }

        function isPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;
            for (let i = 5; i * i <= num; i += 6) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
            }
            return true;
        }

        function analyzePrimes() {
            const type = document.getElementById('primeSequence').value;
            const n = parseInt(document.getElementById('primeTerms').value);
            const seq = generateSequence(type, n);
            
            const canvas = document.getElementById('primeCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw bar chart of sequence values with prime highlighting
            const maxVal = Math.max(...seq);
            const barWidth = 700 / n;
            
            seq.forEach((val, i) => {
                const barHeight = (val / maxVal) * 300;
                const x = 50 + i * barWidth;
                const y = 350 - barHeight;
                
                ctx.fillStyle = isPrime(val) ? '#28a745' : '#6c757d';
                ctx.fillRect(x, y, barWidth - 2, barHeight);
            });
            
            // Create table
            let tableHtml = '<table class="table"><thead><tr><th>Index</th><th>Value</th><th>Prime?</th><th>Prime Index?</th></tr></thead><tbody>';
            let primeCount = 0;
            let primeIndexCount = 0;
            
            seq.forEach((val, idx) => {
                const valPrime = isPrime(val);
                const idxPrime = isPrime(idx);
                if (valPrime) primeCount++;
                if (idxPrime) primeIndexCount++;
                
                tableHtml += `<tr>
                    <td>${idx}</td>
                    <td>${val}</td>
                    <td class="${valPrime ? 'prime-yes' : 'prime-no'}">${valPrime ? 'Yes' : 'No'}</td>
                    <td class="${idxPrime ? 'prime-yes' : 'prime-no'}">${idxPrime ? 'Yes' : 'No'}</td>
                </tr>`;
            });
            tableHtml += '</tbody></table>';
            tableHtml = `<div class="result-box">
                <h3>Prime Analysis Summary</h3>
                <p><b>Prime Values:</b> ${primeCount} out of ${n} (${(primeCount/n*100).toFixed(1)}%)</p>
                <p><b>Values at Prime Indices:</b> ${primeIndexCount} primes</p>
            </div>` + tableHtml;
            
            document.getElementById('primeTable').innerHTML = tableHtml;
        }

        function analyzeEntropy() {
            const type = document.getElementById('entropySequence').value;
            const m = parseInt(document.getElementById('entropyModulus').value);
            const n = parseInt(document.getElementById('entropySamples').value);
            const seq = generateSequence(type, n);
            
            const residues = seq.map(v => ((v % m) + m) % m);
            const freq = new Array(m).fill(0);
            residues.forEach(r => freq[r]++);
            
            // Calculate Shannon entropy
            let entropy = 0;
            freq.forEach(f => {
                if (f > 0) {
                    const p = f / n;
                    entropy -= p * Math.log2(p);
                }
            });
            
            const maxEntropy = Math.log2(m);
            const normalizedEntropy = entropy / maxEntropy;
            
            // Draw frequency distribution
            const canvas = document.getElementById('entropyCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = 600 / m;
            const maxFreq = Math.max(...freq);
            
            freq.forEach((f, i) => {
                const barHeight = (f / maxFreq) * 300;
                const x = 100 + i * barWidth;
                const y = 350 - barHeight;
                
                const hue = (i * 360 / m);
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.fillRect(x, y, barWidth - 2, barHeight);
                
                // Label
                ctx.fillStyle = '#333';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(i, x + barWidth/2, 370);
                ctx.fillText(f, x + barWidth/2, y - 5);
            });
            
            // Draw uniform distribution line
            ctx.strokeStyle = '#28a745';
            ctx.setLineDash([5, 5]);
            const uniformHeight = 350 - (n/m / maxFreq * 300);
            ctx.beginPath();
            ctx.moveTo(100, uniformHeight);
            ctx.lineTo(700, uniformHeight);
            ctx.stroke();
            ctx.setLineDash([]);
            
            document.getElementById('entropyResult').innerHTML = `
                <h3>Entropy Analysis Results</h3>
                <p><b>Shannon Entropy:</b> ${entropy.toFixed(4)} bits</p>
                <p><b>Maximum Entropy:</b> ${maxEntropy.toFixed(4)} bits</p>
                <p><b>Normalized Entropy:</b> ${(normalizedEntropy * 100).toFixed(2)}%</p>
                <p><b>Chi-squared statistic:</b> ${calculateChiSquared(freq, n/m).toFixed(4)}</p>
                <p>${normalizedEntropy > 0.9 ? '‚úÖ High randomness detected' : '‚ö†Ô∏è Pattern detected in residues'}</p>
            `;
        }

        function calculateChiSquared(observed, expected) {
            return observed.reduce((sum, obs) => {
                return sum + Math.pow(obs - expected, 2) / expected;
            }, 0);
        }

        function generateMapping() {
            const sourceType = document.getElementById('sourceSeq').value;
            const targetType = document.getElementById('targetSeq').value;
            const n = parseInt(document.getElementById('mappingTerms').value);
            
            const sourceSeq = generateSequence(sourceType, n);
            const targetSeq = generateSequence(targetType, n);
            
            const canvas = document.getElementById('mappingCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Normalize sequences for visualization
            const maxSource = Math.max(...sourceSeq);
            const maxTarget = Math.max(...targetSeq);
            
            // Draw source sequence
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            sourceSeq.forEach((val, i) => {
                const x = 50 + (i * 700 / n);
                const y = 200 - (val / maxSource * 150);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw target sequence
            ctx.strokeStyle = '#764ba2';
            ctx.beginPath();
            targetSeq.forEach((val, i) => {
                const x = 50 + (i * 700 / n);
                const y = 350 - (val / maxTarget * 150);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw mapping connections
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < n; i += 3) {
                const x = 50 + (i * 700 / n);
                const y1 = 200 - (sourceSeq[i] / maxSource * 150);
                const y2 = 350 - (targetSeq[i] / maxTarget * 150);
                ctx.beginPath();
                ctx.moveTo(x, y1);
                ctx.lineTo(x, y2);
                ctx.stroke();
            }
            
            // Calculate correlation
            const correlation = calculateCorrelation(sourceSeq, targetSeq);
            
            document.getElementById('mappingResult').innerHTML = `
                <h3>Mapping Analysis</h3>
                <p><b>Source:</b> ${sequences[sourceType].name} (blue)</p>
                <p><b>Target:</b> ${sequences[targetType].name} (purple)</p>
                <p><b>Correlation:</b> ${correlation.toFixed(4)}</p>
                <p><b>Mapping Type:</b> ${Math.abs(correlation) > 0.7 ? 'Strong' : Math.abs(correlation) > 0.4 ? 'Moderate' : 'Weak'} relationship</p>
            `;
        }

        function calculateCorrelation(x, y) {
            const n = x.length;
            const meanX = x.reduce((a, b) => a + b) / n;
            const meanY = y.reduce((a, b) => a + b) / n;
            
            let num = 0, denX = 0, denY = 0;
            for (let i = 0; i < n; i++) {
                num += (x[i] - meanX) * (y[i] - meanY);
                denX += Math.pow(x[i] - meanX, 2);
                denY += Math.pow(y[i] - meanY, 2);
            }
            
            return num / Math.sqrt(denX * denY);
        }

        function detectSequence() {
            const input = document.getElementById('inputSequence').value;
            const seq = input.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            
            if (seq.length < 3) {
                document.getElementById('detectorResult').innerHTML = '<p>Please enter at least 3 numbers</p>';
                return;
            }
            
            let results = [];
            
            // Check Fibonacci
            let isFib = true;
            for (let i = 2; i < seq.length && isFib; i++) {
                if (seq[i] !== seq[i-1] + seq[i-2]) isFib = false;
            }
            if (isFib) results.push('Fibonacci sequence detected');
            
            // Check Pell
            let isPell = true;
            for (let i = 2; i < seq.length && isPell; i++) {
                if (seq[i] !== 2*seq[i-1] + seq[i-2]) isPell = false;
            }
            if (isPell) results.push('Pell sequence detected');
            
            // Check Tribonacci
            let isTrib = seq.length >= 3;
            for (let i = 3; i < seq.length && isTrib; i++) {
                if (seq[i] !== seq[i-1] + seq[i-2] + seq[i-3]) isTrib = false;
            }
            if (isTrib && seq.length > 3) results.push('Tribonacci sequence detected');
            
            // Check for linear recurrence
            if (results.length === 0 && seq.length >= 4) {
                const diffs = [];
                for (let i = 1; i < seq.length; i++) {
                    diffs.push(seq[i] - seq[i-1]);
                }
                const secondDiffs = [];
                for (let i = 1; i < diffs.length; i++) {
                    secondDiffs.push(diffs[i] - diffs[i-1]);
                }
                
                const isArithmetic = diffs.every(d => d === diffs[0]);
                const isQuadratic = secondDiffs.every(d => d === secondDiffs[0]);
                
                if (isArithmetic) results.push('Arithmetic sequence detected');
                else if (isQuadratic) results.push('Quadratic sequence detected');
            }
            
            if (results.length === 0) {
                results.push('Unknown sequence pattern');
            }
            
            // Calculate growth rate
            const ratios = [];
            for (let i = 1; i < seq.length; i++) {
                if (seq[i-1] !== 0) {
                    ratios.push(seq[i] / seq[i-1]);
                }
            }
            const avgRatio = ratios.reduce((a, b) => a + b, 0) / ratios.length;
            
            document.getElementById('detectorResult').innerHTML = `
                <h3>Detection Results</h3>
                <p><b>Pattern:</b> ${results.join(', ')}</p>
                <p><b>Sequence:</b> ${seq.join(', ')}</p>
                <p><b>Length:</b> ${seq.length} terms</p>
                <p><b>Average Growth Rate:</b> ${avgRatio.toFixed(4)}</p>
                <p><b>Max Value:</b> ${Math.max(...seq)}</p>
            `;
        }

        function showProof(type) {
            const proofs = {
                fibonacci: `
                    <div class="proof-section">
                        <h3>Fibonacci Embedding in UNNS</h3>
                        <p><b>Lemma:</b> The Fibonacci sequence F(n) is exactly embeddable in UNNS.</p>
                        <div class="formula">
                        Construction:
                        - S = ‚Ñ§ (nests as integers)
                        - G = {0, 1} (seeds)
                        - Combinator: ‚ãÜ(x, y) = x + y
                        - Update rule: s(n+1) = s(n-1) + s(n)
                        </div>
                        <p><b>Proof by Induction:</b></p>
                        <p>Base: s(0) = 0 = F(0), s(1) = 1 = F(1) ‚úì</p>
                        <p>Step: If s(k) = F(k) for k ‚â§ n, then s(n+1) = s(n-1) + s(n) = F(n-1) + F(n) = F(n+1) ‚úì</p>
                        <p><b>Convergence:</b> By Binet's formula, F(n+1)/F(n) ‚Üí œÜ = (1+‚àö5)/2</p>
                    </div>
                `,
                pell: `
                    <div class="proof-section">
                        <h3>Pell Sequence Convergence</h3>
                        <p><b>Lemma:</b> The Pell sequence P(n) converges to 1+‚àö2.</p>
                        <div class="formula">
                        Recurrence: P(n) = 2P(n-1) + P(n-2)
                        Characteristic polynomial: r¬≤ - 2r - 1 = 0
                        Roots: r = 1 ¬± ‚àö2
                        </div>
                        <p><b>Dominant root:</b> 1 + ‚àö2 ‚âà 2.414</p>
                        <p><b>Closed form:</b> P(n) = [(1+‚àö2)‚Åø - (1-‚àö2)‚Åø] / (2‚àö2)</p>
                        <p>Since |1-‚àö2| < 1, the second term vanishes, yielding convergence.</p>
                    </div>
                `,
                tribonacci: `
                    <div class="proof-section">
                        <h3>Tribonacci Properties</h3>
                        <p><b>Definition:</b> T(n) = T(n-1) + T(n-2) + T(n-3)</p>
                        <div class="formula">
                        Characteristic equation: r¬≥ - r¬≤ - r - 1 = 0
                        Dominant root: œÑ ‚âà 1.839286755
                        </div>
                        <p><b>Key Property:</b> The Tribonacci constant œÑ is the unique real solution.</p>
                        <p><b>UNNS Embedding:</b> Use ternary combinator ‚ãÜ(x,y,z) = x + y + z</p>
                        <p><b>Growth:</b> T(n) ~ AœÑ‚Åø for some constant A</p>
                    </div>
                `,
                general: `
                    <div class="proof-section">
                        <h3>The Many-Faces Theorem</h3>
                        <p><b>Theorem:</b> Any UNNS system U = (S, C, G, {Œº_D}) satisfies:</p>
                        <ol>
                            <li><b>Linear Recurrence Embedding:</b> Any linear recurrence a(n) = Œ£c_i¬∑a(n-i) is embeddable</li>
                            <li><b>Dominant-Root Attractor:</b> Ratios converge to the dominant characteristic root</li>
                            <li><b>Modular Partition:</b> Residues mod m partition into deterministic domains</li>
                            <li><b>Cross-Domain Homomorphism:</b> Structure-preserving mappings exist between encodings</li>
                            <li><b>Computational Completeness:</b> With sufficient combinators, UNNS is Turing-complete</li>
                        </ol>
                        <p><b>Significance:</b> UNNS unifies algebraic, geometric, topological, and computational perspectives.</p>
                    </div>
                `
            };
            
            document.getElementById('proofContent').innerHTML = proofs[type] || '<p>Proof not available</p>';
        }

        // Initialize Faces Map
        function initFacesMap() {
            const canvas = document.getElementById('facesCanvas');
            const ctx = canvas.getContext('2d');
            
            const faces = [
                {name: 'Algebraic', x: 400, y: 100, color: '#667eea'},
                {name: 'Geometric', x: 600, y: 200, color: '#764ba2'},
                {name: 'Topological', x: 650, y: 400, color: '#f39c12'},
                {name: 'Number-Theoretic', x: 400, y: 500, color: '#27ae60'},
                {name: 'Computational', x: 150, y: 400, color: '#e74c3c'},
                {name: 'Modular', x: 200, y: 200, color: '#3498db'}
            ];
            
            function drawFaces() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw center
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(400, 300, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('UNNS', 400, 305);
                
                // Draw connections
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 2;
                faces.forEach(face => {
                    ctx.beginPath();
                    ctx.moveTo(400, 300);
                    ctx.lineTo(face.x, face.y);
                    ctx.stroke();
                });
                
                // Draw face nodes
                faces.forEach(face => {
                    ctx.fillStyle = face.color;
                    ctx.beginPath();
                    ctx.arc(face.x, face.y, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(face.name, face.x, face.y + 5);
                });
            }
            
            drawFaces();
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                faces.forEach(face => {
                    const dist = Math.sqrt(Math.pow(x - face.x, 2) + Math.pow(y - face.y, 2));
                    if (dist <= 40) {
                        showFaceDescription(face.name);
                    }
                });
                
                // Check center
                const centerDist = Math.sqrt(Math.pow(x - 400, 2) + Math.pow(y - 300, 2));
                if (centerDist <= 50) {
                    showFaceDescription('UNNS Core');
                }
            });
        }

        function showFaceDescription(faceName) {
            const descriptions = {
                'Algebraic': 'The algebraic face deals with polynomial representations, characteristic equations, and linear algebra structures embedded in UNNS.',
                'Geometric': 'The geometric face explores spiral attractors, growth patterns, and visual representations of sequence dynamics.',
                'Topological': 'The topological face examines graph structures, connectivity patterns, and invariant properties under continuous transformations.',
                'Number-Theoretic': 'The number-theoretic face investigates prime distributions, divisibility properties, and modular arithmetic patterns.',
                'Computational': 'The computational face addresses algorithmic complexity, Turing completeness, and finite automata simulations.',
                'Modular': 'The modular face analyzes residue patterns, cyclic behaviors, and finite field properties of sequences.',
                'UNNS Core': 'The central UNNS framework unifies all mathematical faces through combinator algebras and domain mappings.'
            };
            
            document.getElementById('faceDescription').innerHTML = `
                <h3>${faceName}</h3>
                <p>${descriptions[faceName] || 'Click on a face to learn more.'}</p>
            `;
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initFacesMap();
        });
    </script>
</body>
</html>