<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Advanced Mathematical Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 10px 10px 0;
            gap: 5px;
        }

        .tab-button {
            background: white;
            border: 2px solid #dee2e6;
            border-bottom: none;
            padding: 10px 16px;
            cursor: pointer;
            border-radius: 10px 10px 0 0;
            transition: all 0.3s;
            font-weight: 500;
            color: #495057;
            font-size: 14px;
        }

        .tab-button:hover {
            background: #f1f3f5;
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: white;
            color: #667eea;
            border-color: #667eea;
            transform: translateY(2px);
            box-shadow: 0 -3px 10px rgba(102, 126, 234, 0.2);
        }

        .tab-content {
            padding: 30px;
            display: none;
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.3s, box-shadow 0.3s;
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        canvas {
            border: 2px solid #dee2e6;
            border-radius: 10px;
            margin: 20px 0;
            display: block;
            background: white;
        }

        .result-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #2196f3;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .matrix-display {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .formula {
            font-family: 'Courier New', monospace;
            background: #e8eaf6;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            overflow-x: auto;
        }

        .animation-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }

        .speed-slider {
            width: 200px;
        }

        .sequence-item {
            display: inline-block;
            padding: 8px 12px;
            margin: 5px;
            background: #e3f2fd;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .sequence-item.highlight {
            background: #667eea;
            color: white;
            transform: scale(1.2);
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
        }

        .table td {
            padding: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .custom-input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 5px;
            margin: 10px 0;
        }

        .custom-input-grid input {
            padding: 5px;
            text-align: center;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
        }

        @keyframes particleFlow {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }

        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted #999;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîÆ UNNS Advanced Mathematical Explorer</h1>
            <p>Extended sequences, advanced analysis, and real-time animations</p>
        </div>

        <div class="tabs">
            <button class="tab-button active" onclick="showTab('sequences')">üìö Sequences</button>
            <button class="tab-button" onclick="showTab('custom')">üîß Custom</button>
            <button class="tab-button" onclick="showTab('animation')">üé¨ Animation</button>
            <button class="tab-button" onclick="showTab('matrix')">‚äû Matrix</button>
            <button class="tab-button" onclick="showTab('binet')">üìê Binet</button>
            <button class="tab-button" onclick="showTab('generating')">‚àë Generating</button>
            <button class="tab-button" onclick="showTab('padic')">p-adic</button>
            <button class="tab-button" onclick="showTab('modular')">‚óâ Modular</button>
            <button class="tab-button" onclick="showTab('nonlinear')">‚àø Non-Linear</button>
        </div>

        <div id="sequences" class="tab-content active">
            <h2>üìö Extended Sequence Library</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence Type:</label>
                        <select id="extendedSequence" onchange="updateSequenceInfo()">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="lucas">Lucas</option>
                            <option value="pell">Pell</option>
                            <option value="jacobsthal">Jacobsthal</option>
                            <option value="narayana">Narayana</option>
                            <option value="perrin">Perrin</option>
                            <option value="tribonacci">Tribonacci</option>
                            <option value="tetranacci">Tetranacci</option>
                            <option value="pentanacci">Pentanacci</option>
                            <option value="padovan">Padovan</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Number of Terms:</label>
                        <input type="number" id="seqTerms" value="30" min="5" max="100">
                    </div>
                </div>
                <button onclick="generateExtendedSequence()">Generate & Analyze</button>
            </div>
            <div id="sequenceInfo" class="result-box"></div>
            <canvas id="seqCanvas" width="900" height="400"></canvas>
            <div id="seqAnalysis" class="result-box"></div>
            <div id="seqTable"></div>
        </div>

        <div id="custom" class="tab-content">
            <h2>üîß Custom Linear Recurrence</h2>
            <div class="control-panel">
                <div class="control-group">
                    <label>Recurrence Order (k):</label>
                    <input type="number" id="customOrder" value="3" min="2" max="10" onchange="updateCustomInputs()">
                </div>
                <div class="control-group">
                    <label>Coefficients (c‚ÇÅ, c‚ÇÇ, ..., c‚Çñ):</label>
                    <div id="coeffInputs" class="custom-input-grid"></div>
                </div>
                <div class="control-group">
                    <label>Initial Values:</label>
                    <div id="seedInputs" class="custom-input-grid"></div>
                </div>
                <div class="control-group">
                    <label>Generate Terms:</label>
                    <input type="number" id="customTerms" value="30" min="5" max="100">
                </div>
                <button onclick="generateCustomSequence()">Generate Custom Sequence</button>
            </div>
            <div class="formula" id="customFormula"></div>
            <canvas id="customCanvas" width="900" height="400"></canvas>
            <div id="customResult" class="result-box"></div>
        </div>

        <div id="animation" class="tab-content">
            <h2>üé¨ Real-Time Animation</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Animation Type:</label>
                        <select id="animationType">
                            <option value="termByTerm">Term-by-Term Generation</option>
                            <option value="morph">Sequence Morphing</option>
                            <option value="modularFlow">Modular Residue Flow</option>
                            <option value="ratioConverge">Ratio Convergence</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Sequence:</label>
                        <select id="animSeq">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="lucas">Lucas</option>
                            <option value="pell">Pell</option>
                            <option value="tribonacci">Tribonacci</option>
                        </select>
                    </div>
                </div>
                <div class="animation-controls">
                    <button onclick="startAnimation()">‚ñ∂ Play</button>
                    <button onclick="pauseAnimation()">‚è∏ Pause</button>
                    <button onclick="resetAnimation()">‚èπ Reset</button>
                    <label>Speed:</label>
                    <input type="range" class="speed-slider" id="animSpeed" min="1" max="10" value="5">
                </div>
            </div>
            <div id="animationDisplay"></div>
            <canvas id="animCanvas" width="900" height="400"></canvas>
            <div id="animInfo" class="result-box"></div>
        </div>

        <div id="matrix" class="tab-content">
            <h2>‚äû Matrix Representation</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence Type:</label>
                        <select id="matrixSeq">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="lucas">Lucas</option>
                            <option value="pell">Pell</option>
                            <option value="tribonacci">Tribonacci</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Matrix Power (n):</label>
                        <input type="number" id="matrixPower" value="10" min="1" max="20">
                    </div>
                </div>
                <button onclick="computeMatrix()">Compute Matrix Powers</button>
            </div>
            <div id="matrixDisplay" class="matrix-display"></div>
            <canvas id="matrixCanvas" width="900" height="400"></canvas>
            <div id="matrixResult" class="result-box"></div>
        </div>

        <div id="binet" class="tab-content">
            <h2>üìê Binet Formula Calculator</h2>
            <div class="control-panel">
                <div class="control-group">
                    <label>Select or enter characteristic polynomial:</label>
                    <select id="binetType" onchange="updateBinetInputs()">
                        <option value="fibonacci">Fibonacci (x¬≤ - x - 1)</option>
                        <option value="lucas">Lucas (x¬≤ - x - 1)</option>
                        <option value="pell">Pell (x¬≤ - 2x - 1)</option>
                        <option value="custom">Custom Polynomial</option>
                    </select>
                </div>
                <div id="binetCustom" style="display:none;">
                    <label>Enter polynomial coefficients (highest to lowest degree):</label>
                    <div id="polyInputs" class="custom-input-grid"></div>
                </div>
                <button onclick="calculateBinet()">Calculate Binet Formula</button>
            </div>
            <div id="binetFormula" class="formula"></div>
            <canvas id="binetCanvas" width="900" height="400"></canvas>
            <div id="binetResult" class="result-box"></div>
        </div>

        <div id="generating" class="tab-content">
            <h2>‚àë Generating Functions</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence Type:</label>
                        <select id="genSeq">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="lucas">Lucas</option>
                            <option value="pell">Pell</option>
                            <option value="catalan">Catalan</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Function Type:</label>
                        <select id="genType">
                            <option value="ordinary">Ordinary (OGF)</option>
                            <option value="exponential">Exponential (EGF)</option>
                        </select>
                    </div>
                </div>
                <button onclick="generateFunction()">Generate Function</button>
            </div>
            <div id="genFormula" class="formula"></div>
            <canvas id="genCanvas" width="900" height="400"></canvas>
            <div id="genResult" class="result-box"></div>
        </div>

        <div id="padic" class="tab-content">
            <h2>p-adic Analysis</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence:</label>
                        <select id="padicSeq">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="lucas">Lucas</option>
                            <option value="pell">Pell</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Prime p:</label>
                        <input type="number" id="padicPrime" value="5" min="2" max="31">
                    </div>
                    <div class="control-group">
                        <label>Terms to Analyze:</label>
                        <input type="number" id="padicTerms" value="30" min="10" max="100">
                    </div>
                </div>
                <button onclick="analyzePadic()">Analyze p-adic Properties</button>
            </div>
            <canvas id="padicCanvas" width="900" height="400"></canvas>
            <div id="padicResult" class="result-box"></div>
            <div id="padicTable"></div>
        </div>

        <div id="modular" class="tab-content">
            <h2>‚óâ Modular Visualization</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence:</label>
                        <select id="modSeq">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="lucas">Lucas</option>
                            <option value="pell">Pell</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Modulus:</label>
                        <input type="number" id="modValue" value="12" min="2" max="50">
                    </div>
                    <div class="control-group">
                        <label>Terms:</label>
                        <input type="number" id="modTerms" value="100" min="50" max="500">
                    </div>
                </div>
                <button onclick="visualizeModular()">Visualize Modular Pattern</button>
                <button onclick="startModularAnimation()">Animate Flow</button>
            </div>
            <canvas id="modCanvas" width="900" height="500"></canvas>
            <div id="modResult" class="result-box"></div>
        </div>

        <div id="nonlinear" class="tab-content">
            <h2>‚àø Non-Linear Sequences</h2>
            <div class="control-panel">
                <div class="grid">
                    <div class="control-group">
                        <label>Sequence Type:</label>
                        <select id="nonlinearSeq">
                            <option value="catalan">Catalan Numbers</option>
                            <option value="factorial">Factorial</option>
                            <option value="bell">Bell Numbers</option>
                            <option value="prime">Prime Numbers</option>
                            <option value="partition">Partition Function</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Terms:</label>
                        <input type="number" id="nonlinearTerms" value="20" min="5" max="50">
                    </div>
                </div>
                <button onclick="generateNonlinear()">Generate & Compare</button>
            </div>
            <canvas id="nonlinearCanvas" width="900" height="400"></canvas>
            <div id="nonlinearResult" class="result-box"></div>
            <div id="nonlinearComparison"></div>
        </div>
    </div>

    <script>
        // Extended sequence definitions
        const sequences = {
            fibonacci: { 
                recurrence: [1, 1], 
                seeds: [0, 1], 
                name: "Fibonacci",
                constant: (1 + Math.sqrt(5))/2
            },
            lucas: { 
                recurrence: [1, 1], 
                seeds: [2, 1], 
                name: "Lucas",
                constant: (1 + Math.sqrt(5))/2
            },
            pell: { 
                recurrence: [2, 1], 
                seeds: [0, 1], 
                name: "Pell",
                constant: 1 + Math.sqrt(2)
            },
            jacobsthal: { 
                recurrence: [1, 2], 
                seeds: [0, 1], 
                name: "Jacobsthal",
                constant: 2
            },
            narayana: { 
                recurrence: [1, 1], 
                seeds: [1, 1], 
                name: "Narayana",
                constant: (1 + Math.sqrt(5))/2
            },
            perrin: { 
                recurrence: [0, 1, 1], 
                seeds: [3, 0, 2], 
                name: "Perrin",
                constant: 1.324717957
            },
            tribonacci: { 
                recurrence: [1, 1, 1], 
                seeds: [0, 0, 1], 
                name: "Tribonacci",
                constant: 1.839286755
            },
            tetranacci: { 
                recurrence: [1, 1, 1, 1], 
                seeds: [0, 0, 0, 1], 
                name: "Tetranacci",
                constant: 1.927561975
            },
            pentanacci: { 
                recurrence: [1, 1, 1, 1, 1], 
                seeds: [0, 0, 0, 0, 1], 
                name: "Pentanacci",
                constant: 1.965948236
            },
            padovan: { 
                recurrence: [0, 1, 1], 
                seeds: [1, 1, 1], 
                name: "Padovan",
                constant: 1.324717957
            }
        };

        // Animation state
        let animationId = null;
        let animationFrame = 0;
        let animationData = null;

        // Generate linear recurrence sequence
        function generateLinearSequence(coeffs, seeds, n) {
            const seq = seeds.slice();
            const order = coeffs.length;
            
            while (seq.length < n) {
                let next = 0;
                for (let i = 0; i < order; i++) {
                    next += coeffs[i] * seq[seq.length - order + i];
                }
                seq.push(next);
            }
            return seq;
        }

        // Matrix operations
        function multiplyMatrix(A, B) {
            const n = A.length;
            const C = Array(n).fill(null).map(() => Array(n).fill(0));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    for (let k = 0; k < n; k++) {
                        C[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return C;
        }

        function matrixPower(M, n) {
            if (n === 1) return M;
            if (n % 2 === 0) {
                const half = matrixPower(M, n/2);
                return multiplyMatrix(half, half);
            }
            return multiplyMatrix(M, matrixPower(M, n-1));
        }

        // Tab management
        function showTab(tabId) {
            const tabs = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }

        // Extended sequences functions
        function updateSequenceInfo() {
            const type = document.getElementById('extendedSequence').value;
            const seq = sequences[type];
            document.getElementById('sequenceInfo').innerHTML = `
                <h3>${seq.name} Sequence</h3>
                <p><b>Recurrence coefficients:</b> [${seq.recurrence.join(', ')}]</p>
                <p><b>Initial values:</b> [${seq.seeds.join(', ')}]</p>
                <p><b>Limit ratio:</b> ${seq.constant.toFixed(6)}</p>
            `;
        }

        function generateExtendedSequence() {
            const type = document.getElementById('extendedSequence').value;
            const n = parseInt(document.getElementById('seqTerms').value);
            const seqDef = sequences[type];
            
            const seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, n);
            
            // Visualize
            const canvas = document.getElementById('seqCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw sequence values
            const maxVal = Math.max(...seq.slice(0, Math.min(n, 30)));
            const barWidth = 800 / Math.min(n, 30);
            
            ctx.fillStyle = '#667eea';
            seq.slice(0, Math.min(n, 30)).forEach((val, i) => {
                const height = (val / maxVal) * 300;
                ctx.fillRect(50 + i * barWidth, 350 - height, barWidth - 2, height);
            });
            
            // Analysis
            const ratios = [];
            for (let i = 1; i < seq.length; i++) {
                if (seq[i-1] !== 0) ratios.push(seq[i] / seq[i-1]);
            }
            const lastRatio = ratios[ratios.length - 1];
            
            document.getElementById('seqAnalysis').innerHTML = `
                <h3>Analysis</h3>
                <p><b>Generated ${n} terms</b></p>
                <p><b>Last value:</b> ${seq[n-1]}</p>
                <p><b>Last ratio:</b> ${lastRatio ? lastRatio.toFixed(6) : 'N/A'}</p>
                <p><b>Convergence error:</b> ${lastRatio ? Math.abs(lastRatio - seqDef.constant).toExponential(3) : 'N/A'}</p>
            `;
            
            // Table
            let table = '<table class="table"><thead><tr><th>n</th><th>Value</th><th>Ratio</th></tr></thead><tbody>';
            for (let i = 0; i < Math.min(20, n); i++) {
                const ratio = i > 0 && seq[i-1] !== 0 ? (seq[i]/seq[i-1]).toFixed(4) : '-';
                table += `<tr><td>${i}</td><td>${seq[i]}</td><td>${ratio}</td></tr>`;
            }
            table += '</tbody></table>';
            document.getElementById('seqTable').innerHTML = table;
        }

        // Custom sequence functions
        function updateCustomInputs() {
            const order = parseInt(document.getElementById('customOrder').value);
            
            let coeffHtml = '';
            let seedHtml = '';
            
            for (let i = 0; i < order; i++) {
                coeffHtml += `<input type="number" id="coeff${i}" value="1" step="any">`;
                seedHtml += `<input type="number" id="seed${i}" value="${i}" step="any">`;
            }
            
            document.getElementById('coeffInputs').innerHTML = coeffHtml;
            document.getElementById('seedInputs').innerHTML = seedHtml;
        }

        function generateCustomSequence() {
            const order = parseInt(document.getElementById('customOrder').value);
            const n = parseInt(document.getElementById('customTerms').value);
            
            const coeffs = [];
            const seeds = [];
            
            for (let i = 0; i < order; i++) {
                coeffs.push(parseFloat(document.getElementById(`coeff${i}`).value) || 0);
                seeds.push(parseFloat(document.getElementById(`seed${i}`).value) || 0);
            }
            
            // Display formula
            let formula = 'a(n) = ';
            coeffs.forEach((c, i) => {
                if (i > 0) formula += ' + ';
                formula += `${c}¬∑a(n-${order-i})`;
            });
            document.getElementById('customFormula').innerHTML = formula;
            
            // Generate sequence
            const seq = generateLinearSequence(coeffs, seeds, n);
            
            // Visualize
            const canvas = document.getElementById('customCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Scale for visualization
            const maxVal = Math.max(...seq.filter(v => Math.abs(v) < Infinity));
            const minVal = Math.min(...seq.filter(v => Math.abs(v) < Infinity));
            const range = maxVal - minVal || 1;
            
            ctx.strokeStyle = '#764ba2';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            seq.forEach((val, i) => {
                const x = 50 + (i * 800 / n);
                const y = 350 - ((val - minVal) / range * 300);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Calculate characteristic polynomial roots (simplified)
            document.getElementById('customResult').innerHTML = `
                <h3>Custom Sequence Generated</h3>
                <p><b>Order:</b> ${order}</p>
                <p><b>Coefficients:</b> [${coeffs.join(', ')}]</p>
                <p><b>Seeds:</b> [${seeds.join(', ')}]</p>
                <p><b>Last value:</b> ${seq[n-1]}</p>
            `;
        }

        // Animation functions
        function startAnimation() {
            const type = document.getElementById('animationType').value;
            const seqType = document.getElementById('animSeq').value;
            
            if (animationId) cancelAnimationFrame(animationId);
            animationFrame = 0;
            
            switch(type) {
                case 'termByTerm':
                    animateTermByTerm(seqType);
                    break;
                case 'morph':
                    animateMorph();
                    break;
                case 'modularFlow':
                    animateModularFlow(seqType);
                    break;
                case 'ratioConverge':
                    animateRatioConvergence(seqType);
                    break;
            }
        }

        function pauseAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function resetAnimation() {
            pauseAnimation();
            animationFrame = 0;
            const canvas = document.getElementById('animCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('animationDisplay').innerHTML = '';
        }

        function animateTermByTerm(seqType) {
            const seqDef = sequences[seqType];
            const seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, 30);
            const speed = 11 - parseInt(document.getElementById('animSpeed').value);
            
            let html = '<div style="padding: 20px;">';
            
            function animate() {
                if (animationFrame < seq.length) {
                    html = '<div style="padding: 20px;">';
                    for (let i = 0; i <= animationFrame; i++) {
                        html += `<span class="sequence-item ${i === animationFrame ? 'highlight' : ''}">${seq[i]}</span>`;
                    }
                    html += '</div>';
                    document.getElementById('animationDisplay').innerHTML = html;
                    
                    if (animationFrame > 1) {
                        const ratio = seq[animationFrame] / seq[animationFrame - 1];
                        document.getElementById('animInfo').innerHTML = `
                            <p><b>Term ${animationFrame}:</b> ${seq[animationFrame]}</p>
                            <p><b>Ratio to previous:</b> ${ratio.toFixed(6)}</p>
                            <p><b>Target ratio:</b> ${seqDef.constant.toFixed(6)}</p>
                        `;
                    }
                    
                    animationFrame++;
                    animationId = setTimeout(() => animate(), speed * 100);
                }
            }
            animate();
        }

        function animateMorph() {
            const canvas = document.getElementById('animCanvas');
            const ctx = canvas.getContext('2d');
            const speed = parseInt(document.getElementById('animSpeed').value);
            
            const seq1 = generateLinearSequence([1, 1], [0, 1], 20); // Fibonacci
            const seq2 = generateLinearSequence([2, 1], [0, 1], 20); // Pell
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const t = (Math.sin(animationFrame * 0.02 * speed) + 1) / 2;
                
                ctx.strokeStyle = `hsl(${t * 60 + 240}, 70%, 50%)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < 20; i++) {
                    const val = seq1[i] * (1-t) + seq2[i] * t;
                    const x = 50 + i * 40;
                    const y = 350 - val * 10;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                document.getElementById('animInfo').innerHTML = `
                    <p><b>Morphing:</b> ${(100 * (1-t)).toFixed(0)}% Fibonacci, ${(100 * t).toFixed(0)}% Pell</p>
                `;
                
                animationFrame++;
                animationId = requestAnimationFrame(animate);
            }
            animate();
        }

        function animateModularFlow(seqType) {
            const canvas = document.getElementById('animCanvas');
            const ctx = canvas.getContext('2d');
            const seqDef = sequences[seqType];
            const seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, 100);
            const modulus = 12;
            const speed = parseInt(document.getElementById('animSpeed').value);
            
            function animate() {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const index = Math.floor(animationFrame / 5) % seq.length;
                const residue = ((seq[index] % modulus) + modulus) % modulus;
                
                // Draw modular circle
                const cx = 450, cy = 200, radius = 150;
                
                for (let i = 0; i < modulus; i++) {
                    const angle = (i / modulus) * 2 * Math.PI - Math.PI/2;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    
                    ctx.fillStyle = i === residue ? '#667eea' : '#e0e0e0';
                    ctx.beginPath();
                    ctx.arc(x, y, i === residue ? 15 : 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    if (i === residue) {
                        // Add particle effect
                        ctx.fillStyle = `rgba(102, 126, 234, ${0.5 + 0.5 * Math.sin(animationFrame * 0.1)})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 20, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                document.getElementById('animInfo').innerHTML = `
                    <p><b>Term ${index}:</b> ${seq[index]}</p>
                    <p><b>Residue (mod ${modulus}):</b> ${residue}</p>
                `;
                
                animationFrame++;
                animationId = requestAnimationFrame(animate);
            }
            animate();
        }

        function animateRatioConvergence(seqType) {
            const canvas = document.getElementById('animCanvas');
            const ctx = canvas.getContext('2d');
            const seqDef = sequences[seqType];
            const seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, 50);
            const speed = parseInt(document.getElementById('animSpeed').value);
            
            const ratios = [];
            for (let i = 1; i < seq.length; i++) {
                if (seq[i-1] !== 0) ratios.push(seq[i] / seq[i-1]);
            }
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const displayCount = Math.min(Math.floor(animationFrame / 2), ratios.length);
                
                // Draw target line
                ctx.strokeStyle = '#28a745';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                const targetY = 200;
                ctx.moveTo(50, targetY);
                ctx.lineTo(850, targetY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw ratios
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < displayCount; i++) {
                    const x = 50 + (i * 800 / ratios.length);
                    const deviation = (ratios[i] - seqDef.constant) * 100;
                    const y = targetY - deviation;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    
                    // Draw point
                    ctx.fillStyle = '#667eea';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
                ctx.stroke();
                
                if (displayCount > 0) {
                    const lastRatio = ratios[displayCount - 1];
                    document.getElementById('animInfo').innerHTML = `
                        <p><b>Term ${displayCount}:</b> Ratio = ${lastRatio.toFixed(8)}</p>
                        <p><b>Target:</b> ${seqDef.constant.toFixed(8)}</p>
                        <p><b>Error:</b> ${Math.abs(lastRatio - seqDef.constant).toExponential(3)}</p>
                    `;
                }
                
                animationFrame++;
                if (displayCount < ratios.length) {
                    animationId = setTimeout(() => animate(), 50 * (11 - speed));
                }
            }
            animate();
        }

        // Matrix functions
        function computeMatrix() {
            const type = document.getElementById('matrixSeq').value;
            const n = parseInt(document.getElementById('matrixPower').value);
            const seqDef = sequences[type];
            
            // Construct companion matrix
            const order = seqDef.recurrence.length;
            const matrix = Array(order).fill(null).map(() => Array(order).fill(0));
            
            // Fill first row with coefficients
            for (let i = 0; i < order; i++) {
                matrix[0][i] = seqDef.recurrence[i];
            }
            
            // Fill subdiagonal with 1s
            for (let i = 1; i < order; i++) {
                matrix[i][i-1] = 1;
            }
            
            // Display initial matrix
            let display = '<h3>Companion Matrix:</h3><pre>';
            matrix.forEach(row => {
                display += '[' + row.map(v => v.toString().padStart(3)).join(' ') + ']\n';
            });
            display += '</pre>';
            
            // Compute matrix power
            const matrixN = matrixPower(matrix, n);
            
            display += `<h3>Matrix^${n}:</h3><pre>`;
            matrixN.forEach(row => {
                display += '[' + row.map(v => v.toFixed(0).padStart(8)).join(' ') + ']\n';
            });
            display += '</pre>';
            
            document.getElementById('matrixDisplay').innerHTML = display;
            
            // Verify sequence generation
            const seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, n + 1);
            
            document.getElementById('matrixResult').innerHTML = `
                <h3>Verification</h3>
                <p><b>Sequence term ${n}:</b> ${seq[n]}</p>
                <p><b>From matrix:</b> ${matrixN[0][0] * seqDef.seeds[order-1] + (order > 1 ? matrixN[0][1] * seqDef.seeds[order-2] : 0)}</p>
                <p>The matrix powers encode the sequence values!</p>
            `;
            
            // Visualize eigenvalues (simplified)
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#667eea';
            ctx.font = '16px monospace';
            ctx.fillText(`Dominant eigenvalue ‚âà ${seqDef.constant.toFixed(6)}`, 50, 50);
        }

        // Binet formula functions
        function updateBinetInputs() {
            const type = document.getElementById('binetType').value;
            if (type === 'custom') {
                document.getElementById('binetCustom').style.display = 'block';
                let html = '';
                for (let i = 0; i <= 2; i++) {
                    html += `<input type="number" id="poly${i}" placeholder="x^${2-i}" value="${i === 0 ? 1 : i === 1 ? -1 : -1}">`;
                }
                document.getElementById('polyInputs').innerHTML = html;
            } else {
                document.getElementById('binetCustom').style.display = 'none';
            }
        }

        function calculateBinet() {
            const type = document.getElementById('binetType').value;
            let coeffs;
            
            if (type === 'custom') {
                coeffs = [
                    parseFloat(document.getElementById('poly0').value) || 1,
                    parseFloat(document.getElementById('poly1').value) || 0,
                    parseFloat(document.getElementById('poly2').value) || 0
                ];
            } else {
                const polynomials = {
                    fibonacci: [1, -1, -1],
                    lucas: [1, -1, -1],
                    pell: [1, -2, -1]
                };
                coeffs = polynomials[type];
            }
            
            // Solve quadratic (simplified for quadratic case)
            const a = coeffs[0], b = coeffs[1], c = coeffs[2];
            const discriminant = b * b - 4 * a * c;
            const root1 = (-b + Math.sqrt(Math.abs(discriminant))) / (2 * a);
            const root2 = (-b - Math.sqrt(Math.abs(discriminant))) / (2 * a);
            
            let formula = '<h3>Binet Formula</h3>';
            formula += `<p>Characteristic equation: ${a}x¬≤ ${b >= 0 ? '+' : ''}${b}x ${c >= 0 ? '+' : ''}${c} = 0</p>`;
            formula += `<p>Roots: r‚ÇÅ = ${root1.toFixed(6)}, r‚ÇÇ = ${root2.toFixed(6)}</p>`;
            
            if (discriminant >= 0) {
                formula += `<p>Closed form: a(n) = A¬∑(${root1.toFixed(3)})‚Åø + B¬∑(${root2.toFixed(3)})‚Åø</p>`;
            } else {
                formula += `<p>Complex roots - spiral behavior</p>`;
            }
            
            document.getElementById('binetFormula').innerHTML = formula;
            
            // Visualize convergence
            const canvas = document.getElementById('binetCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (discriminant >= 0 && Math.abs(root1) > Math.abs(root2)) {
                // Draw exponential growth
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let n = 0; n <= 20; n++) {
                    const val = Math.pow(root1, n);
                    const x = 50 + n * 40;
                    const y = 350 - Math.min(val * 10, 300);
                    
                    if (n === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                document.getElementById('binetResult').innerHTML = `
                    <h3>Analysis</h3>
                    <p><b>Dominant root:</b> ${root1.toFixed(6)}</p>
                    <p><b>Growth rate:</b> Exponential with base ${Math.abs(root1).toFixed(3)}</p>
                `;
            }
        }

        // Generating functions
        function generateFunction() {
            const seqType = document.getElementById('genSeq').value;
            const funcType = document.getElementById('genType').value;
            
            const functions = {
                fibonacci: {
                    ordinary: 'x / (1 - x - x¬≤)',
                    exponential: 'exp(x) ¬∑ sinh(x‚àö5) / ‚àö5'
                },
                lucas: {
                    ordinary: '(2 - x) / (1 - x - x¬≤)',
                    exponential: 'exp(x) ¬∑ (2cosh(x‚àö5) + sinh(x‚àö5)/‚àö5)'
                },
                pell: {
                    ordinary: 'x / (1 - 2x - x¬≤)',
                    exponential: 'exp(x) ¬∑ sinh(x‚àö2) / ‚àö2'
                },
                catalan: {
                    ordinary: '(1 - ‚àö(1 - 4x)) / 2x',
                    exponential: 'Œ£(n!¬∑C‚Çô¬∑x‚Åø/n!)'
                }
            };
            
            const formula = functions[seqType][funcType];
            
            document.getElementById('genFormula').innerHTML = `
                <h3>${funcType === 'ordinary' ? 'Ordinary' : 'Exponential'} Generating Function</h3>
                <p>${sequences[seqType]?.name || 'Catalan'}: G(x) = ${formula}</p>
            `;
            
            // Visualize power series coefficients
            const canvas = document.getElementById('genCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let seq;
            if (seqType === 'catalan') {
                seq = [];
                for (let n = 0; n < 10; n++) {
                    seq.push(catalan(n));
                }
            } else {
                const seqDef = sequences[seqType];
                seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, 20);
            }
            
            // Draw coefficients
            const maxVal = Math.max(...seq.slice(0, 10));
            ctx.fillStyle = '#667eea';
            
            seq.slice(0, 10).forEach((val, i) => {
                const height = (val / maxVal) * 300;
                ctx.fillRect(100 + i * 70, 350 - height, 50, height);
                
                ctx.fillStyle = '#333';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`x^${i}`, 125 + i * 70, 370);
                ctx.fillText(val.toString(), 125 + i * 70, 340 - height);
                ctx.fillStyle = '#667eea';
            });
            
            document.getElementById('genResult').innerHTML = `
                <h3>Power Series Expansion</h3>
                <p>G(x) = ${seq.slice(0, 5).map((v, i) => `${v}x^${i}`).join(' + ')} + ...</p>
            `;
        }

        // p-adic analysis
        function analyzePadic() {
            const seqType = document.getElementById('padicSeq').value;
            const p = parseInt(document.getElementById('padicPrime').value);
            const n = parseInt(document.getElementById('padicTerms').value);
            
            // Check if p is prime
            if (!isPrime(p)) {
                document.getElementById('padicResult').innerHTML = `<p style="color:red;">Please enter a prime number</p>`;
                return;
            }
            
            const seqDef = sequences[seqType];
            const seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, n);
            
            // Calculate p-adic valuations
            const valuations = seq.map(val => padicValuation(val, p));
            
            // Visualize
            const canvas = document.getElementById('padicCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw valuations
            const maxVal = Math.max(...valuations.filter(v => v !== Infinity));
            const barWidth = 800 / n;
            
            valuations.forEach((val, i) => {
                if (val !== Infinity) {
                    const height = ((val + 1) / (maxVal + 1)) * 300;
                    const hue = (val * 60) % 360;
                    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                    ctx.fillRect(50 + i * barWidth, 350 - height, barWidth - 1, height);
                }
            });
            
            // Analysis
            const period = findPisanoPeriod(seqDef, p);
            
            document.getElementById('padicResult').innerHTML = `
                <h3>${p}-adic Analysis</h3>
                <p><b>Prime p:</b> ${p}</p>
                <p><b>Pisano period:</b> ${period || 'Not found in range'}</p>
                <p><b>Max valuation:</b> ${maxVal}</p>
            `;
            
            // Table
            let table = '<table class="table"><thead><tr><th>n</th><th>a(n)</th><th>v_p(a(n))</th></tr></thead><tbody>';
            for (let i = 0; i < Math.min(20, n); i++) {
                table += `<tr><td>${i}</td><td>${seq[i]}</td><td>${valuations[i] === Infinity ? '‚àû' : valuations[i]}</td></tr>`;
            }
            table += '</tbody></table>';
            document.getElementById('padicTable').innerHTML = table;
        }

        function padicValuation(n, p) {
            if (n === 0) return Infinity;
            let v = 0;
            let m = Math.abs(n);
            while (m % p === 0) {
                v++;
                m /= p;
            }
            return v;
        }

        function isPrime(n) {
            if (n <= 1) return false;
            if (n <= 3) return true;
            if (n % 2 === 0 || n % 3 === 0) return false;
            for (let i = 5; i * i <= n; i += 6) {
                if (n % i === 0 || n % (i + 2) === 0) return false;
            }
            return true;
        }

        function findPisanoPeriod(seqDef, m) {
            const seq = [seqDef.seeds[0] % m, seqDef.seeds[1] % m];
            const seen = new Set();
            seen.add(`${seq[0]},${seq[1]}`);
            
            for (let i = 2; i < 1000; i++) {
                const next = generateLinearSequence(seqDef.recurrence, seq.slice(-seqDef.recurrence.length), i + 1);
                seq.push(((next[i] % m) + m) % m);
                
                if (i >= seqDef.recurrence.length) {
                    const key = seq.slice(-seqDef.recurrence.length).join(',');
                    if (seen.has(key)) {
                        return i - seqDef.recurrence.length;
                    }
                    seen.add(key);
                }
            }
            return null;
        }

        // Modular visualization
        function visualizeModular() {
            const seqType = document.getElementById('modSeq').value;
            const m = parseInt(document.getElementById('modValue').value);
            const n = parseInt(document.getElementById('modTerms').value);
            
            const seqDef = sequences[seqType];
            const seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, n);
            
            const canvas = document.getElementById('modCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw modular wheel
            const cx = 450, cy = 250, radius = 180;
            
            // Draw base circle
            ctx.strokeStyle = '#dee2e6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw modular positions
            for (let i = 0; i < m; i++) {
                const angle = (i / m) * 2 * Math.PI - Math.PI/2;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);
                
                ctx.fillStyle = '#e0e0e0';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#333';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x, y - 15);
            }
            
            // Plot sequence path
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const residues = [];
            seq.forEach((val, i) => {
                const residue = ((val % m) + m) % m;
                residues.push(residue);
                
                const angle = (residue / m) * 2 * Math.PI - Math.PI/2;
                const x = cx + (radius - 20) * Math.cos(angle);
                const y = cy + (radius - 20) * Math.sin(angle);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                // Highlight current position
                if (i === seq.length - 1) {
                    ctx.fillStyle = '#667eea';
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            ctx.stroke();
            
            // Calculate period
            const period = findModularPeriod(residues);
            
            document.getElementById('modResult').innerHTML = `
                <h3>Modular Analysis (mod ${m})</h3>
                <p><b>Period length:</b> ${period || 'No period found'}</p>
                <p><b>Unique residues:</b> ${new Set(residues).size} out of ${m}</p>
                <p><b>Sequence:</b> ${seqDef.name}</p>
            `;
        }

        function findModularPeriod(residues) {
            for (let period = 1; period < residues.length / 2; period++) {
                let isPeriodic = true;
                for (let i = 0; i < period; i++) {
                    if (residues[i] !== residues[i + period]) {
                        isPeriodic = false;
                        break;
                    }
                }
                if (isPeriodic) return period;
            }
            return null;
        }

        let modularAnimId = null;
        function startModularAnimation() {
            const seqType = document.getElementById('modSeq').value;
            const m = parseInt(document.getElementById('modValue').value);
            
            const seqDef = sequences[seqType];
            const seq = generateLinearSequence(seqDef.recurrence, seqDef.seeds, 200);
            
            let frame = 0;
            const canvas = document.getElementById('modCanvas');
            const ctx = canvas.getContext('2d');
            const cx = 450, cy = 250, radius = 180;
            
            function animate() {
                // Fade effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const index = frame % seq.length;
                const residue = ((seq[index] % m) + m) % m;
                const angle = (residue / m) * 2 * Math.PI - Math.PI/2;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);
                
                // Draw particle
                const particleSize = 10 + 5 * Math.sin(frame * 0.1);
                ctx.fillStyle = `hsla(${(frame * 2) % 360}, 70%, 50%, 0.8)`;
                ctx.beginPath();
                ctx.arc(x, y, particleSize, 0, 2 * Math.PI);
                ctx.fill();
                
                frame++;
                modularAnimId = requestAnimationFrame(animate);
            }
            
            if (modularAnimId) cancelAnimationFrame(modularAnimId);
            visualizeModular(); // Draw base
            animate();
        }

        // Non-linear sequences
        function catalan(n) {
            if (n <= 1) return 1;
            let c = 1;
            for (let i = 2; i <= n; i++) {
                c = c * 2 * (2 * i - 1) / (i + 1);
            }
            return Math.round(c);
        }

        function factorial(n) {
            if (n <= 1) return 1;
            return n * factorial(n - 1);
        }

        function bell(n) {
            const bell = [[1]];
            for (let i = 1; i <= n; i++) {
                bell[i] = [bell[i-1][i-1]];
                for (let j = 1; j <= i; j++) {
                    bell[i][j] = bell[i][j-1] + bell[i-1][j-1];
                }
            }
            return bell[n][0];
        }

        function generateNonlinear() {
            const type = document.getElementById('nonlinearSeq').value;
            const n = parseInt(document.getElementById('nonlinearTerms').value);
            
            let seq = [];
            let name = '';
            
            switch(type) {
                case 'catalan':
                    for (let i = 0; i < n; i++) seq.push(catalan(i));
                    name = 'Catalan Numbers';
                    break;
                case 'factorial':
                    for (let i = 0; i < n; i++) seq.push(factorial(i));
                    name = 'Factorial';
                    break;
                case 'bell':
                    for (let i = 0; i < n; i++) seq.push(bell(i));
                    name = 'Bell Numbers';
                    break;
                case 'prime':
                    let count = 0, num = 2;
                    while (count < n) {
                        if (isPrime(num)) {
                            seq.push(num);
                            count++;
                        }
                        num++;
                    }
                    name = 'Prime Numbers';
                    break;
                case 'partition':
                    // Simplified partition function
                    seq = [1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56, 77, 101, 135];
                    name = 'Partition Function';
                    break;
            }
            
            // Visualize
            const canvas = document.getElementById('nonlinearCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Use log scale for large values
            const useLog = Math.max(...seq) > 1000;
            const values = useLog ? seq.map(v => Math.log10(v + 1)) : seq;
            const maxVal = Math.max(...values);
            
            ctx.fillStyle = '#764ba2';
            const barWidth = 800 / n;
            
            values.forEach((val, i) => {
                const height = (val / maxVal) * 300;
                ctx.fillRect(50 + i * barWidth, 350 - height, barWidth - 1, height);
            });
            
            // Compare with Fibonacci
            const fib = generateLinearSequence([1, 1], [0, 1], n);
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const fibValues = useLog ? fib.map(v => Math.log10(v + 1)) : fib;
            fibValues.forEach((val, i) => {
                const x = 50 + i * barWidth + barWidth/2;
                const y = 350 - (val / maxVal) * 300;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            document.getElementById('nonlinearResult').innerHTML = `
                <h3>${name}</h3>
                <p><b>Type:</b> Non-linear sequence</p>
                <p><b>Scale:</b> ${useLog ? 'Logarithmic (base 10)' : 'Linear'}</p>
                <p><b>Comparison:</b> Purple bars = ${name}, Blue line = Fibonacci</p>
            `;
            
            // Growth comparison
            const growthRates = [];
            for (let i = 1; i < Math.min(10, seq.length); i++) {
                if (seq[i-1] > 0) {
                    growthRates.push(seq[i] / seq[i-1]);
                }
            }
            const avgGrowth = growthRates.reduce((a, b) => a + b, 0) / growthRates.length;
            
            document.getElementById('nonlinearComparison').innerHTML = `
                <div class="result-box">
                    <h3>Growth Analysis</h3>
                    <p><b>Average growth rate (first 10 terms):</b> ${avgGrowth.toFixed(3)}</p>
                    <p><b>Fibonacci golden ratio:</b> ${((1 + Math.sqrt(5))/2).toFixed(3)}</p>
                    <p><b>Growth type:</b> ${type === 'factorial' ? 'Super-exponential' : 
                                            type === 'prime' ? 'Logarithmic (by prime number theorem)' :
                                            type === 'catalan' ? 'Exponential ~4^n' : 'Complex'}</p>
                </div>
            `;
        }

        // Initialize
        updateSequenceInfo();
        updateCustomInputs();
    </script>
</body>
</html>