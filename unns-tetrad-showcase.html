<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Operational Grammar: The Four Operators</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0d1117 100%);
            color: #e4e6eb;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Landing Page Styles */
        .landing {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            position: relative;
            background: radial-gradient(circle at center, rgba(99, 102, 241, 0.1) 0%, transparent 50%);
        }

        .cosmic-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
            z-index: 0;
        }

        .main-title {
            font-size: clamp(2rem, 5vw, 3.5rem);
            text-align: center;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite alternate;
            z-index: 1;
            position: relative;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(102, 126, 234, 0.5); }
            to { text-shadow: 0 0 20px rgba(118, 75, 162, 0.8); }
        }

        .subtitle {
            font-size: 1.2rem;
            color: #8b92a9;
            text-align: center;
            margin-bottom: 3rem;
            z-index: 1;
            position: relative;
        }

        /* Animated Intro Canvas */
        #introCanvas {
            width: 300px;
            height: 300px;
            margin: 2rem auto;
            border-radius: 50%;
            box-shadow: 0 0 50px rgba(102, 126, 234, 0.3);
        }

        /* Operator Buttons */
        .operators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 2rem;
            max-width: 1000px;
            width: 100%;
            margin-top: 2rem;
            z-index: 1;
            position: relative;
        }

        .operator-btn {
            padding: 2rem;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-size: 1.1rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .operator-btn:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            transition: all 0.5s ease;
            z-index: 0;
        }

        .operator-btn:hover:before {
            width: 300px;
            height: 300px;
            margin-top: -150px;
            margin-left: -150px;
        }

        .operator-btn span {
            position: relative;
            z-index: 1;
        }

        .operator-btn.inletting {
            background: linear-gradient(135deg, #667eea 0%, #4c5fd5 100%);
        }

        .operator-btn.inletting:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
        }

        .operator-btn.inletting:before {
            background: rgba(102, 126, 234, 0.3);
        }

        .operator-btn.inlaying {
            background: linear-gradient(135deg, #f59e0b 0%, #ea580c 100%);
        }

        .operator-btn.inlaying:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(245, 158, 11, 0.5);
        }

        .operator-btn.inlaying:before {
            background: rgba(245, 158, 11, 0.3);
        }

        .operator-btn.repair {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .operator-btn.repair:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.5);
        }

        .operator-btn.repair:before {
            background: rgba(16, 185, 129, 0.3);
        }

        .operator-btn.trans {
            background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
        }

        .operator-btn.trans:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(168, 85, 247, 0.5);
        }

        .operator-btn.trans:before {
            background: rgba(168, 85, 247, 0.3);
        }

        /* Module Container */
        .module {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 39, 0.98);
            z-index: 1000;
            overflow-y: auto;
            animation: fadeIn 0.3s ease;
        }

        .module.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .module-header {
            padding: 2rem;
            background: linear-gradient(180deg, rgba(26, 31, 58, 0.9) 0%, transparent 100%);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .module-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .close-btn {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .module-content {
            padding: 2rem;
            display: grid;
            gap: 2rem;
        }

        .visualization-panel {
            background: rgba(26, 31, 58, 0.5);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            padding: 2rem;
            position: relative;
        }

        .control-panel {
            background: rgba(26, 31, 58, 0.3);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 10px;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        .slider-container {
            margin: 1rem 0;
        }

        .slider {
            width: 100%;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 5px;
            background: rgba(102, 126, 234, 0.3);
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .theory-btn, .apps-btn {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.5);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 5px;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.3s ease;
        }

        .theory-btn:hover, .apps-btn:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: translateY(-2px);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            background: linear-gradient(135deg, #1a1f3a 0%, #0d1117 100%);
            border: 2px solid rgba(102, 126, 234, 0.5);
            border-radius: 15px;
            padding: 2rem;
            overflow-y: auto;
            z-index: 2000;
            box-shadow: 0 0 50px rgba(102, 126, 234, 0.5);
        }

        .modal.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translate(-50%, -60%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1500;
        }

        .modal-overlay.active {
            display: block;
        }

        .philosophical-quote {
            font-style: italic;
            color: #8b92a9;
            text-align: center;
            padding: 1rem;
            margin: 2rem 0;
            border-left: 3px solid rgba(102, 126, 234, 0.5);
            animation: fadeInQuote 2s ease;
        }

        @keyframes fadeInQuote {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Canvas Styles */
        canvas {
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.2);
            width: 100%;
            max-width: 600px;
            height: 400px;
            margin: 0 auto;
            display: block;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .operators-grid {
                grid-template-columns: 1fr;
            }
            
            .module-content {
                grid-template-columns: 1fr;
            }
            
            .main-title {
                font-size: 2rem;
            }
        }

        /* Table Styles */
        .reference-table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
        }

        .reference-table th {
            background: rgba(102, 126, 234, 0.2);
            padding: 1rem;
            text-align: left;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .reference-table td {
            padding: 1rem;
            border: 1px solid rgba(102, 126, 234, 0.2);
            transition: background 0.3s ease;
        }

        .reference-table tr:hover td {
            background: rgba(102, 126, 234, 0.1);
        }

        /* Dropdown Styles */
        select {
            background: rgba(26, 31, 58, 0.8);
            color: white;
            border: 1px solid rgba(102, 126, 234, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            margin: 0.5rem 0;
        }

        select option {
            background: #1a1f3a;
        }

        .action-btn {
            margin: 5px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <!-- Cosmic Background Canvas -->
    <canvas id="cosmicBg" class="cosmic-bg"></canvas>

    <!-- Landing Page -->
    <div class="landing" id="landing">
        <h1 class="main-title">UNNS Operational Grammar</h1>
        <p class="subtitle">The Four Tetrad Operators</p>
        
        <!-- Animated Intro Canvas -->
        <canvas id="introCanvas"></canvas>
        
        <div class="philosophical-quote" id="quote">
            "Set theory builds the skeleton. UNNS animates the soul."
        </div>

        <!-- Operator Buttons Grid -->
        <div class="operators-grid">
            <button class="operator-btn inletting" onclick="window.openModule('inletting')">
                <span>üîµ Inletting</span>
            </button>
            <button class="operator-btn inlaying" onclick="window.openModule('inlaying')">
                <span>üü† Inlaying</span>
            </button>
            <button class="operator-btn repair" onclick="window.openModule('repair')">
                <span>üü¢ Repair & Normalization</span>
            </button>
            <button class="operator-btn trans" onclick="window.openModule('trans')">
                <span>üü£ Trans-Sentifying</span>
            </button>
        </div>
    </div>

    <!-- Inletting Module -->
    <div class="module" id="inletting-module">
        <div class="module-header">
            <button class="close-btn" onclick="window.closeModule('inletting')">‚úï Close</button>
            <h2 class="module-title">üîµ Inletting: Injecting Seeds into Recursion</h2>
        </div>
        <div class="module-content">
            <div class="visualization-panel">
                <canvas id="inlettingCanvas"></canvas>
                <div class="control-panel">
                    <label>Injection Strength:</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="inlettingSlider" min="0" max="100" value="50" oninput="document.getElementById('inlettingValue').textContent = this.value">
                        <span id="inlettingValue">50</span>
                    </div>
                    <label>Sequence Type:</label>
                    <select id="inlettingSequence">
                        <option value="fibonacci">Fibonacci</option>
                        <option value="padovan">Padovan</option>
                        <option value="pell">Pell</option>
                    </select>
                </div>
            </div>
            <div>
                <button class="theory-btn" onclick="window.showTheory('inletting')">üìö View Theory</button>
                <button class="apps-btn" onclick="window.showApplications('inletting')">üåç Applications</button>
            </div>
        </div>
    </div>

    <!-- Inlaying Module -->
    <div class="module" id="inlaying-module">
        <div class="module-header">
            <button class="close-btn" onclick="window.closeModule('inlaying')">‚úï Close</button>
            <h2 class="module-title">üü† Inlaying: Embedding Sequences into Structures</h2>
        </div>
        <div class="module-content">
            <div class="visualization-panel">
                <canvas id="inlayingCanvas"></canvas>
                <div class="control-panel">
                    <label>Lattice Type:</label>
                    <select id="latticeType">
                        <option value="square">Square Lattice (mod 4)</option>
                        <option value="hexagonal">Hexagonal Lattice (mod 6)</option>
                        <option value="spiral">Spiral Embedding</option>
                    </select>
                    <label>Animation Speed:</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="inlayingSpeed" min="1" max="100" value="50" oninput="document.getElementById('inlayingSpeedValue').textContent = this.value">
                        <span id="inlayingSpeedValue">50</span>
                    </div>
                </div>
            </div>
            <div>
                <button class="theory-btn" onclick="window.showTheory('inlaying')">üìö View Theory</button>
                <button class="apps-btn" onclick="window.showApplications('inlaying')">üåç Applications</button>
            </div>
        </div>
    </div>

    <!-- Repair & Normalization Module -->
    <div class="module" id="repair-module">
        <div class="module-header">
            <button class="close-btn" onclick="window.closeModule('repair')">‚úï Close</button>
            <h2 class="module-title">üü¢ Repair & Normalization: Error Correction</h2>
        </div>
        <div class="module-content">
            <div class="visualization-panel">
                <canvas id="repairCanvas"></canvas>
                <div class="control-panel">
                    <label>Error Rate:</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="errorRate" min="0" max="50" value="10" oninput="document.getElementById('errorRateValue').textContent = this.value + '%'">
                        <span id="errorRateValue">10%</span>
                    </div>
                    <button class="action-btn" onclick="window.applyRepair('proofread')">Proofreading</button>
                    <button class="action-btn" onclick="window.applyRepair('excision')">Excision</button>
                    <button class="action-btn" onclick="window.applyRepair('renormalize')">Renormalization</button>
                </div>
            </div>
            <div>
                <button class="theory-btn" onclick="window.showTheory('repair')">üìö View Theory</button>
                <button class="apps-btn" onclick="window.showApplications('repair')">üåç Applications</button>
            </div>
        </div>
    </div>

    <!-- Trans-Sentifying Module -->
    <div class="module" id="trans-module">
        <div class="module-header">
            <button class="close-btn" onclick="window.closeModule('trans')">‚úï Close</button>
            <h2 class="module-title">üü£ Trans-Sentifying: Sequence to Sensation</h2>
        </div>
        <div class="module-content">
            <div class="visualization-panel">
                <canvas id="transCanvas"></canvas>
                <div class="control-panel">
                    <label>Mapping Mode:</label>
                    <select id="mappingMode">
                        <option value="color">Color Bands</option>
                        <option value="sound">Sound Pulses</option>
                        <option value="symbol">Symbolic Glyphs</option>
                    </select>
                    <label>Frequency:</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="transFreq" min="1" max="100" value="50" oninput="document.getElementById('transFreqValue').textContent = this.value">
                        <span id="transFreqValue">50</span>
                    </div>
                    <button class="action-btn" onclick="window.playSequence()">‚ñ∂ Play Sequence</button>
                </div>
            </div>
            <div>
                <button class="theory-btn" onclick="window.showTheory('trans')">üìö View Theory</button>
                <button class="apps-btn" onclick="window.showApplications('trans')">üåç Applications</button>
            </div>
        </div>
    </div>

    <!-- Theory Modal -->
    <div class="modal-overlay" id="modalOverlay" onclick="window.closeModal()"></div>
    <div class="modal" id="theoryModal">
        <button class="close-btn" onclick="window.closeModal()">‚úï</button>
        <h3 id="modalTitle">Theory</h3>
        <div id="modalContent"></div>
    </div>

    <script>
        // Global Animation Variables
        window.animationFrames = {};
        window.sequences = {
            fibonacci: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144],
            padovan: [1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 12, 16],
            pell: [1, 2, 5, 12, 29, 70, 169, 408, 985, 2378, 5741, 13860]
        };

        // Audio context for sound generation
        let audioContext = null;

        // Quote rotation
        const quotes = [
            "Set theory builds the skeleton. UNNS animates the soul.",
            "From recursion comes pattern, from pattern comes meaning.",
            "The operators are not tools‚Äîthey are transformations.",
            "In the space between numbers lies the architecture of thought.",
            "Every sequence tells a story; every operator changes its narrative."
        ];
        let quoteIndex = 0;

        // Initialize everything when page loads
        window.addEventListener('DOMContentLoaded', function() {
            initCosmicBackground();
            initIntroAnimation();
            rotateQuotes();
        });

        // Cosmic Background Animation
        function initCosmicBackground() {
            const canvas = document.getElementById('cosmicBg');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const particles = [];
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    speedX: (Math.random() - 0.5) * 0.5,
                    speedY: (Math.random() - 0.5) * 0.5,
                    opacity: Math.random()
                });
            }

            function animate() {
                ctx.fillStyle = 'rgba(10, 14, 39, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                particles.forEach(p => {
                    p.opacity += (Math.random() - 0.5) * 0.05;
                    p.opacity = Math.max(0.1, Math.min(1, p.opacity));
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(102, 126, 234, ${p.opacity * 0.5})`;
                    ctx.fill();

                    p.x += p.speedX;
                    p.y += p.speedY;

                    if (p.x < 0) p.x = canvas.width;
                    if (p.x > canvas.width) p.x = 0;
                    if (p.y < 0) p.y = canvas.height;
                    if (p.y > canvas.height) p.y = 0;
                });

                requestAnimationFrame(animate);
            }
            animate();
        }

        // Intro Canvas Animation
        function initIntroAnimation() {
            const canvas = document.getElementById('introCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 300;
            canvas.height = 300;

            let phase = 0;
            
            function animate() {
                ctx.fillStyle = 'rgba(10, 14, 39, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(150, 150);
                
                const time = phase * 0.01;
                
                // Morphing spiral
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < 100; i++) {
                    const angle = i * 0.2;
                    const radius = i * 1.5 * (1 + Math.sin(time) * 0.3);
                    const x = Math.cos(angle + time) * radius;
                    const y = Math.sin(angle + time) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Network mesh
                ctx.strokeStyle = 'rgba(245, 158, 11, 0.5)';
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 / 6) * i + time;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * 80, Math.sin(angle) * 80, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // DNA helix
                ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
                ctx.beginPath();
                for (let i = -50; i < 50; i += 5) {
                    const x1 = Math.sin(i * 0.1 + time) * 30;
                    const x2 = Math.sin(i * 0.1 + time + Math.PI) * 30;
                    ctx.moveTo(x1, i);
                    ctx.lineTo(x2, i);
                }
                ctx.stroke();

                ctx.restore();
                
                phase++;
                window.animationFrames.intro = requestAnimationFrame(animate);
            }
            animate();
        }

        // Quote Rotation
        function rotateQuotes() {
            setInterval(() => {
                quoteIndex = (quoteIndex + 1) % quotes.length;
                const quoteEl = document.getElementById('quote');
                if (quoteEl) {
                    quoteEl.style.opacity = '0';
                    setTimeout(() => {
                        quoteEl.textContent = quotes[quoteIndex];
                        quoteEl.style.opacity = '1';
                    }, 500);
                }
            }, 5000);
        }

        // Module Functions
        window.openModule = function(type) {
            const module = document.getElementById(type + '-module');
            if (module) {
                module.classList.add('active');
                
                // Initialize visualization
                switch(type) {
                    case 'inletting':
                        initInlettingVisualization();
                        break;
                    case 'inlaying':
                        initInlayingVisualization();
                        break;
                    case 'repair':
                        initRepairVisualization();
                        break;
                    case 'trans':
                        initTransVisualization();
                        break;
                }
            }
        };

        window.closeModule = function(type) {
            const module = document.getElementById(type + '-module');
            if (module) {
                module.classList.remove('active');
                // Stop animation
                if (window.animationFrames[type]) {
                    cancelAnimationFrame(window.animationFrames[type]);
                }
            }
        };

        // Inletting Visualization
        function initInlettingVisualization() {
            const canvas = document.getElementById('inlettingCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600;
            canvas.height = 400;

            let nodes = [];
            const nodeCount = 10;
            let injectionPhase = 0;
            
            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    x: 50 + i * 50,
                    y: 200 + Math.sin(i * 0.5) * 50,
                    value: window.sequences.fibonacci[i],
                    injected: false,
                    pulseSize: 0
                });
            }

            function animate() {
                ctx.fillStyle = 'rgba(26, 31, 58, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const slider = document.getElementById('inlettingSlider');
                const strength = slider ? slider.value / 100 : 0.5;
                const seqType = document.getElementById('inlettingSequence')?.value || 'fibonacci';
                
                injectionPhase += 0.02;
                
                // Draw connections
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < nodes.length - 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[i + 1].x, nodes[i + 1].y);
                    ctx.stroke();
                }

                // Draw nodes and injection arrows
                nodes.forEach((node, i) => {
                    // Injection animation
                    if (Math.sin(injectionPhase + i * 0.5) > 0.8 && strength > 0.3) {
                        node.injected = true;
                        node.pulseSize = 10;
                    }
                    
                    if (node.pulseSize > 0) {
                        node.pulseSize *= 0.95;
                        if (node.pulseSize < 0.1) {
                            node.injected = false;
                            node.pulseSize = 0;
                        }
                    }

                    // Draw injection arrow
                    if (node.injected) {
                        ctx.save();
                        ctx.strokeStyle = '#667eea';
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = node.pulseSize / 10;
                        
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y - 50);
                        ctx.lineTo(node.x, node.y - 20);
                        ctx.stroke();
                        
                        // Arrow head
                        ctx.beginPath();
                        ctx.moveTo(node.x - 5, node.y - 25);
                        ctx.lineTo(node.x, node.y - 20);
                        ctx.lineTo(node.x + 5, node.y - 25);
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Draw pulse effect
                    if (node.pulseSize > 0) {
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, 15 + node.pulseSize, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(102, 126, 234, ' + (node.pulseSize / 20) + ')';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    // Draw node
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 15, 0, Math.PI * 2);
                    ctx.fillStyle = node.injected ? '#667eea' : 'rgba(102, 126, 234, 0.5)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(102, 126, 234, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw value
                    ctx.fillStyle = 'white';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(window.sequences[seqType][i] || '?', node.x, node.y);
                });

                window.animationFrames.inletting = requestAnimationFrame(animate);
            }
            animate();
        }

        // Inlaying Visualization
        function initInlayingVisualization() {
            const canvas = document.getElementById('inlayingCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600;
            canvas.height = 400;

            let phase = 0;
            let embedPoints = [];

            function animate() {
                ctx.fillStyle = 'rgba(26, 31, 58, 0.95)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const latticeType = document.getElementById('latticeType')?.value || 'square';
                const speed = (document.getElementById('inlayingSpeed')?.value || 50) / 100;
                
                phase += speed * 0.05;

                if (latticeType === 'square') {
                    // Square lattice
                    const gridSize = 40;
                    const offsetX = 100;
                    const offsetY = 50;
                    
                    for (let i = 0; i < 10; i++) {
                        for (let j = 0; j < 8; j++) {
                            const x = offsetX + i * gridSize;
                            const y = offsetY + j * gridSize;
                            const seqIndex = (i + j * 10) % window.sequences.fibonacci.length;
                            const value = window.sequences.fibonacci[seqIndex] % 4;
                            
                            // Draw lattice point
                            ctx.beginPath();
                            ctx.arc(x, y, 5 + Math.sin(phase + seqIndex) * 2, 0, Math.PI * 2);
                            
                            const colors = ['#667eea', '#f59e0b', '#10b981', '#a855f7'];
                            ctx.fillStyle = colors[value];
                            ctx.fill();
                            
                            // Draw connections
                            if (i < 9) {
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + gridSize, y);
                                ctx.strokeStyle = 'rgba(245, 158, 11, 0.2)';
                                ctx.stroke();
                            }
                            if (j < 7) {
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x, y + gridSize);
                                ctx.strokeStyle = 'rgba(245, 158, 11, 0.2)';
                                ctx.stroke();
                            }
                        }
                    }
                } else if (latticeType === 'hexagonal') {
                    // Hexagonal lattice
                    const hexSize = 25;
                    const offsetX = 100;
                    const offsetY = 100;
                    
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 10; col++) {
                            const x = offsetX + col * hexSize * 1.5;
                            const y = offsetY + row * hexSize * Math.sqrt(3) + (col % 2) * hexSize * Math.sqrt(3) / 2;
                            
                            const seqIndex = (row * 10 + col) % window.sequences.fibonacci.length;
                            const value = window.sequences.fibonacci[seqIndex] % 6;
                            
                            // Draw hexagon
                            ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = Math.PI / 3 * i + phase * 0.1;
                                const hx = x + hexSize * Math.cos(angle);
                                const hy = y + hexSize * Math.sin(angle);
                                if (i === 0) ctx.moveTo(hx, hy);
                                else ctx.lineTo(hx, hy);
                            }
                            ctx.closePath();
                            
                            ctx.fillStyle = `hsla(${value * 60}, 70%, 50%, 0.3)`;
                            ctx.fill();
                            ctx.strokeStyle = 'rgba(245, 158, 11, 0.5)';
                            ctx.stroke();
                            
                            // Center point
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, Math.PI * 2);
                            ctx.fillStyle = '#f59e0b';
                            ctx.fill();
                        }
                    }
                } else {
                    // Spiral embedding
                    ctx.save();
                    ctx.translate(300, 200);
                    
                    for (let i = 0; i < 100; i++) {
                        const angle = i * 0.2 + phase;
                        const radius = i * 2;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        const seqIndex = i % window.sequences.fibonacci.length;
                        const value = window.sequences.fibonacci[seqIndex];
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 3 + (value % 5), 0, Math.PI * 2);
                        
                        const hue = (value * 30) % 360;
                        ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.8)`;
                        ctx.fill();
                        
                        if (i > 0) {
                            const prevAngle = (i - 1) * 0.2 + phase;
                            const prevRadius = (i - 1) * 2;
                            const prevX = Math.cos(prevAngle) * prevRadius;
                            const prevY = Math.sin(prevAngle) * prevRadius;
                            
                            ctx.beginPath();
                            ctx.moveTo(prevX, prevY);
                            ctx.lineTo(x, y);
                            ctx.strokeStyle = 'rgba(245, 158, 11, 0.3)';
                            ctx.stroke();
                        }
                    }
                    
                    ctx.restore();
                }

                window.animationFrames.inlaying = requestAnimationFrame(animate);
            }
            animate();
        }

        // Repair Visualization
        function initRepairVisualization() {
            const canvas = document.getElementById('repairCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600;
            canvas.height = 400;

            let sequence = [...window.sequences.fibonacci];
            let errors = [];
            let repairPhase = 0;
            let repairMode = 'none';

            function introduceErrors() {
                const errorRate = (document.getElementById('errorRate')?.value || 10) / 100;
                errors = [];
                for (let i = 0; i < sequence.length; i++) {
                    if (Math.random() < errorRate) {
                        errors.push(i);
                        sequence[i] = Math.floor(Math.random() * 100);
                    }
                }
            }

            introduceErrors();

            window.applyRepair = function(mode) {
                repairMode = mode;
                repairPhase = 0;
                
                setTimeout(() => {
                    if (mode === 'proofread') {
                        // Restore correct values
                        sequence = [...window.sequences.fibonacci];
                    } else if (mode === 'excision') {
                        // Remove errors
                        errors.forEach(idx => {
                            sequence[idx] = 0;
                        });
                    } else if (mode === 'renormalize') {
                        // Scale sequence
                        const max = Math.max(...sequence);
                        sequence = sequence.map(v => Math.floor(v * 10 / max));
                    }
                    errors = [];
                }, 1000);
            };

            function animate() {
                ctx.fillStyle = 'rgba(26, 31, 58, 0.95)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                repairPhase += 0.05;

                // Draw DNA-like structure
                ctx.save();
                ctx.translate(300, 50);

                for (let i = 0; i < sequence.length; i++) {
                    const y = i * 30;
                    const isError = errors.includes(i);
                    
                    // Draw helix backbone
                    const x1 = Math.sin(y * 0.05 + repairPhase) * 50;
                    const x2 = Math.sin(y * 0.05 + repairPhase + Math.PI) * 50;
                    
                    ctx.strokeStyle = isError ? '#ef4444' : 'rgba(16, 185, 129, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x1 - 100, y);
                    ctx.lineTo(x1, y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(x2, y);
                    ctx.lineTo(x2 + 100, y);
                    ctx.stroke();
                    
                    // Draw connection
                    ctx.beginPath();
                    ctx.moveTo(x1, y);
                    ctx.lineTo(x2, y);
                    ctx.strokeStyle = isError ? '#ef4444' : 'rgba(16, 185, 129, 0.3)';
                    ctx.stroke();
                    
                    // Draw value nodes
                    ctx.beginPath();
                    ctx.arc(x1, y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = isError ? '#ef4444' : '#10b981';
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(x2, y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = isError ? '#ef4444' : '#10b981';
                    ctx.fill();
                    
                    // Draw values
                    ctx.fillStyle = 'white';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(sequence[i], x1, y);
                    ctx.fillText(sequence[i], x2, y);
                    
                    // Draw repair enzyme animation
                    if (repairMode !== 'none' && isError) {
                        const enzymeY = y + Math.sin(repairPhase * 5) * 5;
                        ctx.beginPath();
                        ctx.arc(0, enzymeY, 15, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(16, 185, 129, 0.8)';
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.font = '8px monospace';
                        ctx.fillText('REPAIR', 0, enzymeY);
                    }
                }

                ctx.restore();

                // Error rate display
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '14px monospace';
                ctx.fillText(`Errors: ${errors.length}/${sequence.length}`, 20, 380);

                window.animationFrames.repair = requestAnimationFrame(animate);
            }
            animate();
        }

        // Trans-Sentifying Visualization
        function initTransVisualization() {
            const canvas = document.getElementById('transCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600;
            canvas.height = 400;

            let phase = 0;

            window.playSequence = function() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const sequence = window.sequences.fibonacci;
                sequence.forEach((value, i) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 200 + value * 20;
                    gainNode.gain.value = 0.1;
                    
                    oscillator.start(audioContext.currentTime + i * 0.1);
                    oscillator.stop(audioContext.currentTime + i * 0.1 + 0.08);
                });
            };

            function animate() {
                ctx.fillStyle = 'rgba(26, 31, 58, 0.95)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const mode = document.getElementById('mappingMode')?.value || 'color';
                const freq = (document.getElementById('transFreq')?.value || 50) / 10;
                
                phase += 0.02 * freq;

                const sequence = window.sequences.fibonacci;

                if (mode === 'color') {
                    // Color bands visualization
                    const bandWidth = canvas.width / sequence.length;
                    
                    sequence.forEach((value, i) => {
                        const hue = (value * 30) % 360;
                        const lightness = 30 + (value % 40);
                        const height = 50 + value * 3 + Math.sin(phase + i) * 20;
                        
                        ctx.fillStyle = `hsla(${hue}, 70%, ${lightness}%, 0.8)`;
                        ctx.fillRect(i * bandWidth, canvas.height / 2 - height / 2, bandWidth - 2, height);
                        
                        // Add glow effect
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = `hsla(${hue}, 70%, 50%, 0.5)`;
                        ctx.fillRect(i * bandWidth, canvas.height / 2 - height / 2, bandWidth - 2, height);
                        ctx.shadowBlur = 0;
                    });
                } else if (mode === 'sound') {
                    // Sound pulse visualization
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    
                    sequence.forEach((value, i) => {
                        const angle = (i / sequence.length) * Math.PI * 2;
                        const radius = 50 + value * 2 + Math.sin(phase + i) * 10;
                        
                        ctx.beginPath();
                        ctx.arc(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius,
                            value / 2,
                            0,
                            Math.PI * 2
                        );
                        
                        ctx.fillStyle = `hsla(${280}, 70%, 50%, ${0.3 + Math.sin(phase + i) * 0.2})`;
                        ctx.fill();
                        
                        // Draw connecting lines
                        if (i > 0) {
                            const prevAngle = ((i - 1) / sequence.length) * Math.PI * 2;
                            const prevRadius = 50 + sequence[i - 1] * 2 + Math.sin(phase + i - 1) * 10;
                            
                            ctx.beginPath();
                            ctx.moveTo(
                                Math.cos(prevAngle) * prevRadius,
                                Math.sin(prevAngle) * prevRadius
                            );
                            ctx.lineTo(
                                Math.cos(angle) * radius,
                                Math.sin(angle) * radius
                            );
                            ctx.strokeStyle = 'rgba(168, 85, 247, 0.3)';
                            ctx.stroke();
                        }
                    });
                    
                    ctx.restore();
                } else {
                    // Symbolic glyphs
                    const glyphs = ['‚óÜ', '‚óè', '‚ñ≤', '‚ñ†', '‚òÖ', '‚ú¶', '‚óâ', '‚óà', '‚óä', '‚óã'];
                    
                    sequence.forEach((value, i) => {
                        const x = 50 + (i % 10) * 50;
                        const y = 50 + Math.floor(i / 10) * 50;
                        const glyph = glyphs[value % glyphs.length];
                        const size = 15 + value / 3 + Math.sin(phase + i) * 5;
                        
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(phase * 0.1 + i * 0.2);
                        
                        ctx.font = `${size}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = `hsla(${value * 30}, 70%, 60%, 0.8)`;
                        ctx.fillText(glyph, 0, 0);
                        
                        ctx.restore();
                    });
                }

                window.animationFrames.trans = requestAnimationFrame(animate);
            }
            animate();
        }

        // Theory and Applications Modals
        window.showTheory = function(operator) {
            const modal = document.getElementById('theoryModal');
            const overlay = document.getElementById('modalOverlay');
            const title = document.getElementById('modalTitle');
            const content = document.getElementById('modalContent');
            
            const theories = {
                inletting: {
                    title: 'Inletting Theory',
                    content: `
                        <h4>Mathematical Foundation</h4>
                        <p>Inletting introduces external forcing terms into recursive sequences, modifying their evolution through controlled injection of values.</p>
                        <h4>Key Concepts</h4>
                        <ul>
                            <li>Seeds and forcing terms alter recursive trajectories</li>
                            <li>Injection points create bifurcations in sequence space</li>
                            <li>Boundary conditions emerge from strategic inletting</li>
                        </ul>
                        <h4>References</h4>
                        <p>For detailed theory, see:</p>
                        <ul>
                            <li><a href="https://ukbbi.github.io/UNNS/docs/UNNS_Operational_Grammar/UNNS Inletting_Mathematical and Physical Perspectives.pdf" target="_blank">Mathematical and Physical Perspectives</a></li>
                            <li><a href="https://ukbbi.github.io/UNNS/docs/UNNS_Operational_Grammar/UNNS Inletting Mathematical_Physical Perspectives_Appendix Worked Example.pdf" target="_blank">Worked Examples</a></li>
                        </ul>
                    `
                },
                inlaying: {
                    title: 'Inlaying Theory',
                    content: `
                        <h4>Embedding Sequences into Higher Structures</h4>
                        <p>Inlaying maps UNNS sequences onto geometric lattices and topological spaces, revealing hidden symmetries.</p>
                        <h4>Lattice Embeddings</h4>
                        <ul>
                            <li>Square lattices (mod 4): Reveals quaternary patterns</li>
                            <li>Hexagonal lattices (mod 6): Exposes six-fold symmetries</li>
                            <li>Spiral embeddings: Shows growth dynamics</li>
                        </ul>
                        <h4>References</h4>
                        <p><a href="https://ukbbi.github.io/UNNS/docs/UNNS_Operational_Grammar/UNNS Inlaying.pdf" target="_blank">UNNS Inlaying Theory</a></p>
                    `
                },
                repair: {
                    title: 'Repair & Normalization Theory',
                    content: `
                        <h4>Error Correction in Recursive Systems</h4>
                        <p>Repair mechanisms maintain sequence integrity through proofreading, excision, and renormalization.</p>
                        <h4>Three Repair Modes</h4>
                        <ul>
                            <li><strong>Proofreading:</strong> Detects and corrects local errors</li>
                            <li><strong>Excision:</strong> Removes corrupted segments</li>
                            <li><strong>Renormalization:</strong> Global rescaling for stability</li>
                        </ul>
                        <h4>Biological Analogies</h4>
                        <p>Inspired by DNA repair mechanisms and cellular error correction.</p>
                        <p><a href="https://ukbbi.github.io/UNNS/docs/UNNS_Operational_Grammar/UNNS Repair Rules and Normalization.pdf" target="_blank">Full Theory Document</a></p>
                    `
                },
                trans: {
                    title: 'Trans-Sentifying Theory',
                    content: `
                        <h4>From Sequence to Sensation</h4>
                        <p>Trans-Sentifying maps numerical sequences to sensory modalities: color, sound, and symbolic representations.</p>
                        <h4>Mapping Modes</h4>
                        <ul>
                            <li><strong>Chromatic:</strong> Value ‚Üí Hue/Saturation/Lightness</li>
                            <li><strong>Acoustic:</strong> Value ‚Üí Frequency/Amplitude</li>
                            <li><strong>Symbolic:</strong> Value ‚Üí Glyph/Size/Rotation</li>
                        </ul>
                        <h4>Applications</h4>
                        <p>Data sonification, synesthetic interfaces, pattern recognition enhancement.</p>
                        <p><a href="https://ukbbi.github.io/UNNS/docs/UNNS_Operational_Grammar/UNNS Trans‚ÄìSentifying.pdf" target="_blank">Complete Theory</a></p>
                    `
                }
            };
            
            title.textContent = theories[operator].title;
            content.innerHTML = theories[operator].content;
            
            modal.classList.add('active');
            overlay.classList.add('active');
        };

        window.showApplications = function(operator) {
            const modal = document.getElementById('theoryModal');
            const overlay = document.getElementById('modalOverlay');
            const title = document.getElementById('modalTitle');
            const content = document.getElementById('modalContent');
            
            const applications = {
                inletting: {
                    title: 'Inletting Applications',
                    content: `
                        <h4>Real-World Applications</h4>
                        <table class="reference-table">
                            <tr><th>Domain</th><th>Application</th></tr>
                            <tr><td>Physics</td><td>External field injection in quantum systems</td></tr>
                            <tr><td>Engineering</td><td>Control signals in feedback loops</td></tr>
                            <tr><td>Biology</td><td>Gene regulatory network perturbations</td></tr>
                            <tr><td>Computing</td><td>Interrupt handling in recursive algorithms</td></tr>
                            <tr><td>Finance</td><td>Market shock modeling</td></tr>
                        </table>
                    `
                },
                inlaying: {
                    title: 'Inlaying Applications',
                    content: `
                        <h4>Real-World Applications</h4>
                        <table class="reference-table">
                            <tr><th>Domain</th><th>Application</th></tr>
                            <tr><td>Cryptography</td><td>Sequence-based encryption lattices</td></tr>
                            <tr><td>Materials Science</td><td>Quasicrystal structure generation</td></tr>
                            <tr><td>Architecture</td><td>Parametric design patterns</td></tr>
                            <tr><td>Network Theory</td><td>Topology embedding optimization</td></tr>
                            <tr><td>Machine Learning</td><td>Feature space embeddings</td></tr>
                        </table>
                    `
                },
                repair: {
                    title: 'Repair & Normalization Applications',
                    content: `
                        <h4>Real-World Applications</h4>
                        <table class="reference-table">
                            <tr><th>Domain</th><th>Application</th></tr>
                            <tr><td>Genetics</td><td>DNA mismatch repair algorithms</td></tr>
                            <tr><td>Telecommunications</td><td>Error correction codes</td></tr>
                            <tr><td>AI Safety</td><td>Recursive model stability</td></tr>
                            <tr><td>Data Science</td><td>Outlier detection and correction</td></tr>
                            <tr><td>Quantum Computing</td><td>Quantum error correction</td></tr>
                        </table>
                    `
                },
                trans: {
                    title: 'Trans-Sentifying Applications',
                    content: `
                        <h4>Real-World Applications</h4>
                        <table class="reference-table">
                            <tr><th>Domain</th><th>Application</th></tr>
                            <tr><td>Accessibility</td><td>Data sonification for visually impaired</td></tr>
                            <tr><td>Music</td><td>Algorithmic composition</td></tr>
                            <tr><td>Medicine</td><td>EEG/ECG pattern visualization</td></tr>
                            <tr><td>Education</td><td>Mathematical concept visualization</td></tr>
                            <tr><td>Art</td><td>Generative audiovisual installations</td></tr>
                        </table>
                    `
                }
            };
            
            title.textContent = applications[operator].title;
            content.innerHTML = applications[operator].content;
            
            modal.classList.add('active');
            overlay.classList.add('active');
        };

        window.closeModal = function() {
            document.getElementById('theoryModal').classList.remove('active');
            document.getElementById('modalOverlay').classList.remove('active');
        };

        // Resize handler
        window.addEventListener('resize', function() {
            const canvas = document.getElementById('cosmicBg');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
