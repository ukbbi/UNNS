   <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Attractor-to-AI Node Mapper</title>
    <style>
        /* Blogger-resistant styling with unique namespace and !important flags */
        .unns-container * {
            box-sizing: border-box !important;
        }
        
        .unns-container {
            font-family: 'Segoe UI', system-ui, sans-serif !important;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%) !important;
            color: #e0e6ed !important;
            padding: 20px !important;
            min-height: 100vh !important;
            position: relative !important;
            overflow-x: hidden !important;
        }
        
        .unns-header {
            text-align: center !important;
            margin-bottom: 30px !important;
            animation: unns-fadeIn 1s ease-out !important;
        }
        
        .unns-title {
            font-size: 2.5em !important;
            background: linear-gradient(45deg, #00ffff, #ff00ff) !important;
            -webkit-background-clip: text !important;
            background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            margin: 0 0 10px 0 !important;
            font-weight: bold !important;
        }
        
        .unns-subtitle {
            color: #8892b0 !important;
            font-size: 1.1em !important;
            margin: 0 !important;
        }
        
        .unns-main-grid {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            gap: 20px !important;
            margin-bottom: 20px !important;
        }
        
        @media (max-width: 968px) {
            .unns-main-grid {
                grid-template-columns: 1fr !important;
            }
            
            .unns-hybrid-network {
                grid-template-columns: repeat(2, 1fr) !important;
                grid-template-rows: repeat(2, 1fr) !important;
            }
            
            .unns-hybrid-controls {
                grid-template-columns: 1fr !important;
            }
            
            .unns-layer-stats {
                grid-template-columns: repeat(2, 1fr) !important;
            }
        }
        
        .unns-panel {
            background: rgba(30, 40, 70, 0.8) !important;
            border: 1px solid rgba(100, 255, 218, 0.3) !important;
            border-radius: 15px !important;
            padding: 20px !important;
            backdrop-filter: blur(10px) !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
            animation: unns-slideUp 0.6s ease-out !important;
        }
        
        .unns-panel-title {
            font-size: 1.3em !important;
            color: #64ffda !important;
            margin: 0 0 15px 0 !important;
            padding-bottom: 10px !important;
            border-bottom: 2px solid rgba(100, 255, 218, 0.2) !important;
        }
        
        .unns-canvas {
            width: 100% !important;
            height: 400px !important;
            background: rgba(10, 14, 39, 0.9) !important;
            border-radius: 10px !important;
            border: 1px solid rgba(100, 255, 218, 0.2) !important;
            margin-bottom: 15px !important;
            position: relative !important;
            overflow: hidden !important;
        }
        
        .unns-controls {
            display: flex !important;
            flex-direction: column !important;
            gap: 15px !important;
        }
        
        .unns-control-group {
            display: flex !important;
            flex-direction: column !important;
            gap: 8px !important;
        }
        
        .unns-label {
            color: #8892b0 !important;
            font-size: 0.9em !important;
            font-weight: 500 !important;
            display: block !important;
            margin: 0 !important;
        }
        
        .unns-select, .unns-input {
            width: 100% !important;
            padding: 10px !important;
            background: rgba(10, 14, 39, 0.8) !important;
            border: 1px solid rgba(100, 255, 218, 0.3) !important;
            border-radius: 8px !important;
            color: #e0e6ed !important;
            font-size: 14px !important;
            transition: all 0.3s ease !important;
            margin: 0 !important;
        }
        
        .unns-select:hover, .unns-input:hover {
            border-color: #64ffda !important;
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.2) !important;
        }
        
        .unns-select:focus, .unns-input:focus {
            outline: none !important;
            border-color: #64ffda !important;
            box-shadow: 0 0 15px rgba(100, 255, 218, 0.3) !important;
        }
        
        .unns-button {
            padding: 12px 24px !important;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            border: none !important;
            border-radius: 8px !important;
            color: white !important;
            font-weight: 600 !important;
            font-size: 14px !important;
            cursor: pointer !important;
            transition: all 0.3s ease !important;
            text-transform: uppercase !important;
            letter-spacing: 1px !important;
            margin: 5px 0 !important;
        }
        
        .unns-button:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4) !important;
        }
        
        .unns-button:active {
            transform: translateY(0) !important;
        }
        
        .unns-stats {
            display: grid !important;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)) !important;
            gap: 10px !important;
            margin-top: 15px !important;
        }
        
        .unns-stat {
            background: rgba(10, 14, 39, 0.6) !important;
            padding: 10px !important;
            border-radius: 8px !important;
            border: 1px solid rgba(100, 255, 218, 0.2) !important;
        }
        
        .unns-stat-label {
            color: #8892b0 !important;
            font-size: 0.8em !important;
            margin: 0 0 5px 0 !important;
        }
        
        .unns-stat-value {
            color: #64ffda !important;
            font-size: 1.2em !important;
            font-weight: bold !important;
            margin: 0 !important;
        }
        
        @keyframes unns-fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes unns-slideUp {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes unns-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .unns-node {
            position: absolute !important;
            width: 12px !important;
            height: 12px !important;
            border-radius: 50% !important;
            transition: all 0.3s ease !important;
        }
        
        .unns-connection {
            position: absolute !important;
            height: 1px !important;
            background: linear-gradient(90deg, transparent, rgba(100, 255, 218, 0.5), transparent) !important;
            transform-origin: left center !important;
            pointer-events: none !important;
        }
        
        .unns-emergence-layer {
            position: absolute !important;
            width: 100% !important;
            border-top: 1px dashed rgba(100, 255, 218, 0.2) !important;
            pointer-events: none !important;
        }
        
        .unns-attractor-point {
            position: absolute !important;
            width: 4px !important;
            height: 4px !important;
            background: rgba(255, 255, 255, 0.8) !important;
            border-radius: 50% !important;
            pointer-events: none !important;
        }
    </style>
</head>
<body>
    <div class="unns-container">
        <div class="unns-header">
            <h1 class="unns-title">UNNS Attractor Mapper</h1>
            <p class="unns-subtitle">Neural Network Dynamics with Anchor Parameterization</p>
        </div>
        
        <div class="unns-main-grid">
            <div class="unns-panel">
                <h2 class="unns-panel-title">Network Visualization</h2>
                <div class="unns-canvas" id="networkCanvas"></div>
                <div class="unns-stats">
                    <div class="unns-stat">
                        <p class="unns-stat-label">Active Nodes</p>
                        <p class="unns-stat-value" id="activeNodes">0</p>
                    </div>
                    <div class="unns-stat">
                        <p class="unns-stat-label">Convergence</p>
                        <p class="unns-stat-value" id="convergence">0%</p>
                    </div>
                    <div class="unns-stat">
                        <p class="unns-stat-label">Entropy</p>
                        <p class="unns-stat-value" id="entropy">0.00</p>
                    </div>
                    <div class="unns-stat">
                        <p class="unns-stat-label">Recursion Depth</p>
                        <p class="unns-stat-value" id="recursionDepth">0</p>
                    </div>
                </div>
            </div>
            
            <div class="unns-panel">
                <h2 class="unns-panel-title">Attractor Configuration</h2>
                <div class="unns-controls">
                    <div class="unns-control-group">
                        <label class="unns-label">Attractor Type</label>
                        <select class="unns-select" id="attractorType">
                            <option value="harmonic">Harmonic (φ Convergence)</option>
                            <option value="lorenz">Lorenz (Chaotic)</option>
                            <option value="rossler">Rössler Attractor</option>
                            <option value="henon">Hénon Map</option>
                            <option value="custom">Custom Dynamics</option>
                        </select>
                    </div>
                    
                    <div class="unns-control-group">
                        <label class="unns-label">Network Layers</label>
                        <input class="unns-input" id="layerCount" max="8" type="range" value="4" />
                        <span class="unns-label" id="layerValue">4 layers</span>
                    </div>
                    
                    <div class="unns-control-group">
                        <label class="unns-label">Nodes per Layer</label>
                        <input class="unns-input" id="nodeCount" max="12" type="range" value="6" />
                        <span class="unns-label" id="nodeValue">6 nodes</span>
                    </div>
                    
                    <div class="unns-control-group">
                        <label class="unns-label">φ Parameter (Golden Ratio)</label>
                        <input class="unns-input" id="phiParam" max="100" type="range" value="61.8" />
                        <span class="unns-label" id="phiValue">1.618</span>
                    </div>
                    
                    <div class="unns-control-group">
                        <label class="unns-label">Chaos Factor (σ)</label>
                        <input class="unns-input" id="chaosParam" max="100" type="range" value="10" />
                        <span class="unns-label" id="chaosValue">10.0</span>
                    </div>
                    
                    <div class="unns-control-group">
                        <label class="unns-label">Recursion Rate</label>
                        <input class="unns-input" id="recursionRate" max="100" type="range" value="50" />
                        <span class="unns-label" id="recursionValue">50%</span>
                    </div>
                    
                    <button class="unns-button" id="initializeBtn">Initialize Network</button>
                    <button class="unns-button" id="runSimBtn">Run Simulation</button>
                    <button class="unns-button" id="resetBtn">Reset</button>
                </div>
            </div>
        </div>
        
        <div class="unns-panel">
            <h2 class="unns-panel-title">Cognitive Engine Output</h2>
            <div class="unns-canvas" id="cognitiveCanvas" style="height: 200px;"></div>
        </div>
    </div>
    
    <script>
        // UNNS Attractor Mapping System
        class UNNSMapper {
            constructor() {
                this.canvas = document.getElementById('networkCanvas');
                this.cogCanvas = document.getElementById('cognitiveCanvas');
                this.nodes = [];
                this.connections = [];
                this.attractorPoints = [];
                this.layers = 4;
                this.nodesPerLayer = 6;
                this.phi = 1.618;
                this.chaos = 10;
                this.recursionRate = 0.5;
                this.attractorType = 'harmonic';
                this.animationId = null;
                this.time = 0;
                this.recursionDepth = 0;
                
                this.initializeControls();
                this.initializeNetwork();
            }
            
            initializeControls() {
                // Attractor type
                document.getElementById('attractorType').addEventListener('change', (e) => {
                    this.attractorType = e.target.value;
                    this.updateAttractorDynamics();
                });
                
                // Layer count
                document.getElementById('layerCount').addEventListener('input', (e) => {
                    this.layers = parseInt(e.target.value);
                    document.getElementById('layerValue').textContent = `${this.layers} layers`;
                });
                
                // Node count
                document.getElementById('nodeCount').addEventListener('input', (e) => {
                    this.nodesPerLayer = parseInt(e.target.value);
                    document.getElementById('nodeValue').textContent = `${this.nodesPerLayer} nodes`;
                });
                
                // Phi parameter
                document.getElementById('phiParam').addEventListener('input', (e) => {
                    this.phi = 1 + (e.target.value / 100) * 0.618;
                    document.getElementById('phiValue').textContent = this.phi.toFixed(3);
                });
                
                // Chaos parameter
                document.getElementById('chaosParam').addEventListener('input', (e) => {
                    this.chaos = parseFloat(e.target.value);
                    document.getElementById('chaosValue').textContent = this.chaos.toFixed(1);
                });
                
                // Recursion rate
                document.getElementById('recursionRate').addEventListener('input', (e) => {
                    this.recursionRate = e.target.value / 100;
                    document.getElementById('recursionValue').textContent = `${e.target.value}%`;
                });
                
                // Buttons
                document.getElementById('initializeBtn').addEventListener('click', () => {
                    this.initializeNetwork();
                });
                
                document.getElementById('runSimBtn').addEventListener('click', () => {
                    this.runSimulation();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });
            }
            
            initializeNetwork() {
                // Clear existing elements
                this.canvas.innerHTML = '';
                this.cogCanvas.innerHTML = '';
                this.nodes = [];
                this.connections = [];
                
                const width = this.canvas.offsetWidth;
                const height = this.canvas.offsetHeight;
                
                // Create emergence layers
                for (let i = 0; i < this.layers; i++) {
                    const layer = document.createElement('div');
                    layer.className = 'unns-emergence-layer';
                    layer.style.top = `${(i + 1) * (height / (this.layers + 1))}px`;
                    layer.style.opacity = '0.3';
                    this.canvas.appendChild(layer);
                }
                
                // Create nodes
                for (let layer = 0; layer < this.layers; layer++) {
                    for (let n = 0; n < this.nodesPerLayer; n++) {
                        const node = document.createElement('div');
                        node.className = 'unns-node';
                        
                        const x = (n + 1) * (width / (this.nodesPerLayer + 1));
                        const y = (layer + 1) * (height / (this.layers + 1));
                        
                        node.style.left = `${x - 6}px`;
                        node.style.top = `${y - 6}px`;
                        node.style.background = this.getNodeColor(layer);
                        node.style.boxShadow = `0 0 20px ${this.getNodeColor(layer)}`;
                        
                        this.canvas.appendChild(node);
                        
                        this.nodes.push({
                            element: node,
                            x: x,
                            y: y,
                            layer: layer,
                            activation: Math.random(),
                            phase: Math.random() * Math.PI * 2,
                            attractorX: x,
                            attractorY: y
                        });
                    }
                }
                
                // Create connections
                this.createConnections();
                
                // Initialize cognitive engine visualization
                this.initializeCognitiveEngine();
                
                this.updateStats();
            }
            
            createConnections() {
                // Connect layers
                for (let l = 0; l < this.layers - 1; l++) {
                    const currentLayer = this.nodes.filter(n => n.layer === l);
                    const nextLayer = this.nodes.filter(n => n.layer === l + 1);
                    
                    currentLayer.forEach(node1 => {
                        nextLayer.forEach(node2 => {
                            if (Math.random() < 0.6) { // 60% connection probability
                                const connection = document.createElement('div');
                                connection.className = 'unns-connection';
                                
                                const dx = node2.x - node1.x;
                                const dy = node2.y - node1.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx);
                                
                                connection.style.left = `${node1.x}px`;
                                connection.style.top = `${node1.y}px`;
                                connection.style.width = `${distance}px`;
                                connection.style.transform = `rotate(${angle}rad)`;
                                connection.style.opacity = '0.3';
                                
                                this.canvas.appendChild(connection);
                                
                                this.connections.push({
                                    element: connection,
                                    from: node1,
                                    to: node2,
                                    strength: Math.random()
                                });
                            }
                        });
                    });
                }
            }
            
            initializeCognitiveEngine() {
                const width = this.cogCanvas.offsetWidth;
                const height = this.cogCanvas.offsetHeight;
                
                // Create recursive computation visualization
                for (let i = 0; i < 5; i++) {
                    const ring = document.createElement('div');
                    ring.style.position = 'absolute';
                    ring.style.border = `1px solid rgba(100, 255, 218, ${0.2 + i * 0.1})`;
                    ring.style.borderRadius = '50%';
                    ring.style.width = `${30 + i * 30}px`;
                    ring.style.height = `${30 + i * 30}px`;
                    ring.style.left = `${width / 2 - (15 + i * 15)}px`;
                    ring.style.top = `${height / 2 - (15 + i * 15)}px`;
                    ring.style.animation = `unns-pulse ${2 + i * 0.5}s infinite`;
                    
                    this.cogCanvas.appendChild(ring);
                }
            }
            
            getNodeColor(layer) {
                const colors = [
                    '#ff006e', '#fb5607', '#ffbe0b', '#8338ec',
                    '#3a86ff', '#06ba63', '#ff4365', '#00f5ff'
                ];
                return colors[layer % colors.length];
            }
            
            updateAttractorDynamics() {
                this.nodes.forEach((node, i) => {
                    switch(this.attractorType) {
                        case 'harmonic':
                            // Golden ratio harmonic convergence
                            node.attractorX = node.x + Math.sin(i * this.phi) * 30;
                            node.attractorY = node.y + Math.cos(i * this.phi) * 30;
                            break;
                        
                        case 'lorenz':
                            // Lorenz attractor dynamics
                            const dt = 0.01;
                            const x = (node.x - this.canvas.offsetWidth / 2) / 100;
                            const y = (node.y - this.canvas.offsetHeight / 2) / 100;
                            const z = node.layer * 5;
                            
                            const dx = this.chaos * (y - x) * dt;
                            const dy = (x * (28 - z) - y) * dt;
                            
                            node.attractorX = node.x + dx * 100;
                            node.attractorY = node.y + dy * 100;
                            break;
                        
                        case 'rossler':
                            // Rössler attractor
                            const a = 0.2, b = 0.2, c = 5.7;
                            const rx = (node.x - this.canvas.offsetWidth / 2) / 100;
                            const ry = (node.y - this.canvas.offsetHeight / 2) / 100;
                            const rz = node.layer;
                            
                            node.attractorX = node.x + (-ry - rz) * 10;
                            node.attractorY = node.y + (rx + a * ry) * 10;
                            break;
                        
                        case 'henon':
                            // Hénon map
                            const ha = 1.4, hb = 0.3;
                            const hx = (node.x - this.canvas.offsetWidth / 2) / 100;
                            const hy = (node.y - this.canvas.offsetHeight / 2) / 100;
                            
                            node.attractorX = this.canvas.offsetWidth / 2 + (1 - ha * hx * hx + hy) * 100;
                            node.attractorY = this.canvas.offsetHeight / 2 + (hb * hx) * 100;
                            break;
                        
                        case 'custom':
                            // Custom spiral dynamics
                            const angle = this.time * 0.02 + i * 0.5;
                            const radius = 20 + Math.sin(this.time * 0.01) * 10;
                            node.attractorX = node.x + Math.cos(angle) * radius;
                            node.attractorY = node.y + Math.sin(angle) * radius;
                            break;
                    }
                });
            }
            
            runSimulation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    document.getElementById('runSimBtn').textContent = 'Run Simulation';
                } else {
                    document.getElementById('runSimBtn').textContent = 'Stop Simulation';
                    this.animate();
                }
            }
            
            animate() {
                this.time++;
                
                // Update attractor dynamics
                this.updateAttractorDynamics();
                
                // Update nodes
                this.nodes.forEach((node, i) => {
                    // Move towards attractor
                    const dx = node.attractorX - node.x;
                    const dy = node.attractorY - node.y;
                    
                    node.x += dx * 0.05;
                    node.y += dy * 0.05;
                    
                    // Apply some oscillation
                    const oscX = Math.sin(this.time * 0.02 + node.phase) * 5;
                    const oscY = Math.cos(this.time * 0.02 + node.phase) * 5;
                    
                    node.element.style.left = `${node.x + oscX - 6}px`;
                    node.element.style.top = `${node.y + oscY - 6}px`;
                    
                    // Update activation
                    node.activation = (Math.sin(this.time * 0.01 + i * 0.5) + 1) / 2;
                    node.element.style.opacity = 0.5 + node.activation * 0.5;
                    
                    // Recursive computation effect
                    if (Math.random() < this.recursionRate * 0.01) {
                        this.createRecursionPulse(node);
                        this.recursionDepth = Math.min(this.recursionDepth + 1, 10);
                    }
                });
                
                // Update connections
                this.connections.forEach(conn => {
                    const strength = (conn.from.activation + conn.to.activation) / 2;
                    conn.element.style.opacity = strength * 0.5;
                });
                
                // Update cognitive engine
                this.updateCognitiveEngine();
                
                // Update stats
                this.updateStats();
                
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            createRecursionPulse(node) {
                const pulse = document.createElement('div');
                pulse.style.position = 'absolute';
                pulse.style.left = `${node.x - 15}px`;
                pulse.style.top = `${node.y - 15}px`;
                pulse.style.width = '30px';
                pulse.style.height = '30px';
                pulse.style.border = `2px solid ${this.getNodeColor(node.layer)}`;
                pulse.style.borderRadius = '50%';
                pulse.style.pointerEvents = 'none';
                pulse.style.animation = 'unns-pulse 1s ease-out';
                
                this.canvas.appendChild(pulse);
                
                setTimeout(() => {
                    pulse.remove();
                }, 1000);
            }
            
            updateCognitiveEngine() {
                const rings = this.cogCanvas.querySelectorAll('div');
                rings.forEach((ring, i) => {
                    const scale = 1 + Math.sin(this.time * 0.02 + i * 0.5) * 0.1;
                    ring.style.transform = `scale(${scale}) rotate(${this.time + i * 30}deg)`;
                });
            }
            
            updateStats() {
                const activeCount = this.nodes.filter(n => n.activation > 0.5).length;
                const convergence = this.calculateConvergence();
                const entropy = this.calculateEntropy();
                
                document.getElementById('activeNodes').textContent = activeCount;
                document.getElementById('convergence').textContent = `${Math.round(convergence)}%`;
                document.getElementById('entropy').textContent = entropy.toFixed(2);
                document.getElementById('recursionDepth').textContent = this.recursionDepth;
            }
            
            calculateConvergence() {
                let totalDist = 0;
                let maxDist = 0;
                
                this.nodes.forEach(node => {
                    const dx = node.attractorX - node.x;
                    const dy = node.attractorY - node.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    totalDist += dist;
                    maxDist = Math.max(maxDist, 100);
                });
                
                return Math.max(0, 100 - (totalDist / (this.nodes.length * maxDist)) * 100);
            }
            
            calculateEntropy() {
                const activations = this.nodes.map(n => n.activation);
                const sum = activations.reduce((a, b) => a + b, 0);
                
                if (sum === 0) return 0;
                
                let entropy = 0;
                activations.forEach(a => {
                    const p = a / sum;
                    if (p > 0) {
                        entropy -= p * Math.log2(p);
                    }
                });
                
                return entropy;
            }
            
            reset() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                this.time = 0;
                this.recursionDepth = 0;
                document.getElementById('runSimBtn').textContent = 'Run Simulation';
                
                this.initializeNetwork();
            }
        }
        
        // Initialize the system
        const unnsMapper = new UNNSMapper();
    </script>
</body>
</html>
