<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Trans-Sentifying: Ceremonial Protocol</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        /* Glyphic Header Block */
        .glyphic-header {
            position: relative;
            height: 400px;
            background: radial-gradient(ellipse at center, rgba(0,255,255,0.1) 0%, rgba(255,0,255,0.05) 50%, transparent 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .glyph-ring {
            position: absolute;
            width: 350px;
            height: 350px;
            animation: rotate 30s linear infinite;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .glyph-symbol {
            position: absolute;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px currentColor;
            transition: all 0.3s ease;
        }
        
        .glyph-symbol:hover {
            transform: scale(1.3);
            filter: brightness(1.5);
        }
        
        .ceremonial-title {
            font-size: 3rem;
            color: #00ffff;
            text-align: center;
            text-shadow: 0 0 30px #00ffff50;
            z-index: 10;
            animation: pulse 3s ease-in-out infinite;
            margin-bottom: 1rem;
        }
        
        .ceremonial-subtitle {
            font-size: 1.5rem;
            color: #ff00ff;
            text-align: center;
            opacity: 0.9;
            z-index: 10;
            font-style: italic;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* Trans-Sentifying Score */
        .score-display {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 1rem;
            z-index: 100;
        }
        
        .score-meter {
            position: relative;
            width: 150px;
            height: 150px;
            margin: 0 auto;
        }
        
        .score-spiral {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, 
                transparent 0deg,
                #00ffff 90deg,
                #ff00ff 180deg,
                #ffff00 270deg,
                transparent 360deg);
            animation: rotate 4s linear infinite;
            opacity: 0.3;
        }
        
        .score-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 10px currentColor;
        }
        
        .score-label {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #ff00ff;
        }
        
        /* Operator Flow */
        .operator-flow {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .operator-node {
            padding: 5px 10px;
            background: linear-gradient(45deg, rgba(0,255,255,0.3), rgba(255,0,255,0.3));
            border: 1px solid #00ffff;
            border-radius: 5px;
            font-size: 0.9rem;
            position: relative;
        }
        
        .operator-arrow {
            width: 20px;
            height: 2px;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            position: relative;
        }
        
        .operator-arrow::after {
            content: '▶';
            position: absolute;
            right: -8px;
            top: -7px;
            color: #ff00ff;
            font-size: 12px;
        }
        
        /* Extended Pedagogy Levels */
        .level-badge {
            display: inline-block;
            padding: 3px 8px;
            background: linear-gradient(45deg, #00ffff20, #ff00ff20);
            border: 1px solid #00ffff;
            border-radius: 5px;
            font-size: 0.8rem;
            margin-left: 10px;
        }
        
        .glyph-unlock {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #000 0%, #1a1a2e 100%);
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            display: none;
            z-index: 200;
            animation: glowUnlock 2s ease-in-out;
        }
        
        @keyframes glowUnlock {
            0% { box-shadow: 0 0 5px #ffd700; }
            50% { box-shadow: 0 0 30px #ffd700, 0 0 50px #ff00ff; }
            100% { box-shadow: 0 0 5px #ffd700; }
        }
        
        .main-content {
            padding: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .intro {
            background: rgba(0,255,255,0.05);
            border: 1px solid #00ffff30;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border-radius: 10px;
        }
        
        .engine-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .engine {
            background: rgba(255,255,255,0.02);
            border: 1px solid #444;
            border-radius: 15px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .engine:hover {
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0,255,255,0.2);
        }
        
        .engine-header {
            background: linear-gradient(90deg, rgba(0,255,255,0.1), rgba(255,0,255,0.1));
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
        }
        
        .engine-title {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 0.3rem;
        }
        
        .engine-desc {
            color: #ff00ff;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .engine-content {
            padding: 1.5rem;
        }
        
        .perception-canvas {
            width: 100%;
            height: 300px;
            border: 2px solid #333;
            border-radius: 10px;
            background: #000;
            margin-bottom: 1rem;
        }
        
        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }
        
        .control-label {
            color: #aaa;
            font-size: 0.8rem;
        }
        
        .slider {
            width: 120px;
            height: 5px;
            background: #333;
            outline: none;
            border-radius: 5px;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .button {
            background: linear-gradient(45deg, #00ffff20, #ff00ff20);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            background: linear-gradient(45deg, #00ffff40, #ff00ff40);
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
        }
        
        .output-panel {
            background: rgba(0,0,0,0.3);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .theory-section {
            background: rgba(255,0,255,0.05);
            border: 1px solid #ff00ff30;
            padding: 2rem;
            margin-top: 2rem;
            border-radius: 15px;
        }
        
        .theory-title {
            color: #ff00ff;
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .lesson-stage {
            background: rgba(0,255,255,0.05);
            border: 1px solid #00ffff30;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
        }
        
        .stage-title {
            color: #00ffff;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            width: 0%;
            transition: width 1s ease;
        }
        
        .interactive-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: 3px;
            margin: 1rem 0;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .grid-cell {
            aspect-ratio: 1;
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #111;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .grid-cell:hover {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
        }
        
        .grid-cell.revealed {
            border-color: #00ffff;
            background: linear-gradient(45deg, rgba(0,255,255,0.2), rgba(255,0,255,0.2));
        }
        
        .grid-cell.correct {
            border-color: #00ff00;
            background: rgba(0,255,0,0.2);
            animation: cellpulse 0.5s ease;
        }
        
        @keyframes cellpulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- Glyphic Header Block -->
    <div class="glyphic-header">
        <div class="glyph-ring" id="glyphRing"></div>
        <h1 class="ceremonial-title">UNNS Trans-Sentifying Protocol</h1>
        <div class="ceremonial-subtitle">From mathematical silence to perceptual breath</div>
    </div>
    
    <!-- Trans-Sentifying Score Display -->
    <div class="score-display">
        <div class="score-meter">
            <div class="score-spiral"></div>
            <div class="score-value" id="scoreValue">0</div>
        </div>
        <div class="score-label">Trans-Sentifying Index</div>
        <div style="margin-top: 10px; font-size: 0.8rem;">
            <div>Complexity: <span id="scoreComplexity">0</span></div>
            <div>Rhythm: <span id="scoreRhythm">0</span></div>
            <div>Clarity: <span id="scoreClarity">0</span></div>
        </div>
    </div>
    
    <!-- Glyph Unlock Notification -->
    <div class="glyph-unlock" id="glyphUnlock">
        <h2 style="color: #ffd700; margin-bottom: 1rem;">🔓 Glyph Unlocked!</h2>
        <div id="unlockedGlyph" style="font-size: 3rem; margin: 1rem 0;"></div>
        <div id="unlockedName" style="color: #00ffff;"></div>
    </div>
    
    <div class="main-content">
        <div class="intro">
            <p><strong>Trans-Sentifying</strong> transforms abstract recursive mathematical structures into forms accessible to human perception and intuition. It bridges the gap between mathematical elegance and experiential understanding, making UNNS <em>feelable</em> rather than merely comprehensible.</p>
            <p>These three perception engines demonstrate how recursive patterns can be exported into visual art, scientific visualization, and pedagogical tools - each optimized for different modes of human cognition.</p>
        </div>
        
        <div class="engine-grid">
            <!-- Art Perception Engine -->
            <div class="engine">
                <div class="engine-header">
                    <div class="engine-title">🎨 Art Perception Engine</div>
                    <div class="engine-desc">Continuous transformation of recursive sequences into evolving visual art</div>
                </div>
                <div class="engine-content">
                    <div class="operator-flow" id="artOperatorFlow">
                        <div class="operator-node">Inlaying</div>
                        <div class="operator-arrow"></div>
                        <div class="operator-node">Cascade</div>
                        <div class="operator-arrow"></div>
                        <div class="operator-node">Echo</div>
                        <button class="button" style="margin-left: auto; padding: 3px 8px; font-size: 0.8rem;" onclick="toggleOperatorFlow('art')">View Flow</button>
                    </div>
                    <canvas id="artCanvas" class="perception-canvas"></canvas>
                    <div class="controls">
                        <div class="control-group">
                            <label class="control-label">Sequence Type</label>
                            <select id="artSequence" class="button" style="width: auto;">
                                <option value="fibonacci">Fibonacci</option>
                                <option value="tribonacci">Tribonacci</option>
                                <option value="lucas">Lucas</option>
                                <option value="pell">Pell</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Visual Mode</label>
                            <select id="artMode" class="button" style="width: auto;">
                                <option value="morphing_spiral">Morphing Spiral</option>
                                <option value="flowing_wave">Flowing Wave</option>
                                <option value="growing_fractal">Growing Fractal</option>
                                <option value="dancing_particles">Dancing Particles</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Complexity: <span id="complexityValue">8</span></label>
                            <input type="range" id="complexity" class="slider" min="5" max="15" value="8">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Speed: <span id="speedValue">50</span>ms</label>
                            <input type="range" id="animSpeed" class="slider" min="20" max="200" value="50">
                        </div>
                        <button id="pauseArt" class="button">Pause</button>
                    </div>
                    <div class="output-panel" id="artOutput">
                        🎨 Art Engine: ACTIVE | Mode: Morphing Spiral<br>
                        Operator Chain: Inlaying → Cascade → Echo<br>
                        Trans-Sentified: Mathematical ratios → Continuous visual harmony
                    </div>
                </div>
            </div>
            
            <!-- Science Perception Engine -->
            <div class="engine">
                <div class="engine-header">
                    <div class="engine-title">🔬 Science Perception Engine</div>
                    <div class="engine-desc">Distinct visualizations of scientific phenomena through UNNS operators</div>
                </div>
                <div class="engine-content">
                    <div class="operator-flow" id="scienceOperatorFlow">
                        <div class="operator-node">Branching</div>
                        <div class="operator-arrow"></div>
                        <div class="operator-node">Merging</div>
                        <div class="operator-arrow"></div>
                        <div class="operator-node">Projection</div>
                        <button class="button" style="margin-left: auto; padding: 3px 8px; font-size: 0.8rem;" onclick="toggleOperatorFlow('science')">View Flow</button>
                    </div>
                    <canvas id="scienceCanvas" class="perception-canvas"></canvas>
                    <div class="controls">
                        <div class="control-group">
                            <label class="control-label">Scientific Domain</label>
                            <select id="scienceDomain" class="button" style="width: auto;">
                                <option value="quantum">Quantum Field</option>
                                <option value="neural">Neural Network</option>
                                <option value="ecosystem">Ecosystem Web</option>
                                <option value="galaxy">Galaxy Formation</option>
                                <option value="molecular">Molecular Dance</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="control-label">UNNS Operator</label>
                            <select id="scienceOperator" class="button" style="width: auto;">
                                <optgroup label="🔹 Tetrad (Foundational)">
                                    <option value="inletting">Inletting</option>
                                    <option value="inlaying">Inlaying</option>
                                    <option value="repair">Repair</option>
                                    <option value="trans-sentifying">Trans-Sentifying</option>
                                </optgroup>
                                <optgroup label="🔸 Octad (Transformational)">
                                    <option value="branching">Branching</option>
                                    <option value="merging">Merging</option>
                                    <option value="shadowing">Shadowing</option>
                                    <option value="projection">Projection</option>
                                </optgroup>
                                <optgroup label="🔺 Higher-Order Triad">
                                    <option value="decomposing">Decomposing</option>
                                    <option value="evaluating">Evaluating</option>
                                    <option value="adopting">Adopting</option>
                                </optgroup>
                                <optgroup label="🔻 Meta-Operator">
                                    <option value="collapse">Collapse</option>
                                </optgroup>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Intensity: <span id="intensityValue">5</span></label>
                            <input type="range" id="intensity" class="slider" min="1" max="10" value="5">
                        </div>
                        <button id="resetSim" class="button">Reset</button>
                    </div>
                    <div class="output-panel" id="scienceOutput">
                        🔬 Science Engine: Quantum Field + Inletting<br>
                        Operator Chain: Branching → Merging → Projection<br>
                        System Evolution: t=0.0s | Operator Effect: Initializing
                    </div>
                </div>
            </div>
            
            <!-- Pedagogy Perception Engine -->
            <div class="engine">
                <div class="engine-header">
                    <div class="engine-title">🎓 Pedagogy Perception Engine</div>
                    <div class="engine-desc">Progressive, animated lessons that guide mathematical discovery</div>
                </div>
                <div class="engine-content">
                    <div class="operator-flow" id="pedagogyOperatorFlow">
                        <div class="operator-node">Discovery</div>
                        <div class="operator-arrow"></div>
                        <div class="operator-node">Pattern</div>
                        <div class="operator-arrow"></div>
                        <div class="operator-node">Recursion</div>
                        <button class="button" style="margin-left: auto; padding: 3px 8px; font-size: 0.8rem;" onclick="toggleOperatorFlow('pedagogy')">View Flow</button>
                    </div>
                    <canvas id="pedagogyCanvas" class="perception-canvas"></canvas>
                    
                    <div class="lesson-stage">
                        <div class="stage-title" id="stageTitle">Ready to Explore Recursion</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div id="stageDescription">Click "Begin Journey" to start your mathematical adventure!</div>
                    </div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label class="control-label">Learning Level</label>
                            <select id="learningLevel" class="button" style="width: auto;">
                                <option value="elementary">Elementary</option>
                                <option value="middle">Middle School</option>
                                <option value="high">High School</option>
                                <option value="advanced">Advanced</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Learning Speed</label>
                            <input type="range" id="learningSpeed" class="slider" min="500" max="3000" value="1500">
                        </div>
                        <button id="beginJourney" class="button">Begin Journey</button>
                        <button id="nextStage" class="button" style="display:none;">Next Stage</button>
                        <button id="getHint" class="button">Get Hint</button>
                    </div>
                    
                    <div class="interactive-grid" id="interactiveGrid">
                        <!-- Grid will be populated dynamically -->
                    </div>
                    
                    <div class="output-panel" id="pedagogyOutput">
                        🎓 Pedagogy Engine: Ready | Level: Elementary<br>
                        Learning Stage: 0/5 | Discoveries Made: 0<br>
                        Trans-Sentified: Abstract recursion → Interactive pattern discovery
                    </div>
                </div>
            </div>
        </div>
        
        <div class="theory-section">
            <h3 class="theory-title">Trans-Sentifying Theory & Ceremonial Implementation</h3>
            <p><strong>The Glyphic Protocol:</strong> Each UNNS operator is more than a function - it's a ceremonial glyph that transforms mathematical silence into perceptual breath. The twelve glyphs spiral through consciousness, each leaving its unique resonance.</p>
            
            <p><strong>Operator Chains:</strong> No transformation occurs in isolation. Each engine employs a chain of operators, creating a flow from input to experience. Art flows through Inlaying → Cascade → Echo. Science branches through Branching → Merging → Projection. Pedagogy discovers through Discovery → Pattern → Recursion.</p>
            
            <p><strong>The Trans-Sentifying Index:</strong> A living metric that measures how successfully abstract recursion becomes experienceable. It factors complexity (structural depth), rhythm (temporal harmony), and clarity (perceptual resolution) into a unified score that spirals between 0 and ∞.</p>
            
            <p><strong>Progressive Mastery:</strong> The learning path evolves from Elementary (basic pattern recognition) through Recursive (self-referential understanding), to Glyphic (operator manipulation), and finally to Collapse (unified transcendence). Each level unlocks new glyphs and deeper ceremonial understanding.</p>
        </div>
    </div>
    
    <script>
        // Initialize Glyphic Header
        function initializeGlyphRing() {
            const glyphs = ['◈', '◊', '◉', '◎', '◐', '◑', '◒', '◓', '◔', '◕', '◖', '◗'];
            const glyphNames = ['Inletting', 'Inlaying', 'Repair', 'Trans-Sentifying', 
                               'Branching', 'Merging', 'Shadowing', 'Projection',
                               'Decomposing', 'Evaluating', 'Adopting', 'Collapse'];
            
            const ring = document.getElementById('glyphRing');
            const radius = 150;
            
            glyphs.forEach((glyph, i) => {
                const angle = (i / glyphs.length) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * radius + 175;
                const y = Math.sin(angle) * radius + 175;
                
                const glyphEl = document.createElement('div');
                glyphEl.className = 'glyph-symbol';
                glyphEl.textContent = glyph;
                glyphEl.style.left = x + 'px';
                glyphEl.style.top = y + 'px';
                glyphEl.style.color = `hsl(${i * 30}, 80%, 70%)`;
                glyphEl.title = glyphNames[i];
                
                glyphEl.addEventListener('mouseenter', () => {
                    glyphEl.style.fontSize = '36px';
                    glyphEl.style.textShadow = `0 0 25px hsl(${i * 30}, 80%, 70%)`;
                });
                
                glyphEl.addEventListener('mouseleave', () => {
                    glyphEl.style.fontSize = '28px';
                    glyphEl.style.textShadow = `0 0 15px currentColor`;
                });
                
                ring.appendChild(glyphEl);
            });
        }
        
        // Trans-Sentifying Score Calculator
        class TransSentifyingScore {
            constructor() {
                this.complexity = 0;
                this.rhythm = 0;
                this.clarity = 0;
                this.update();
            }
            
            update() {
                this.complexity = Math.floor(Math.random() * 30) + parseInt(document.getElementById('complexity')?.value || 8);
                this.rhythm = Math.floor(Math.sin(Date.now() * 0.001) * 20 + 50);
                this.clarity = Math.floor(Math.random() * 20 + 60);
                
                const total = Math.floor((this.complexity + this.rhythm + this.clarity) / 3);
                
                document.getElementById('scoreValue').textContent = total;
                document.getElementById('scoreComplexity').textContent = this.complexity;
                document.getElementById('scoreRhythm').textContent = this.rhythm;
                document.getElementById('scoreClarity').textContent = this.clarity;
                
                const spiral = document.querySelector('.score-spiral');
                if (spiral) {
                    spiral.style.animationDuration = Math.max(1, 10 - total / 10) + 's';
                }
            }
        }
        
        // Art Perception Engine
        class ArtEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.time = 0;
                this.frameCount = 0;
                this.isRunning = true;
                this.operatorChain = ['Inlaying', 'Cascade', 'Echo'];
                
                this.sequences = {
                    fibonacci: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233],
                    tribonacci: [1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274],
                    lucas: [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199],
                    pell: [1, 2, 5, 12, 29, 70, 169, 408, 985, 2378]
                };
                
                this.startAnimation();
            }
            
            startAnimation() {
                const animate = () => {
                    if (this.isRunning) {
                        this.render();
                        this.time += 0.02;
                        this.frameCount++;
                        
                        const speed = parseInt(document.getElementById('animSpeed').value);
                        setTimeout(() => {
                            requestAnimationFrame(animate);
                        }, speed);
                    }
                };
                animate();
            }
            
            render() {
                const sequence = document.getElementById('artSequence').value;
                const mode = document.getElementById('artMode').value;
                const complexity = parseInt(document.getElementById('complexity').value);
                
                const seq = this.sequences[sequence];
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                switch(mode) {
                    case 'morphing_spiral':
                        this.drawMorphingSpiral(seq, complexity);
                        break;
                    case 'flowing_wave':
                        this.drawFlowingWave(seq, complexity);
                        break;
                    case 'growing_fractal':
                        this.drawGrowingFractal(seq, complexity);
                        break;
                    case 'dancing_particles':
                        this.drawDancingParticles(seq, complexity);
                        break;
                }
                
                const currentSeqIndex = Math.floor(this.time * 2) % seq.length;
                document.getElementById('artOutput').innerHTML = 
                    `🎨 Art Engine: ACTIVE | Mode: ${mode.replace('_', ' ')}<br>
                    Operator Chain: ${this.operatorChain.join(' → ')}<br>
                    Frame: ${this.frameCount} | Sequence: ${sequence}[${currentSeqIndex}] = ${seq[currentSeqIndex]}`;
            }
            
            drawMorphingSpiral(seq, complexity) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                for (let i = 0; i < complexity; i++) {
                    const seqValue = seq[i % seq.length];
                    const angle = this.time + i * 0.5;
                    const radius = 20 + seqValue * 3 + Math.sin(this.time + i) * 10;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const hue = (seqValue * 30 + this.time * 50) % 360;
                    const alpha = 0.8 + Math.sin(this.time + i) * 0.2;
                    
                    this.ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 4 + Math.sin(this.time + i) * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    if (i < complexity - 1) {
                        const nextSeqValue = seq[(i + 1) % seq.length];
                        const nextAngle = this.time + (i + 1) * 0.5;
                        const nextRadius = 20 + nextSeqValue * 3 + Math.sin(this.time + i + 1) * 10;
                        const nextX = centerX + Math.cos(nextAngle) * nextRadius;
                        const nextY = centerY + Math.sin(nextAngle) * nextRadius;
                        
                        this.ctx.strokeStyle = `hsla(${hue}, 60%, 50%, 0.4)`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, y);
                        this.ctx.lineTo(nextX, nextY);
                        this.ctx.stroke();
                    }
                }
            }
            
            drawFlowingWave(seq, complexity) {
                const waves = 3;
                for (let wave = 0; wave < waves; wave++) {
                    this.ctx.beginPath();
                    const hue = (wave * 120 + this.time * 30) % 360;
                    this.ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.7)`;
                    this.ctx.lineWidth = 3 - wave * 0.5;
                    
                    for (let x = 0; x < this.canvas.width; x += 3) {
                        const seqIndex = Math.floor((x / this.canvas.width) * complexity) % seq.length;
                        const seqValue = seq[seqIndex];
                        
                        const baseY = this.canvas.height / 2;
                        const frequency = (seqValue / 20) + wave * 0.5;
                        const amplitude = 40 + seqValue * 2;
                        const phase = this.time * 2 + wave * Math.PI / 3;
                        
                        const y = baseY + Math.sin(x * frequency * 0.01 + phase) * amplitude / (wave + 1);
                        
                        if (x === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();
                }
            }
            
            drawGrowingFractal(seq, complexity) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height - 50;
                const maxDepth = Math.min(complexity, 8);
                
                this.drawFractalBranch(centerX, centerY, -Math.PI/2, 80, seq, 0, maxDepth);
            }
            
            drawFractalBranch(x, y, angle, length, seq, depth, maxDepth) {
                if (depth >= maxDepth || length < 3) return;
                
                const seqValue = seq[depth % seq.length];
                const growthFactor = 0.5 + Math.sin(this.time + depth) * 0.3;
                const actualLength = length * growthFactor;
                
                const endX = x + Math.cos(angle) * actualLength;
                const endY = y + Math.sin(angle) * actualLength;
                
                const hue = (seqValue * 25 + depth * 40 + this.time * 20) % 360;
                const alpha = Math.max(0.3, 1 - depth * 0.15);
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(endX, endY);
                this.ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
                this.ctx.lineWidth = Math.max(1, maxDepth - depth + 1);
                this.ctx.stroke();
                
                const angleStep = (seqValue / 10) + Math.sin(this.time) * 0.2;
                const newLength = actualLength * (0.6 + seqValue / 50);
                
                this.drawFractalBranch(endX, endY, angle - angleStep, newLength, seq, depth + 1, maxDepth);
                this.drawFractalBranch(endX, endY, angle + angleStep, newLength, seq, depth + 1, maxDepth);
            }
            
            drawDancingParticles(seq, complexity) {
                const particleCount = complexity * 8;
                
                for (let i = 0; i < particleCount; i++) {
                    const seqValue = seq[i % seq.length];
                    const baseX = (i % 10) * (this.canvas.width / 10) + this.canvas.width / 20;
                    const baseY = Math.floor(i / 10) * (this.canvas.height / 8) + this.canvas.height / 16;
                    
                    const offsetX = Math.sin(this.time + i * 0.1) * seqValue * 2;
                    const offsetY = Math.cos(this.time + i * 0.15) * seqValue * 1.5;
                    
                    const x = baseX + offsetX;
                    const y = baseY + offsetY;
                    
                    const size = 3 + (seqValue % 8) + Math.sin(this.time * 2 + i) * 2;
                    const hue = (seqValue * 20 + this.time * 100 + i * 10) % 360;
                    const alpha = 0.6 + Math.sin(this.time * 3 + i) * 0.4;
                    
                    this.ctx.fillStyle = `hsla(${hue}, 85%, 65%, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    const prevX = baseX + Math.sin(this.time - 0.1 + i * 0.1) * seqValue * 2;
                    const prevY = baseY + Math.cos(this.time - 0.1 + i * 0.15) * seqValue * 1.5;
                    
                    this.ctx.strokeStyle = `hsla(${hue}, 60%, 50%, 0.3)`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(prevX, prevY);
                    this.ctx.lineTo(x, y);
                    this.ctx.stroke();
                }
            }
            
            pause() {
                this.isRunning = !this.isRunning;
                if (this.isRunning) {
                    this.startAnimation();
                }
            }
        }
        
        // Science Perception Engine - FULL RESTORATION
        class ScienceEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.time = 0;
                this.isRunning = true;
                this.startAnimation();
            }
            
            startAnimation() {
                const animate = () => {
                    if (this.isRunning) {
                        this.render();
                        this.time += 0.05;
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }
            
            render() {
                const domain = document.getElementById('scienceDomain').value;
                const operator = document.getElementById('scienceOperator').value;
                const intensity = parseInt(document.getElementById('intensity').value);
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                switch(domain) {
                    case 'quantum':
                        this.renderQuantumField(operator, intensity);
                        break;
                    case 'neural':
                        this.renderNeuralNetwork(operator, intensity);
                        break;
                    case 'ecosystem':
                        this.renderEcosystemWeb(operator, intensity);
                        break;
                    case 'galaxy':
                        this.renderGalaxyFormation(operator, intensity);
                        break;
                    case 'molecular':
                        this.renderMolecularDance(operator, intensity);
                        break;
                }
                
                document.getElementById('scienceOutput').innerHTML = 
                    `🔬 Science Engine: ${domain.charAt(0).toUpperCase() + domain.slice(1)} + ${operator.charAt(0).toUpperCase() + operator.slice(1)}<br>
                    System Evolution: t=${this.time.toFixed(1)}s | Intensity: ${intensity}/10<br>
                    Trans-Sentified: ${this.getTransSentifyDescription(domain, operator)}`;
            }
            
            renderQuantumField(operator, intensity) {
                for (let i = 0; i < 12; i++) {
                    const x = (i + 0.5) * (this.canvas.width / 12);
                    const baseAmplitude = 50 * (intensity / 10);
                    
                    let amplitude = baseAmplitude;
                    let frequency = 1;
                    let phase = 0;
                    
                    switch(operator) {
                        case 'inletting':
                            amplitude *= 1 + Math.sin(this.time + i * 0.5) * 0.5;
                            break;
                        case 'inlaying':
                            amplitude *= 0.7 + Math.cos(this.time * 2 + i) * 0.4;
                            phase = Math.sin(this.time + i) * Math.PI;
                            break;
                        case 'repair':
                            amplitude *= 0.8 + Math.abs(Math.sin(this.time * 2 + i)) * 0.4;
                            break;
                        case 'trans-sentifying':
                            amplitude *= 1 + Math.sin(this.time * 3) * Math.cos(i * 0.5) * 0.6;
                            frequency = 1 + Math.sin(i * 0.3) * 0.5;
                            break;
                        case 'branching':
                            amplitude *= (i % 2 === 0) ? 1.3 : 0.7;
                            break;
                        case 'merging':
                            amplitude *= 1 - Math.abs(i - 6) * 0.1;
                            break;
                        case 'shadowing':
                            amplitude *= Math.abs(Math.sin(this.time + i * 0.8)) * 1.2;
                            break;
                        case 'projection':
                            amplitude *= Math.exp(-Math.pow(i - 6, 2) * 0.05);
                            break;
                        case 'decomposing':
                            amplitude *= Math.sin(this.time) > 0 ? (1 + i * 0.1) : (1 - i * 0.05);
                            break;
                        case 'evaluating':
                            amplitude *= 0.5 + Math.abs(Math.sin(this.time + i * 0.7)) * 0.8;
                            break;
                        case 'adopting':
                            amplitude *= Math.exp(-Math.abs(this.time % 4 - 2)) * (1 + i * 0.1);
                            break;
                        case 'collapse':
                            amplitude *= Math.exp(-Math.abs(Math.sin(this.time + i)));
                            break;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = `hsl(${200 + i * 10}, 80%, 60%)`;
                    this.ctx.lineWidth = 2;
                    
                    for (let y = 50; y < this.canvas.height - 50; y += 2) {
                        const waveY = y + Math.sin((y - 50) * 0.02 * frequency + this.time + i * 0.3 + phase) * amplitude * 0.3;
                        if (y === 50) this.ctx.moveTo(x, waveY);
                        else this.ctx.lineTo(x, waveY);
                    }
                    this.ctx.stroke();
                    
                    const probability = Math.abs(Math.sin(this.time + i * 0.3));
                    this.ctx.fillStyle = `hsla(${200 + i * 15}, 80%, 70%, ${probability * 0.5})`;
                    this.ctx.fillRect(x - 8, this.canvas.height - 100, 16, probability * 80);
                }
            }
            
            renderNeuralNetwork(operator, intensity) {
                const neurons = 24;
                const layers = 4;
                
                for (let layer = 0; layer < layers; layer++) {
                    const layerX = (layer + 1) * (this.canvas.width / (layers + 1));
                    const neuronsInLayer = neurons - layer * 2;
                    
                    for (let n = 0; n < neuronsInLayer; n++) {
                        const y = (n + 1) * (this.canvas.height / (neuronsInLayer + 1));
                        
                        let activation = Math.sin(this.time + layer * 0.5 + n * 0.3);
                        
                        switch(operator) {
                            case 'inletting':
                                activation *= 1 + Math.sin(this.time * 2 + n) * 0.7;
                                break;
                            case 'inlaying':
                                activation *= 0.5 + Math.abs(Math.cos(this.time + layer + n)) * 0.8;
                                break;
                            case 'repair':
                                activation = Math.abs(activation) * (0.7 + intensity / 20);
                                break;
                            case 'trans-sentifying':
                                activation *= 1 + Math.sin(this.time * 3 + layer * n) * 0.5;
                                break;
                            case 'branching':
                                activation *= (1 + layer * 0.3) * (n % 2 === 0 ? 1.2 : 0.8);
                                break;
                            case 'merging':
                                const centerDistance = Math.abs(n - neuronsInLayer / 2);
                                activation *= 1.2 - centerDistance * 0.1;
                                break;
                            case 'shadowing':
                                activation *= Math.abs(Math.sin(this.time + n * 0.8)) * 1.3;
                                break;
                            case 'projection':
                                activation *= Math.exp(-layer * 0.3) * (1 + Math.sin(n * 0.5));
                                break;
                            case 'decomposing':
                                activation *= (this.time % 3 < 1.5) ? (1 + n * 0.05) : (0.5 + n * 0.02);
                                break;
                            case 'evaluating':
                                const evalPhase = Math.floor(this.time * 2) % 4;
                                activation *= (layer === evalPhase) ? 1.5 : 0.3;
                                break;
                            case 'adopting':
                                activation *= Math.exp(-Math.abs(this.time % 6 - 3)) * (1 + layer * 0.2);
                                break;
                            case 'collapse':
                                activation *= Math.exp(-(this.time % 3)) * (1 - layer * 0.2);
                                break;
                        }
                        
                        activation = Math.max(0, Math.min(1, activation));
                        
                        const size = 8 + activation * 12;
                        this.ctx.fillStyle = `hsl(${layer * 60 + activation * 60}, 80%, ${40 + activation * 40}%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(layerX, y, size, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        if (layer < layers - 1) {
                            const nextLayerX = (layer + 2) * (this.canvas.width / (layers + 1));
                            const nextNeurons = neurons - (layer + 1) * 2;
                            
                            for (let nextN = 0; nextN < nextNeurons; nextN++) {
                                const nextY = (nextN + 1) * (this.canvas.height / (nextNeurons + 1));
                                let weight = Math.sin(this.time + layer + n + nextN) * 0.5 + 0.5;
                                
                                if (operator === 'branching') {
                                    weight *= (nextN % 2 === n % 2) ? 1.3 : 0.7;
                                } else if (operator === 'merging') {
                                    weight *= 1.2 - Math.abs(nextN - n) * 0.1;
                                } else if (operator === 'projection') {
                                    weight *= Math.exp(-Math.abs(nextN - n) * 0.2);
                                }
                                
                                this.ctx.strokeStyle = `hsla(${(layer + 1) * 60}, 60%, 50%, ${weight * activation * 0.8})`;
                                this.ctx.lineWidth = 1 + weight * 2;
                                this.ctx.beginPath();
                                this.ctx.moveTo(layerX, y);
                                this.ctx.lineTo(nextLayerX, nextY);
                                this.ctx.stroke();
                            }
                        }
                        
                        if (activation > 0.7) {
                            this.ctx.strokeStyle = `hsl(${layer * 60}, 90%, 80%)`;
                            this.ctx.lineWidth = 3;
                            this.ctx.beginPath();
                            this.ctx.arc(layerX, y, size + 5, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                }
            }
            
            renderEcosystemWeb(operator, intensity) {
                const species = [
                    { name: 'Producers', x: this.canvas.width * 0.2, y: this.canvas.height * 0.7, color: 120, size: 20 },
                    { name: 'Herbivores', x: this.canvas.width * 0.4, y: this.canvas.height * 0.5, color: 60, size: 15 },
                    { name: 'Carnivores', x: this.canvas.width * 0.6, y: this.canvas.height * 0.3, color: 0, size: 18 },
                    { name: 'Decomposers', x: this.canvas.width * 0.8, y: this.canvas.height * 0.6, color: 280, size: 12 },
                    { name: 'Apex', x: this.canvas.width * 0.5, y: this.canvas.height * 0.1, color: 300, size: 22 }
                ];
                
                species.forEach((sp, i) => {
                    let population = Math.sin(this.time * 0.8 + i) * 0.5 + 0.5;
                    
                    switch(operator) {
                        case 'inletting':
                            population *= 1 + Math.sin(this.time * 2 + i * 1.5) * 0.6;
                            break;
                        case 'inlaying':
                            const layerEffect = Math.sin(this.time + i * 0.7) * 0.4 + 0.8;
                            population *= layerEffect;
                            break;
                        case 'repair':
                            population = 0.6 + Math.abs(Math.sin(this.time + i)) * 0.4;
                            break;
                        case 'trans-sentifying':
                            population *= 0.7 + Math.sin(this.time * 3 + i * 2) * 0.5;
                            break;
                        case 'branching':
                            population *= 1 + Math.sin(this.time + i * 2) * 0.7;
                            break;
                        case 'merging':
                            const convergence = 1 - Math.abs(i - 2) * 0.15;
                            population *= convergence;
                            break;
                        case 'shadowing':
                            population *= 0.3 + Math.abs(Math.sin(this.time * 1.5 + i)) * 0.9;
                            break;
                        case 'projection':
                            population *= Math.exp(-Math.abs(i - 2) * 0.3) + 0.3;
                            break;
                        case 'decomposing':
                            const decompPhase = (this.time % 4) / 4;
                            population *= (i === Math.floor(decompPhase * 5)) ? 1.5 : 0.6;
                            break;
                        case 'evaluating':
                            const evalCycle = Math.floor(this.time * 2) % 5;
                            population *= (i === evalCycle) ? 1.8 : 0.4;
                            break;
                        case 'adopting':
                            population *= Math.exp(-Math.abs(this.time % 6 - 3)) * (1.2 - i * 0.1);
                            break;
                        case 'collapse':
                            population *= Math.exp(-Math.abs(this.time % 4 - 2)) * (1 - i * 0.1);
                            break;
                    }
                    
                    population = Math.max(0.1, Math.min(1, population));
                    const currentSize = sp.size * (0.5 + population * 0.8) * (intensity / 10);
                    
                    this.ctx.fillStyle = `hsl(${sp.color}, 70%, ${40 + population * 30}%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(sp.x, sp.y, currentSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = `hsl(${sp.color}, 80%, 70%)`;
                    this.ctx.fillRect(sp.x - 30, sp.y + currentSize + 10, population * 60, 4);
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '10px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(sp.name, sp.x, sp.y + currentSize + 25);
                    this.ctx.textAlign = 'left';
                });
                
                const connections = [
                    [0, 1], [1, 2], [2, 4], [0, 3], [1, 3], [2, 3]
                ];
                
                connections.forEach(([from, to]) => {
                    const fromSp = species[from];
                    const toSp = species[to];
                    let strength = Math.sin(this.time + from + to) * 0.5 + 0.5;
                    
                    if (operator === 'branching') {
                        strength *= 1.5;
                    } else if (operator === 'merging') {
                        strength *= 0.3 + Math.abs(Math.sin(this.time)) * 0.9;
                    } else if (operator === 'collapse') {
                        strength *= Math.exp(-this.time % 3) + 0.2;
                    } else if (operator === 'projection') {
                        strength *= (Math.abs(from - to) === 1) ? 1.3 : 0.5;
                    }
                    
                    this.ctx.strokeStyle = `hsla(${(fromSp.color + toSp.color) / 2}, 60%, 60%, ${strength * 0.6})`;
                    this.ctx.lineWidth = 2 + strength * 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(fromSp.x, fromSp.y);
                    this.ctx.lineTo(toSp.x, toSp.y);
                    this.ctx.stroke();
                    
                    if (strength > 0.7) {
                        const t = (this.time * 2) % 1;
                        const particleX = fromSp.x + (toSp.x - fromSp.x) * t;
                        const particleY = fromSp.y + (toSp.y - fromSp.y) * t;
                        
                        this.ctx.fillStyle = `hsl(45, 80%, 70%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }
            
            renderGalaxyFormation(operator, intensity) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const spiralArms = 4;
                const starsPerArm = 50;
                
                for (let arm = 0; arm < spiralArms; arm++) {
                    for (let star = 0; star < starsPerArm; star++) {
                        const t = star / starsPerArm;
                        let angle = arm * Math.PI / 2 + t * Math.PI * 4 + this.time * 0.1;
                        let radius = t * 120 * (intensity / 10);
                        
                        if (operator === 'inletting') {
                            radius *= 1 + Math.sin(this.time + t * 5) * 0.3;
                        } else if (operator === 'collapse') {
                            radius *= Math.exp(-t * (this.time % 3));
                        } else if (operator === 'branching') {
                            angle += Math.sin(t * 10 + this.time) * 0.5;
                        }
                        
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        const starMass = Math.random() * 0.8 + 0.2;
                        const size = 1 + starMass * 4;
                        const temp = 3000 + Math.random() * 25000;
                        const hue = Math.max(0, Math.min(60, (temp - 3000) / 400));
                        
                        this.ctx.fillStyle = `hsl(${hue}, 80%, ${60 + starMass * 30}%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, size, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        if (starMass > 0.6) {
                            this.ctx.fillStyle = `hsla(${hue}, 60%, 80%, 0.3)`;
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size * 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
                
                const blackHoleSize = 10 + Math.sin(this.time) * 3;
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, blackHoleSize, 0, Math.PI * 2);
                this.ctx.fill();
                
                for (let i = 0; i < 8; i++) {
                    const diskRadius = blackHoleSize + 5 + i * 3;
                    const diskAngle = this.time + i * 0.5;
                    const diskX = centerX + Math.cos(diskAngle) * diskRadius;
                    const diskY = centerY + Math.sin(diskAngle) * diskRadius * 0.3;
                    
                    this.ctx.fillStyle = `hsl(${30 + i * 10}, 90%, 70%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(diskX, diskY, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            renderMolecularDance(operator, intensity) {
                const molecules = 16;
                const bonds = [];
                
                const positions = [];
                for (let i = 0; i < molecules; i++) {
                    const baseAngle = (i / molecules) * Math.PI * 2;
                    let radius = 60 + (i % 3) * 30;
                    
                    if (operator === 'repair') {
                        radius *= 0.8 + Math.sin(this.time + i) * 0.4;
                    } else if (operator === 'branching') {
                        radius *= 1 + (i % 2) * 0.5;
                    } else if (operator === 'collapse') {
                        radius *= Math.exp(-Math.abs(this.time % 2 - 1));
                    }
                    
                    const angle = baseAngle + this.time * 0.3 + Math.sin(this.time + i) * 0.2;
                    const x = this.canvas.width / 2 + Math.cos(angle) * radius * (intensity / 10);
                    const y = this.canvas.height / 2 + Math.sin(angle) * radius * (intensity / 10);
                    
                    positions.push({ x, y, type: i % 4 });
                }
                
                for (let i = 0; i < molecules; i++) {
                    for (let j = i + 1; j < molecules; j++) {
                        const dist = Math.sqrt(
                            Math.pow(positions[i].x - positions[j].x, 2) + 
                            Math.pow(positions[i].y - positions[j].y, 2)
                        );
                        
                        if (dist < 80) {
                            const bondStrength = (80 - dist) / 80;
                            const bondType = (positions[i].type + positions[j].type) % 3;
                            
                            let lineWidth = bondStrength * 3;
                            let alpha = bondStrength * 0.8;
                            
                            if (operator === 'inletting') {
                                alpha *= 1 + Math.sin(this.time + i + j) * 0.5;
                            }
                            
                            const colors = ['#00ffff', '#ff00ff', '#ffff00'];
                            this.ctx.strokeStyle = colors[bondType].replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                            this.ctx.lineWidth = lineWidth;
                            this.ctx.beginPath();
                            this.ctx.moveTo(positions[i].x, positions[i].y);
                            this.ctx.lineTo(positions[j].x, positions[j].y);
                            this.ctx.stroke();
                        }
                    }
                }
                
                positions.forEach((pos, i) => {
                    const moleculeTypes = [
                        { color: 180, size: 8, name: 'O' },
                        { color: 0, size: 6, name: 'H' },
                        { color: 240, size: 10, name: 'C' },
                        { color: 60, size: 7, name: 'N' }
                    ];
                    
                    const mol = moleculeTypes[pos.type];
                    const vibration = Math.sin(this.time * 3 + i) * 2;
                    const currentSize = mol.size + vibration;
                    
                    this.ctx.fillStyle = `hsla(${mol.color}, 60%, 60%, 0.2)`;
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, currentSize * 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = `hsl(${mol.color}, 80%, 70%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, currentSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = 'bold 10px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(mol.name, pos.x, pos.y + 3);
                    this.ctx.textAlign = 'left';
                });
            }
            
            getTransSentifyDescription(domain, operator) {
                const descriptions = {
                    quantum: {
                        inletting: "External field injection → Energy particle visualization",
                        inlaying: "Dimensional embedding → Nested quantum state layers",
                        repair: "Wave function stabilization → Interference pattern healing",
                        'trans-sentifying': "Mathematical quantum → Rainbow interference sensation"
                    },
                    neural: "Neural network dynamics → Synaptic activation patterns",
                    ecosystem: "Ecological interactions → Population flow visualization", 
                    galaxy: "Stellar formation → Cosmic spiral emergence",
                    molecular: "Chemical bonds → Molecular dance patterns"
                };
                
                return descriptions[domain][operator] || descriptions[domain] || "Mathematical structure → Sensory experience";
            }
            
            reset() {
                this.time = 0;
            }
        }
        
        // Pedagogy Perception Engine - ORIGINAL FULL VERSION
        class PedagogyEngine {
            constructor(canvasId, gridId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.grid = document.getElementById(gridId);
                
                this.currentStage = 0;
                this.maxStages = 5;
                this.discoveries = 0;
                this.isActive = false;
                this.time = 0;
                this.unlockedGlyphs = [];
                
                this.stages = [
                    { title: "Discover Numbers", desc: "What makes numbers special?" },
                    { title: "Find Patterns", desc: "Numbers that repeat in interesting ways" },
                    { title: "Build Sequences", desc: "Each number comes from the ones before" },
                    { title: "See the Magic", desc: "How patterns create infinite beauty" },
                    { title: "Master Recursion", desc: "You are now a pattern wizard!" }
                ];
                
                this.drawWelcome();
            }
            
            drawWelcome() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = '#00ffff';
                this.ctx.font = 'bold 24px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Mathematical Pattern Explorer', this.canvas.width/2, this.canvas.height/2 - 40);
                
                this.ctx.fillStyle = '#ff00ff';
                this.ctx.font = '16px Courier New';
                this.ctx.fillText('Discover the hidden magic in numbers!', this.canvas.width/2, this.canvas.height/2 + 10);
                
                this.ctx.fillStyle = '#ffff00';
                this.ctx.font = '12px Courier New';
                this.ctx.fillText('Click "Begin Journey" to start your adventure', this.canvas.width/2, this.canvas.height/2 + 40);
                this.ctx.textAlign = 'left';
            }
            
            beginJourney() {
                this.isActive = true;
                this.currentStage = 0;
                this.discoveries = 0;
                this.startStage(0);
                this.unlockGlyph('◈', 'Discovery');
            }
            
            startStage(stage) {
                this.currentStage = stage;
                const stageInfo = this.stages[stage];
                
                document.getElementById('stageTitle').textContent = stageInfo.title;
                document.getElementById('stageDescription').textContent = stageInfo.desc;
                
                const progress = ((stage + 1) / this.maxStages) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
                
                switch(stage) {
                    case 0:
                        this.stageDiscoverNumbers();
                        break;
                    case 1:
                        this.stageFindPatterns();
                        break;
                    case 2:
                        this.stageBuildSequences();
                        break;
                    case 3:
                        this.stageSeeTheMagic();
                        break;
                    case 4:
                        this.stageMasterRecursion();
                        break;
                }
                
                this.updateOutput();
                
                if (stage < this.maxStages - 1) {
                    document.getElementById('nextStage').style.display = 'inline-block';
                }
            }
            
            stageDiscoverNumbers() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.time = 0;
                this.animateBasicNumbers();
                
                this.grid.innerHTML = '';
                this.grid.style.gridTemplateColumns = 'repeat(6, 1fr)';
                
                for (let i = 1; i <= 12; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = i;
                    cell.dataset.value = i;
                    cell.addEventListener('click', () => this.handleNumberClick(cell, i));
                    this.grid.appendChild(cell);
                }
            }
            
            animateBasicNumbers() {
                if (!this.isActive || this.currentStage !== 0) return;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let i = 1; i <= 8; i++) {
                    const x = (i * this.canvas.width / 9) + Math.sin(this.time + i) * 20;
                    const y = this.canvas.height/2 + Math.cos(this.time * 0.8 + i) * 30;
                    const size = 20 + Math.sin(this.time + i * 2) * 8;
                    
                    this.ctx.fillStyle = `hsl(${i * 45}, 80%, 70%)`;
                    this.ctx.font = `bold ${size}px Courier New`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(i.toString(), x, y);
                }
                
                this.ctx.textAlign = 'left';
                this.time += 0.05;
                
                setTimeout(() => this.animateBasicNumbers(), 50);
            }
            
            handleNumberClick(cell, value) {
                if (cell.classList.contains('revealed')) return;
                
                cell.classList.add('revealed');
                
                let property = '';
                if (value === 1) property = 'Unity';
                else if (value === 2) property = 'First Prime';
                else if (value === 3) property = 'Triangle';
                else if (value === 5) property = 'Pentagon';
                else if (value === 8) property = 'Cube';
                else property = 'Special';
                
                cell.innerHTML = `${value}<br><small style="font-size: 0.6rem; opacity: 0.8;">${property}</small>`;
                this.discoveries++;
                
                if (this.discoveries >= 5) {
                    this.completeStage();
                }
            }
            
            stageFindPatterns() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.animatePatterns();
                
                this.grid.innerHTML = '';
                this.grid.style.gridTemplateColumns = 'repeat(8, 1fr)';
                
                const patterns = [2, 4, 6, 8, 10, 12, 14, 16];
                patterns.forEach((num, i) => {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = '?';
                    cell.dataset.value = num;
                    cell.addEventListener('click', () => this.handlePatternClick(cell, num, i));
                    this.grid.appendChild(cell);
                });
                
                this.discoveries = 0;
            }
            
            animatePatterns() {
                if (!this.isActive || this.currentStage !== 1) return;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let i = 0; i < 8; i++) {
                    const num = (i + 1) * 2;
                    const x = (i + 1) * (this.canvas.width / 9);
                    const y = this.canvas.height/2;
                    const pulse = Math.sin(this.time + i * 0.5) * 0.3 + 0.7;
                    
                    this.ctx.fillStyle = `hsla(240, 80%, 70%, ${pulse})`;
                    this.ctx.font = `bold ${20 + pulse * 10}px Courier New`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(num.toString(), x, y);
                }
                
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let i = 0; i < 7; i++) {
                    const x1 = (i + 1) * (this.canvas.width / 9);
                    const x2 = (i + 2) * (this.canvas.width / 9);
                    this.ctx.moveTo(x1, this.canvas.height/2 + 20);
                    this.ctx.lineTo(x2, this.canvas.height/2 + 20);
                }
                this.ctx.stroke();
                
                this.ctx.textAlign = 'left';
                this.time += 0.05;
                
                setTimeout(() => this.animatePatterns(), 50);
            }
            
            handlePatternClick(cell, value, index) {
                if (cell.classList.contains('revealed')) return;
                
                cell.textContent = value;
                cell.classList.add('revealed');
                
                if (index % 2 === 0) {
                    cell.classList.add('correct');
                }
                
                this.discoveries++;
                
                if (this.discoveries >= 6) {
                    this.completeStage();
                    this.unlockGlyph('◊', 'Pattern');
                }
            }
            
            stageBuildSequences() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.animateFibonacci();
                
                this.grid.innerHTML = '';
                this.grid.style.gridTemplateColumns = 'repeat(7, 1fr)';
                
                const fib = [1, 1, 2, 3, 5, 8, 13];
                fib.forEach((num, i) => {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    if (i < 2) {
                        cell.textContent = num;
                        cell.classList.add('revealed');
                    } else {
                        cell.textContent = '?';
                    }
                    cell.dataset.value = num;
                    cell.dataset.index = i;
                    cell.addEventListener('click', () => this.handleFibonacciClick(cell, num, i));
                    this.grid.appendChild(cell);
                });
                
                this.discoveries = 0;
            }
            
            animateFibonacci() {
                if (!this.isActive || this.currentStage !== 2) return;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const fib = [1, 1, 2, 3, 5, 8, 13];
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                for (let i = 0; i < fib.length; i++) {
                    const angle = i * Math.PI / 2 + this.time * 0.5;
                    const radius = fib[i] * 3 + Math.sin(this.time + i) * 5;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const size = 8 + fib[i] * 0.8;
                    this.ctx.fillStyle = `hsl(${i * 30 + this.time * 20}, 80%, 70%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '10px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(fib[i].toString(), x, y + 2);
                }
                
                this.ctx.textAlign = 'left';
                this.time += 0.03;
                
                setTimeout(() => this.animateFibonacci(), 60);
            }
            
            handleFibonacciClick(cell, value, index) {
                if (cell.classList.contains('revealed') || index < 2) return;
                
                const allCells = Array.from(this.grid.children);
                const prev1 = allCells[index - 1];
                const prev2 = allCells[index - 2];
                
                if (prev1.classList.contains('revealed') && prev2.classList.contains('revealed')) {
                    cell.textContent = value;
                    cell.classList.add('revealed', 'correct');
                    this.discoveries++;
                    
                    if (this.discoveries >= 5) {
                        this.completeStage();
                        this.unlockGlyph('◉', 'Recursion');
                    }
                }
            }
            
            stageSeeTheMagic() {
                this.animateGoldenRatio();
                this.setupMagicInteraction();
            }
            
            animateGoldenRatio() {
                if (!this.isActive || this.currentStage !== 3) return;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const phi = 1.618033988749895;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.ctx.strokeStyle = '#ffd700';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                
                for (let t = 0; t <= this.time * 4; t += 0.1) {
                    const radius = t * 5;
                    const angle = t / phi + this.time * 0.1;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (t === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.stroke();
                
                this.ctx.fillStyle = '#ffd700';
                this.ctx.font = 'bold 20px Courier New';
                this.ctx.fillText(`φ = ${phi.toFixed(6)}`, 20, 40);
                this.ctx.font = '14px Courier New';
                this.ctx.fillText('The Golden Ratio', 20, 60);
                
                this.time += 0.02;
                
                setTimeout(() => this.animateGoldenRatio(), 50);
            }
            
            setupMagicInteraction() {
                this.grid.innerHTML = '';
                this.grid.style.gridTemplateColumns = 'repeat(5, 1fr)';
                
                const ratios = [1.5, 1.6, 1.618, 1.62, 1.7];
                ratios.forEach((ratio, i) => {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.innerHTML = `${ratio}<br><small style="font-size: 0.6rem; opacity: 0.8;">Click me</small>`;
                    cell.addEventListener('click', () => this.handleRatioClick(cell, ratio));
                    this.grid.appendChild(cell);
                });
            }
            
            handleRatioClick(cell, ratio) {
                if (Math.abs(ratio - 1.618) < 0.001) {
                    cell.classList.add('correct');
                    cell.innerHTML = `${ratio}<br><small style="font-size: 0.6rem; opacity: 0.8;">Golden!</small>`;
                    this.discoveries++;
                    
                    if (this.discoveries >= 1) {
                        this.completeStage();
                        this.unlockGlyph('◎', 'Golden');
                    }
                } else {
                    cell.style.background = 'rgba(255, 0, 0, 0.3)';
                    setTimeout(() => {
                        cell.style.background = '';
                    }, 500);
                }
            }
            
            stageMasterRecursion() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.celebrationAnimation();
                
                this.grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 2rem; color: #00ffff; font-size: 1.5rem;">🎉 You are now a Recursion Master! 🎉</div>';
                
                document.getElementById('nextStage').style.display = 'none';
                this.unlockGlyph('◗', 'Mastery');
            }
            
            celebrationAnimation() {
                if (!this.isActive || this.currentStage !== 4) return;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const size = 5 + Math.random() * 15;
                    const hue = Math.random() * 360;
                    const alpha = Math.sin(this.time * 2 + i) * 0.5 + 0.5;
                    
                    this.ctx.fillStyle = `hsla(${hue}, 80%, 70%, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.fillStyle = '#00ffff';
                this.ctx.font = 'bold 32px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('RECURSION MASTERED!', this.canvas.width/2, this.canvas.height/2);
                this.ctx.textAlign = 'left';
                
                this.time += 0.08;
                
                setTimeout(() => this.celebrationAnimation(), 50);
            }
            
            completeStage() {
                if (this.currentStage < this.maxStages - 1) {
                    document.getElementById('nextStage').style.display = 'inline-block';
                    document.getElementById('stageDescription').textContent = 'Stage completed! Click "Next Stage" to continue.';
                }
            }
            
            nextStage() {
                if (this.currentStage < this.maxStages - 1) {
                    this.startStage(this.currentStage + 1);
                    document.getElementById('nextStage').style.display = 'none';
                    this.discoveries = 0;
                }
            }
            
            giveHint() {
                const hints = [
                    "Try clicking on small numbers first - they have special properties!",
                    "Look for numbers that follow a pattern - every other one perhaps?",
                    "Remember: each Fibonacci number is the sum of the two before it!",
                    "The golden ratio φ ≈ 1.618 appears in nature everywhere!",
                    "You've mastered the art of mathematical pattern recognition!"
                ];
                
                if (this.currentStage < hints.length) {
                    document.getElementById('stageDescription').textContent = `Hint: ${hints[this.currentStage]}`;
                }
            }
            
            unlockGlyph(glyph, name) {
                this.unlockedGlyphs.push(glyph);
                
                const unlock = document.getElementById('glyphUnlock');
                document.getElementById('unlockedGlyph').textContent = glyph;
                document.getElementById('unlockedName').textContent = name + ' Operator Unlocked';
                
                unlock.style.display = 'block';
                setTimeout(() => {
                    unlock.style.display = 'none';
                }, 3000);
                
                this.updateOutput();
            }
            
            updateOutput() {
                document.getElementById('pedagogyOutput').innerHTML = 
                    `🎓 Pedagogy Engine: Stage ${this.currentStage + 1}/${this.maxStages} | Level: Elementary<br>
                    Learning Progress: ${this.currentStage}/${this.maxStages} | Discoveries: ${this.discoveries}<br>
                    Glyphs Unlocked: ${this.unlockedGlyphs.length} | ${this.unlockedGlyphs.join(' ')}`;
            }
        }
        
        // Toggle operator flow visibility
        function toggleOperatorFlow(engine) {
            const flow = document.getElementById(engine + 'OperatorFlow');
            const display = flow.style.display === 'none' ? 'flex' : 'none';
            flow.style.display = display;
        }
        
        // Initialize everything
        let engines = {};
        let score = new TransSentifyingScore();
        
        window.onload = () => {
            initializeGlyphRing();
            
            engines.art = new ArtEngine('artCanvas');
            engines.science = new ScienceEngine('scienceCanvas');
            engines.pedagogy = new PedagogyEngine('pedagogyCanvas', 'interactiveGrid');
            
            // Update Trans-Sentifying Score periodically
            setInterval(() => score.update(), 2000);
            
            // Event listeners
            document.getElementById('pauseArt').addEventListener('click', () => {
                engines.art.pause();
                document.getElementById('pauseArt').textContent = engines.art.isRunning ? 'Pause' : 'Resume';
            });
            
            document.getElementById('resetSim').addEventListener('click', () => {
                engines.science.reset();
            });
            
            document.getElementById('beginJourney').addEventListener('click', () => {
                engines.pedagogy.beginJourney();
                document.getElementById('beginJourney').style.display = 'none';
            });
            
            document.getElementById('nextStage').addEventListener('click', () => {
                engines.pedagogy.nextStage();
            });
            
            document.getElementById('getHint').addEventListener('click', () => {
                engines.pedagogy.giveHint();
            });
            
            document.getElementById('complexity').addEventListener('input', (e) => {
                document.getElementById('complexityValue').textContent = e.target.value;
                score.update();
            });
            
            document.getElementById('animSpeed').addEventListener('input', (e) => {
                document.getElementById('speedValue').textContent = e.target.value + 'ms';
            });
            
            document.getElementById('intensity').addEventListener('input', (e) => {
                document.getElementById('intensityValue').textContent = e.target.value;
            });
        };
    </script>
</body>
</html>