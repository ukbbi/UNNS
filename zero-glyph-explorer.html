<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Zero Glyph Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Animated Background */
        .quantum-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            background: 
                radial-gradient(ellipse at 25% 25%, rgba(20, 80, 120, 0.2) 0%, transparent 50%),
                radial-gradient(ellipse at 75% 75%, rgba(120, 20, 80, 0.2) 0%, transparent 50%);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, rgba(20, 80, 120, 0.1), rgba(120, 20, 80, 0.1));
            border-radius: 20px;
            margin-bottom: 40px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            font-size: 3em;
            font-weight: 300;
            letter-spacing: 3px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 5s ease infinite;
            background-size: 200% 200%;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .subtitle {
            font-size: 1.2em;
            color: #888;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .philosophy-quote {
            color: #666;
            margin-top: 20px;
            transition: opacity 0.5s;
        }
        
        /* Zero Glyph Visualizer */
        .zero-visualizer {
            position: relative;
            width: 600px;
            height: 600px;
            margin: 0 auto 60px;
        }
        
        #zeroCanvas {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            background: radial-gradient(circle at center, 
                rgba(0, 0, 0, 0.9) 0%, 
                rgba(20, 20, 40, 0.9) 100%);
            max-width: 100%;
            display: block;
        }
        
        /* Aspect Selector */
        .aspect-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .aspect-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .aspect-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, transparent, rgba(255, 255, 255, 0.05));
            animation: rotate 10s linear infinite;
            pointer-events: none;
        }
        
        .aspect-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.2);
        }
        
        .aspect-card.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
            border-color: #00ffff;
        }
        
        @keyframes rotate {
            100% { transform: rotate(360deg); }
        }
        
        .aspect-title {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #00ffff;
        }
        
        .aspect-description {
            color: #aaa;
            line-height: 1.6;
        }
        
        /* Operator Grid */
        .operator-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .operator-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .operator-card:hover {
            background: rgba(255, 255, 255, 0.05);
            transform: scale(1.02);
        }
        
        .operator-name {
            font-size: 1.2em;
            color: #ff00ff;
            margin-bottom: 10px;
        }
        
        .operator-effect {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 15px;
        }
        
        .apply-btn {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .apply-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.4);
        }
        
        /* Theory Comparison */
        .theory-comparison {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }
        
        .theory-card {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .theory-card.unns {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
            border-color: #00ffff;
        }
        
        .theory-name {
            font-size: 1.3em;
            color: #ffff00;
            margin-bottom: 10px;
        }
        
        .theory-focus {
            color: #aaa;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        .theory-card.unns .theory-focus {
            color: #fff;
        }
        
        /* Info Panel */
        .info-panel {
            background: linear-gradient(135deg, rgba(0, 50, 100, 0.1), rgba(100, 0, 50, 0.1));
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-title {
            font-size: 1.8em;
            color: #00ffff;
            margin-bottom: 20px;
        }
        
        .info-content {
            line-height: 1.8;
            color: #ccc;
        }
        
        .highlight {
            color: #ff00ff;
            font-weight: bold;
        }
        
        /* Control Panel */
        .control-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            z-index: 1000;
        }
        
        .control-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .zero-visualizer {
                width: 100%;
                max-width: 400px;
                height: 400px;
            }
            .control-panel {
                bottom: 10px;
                right: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="quantum-field"></div>
    
    <div class="container">
        <header>
            <h1>ZERO GLYPH EXPLORER</h1>
            <div class="subtitle">Unbounded Nested Number Sequences Substrate · The Void That Generates All</div>
            <p class="philosophy-quote">
                "Zero is not nothing—it is the recursive seed from which all mathematical reality emerges"
            </p>
        </header>
        
        <!-- Zero Visualizer -->
        <div class="zero-visualizer">
            <canvas id="zeroCanvas" width="600" height="600"></canvas>
        </div>
        
        <!-- Four Aspects of Zero -->
        <section class="aspect-selector">
            <div class="aspect-card" data-aspect="silence">
                <div class="aspect-title">⚬ Zero as Silence</div>
                <div class="aspect-description">
                    The pause between recursions. The quantum vacuum state where virtual particles flicker. 
                    In UNNS, silence is not absence but potential—the moment before collapse or expansion.
                </div>
            </div>
            
            <div class="aspect-card" data-aspect="scar">
                <div class="aspect-title">◈ Zero as Scar</div>
                <div class="aspect-description">
                    The trace of annihilation. Where positive and negative infinities meet and cancel. 
                    Each zero marks a boundary where something was destroyed to create space for the new.
                </div>
            </div>
            
            <div class="aspect-card" data-aspect="symmetry">
                <div class="aspect-title">◎ Zero as Symmetry</div>
                <div class="aspect-description">
                    The perfect balance point. The axis of rotation for all transformations. 
                    Zero maintains invariance across all Octad operations—the unchanging witness.
                </div>
            </div>
            
            <div class="aspect-card" data-aspect="source">
                <div class="aspect-title">✦ Zero as Source</div>
                <div class="aspect-description">
                    The generative void. The recursive seed that spawns infinite complexity. 
                    Like the Big Bang singularity, zero contains all possible futures in its infinite density.
                </div>
            </div>
        </section>
        
        <!-- Octad Operators on Zero -->
        <div class="info-panel">
            <div class="info-title">Octad Operations on the Zero Substrate</div>
            <div class="info-content">
                When the eight UNNS operators act upon zero, they reveal its true nature as a 
                <span class="highlight">dynamic substrate</span> rather than mere emptiness. 
                Watch how each operation transforms the void into patterns of emergence and collapse.
            </div>
        </div>
        
        <section class="operator-grid">
            <div class="operator-card">
                <div class="operator-name">Inletting [↓]</div>
                <div class="operator-effect">Injects external force into zero, creating ripples in the void</div>
                <button class="apply-btn" data-operator="inlet">Apply to Zero</button>
            </div>
            
            <div class="operator-card">
                <div class="operator-name">Inlaying [⊕]</div>
                <div class="operator-effect">Embeds dimensions within zero, revealing hidden structure</div>
                <button class="apply-btn" data-operator="inlay">Apply to Zero</button>
            </div>
            
            <div class="operator-card">
                <div class="operator-name">Repair [◊]</div>
                <div class="operator-effect">Restores zero's perfect symmetry after perturbation</div>
                <button class="apply-btn" data-operator="repair">Apply to Zero</button>
            </div>
            
            <div class="operator-card">
                <div class="operator-name">Trans-Sentifying [∿]</div>
                <div class="operator-effect">Translates zero into sensory experience—the sound of silence</div>
                <button class="apply-btn" data-operator="transsentify">Apply to Zero</button>
            </div>
            
            <div class="operator-card">
                <div class="operator-name">Resonant Coupling [≈]</div>
                <div class="operator-effect">Zero resonates with itself, creating standing waves</div>
                <button class="apply-btn" data-operator="resonate">Apply to Zero</button>
            </div>
            
            <div class="operator-card">
                <div class="operator-name">Dimensional Folding [⟳]</div>
                <div class="operator-effect">Collapses infinite dimensions into zero's singularity</div>
                <button class="apply-btn" data-operator="fold">Apply to Zero</button>
            </div>
            
            <div class="operator-card">
                <div class="operator-name">Cascade Amplification [⟫]</div>
                <div class="operator-effect">Tiny fluctuations in zero cascade into universes</div>
                <button class="apply-btn" data-operator="cascade">Apply to Zero</button>
            </div>
            
            <div class="operator-card">
                <div class="operator-name">Recursive Transcendence [∞]</div>
                <div class="operator-effect">Zero becomes aware of itself, creating the strange loop</div>
                <button class="apply-btn" data-operator="transcend">Apply to Zero</button>
            </div>
        </section>
        
        <!-- Theory Comparison -->
        <section class="theory-comparison">
            <h2 style="font-size: 2em; color: #00ffff; margin-bottom: 20px;">
                UNNS vs. Traditional Unified Theories
            </h2>
            <p style="color: #aaa; line-height: 1.6; margin-bottom: 30px;">
                While physics searches for the smallest particles and mathematics seeks fundamental axioms, 
                UNNS reveals the <span class="highlight">recursive grammar</span> that generates both.
            </p>
            
            <div class="comparison-grid">
                <div class="theory-card">
                    <div class="theory-name">String Theory</div>
                    <div class="theory-focus">
                        Focus: Vibrating strings in 11 dimensions<br>
                        Zero Role: Background vacuum energy<br>
                        Limitation: Still assumes "things" exist
                    </div>
                </div>
                
                <div class="theory-card">
                    <div class="theory-name">Loop Quantum Gravity</div>
                    <div class="theory-focus">
                        Focus: Discrete spacetime geometry<br>
                        Zero Role: Minimal area/volume<br>
                        Limitation: Quantizes space, not process
                    </div>
                </div>
                
                <div class="theory-card">
                    <div class="theory-name">Category Theory</div>
                    <div class="theory-focus">
                        Focus: Morphisms between objects<br>
                        Zero Role: Identity morphism<br>
                        Limitation: Describes, doesn't generate
                    </div>
                </div>
                
                <div class="theory-card">
                    <div class="theory-name">Information Physics</div>
                    <div class="theory-focus">
                        Focus: Bits as fundamental units<br>
                        Zero Role: Null information state<br>
                        Limitation: Binary, not recursive
                    </div>
                </div>
                
                <div class="theory-card">
                    <div class="theory-name">Wolfram's Hypergraphs</div>
                    <div class="theory-focus">
                        Focus: Computational rules<br>
                        Zero Role: Empty graph<br>
                        Limitation: Rules are given, not emergent
                    </div>
                </div>
                
                <div class="theory-card unns">
                    <div class="theory-name">UNNS Framework</div>
                    <div class="theory-focus">
                        Focus: Recursive operational grammar<br>
                        Zero Role: Generative void & substrate<br>
                        <strong>Advantage: Process creates substance</strong>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Deep Insights -->
        <div class="info-panel">
            <div class="info-title">The Revolutionary Insight</div>
            <div class="info-content">
                Traditional theories ask <span class="highlight">"What are the fundamental building blocks?"</span><br><br>
                
                UNNS asks <span class="highlight">"What are the recursive rules by which ANY structure persists, resonates, or collapses?"</span><br><br>
                
                This shift from <em>ontology of being</em> (particles, sets) to <em>grammar of becoming</em> 
                (operations, recursions) reveals that zero isn't empty space—it's the 
                <span class="highlight">recursive seed</span> containing infinite potential.<br><br>
                
                Every constant in physics (c, ℏ, G), every mathematical invariant (π, e, φ), 
                emerges from recursive operations on the zero substrate. The universe isn't made 
                OF things; it's made BY processes acting on nothing.
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <button class="control-btn" id="resetBtn">Reset Zero</button>
            <button class="control-btn" id="animateBtn">Animate All</button>
            <button class="control-btn" id="toggleBtn">Toggle Mode</button>
        </div>
    </div>
    
    <script>
        // Initialize after DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            // Canvas setup
            const canvas = document.getElementById('zeroCanvas');
            const ctx = canvas.getContext('2d');
            let animationId = null;
            let currentAspect = 'source';
            let particles = [];
            let time = 0;
            let animateInterval = null;
            
            // Initialize particles for visualization
            function initParticles() {
                particles = [];
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        radius: Math.random() * 3,
                        opacity: Math.random(),
                        color: `hsl(${Math.random() * 360}, 100%, 50%)`
                    });
                }
            }
            
            // Draw zero glyph based on current aspect
            function drawZeroGlyph(aspect) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Draw based on aspect
                switch(aspect) {
                    case 'silence':
                        drawSilence(cx, cy);
                        break;
                    case 'scar':
                        drawScar(cx, cy);
                        break;
                    case 'symmetry':
                        drawSymmetry(cx, cy);
                        break;
                    case 'source':
                        drawSource(cx, cy);
                        break;
                }
                
                time += 0.02;
            }
            
            // Draw silence aspect
            function drawSilence(cx, cy) {
                // Fading circle representing the pause
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + Math.sin(time) * 0.2})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, 100 + Math.sin(time) * 20, 0, Math.PI * 2);
                ctx.stroke();
                
                // Virtual particles flickering
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 / 20) * i + time * 0.5;
                    const radius = 80 + Math.sin(time * 3 + i) * 30;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, y, Math.random() * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw scar aspect
            function drawScar(cx, cy) {
                // Collision traces
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    const endX = cx + Math.cos(angle + time) * 150;
                    const endY = cy + Math.sin(angle + time) * 150;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Annihilation points
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(endX, endY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw symmetry aspect
            function drawSymmetry(cx, cy) {
                // Perfect rotating symmetries
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(time);
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    ctx.strokeStyle = `hsl(${60 * i}, 100%, 50%)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(100, 0);
                    ctx.stroke();
                    
                    // Symmetric nodes
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.beginPath();
                    ctx.arc(100, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Central invariant point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw source aspect
            function drawSource(cx, cy) {
                // Generative spirals
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 200; i++) {
                    const angle = i * 0.1;
                    const radius = i * 2;
                    const x = cx + Math.cos(angle + time) * radius;
                    const y = cy + Math.sin(angle + time) * radius;
                    
                    ctx.fillStyle = `hsla(${i * 2}, 100%, 50%, ${1 - i / 200})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Recursive seed at center
                drawRecursiveSeed(cx, cy, 30, 5);
            }
            
            // Draw recursive seed pattern
            function drawRecursiveSeed(x, y, size, depth) {
                if (depth <= 0 || size < 1) return;
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${depth / 5})`;
                ctx.lineWidth = depth / 2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.stroke();
                
                // Recursive smaller seeds
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 / 4) * i + time;
                    const nx = x + Math.cos(angle) * size;
                    const ny = y + Math.sin(angle) * size;
                    drawRecursiveSeed(nx, ny, size / 2, depth - 1);
                }
            }
            
            // Apply operator effects
            function applyOperator(operator) {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                switch(operator) {
                    case 'inlet':
                        // Inletting effect
                        for (let i = 0; i < 50; i++) {
                            ctx.strokeStyle = `rgba(0, 255, 255, ${Math.random() * 0.5})`;
                            ctx.beginPath();
                            ctx.moveTo(cx + Math.random() * 400 - 200, 0);
                            ctx.lineTo(cx, cy);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'inlay':
                        // Dimensional embedding
                        for (let z = 0; z < 10; z++) {
                            ctx.strokeStyle = `rgba(255, 0, 255, ${(10 - z) / 20})`;
                            ctx.strokeRect(
                                cx - 100 + z * 10,
                                cy - 100 + z * 10,
                                200 - z * 20,
                                200 - z * 20
                            );
                        }
                        break;
                        
                    case 'repair':
                        // Self-healing grid
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                        for (let r = 20; r < 200; r += 40) {
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'resonate':
                        // Standing waves
                        for (let r = 0; r < 200; r += 20) {
                            ctx.strokeStyle = `rgba(255, 255, 0, ${0.3 * Math.sin(r / 20 + time * 3)})`;
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'cascade':
                        // Cascade amplification
                        for (let i = 0; i < particles.length; i++) {
                            const p = particles[i];
                            p.vx *= 1.1;
                            p.vy *= 1.1;
                            p.x += p.vx;
                            p.y += p.vy;
                            
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha = p.opacity;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Reset if out of bounds
                            if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                                p.x = cx;
                                p.y = cy;
                                p.vx = (Math.random() - 0.5) * 2;
                                p.vy = (Math.random() - 0.5) * 2;
                            }
                        }
                        break;
                        
                    case 'fold':
                        // Dimensional folding
                        for (let layer = 0; layer < 8; layer++) {
                            const offset = layer * 10;
                            ctx.strokeStyle = `rgba(255, 0, 255, ${0.4 - layer * 0.05})`;
                            ctx.beginPath();
                            ctx.moveTo(cx - 100 + offset, cy - 100 + offset);
                            ctx.lineTo(cx + 100 - offset, cy - 100 + offset);
                            ctx.lineTo(cx + 100 - offset, cy + 100 - offset);
                            ctx.lineTo(cx - 100 + offset, cy + 100 - offset);
                            ctx.closePath();
                            ctx.stroke();
                        }
                        break;
                        
                    case 'transsentify':
                        // Synaesthetic waves
                        for (let wave = 0; wave < 5; wave++) {
                            ctx.strokeStyle = `hsl(${wave * 72}, 100%, 50%)`;
                            ctx.beginPath();
                            for (let x = 0; x < canvas.width; x += 5) {
                                const y = cy + Math.sin((x / 50) + time * 2 + wave) * 30;
                                if (x === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'transcend':
                        // Strange loop visualization
                        const steps = 50;
                        for (let i = 0; i < steps; i++) {
                            const t = (i / steps) * Math.PI * 4;
                            const r = 80 * (1 + 0.5 * Math.sin(t * 3));
                            const x = cx + r * Math.cos(t + time);
                            const y = cy + r * Math.sin(t + time);
                            
                            ctx.fillStyle = `hsl(${i * 7.2}, 100%, 50%)`;
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                }
                
                ctx.restore();
            }
            
            // Animation loop
            function animate() {
                drawZeroGlyph(currentAspect);
                animationId = requestAnimationFrame(animate);
            }
            
            // Control functions
            function resetVisualization() {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                if (animateInterval) {
                    clearInterval(animateInterval);
                    animateInterval = null;
                }
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                time = 0;
                initParticles();
                animate();
            }
            
            function animateAll() {
                if (animateInterval) {
                    clearInterval(animateInterval);
                    animateInterval = null;
                    return;
                }
                
                const aspects = ['silence', 'scar', 'symmetry', 'source'];
                let index = 0;
                
                animateInterval = setInterval(() => {
                    currentAspect = aspects[index];
                    document.querySelectorAll('.aspect-card').forEach(c => c.classList.remove('active'));
                    const activeCard = document.querySelector(`[data-aspect="${currentAspect}"]`);
                    if (activeCard) activeCard.classList.add('active');
                    
                    index = (index + 1) % aspects.length;
                    
                    // Apply random operator
                    const operators = ['inlet', 'inlay', 'resonate', 'cascade', 'fold', 'transcend'];
                    const randomOp = operators[Math.floor(Math.random() * operators.length)];
                    applyOperator(randomOp);
                }, 2000);
            }
            
            let darkMode = true;
            function toggleMode() {
                darkMode = !darkMode;
                if (!darkMode) {
                    document.body.style.background = '#f0f0f0';
                    document.body.style.color = '#333';
                    document.querySelectorAll('.aspect-card, .operator-card, .theory-card, .info-panel').forEach(el => {
                        el.style.background = 'rgba(0, 0, 0, 0.05)';
                        el.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                    });
                } else {
                    document.body.style.background = '#0a0a0a';
                    document.body.style.color = '#e0e0e0';
                    document.querySelectorAll('.aspect-card, .operator-card, .theory-card, .info-panel').forEach(el => {
                        el.style.background = '';
                        el.style.borderColor = '';
                    });
                }
            }
            
            // Event listeners for aspect cards
            document.querySelectorAll('.aspect-card').forEach(card => {
                card.addEventListener('click', function() {
                    document.querySelectorAll('.aspect-card').forEach(c => c.classList.remove('active'));
                    this.classList.add('active');
                    currentAspect = this.dataset.aspect;
                    
                    // Clear canvas for new aspect
                    ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                });
            });
            
            // Event listeners for operator buttons
            document.querySelectorAll('.apply-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const operator = this.dataset.operator;
                    
                    // Visual feedback
                    const originalBg = this.style.background;
                    this.style.background = 'linear-gradient(135deg, #ff00ff, #00ffff)';
                    setTimeout(() => {
                        this.style.background = originalBg;
                    }, 500);
                    
                    // Apply operator effect multiple times for visibility
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            applyOperator(operator);
                        }, i * 50);
                    }
                });
            });
            
            // Control panel buttons
            document.getElementById('resetBtn').addEventListener('click', resetVisualization);
            document.getElementById('animateBtn').addEventListener('click', animateAll);
            document.getElementById('toggleBtn').addEventListener('click', toggleMode);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case '1':
                        currentAspect = 'silence';
                        document.querySelectorAll('.aspect-card').forEach(c => c.classList.remove('active'));
                        document.querySelector('[data-aspect="silence"]').classList.add('active');
                        break;
                    case '2':
                        currentAspect = 'scar';
                        document.querySelectorAll('.aspect-card').forEach(c => c.classList.remove('active'));
                        document.querySelector('[data-aspect="scar"]').classList.add('active');
                        break;
                    case '3':
                        currentAspect = 'symmetry';
                        document.querySelectorAll('.aspect-card').forEach(c => c.classList.remove('active'));
                        document.querySelector('[data-aspect="symmetry"]').classList.add('active');
                        break;
                    case '4':
                        currentAspect = 'source';
                        document.querySelectorAll('.aspect-card').forEach(c => c.classList.remove('active'));
                        document.querySelector('[data-aspect="source"]').classList.add('active');
                        break;
                    case 'r':
                    case 'R':
                        resetVisualization();
                        break;
                    case 'a':
                    case 'A':
                        animateAll();
                        break;
                    case 't':
                    case 'T':
                        toggleMode();
                        break;
                }
            });
            
            // Canvas hover effect
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Create ripple effect at mouse position
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
            
            // Philosophical quote rotation
            const quotes = [
                "Zero is not nothing—it is the recursive seed from which all mathematical reality emerges",
                "The void doesn't lack; it generates",
                "In every zero lies infinite potential",
                "Recursion begins where counting ends",
                "The grammar of becoming supersedes the ontology of being",
                "Zero: where symmetry breaks into creation",
                "Process creates substance through recursive operations on nothing",
                "Every constant emerges from operations on the zero substrate"
            ];
            
            let quoteIndex = 0;
            setInterval(() => {
                quoteIndex = (quoteIndex + 1) % quotes.length;
                const quoteElement = document.querySelector('.philosophy-quote');
                if (quoteElement) {
                    quoteElement.style.opacity = '0';
                    setTimeout(() => {
                        quoteElement.textContent = `"${quotes[quoteIndex]}"`;
                        quoteElement.style.opacity = '1';
                    }, 500);
                }
            }, 5000);
            
            // Create floating particles in background
            function createFloatingParticle() {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.width = '2px';
                particle.style.height = '2px';
                particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = window.innerHeight + 'px';
                particle.style.pointerEvents = 'none';
                particle.style.opacity = Math.random() * 0.5;
                particle.style.zIndex = '-1';
                document.body.appendChild(particle);
                
                let y = window.innerHeight;
                const x = parseFloat(particle.style.left);
                const speed = 1 + Math.random() * 2;
                const wobble = Math.random() * 50 - 25;
                
                const moveParticle = () => {
                    y -= speed;
                    particle.style.top = y + 'px';
                    particle.style.left = (x + Math.sin(y / 50) * wobble) + 'px';
                    
                    if (y < -10) {
                        document.body.removeChild(particle);
                    } else {
                        requestAnimationFrame(moveParticle);
                    }
                };
                
                moveParticle();
            }
            
            // Create floating particles periodically
            setInterval(createFloatingParticle, 800);
            
            // Initialize everything
            initParticles();
            animate();
            
            // Set initial active aspect
            document.querySelector('[data-aspect="source"]').classList.add('active');
            
            // Initial canvas clear
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        });
    </script>
</body>
</html>