<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Mathematical Sequence Explorer - Nurturing Numbers Through Recursion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e6ed;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: rgba(26, 31, 58, 0.95);
            padding: 20px;
            border-bottom: 2px solid #4a9eff;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(90deg, #4a9eff, #00d4ff, #FFD700);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shine 3s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes shine {
            to { background-position: 200% center; }
        }

        .subtitle {
            color: #8892b0;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .unns-subtitle {
            color: #FFD700;
            font-size: 0.95em;
            font-style: italic;
            margin-bottom: 20px;
        }

        .disclaimer {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            color: #ffc107;
            font-size: 0.9em;
        }

        .module-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #4a9eff, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .tab-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(74, 158, 255, 0.3);
        }

        .tab-button.active {
            background: linear-gradient(135deg, #FFD700, #4a9eff);
            box-shadow: 0 4px 15px rgba(74, 158, 255, 0.4);
        }

        .module-content {
            display: none;
            padding: 30px;
            background: rgba(26, 31, 58, 0.6);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            margin: 20px;
            animation: fadeIn 0.5s ease;
        }

        .module-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .visualization-container {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .viz-section {
            flex: 1;
            min-width: 300px;
            background: rgba(26, 31, 58, 0.4);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(74, 158, 255, 0.3);
        }

        .viz-section h3 {
            color: #4a9eff;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .unns-label {
            color: #FFD700;
            font-size: 0.85em;
            font-style: italic;
            margin-bottom: 5px;
        }

        canvas {
            border: 1px solid rgba(74, 158, 255, 0.5);
            border-radius: 8px;
            width: 100%;
            max-width: 100%;
            background: rgba(10, 14, 39, 0.8);
            display: block;
        }

        .controls {
            background: rgba(26, 31, 58, 0.8);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border: 1px solid rgba(74, 158, 255, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #8892b0;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(74, 158, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #4a9eff, #00d4ff);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(74, 158, 255, 0.4);
        }

        select, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px;
            background: rgba(26, 31, 58, 0.8);
            color: #e0e6ed;
            border: 1px solid rgba(74, 158, 255, 0.3);
            border-radius: 5px;
            font-size: 14px;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #4a9eff, #00d4ff);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        .info-panel {
            background: rgba(26, 31, 58, 0.6);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #4a9eff;
        }

        .info-panel h4 {
            color: #4a9eff;
            margin-bottom: 10px;
        }

        .equation {
            font-family: 'Courier New', monospace;
            background: rgba(10, 14, 39, 0.6);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            color: #00d4ff;
            overflow-x: auto;
        }

        .dual-perspective {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .perspective-box {
            padding: 15px;
            border-radius: 8px;
            background: rgba(10, 14, 39, 0.4);
        }

        .perspective-box.math {
            border-left: 3px solid #4a9eff;
        }

        .perspective-box.unns {
            border-left: 3px solid #FFD700;
        }

        .perspective-label {
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 1px;
        }

        .glyph-section {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .glyph-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a9eff, #00d4ff);
            border: none;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .glyph-symbol {
            font-size: 28px;
        }

        .glyph-name {
            font-size: 10px;
            opacity: 0.9;
        }

        .glyph-button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 20px rgba(74, 158, 255, 0.4);
        }

        .glyph-button.active {
            background: linear-gradient(135deg, #FFD700, #FFA500);
        }

        .output-display {
            background: rgba(10, 14, 39, 0.6);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            color: #00d4ff;
            min-height: 100px;
            overflow-y: auto;
            max-height: 300px;
        }

        .metric-card {
            background: rgba(10, 14, 39, 0.6);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00d4ff;
        }

        .metric-label {
            font-size: 0.9em;
            color: #8892b0;
            margin-top: 5px;
        }

        .toggle-perspective {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #FFD700, #4a9eff);
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>UNNS Mathematical Sequence Explorer</h1>
        <div class="subtitle">Interactive Exploration of Recursive Sequences and Special Functions</div>
        <div class="unns-subtitle">Unified Number Nurturing System - Where Mathematics Meets Metaphor</div>
        
        <div class="disclaimer">
            <strong>Dual Perspective Tool:</strong> This explorer presents mathematical sequences through both rigorous mathematical analysis 
            and the UNNS (Unbounded Nested Number Sequences) framework. UNNS offers interpretive language to make 
            mathematical concepts more accessible through systemic and narrative thinking.
        </div>
        
        <div class="module-tabs" id="module-tabs">
            <!-- Tabs will be generated by JavaScript -->
        </div>
    </div>

    <div id="module-container">
        <!-- Modules will be generated by JavaScript -->
    </div>

    <div class="toggle-perspective" onclick="togglePerspectiveMode()">
        Toggle: <span id="perspective-mode">Dual View</span>
    </div>

    <script>
        // Global state
        let currentModule = 'overview';
        let animationFrameId = null;
        let currentGlyph = 'φ';
        let perspectiveMode = 'dual'; // 'dual', 'math', 'unns'

        // Module definitions with UNNS naming
        const modules = [
            { id: 'overview', name: 'Overview', unnsName: 'Nurturing Landscape' },
            { id: 'sequence-builder', name: 'Sequence Builder', unnsName: 'Genesis Chamber' },
            { id: 'interweaving', name: 'Sequence Blending', unnsName: 'Cross-Nurturing Lab' },
            { id: 'convergence', name: 'Convergence Analysis', unnsName: 'Maturation Metrics' },
            { id: 'prime-patterns', name: 'Modular Patterns', unnsName: 'Rhythmic Cycles' },
            { id: 'special-functions', name: 'Special Functions', unnsName: 'Continuous Nurturing' },
            { id: 'references', name: 'References', unnsName: 'Knowledge Roots' }
        ];

        // Core sequences with mathematical properties and UNNS interpretations
        const sequences = {
            fibonacci: { 
                coeffs: [1, 1], 
                init: [0, 1], 
                name: 'Fibonacci',
                unnsName: 'Golden Nurturing',
                dominant: (1 + Math.sqrt(5)) / 2,
                glyph: 'φ',
                description: 'Classical sequence with golden ratio convergence',
                unnsDescription: 'The primordial nurturing pattern where each number embraces its two ancestors'
            },
            pell: { 
                coeffs: [2, 1], 
                init: [0, 1], 
                name: 'Pell',
                unnsName: 'Silver Nurturing',
                dominant: 1 + Math.sqrt(2),
                glyph: 'δ',
                description: 'Related to continued fraction of √2',
                unnsDescription: 'A doubled embrace of the immediate ancestor with memory of the elder'
            },
            tribonacci: { 
                coeffs: [1, 1, 1], 
                init: [0, 0, 1], 
                name: 'Tribonacci',
                unnsName: 'Triple Nurturing',
                dominant: 1.83929,
                glyph: 'ψ',
                description: 'Three-term recurrence relation',
                unnsDescription: 'Three generations unite to birth each new numerical offspring'
            },
            padovan: { 
                coeffs: [0, 1, 1], 
                init: [1, 1, 1], 
                name: 'Padovan',
                unnsName: 'Plastic Nurturing',
                dominant: 1.32472,
                glyph: 'ρ',
                description: 'Plastic number convergence',
                unnsDescription: 'Skipping the immediate to embrace deeper ancestral wisdom'
            }
        };

        // Generate sequence values
        function generateSequence(type, n) {
            const seq = sequences[type];
            if (!seq) return [];
            
            let values = [...seq.init];
            const k = seq.coeffs.length;
            
            while (values.length < n) {
                let next = 0;
                for (let i = 0; i < k; i++) {
                    next += seq.coeffs[i] * values[values.length - k + i];
                }
                values.push(next);
            }
            
            return values;
        }

        // Parse custom recurrence relation
        function parseRecurrence(input) {
            const match = input.match(/S_n\s*=\s*(.*)/i);
            if (!match) throw new Error("Format should be: S_n = expression");
            
            const expr = match[1];
            const coeffs = [];
            
            const termRegex = /([+-]?\s*\d*)\s*\*?\s*S_\{n-(\d+)\}/g;
            let termMatch;
            let maxLag = 0;
            
            while ((termMatch = termRegex.exec(expr)) !== null) {
                const coeff = termMatch[1].replace(/\s/g, '') || '1';
                const lag = parseInt(termMatch[2]);
                maxLag = Math.max(maxLag, lag);
                
                coeffs[lag - 1] = parseFloat(coeff === '+' || coeff === '' ? '1' : 
                                           coeff === '-' ? '-1' : coeff);
            }
            
            for (let i = 0; i < maxLag; i++) {
                if (coeffs[i] === undefined) coeffs[i] = 0;
            }
            
            return coeffs.reverse();
        }

        // Toggle perspective mode
        function togglePerspectiveMode() {
            const modes = ['dual', 'math', 'unns'];
            const currentIndex = modes.indexOf(perspectiveMode);
            perspectiveMode = modes[(currentIndex + 1) % modes.length];
            
            document.getElementById('perspective-mode').textContent = 
                perspectiveMode === 'dual' ? 'Dual View' :
                perspectiveMode === 'math' ? 'Math Only' : 'UNNS Only';
            
            // Refresh current module
            switchToModule(currentModule);
        }

        // Initialize application
        function initApp() {
            createTabs();
            createModules();
            switchToModule('overview');
        }

        // Create tab buttons with UNNS names
        function createTabs() {
            const tabsContainer = document.getElementById('module-tabs');
            tabsContainer.innerHTML = '';
            
            modules.forEach(module => {
                const button = document.createElement('button');
                button.className = 'tab-button';
                button.innerHTML = `
                    ${module.name}
                    ${perspectiveMode !== 'math' ? `<br><span style="font-size: 0.8em; opacity: 0.8">${module.unnsName}</span>` : ''}
                `;
                button.onclick = () => switchToModule(module.id);
                button.id = `tab-${module.id}`;
                tabsContainer.appendChild(button);
            });
        }

        // Create module content
        function createModules() {
            const container = document.getElementById('module-container');
            container.innerHTML = '';
            
            modules.forEach(module => {
                const div = document.createElement('div');
                div.id = `module-${module.id}`;
                div.className = 'module-content';
                
                switch(module.id) {
                    case 'overview':
                        div.innerHTML = createOverviewContent();
                        break;
                    case 'sequence-builder':
                        div.innerHTML = createSequenceBuilderContent();
                        break;
                    case 'interweaving':
                        div.innerHTML = createInterweavingContent();
                        break;
                    case 'convergence':
                        div.innerHTML = createConvergenceContent();
                        break;
                    case 'prime-patterns':
                        div.innerHTML = createPrimePatternsContent();
                        break;
                    case 'special-functions':
                        div.innerHTML = createSpecialFunctionsContent();
                        break;
                    case 'references':
                        div.innerHTML = createReferencesContent();
                        break;
                }
                
                container.appendChild(div);
            });
        }

        // Switch between modules
        function switchToModule(moduleId) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            currentModule = moduleId;
            
            // Recreate tabs to reflect perspective mode
            createTabs();
            
            // Update tabs
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeTab = document.getElementById(`tab-${moduleId}`);
            if (activeTab) {
                activeTab.classList.add('active');
            }
            
            // Update module visibility
            document.querySelectorAll('.module-content').forEach(mod => {
                mod.classList.remove('active');
            });
            const activeModule = document.getElementById(`module-${moduleId}`);
            if (activeModule) {
                activeModule.classList.add('active');
            }
            
            // Initialize module-specific features
            setTimeout(() => {
                if (moduleId === 'overview') {
                    drawOverview();
                } else if (moduleId === 'convergence') {
                    drawConvergenceAnalysis();
                } else if (moduleId === 'interweaving') {
                    drawSequenceBlending();
                } else if (moduleId === 'prime-patterns') {
                    drawModularPatterns();
                }
            }, 100);
        }

        // Create content for each module with UNNS integration
        function createOverviewContent() {
            return `
                <div class="viz-section">
                    <h3>UNNS Nurturing Landscape</h3>
                    <div class="unns-label">Explore the convergence attractors of recursive nurturing</div>
                    
                    <div class="glyph-section">
                        <button class="glyph-button active" onclick="selectGlyph('φ')" title="Golden Ratio (Fibonacci)">
                            <span class="glyph-symbol">φ</span>
                            <span class="glyph-name">Golden</span>
                        </button>
                        <button class="glyph-button" onclick="selectGlyph('δ')" title="Silver Ratio (Pell)">
                            <span class="glyph-symbol">δ</span>
                            <span class="glyph-name">Silver</span>
                        </button>
                        <button class="glyph-button" onclick="selectGlyph('ψ')" title="Tribonacci Root">
                            <span class="glyph-symbol">ψ</span>
                            <span class="glyph-name">Triple</span>
                        </button>
                        <button class="glyph-button" onclick="selectGlyph('ρ')" title="Plastic Number (Padovan)">
                            <span class="glyph-symbol">ρ</span>
                            <span class="glyph-name">Plastic</span>
                        </button>
                    </div>

                    <canvas id="overview-canvas" width="800" height="400"></canvas>
                    
                    <div class="dual-perspective">
                        <div class="perspective-box math" style="display: ${perspectiveMode === 'unns' ? 'none' : 'block'}">
                            <div class="perspective-label" style="color: #4a9eff">Mathematical View</div>
                            <h4 id="math-title">Golden Ratio (φ) - Fibonacci Sequence</h4>
                            <p id="math-description">The Fibonacci sequence converges to the golden ratio φ = (1+√5)/2 ≈ 1.618...</p>
                            <div class="equation" id="math-equation">F(n) = F(n-1) + F(n-2), F(0)=0, F(1)=1</div>
                        </div>
                        
                        <div class="perspective-box unns" style="display: ${perspectiveMode === 'math' ? 'none' : 'block'}">
                            <div class="perspective-label" style="color: #FFD700">UNNS Interpretation</div>
                            <h4 id="unns-title">Golden Nurturing Pattern</h4>
                            <p id="unns-description">The primordial nurturing pattern where each number embraces its two ancestors</p>
                            <div class="equation" id="unns-equation">Child = Parent + Grandparent</div>
                        </div>
                    </div>

                    <div class="info-panel">
                        <h4>Understanding UNNS</h4>
                        <p>The Unbounded Nested Number Sequences (UNNS) provides a framework for understanding recursive sequences. 
                           While the mathematics describes the precise relationships, UNNS offers intuitive language about how numbers 
                           "nurture" their successors through generative rules.</p>
                    </div>
                </div>
            `;
        }

        function createSequenceBuilderContent() {
            return `
                <div class="viz-section">
                    <h3>UNNS Genesis Chamber</h3>
                    <div class="unns-label">Create your own nurturing rules</div>
                    
                    <div class="parser-section">
                        <div class="control-group">
                            <label>Mathematical Recurrence / UNNS Nurturing Rule</label>
                            <input type="text" id="recurrence-input" 
                                   value="S_n = S_{n-1} + S_{n-2}" 
                                   placeholder="e.g., S_n = 2*S_{n-1} + S_{n-2}">
                        </div>
                        
                        <div class="control-group">
                            <label>Initial Values / Seed Numbers</label>
                            <input type="text" id="initial-values" 
                                   value="0, 1" 
                                   placeholder="e.g., 0, 1">
                        </div>
                        
                        <button onclick="buildCustomSequence()">Generate Sequence / Nurture Numbers</button>
                    </div>

                    <canvas id="builder-canvas" width="800" height="400"></canvas>
                    
                    <div class="output-display" id="sequence-output">
                        Enter a nurturing rule above to generate a custom sequence...
                    </div>
                </div>
            `;
        }

        function createInterweavingContent() {
            return `
                <div class="viz-section">
                    <h3>UNNS Cross-Nurturing Laboratory</h3>
                    <div class="unns-label">Blend different nurturing traditions to create hybrid sequences</div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>Source Sequence / Primary Nurturing Pattern</label>
                            <select id="source-sequence">
                                <option value="fibonacci">Fibonacci (Golden)</option>
                                <option value="pell">Pell (Silver)</option>
                                <option value="tribonacci">Tribonacci (Triple)</option>
                                <option value="padovan">Padovan (Plastic)</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Target Sequence / Secondary Nurturing Pattern</label>
                            <select id="target-sequence">
                                <option value="pell">Pell (Silver)</option>
                                <option value="fibonacci">Fibonacci (Golden)</option>
                                <option value="tribonacci">Tribonacci (Triple)</option>
                                <option value="padovan">Padovan (Plastic)</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Blend Ratio / Nurturing Balance: <span id="blend-display">50%</span></label>
                            <input type="range" id="blend-ratio" min="0" max="100" value="50"
                                   oninput="updateBlendDisplay(); drawSequenceBlending()">
                        </div>
                    </div>

                    <canvas id="blending-canvas" width="800" height="400"></canvas>
                    
                    <div class="dual-perspective">
                        <div class="perspective-box math" style="display: ${perspectiveMode === 'unns' ? 'none' : 'block'}">
                            <div class="perspective-label" style="color: #4a9eff">Mathematical Formula</div>
                            <div class="equation">H(n) = r × S₁(n) + (1-r) × S₂(n)</div>
                            <p>Linear interpolation between two sequences</p>
                        </div>
                        
                        <div class="perspective-box unns" style="display: ${perspectiveMode === 'math' ? 'none' : 'block'}">
                            <div class="perspective-label" style="color: #FFD700">UNNS Cross-Nurturing</div>
                            <div class="equation">Hybrid = Heritage₁ + Heritage₂</div>
                            <p>Combining nurturing traditions creates new evolutionary paths</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function createConvergenceContent() {
            return `
                <div class="viz-section">
                    <h3>UNNS Maturation Analysis</h3>
                    <div class="unns-label">Watch sequences mature toward their nurturing equilibria</div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>Sequence Type / Nurturing Pattern</label>
                            <select id="convergence-sequence" onchange="drawConvergenceAnalysis()">
                                <option value="fibonacci">Fibonacci → φ (Golden Equilibrium)</option>
                                <option value="pell">Pell → δ (Silver Equilibrium)</option>
                                <option value="tribonacci">Tribonacci → ψ (Triple Equilibrium)</option>
                                <option value="padovan">Padovan → ρ (Plastic Equilibrium)</option>
                            </select>
                        </div>
                    </div>

                    <canvas id="convergence-canvas" width="800" height="400"></canvas>
                    
                    <div class="error-metrics" id="error-metrics" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-top: 20px;">
                        <!-- Metrics will be populated by JavaScript -->
                    </div>
                </div>
            `;
        }

        function createPrimePatternsContent() {
            return `
                <div class="viz-section">
                    <h3>UNNS Rhythmic Cycles</h3>
                    <div class="unns-label">Discover hidden periodicities in the nurturing patterns</div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>Sequence / Nurturing Pattern</label>
                            <select id="modular-sequence" onchange="drawModularPatterns()">
                                <option value="fibonacci">Fibonacci (Golden)</option>
                                <option value="pell">Pell (Silver)</option>
                                <option value="tribonacci">Tribonacci (Triple)</option>
                                <option value="padovan">Padovan (Plastic)</option>
                            </select>
                        </div>
                    </div>

                    <canvas id="modular-canvas" width="800" height="500"></canvas>
                    
                    <div class="info-panel">
                        <h4>Pisano Periods / UNNS Rhythmic Cycles</h4>
                        <p><strong>Mathematical:</strong> The period of a sequence modulo m reveals hidden periodic structures.</p>
                        <p><strong>UNNS:</strong> Each prime lens reveals different rhythmic patterns in the nurturing flow, 
                           showing how numbers dance in cycles when viewed through modular perspectives.</p>
                    </div>
                </div>
            `;
        }

        function createSpecialFunctionsContent() {
            return `
                <div class="viz-section">
                    <h3>UNNS Continuous Nurturing Fields</h3>
                    <div class="unns-label">Bridge discrete nurturing to smooth mathematical landscapes</div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>Function Type / Continuous Nurturing Field</label>
                            <select id="function-type" onchange="drawSpecialFunction()">
                                <option value="legendre">Legendre Polynomials</option>
                                <option value="bessel">Bessel Functions</option>
                                <option value="chebyshev">Chebyshev Polynomials</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Order / Nurturing Depth: <span id="order-display">5</span></label>
                            <input type="range" id="function-order" min="0" max="10" value="5"
                                   oninput="document.getElementById('order-display').textContent = this.value; drawSpecialFunction()">
                        </div>
                    </div>

                    <canvas id="function-canvas" width="800" height="400"></canvas>
                    
                    <div class="info-panel" id="function-info">
                        <h4>Continuous Extensions</h4>
                        <p>Special functions represent the smooth, continuous analogs of discrete nurturing processes, 
                           showing how recursive patterns extend into the continuous domain.</p>
                    </div>
                </div>
            `;
        }

        function createReferencesContent() {
            return `
                <div class="viz-section">
                    <h3>Knowledge Roots & Mathematical References</h3>
                    
                    <div class="dual-perspective">
                        <div class="perspective-box math" style="display: ${perspectiveMode === 'unns' ? 'none' : 'block'}">
                            <div class="perspective-label" style="color: #4a9eff">Mathematical Resources</div>
                            <h4>Sequence Theory</h4>
                            <a href="https://oeis.org" target="_blank" style="color: #00d4ff">OEIS - The On-Line Encyclopedia of Integer Sequences</a><br>
                            <a href="https://mathworld.wolfram.com/RecurrenceSequence.html" target="_blank" style="color: #00d4ff">Wolfram MathWorld: Recurrence Sequences</a><br>
                            
                            <h4 style="margin-top: 15px">Special Functions</h4>
                            <a href="https://mathworld.wolfram.com/LegendrePolynomial.html" target="_blank" style="color: #00d4ff">Legendre Polynomials</a><br>
                            <a href="https://mathworld.wolfram.com/BesselFunction.html" target="_blank" style="color: #00d4ff">Bessel Functions</a>
                        </div>
                        
                        <div class="perspective-box unns" style="display: ${perspectiveMode === 'math' ? 'none' : 'block'}">
                            <div class="perspective-label" style="color: #FFD700">UNNS Framework</div>
                            <h4>About UNNS</h4>
                            <p>The Unbounded Nested Number Sequences is a framework that describes mathematical 
                               relationships through the language of growth, nurturing, and evolution.</p>
                            
                            <h4 style="margin-top: 15px">Key Concepts</h4>
                            <ul style="color: #e0e6ed; list-style: none; padding-left: 0">
                                <li>• <strong>Nurturing Rules:</strong> Recurrence relations as generative principles</li>
                                <li>• <strong>Equilibria:</strong> Convergence points as stable states</li>
                                <li>• <strong>Cross-Nurturing:</strong> Sequence blending as hybrid evolution</li>
                                <li>• <strong>Rhythmic Cycles:</strong> Modular patterns as natural rhythms</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="info-panel" style="margin-top: 20px">
                        <h4>About This Dual-Perspective Tool</h4>
                        <p>This explorer presents established mathematical concepts alongside the UNNS interpretive framework. 
                           The mathematics represents rigorous, proven relationships, while UNNS offers a complementary 
                           metaphorical language designed to make these concepts more accessible through narrative and 
                           systemic thinking. Toggle between views using the button in the bottom-right corner.</p>
                    </div>
                </div>
            `;
        }

        // Glyph selection with UNNS integration
        function selectGlyph(glyph) {
            currentGlyph = glyph;
            
            // Update glyph buttons
            document.querySelectorAll('.glyph-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.glyph-button').classList.add('active');
            
            // Update display based on perspective mode
            const sequences_info = {
                'φ': { 
                    mathName: 'Golden Ratio (φ) - Fibonacci Sequence', 
                    mathDesc: 'The Fibonacci sequence converges to the golden ratio φ = (1+√5)/2 ≈ 1.618...',
                    mathEq: 'F(n) = F(n-1) + F(n-2), F(0)=0, F(1)=1',
                    unnsName: 'Golden Nurturing Pattern',
                    unnsDesc: 'The primordial nurturing pattern where each number embraces its two ancestors',
                    unnsEq: 'Child = Parent + Grandparent'
                },
                'δ': { 
                    mathName: 'Silver Ratio (δ) - Pell Sequence', 
                    mathDesc: 'The Pell sequence converges to δ = 1 + √2 ≈ 2.414...',
                    mathEq: 'P(n) = 2P(n-1) + P(n-2), P(0)=0, P(1)=1',
                    unnsName: 'Silver Nurturing Pattern',
                    unnsDesc: 'A doubled embrace of the immediate ancestor with memory of the elder',
                    unnsEq: 'Child = 2×Parent + Grandparent'
                },
                'ψ': { 
                    mathName: 'Tribonacci Constant (ψ)', 
                    mathDesc: 'The Tribonacci sequence converges to ψ ≈ 1.839...',
                    mathEq: 'T(n) = T(n-1) + T(n-2) + T(n-3), T(0)=0, T(1)=0, T(2)=1',
                    unnsName: 'Triple Nurturing Pattern',
                    unnsDesc: 'Three generations unite to birth each new numerical offspring',
                    unnsEq: 'Child = Parent + Grandparent + Great-Grandparent'
                },
                'ρ': { 
                    mathName: 'Plastic Number (ρ) - Padovan Sequence', 
                    mathDesc: 'The Padovan sequence converges to ρ ≈ 1.325...',
                    mathEq: 'P(n) = P(n-2) + P(n-3), P(0)=1, P(1)=1, P(2)=1',
                    unnsName: 'Plastic Nurturing Pattern',
                    unnsDesc: 'Skipping the immediate to embrace deeper ancestral wisdom',
                    unnsEq: 'Child = Grandparent + Great-Grandparent'
                }
            };
            
            const info = sequences_info[glyph];
            if (info) {
                // Update math perspective
                const mathTitle = document.getElementById('math-title');
                const mathDesc = document.getElementById('math-description');
                const mathEq = document.getElementById('math-equation');
                if (mathTitle) mathTitle.textContent = info.mathName;
                if (mathDesc) mathDesc.textContent = info.mathDesc;
                if (mathEq) mathEq.textContent = info.mathEq;
                
                // Update UNNS perspective
                const unnsTitle = document.getElementById('unns-title');
                const unnsDesc = document.getElementById('unns-description');
                const unnsEq = document.getElementById('unns-equation');
                if (unnsTitle) unnsTitle.textContent = info.unnsName;
                if (unnsDesc) unnsDesc.textContent = info.unnsDesc;
                if (unnsEq) unnsEq.textContent = info.unnsEq;
            }
            
            drawOverview();
        }

        // Drawing functions
        function drawOverview() {
            const canvas = document.getElementById('overview-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(10, 14, 39, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Handle complex sequences differently
            if (currentGlyph === 'G' || currentGlyph === 'E') {
                let values;
                if (currentGlyph === 'G') {
                    values = generateGaussianSequence(30);
                } else {
                    values = generateEisensteinSequence(30);
                }
                
                const maxVal = Math.max(...values);
                
                // Draw complex sequence modulus
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i < values.length; i++) {
                    const x = (i / (values.length - 1)) * (canvas.width - 40) + 20;
                    const y = canvas.height - 40 - (values[i] / maxVal) * (canvas.height - 80);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    
                    // Complex coloring
                    const hue = (i / values.length) * 360;
                    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px monospace';
                ctx.fillText('Complex Modulus Growth', 20, 30);
                
            } else {
                // Get sequence for current glyph
                let seqType = 'fibonacci';
                if (currentGlyph === 'δ') seqType = 'pell';
                else if (currentGlyph === 'ψ') seqType = 'tribonacci';
                else if (currentGlyph === 'ρ') seqType = 'padovan';
                else if (currentGlyph === 'L') seqType = 'lucas';
                else if (currentGlyph === 'J') seqType = 'jacobsthal';
                
                const values = generateSequence(seqType, 30);
                const maxVal = Math.max(...values);
                
                // Draw sequence
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i < values.length; i++) {
                    const x = (i / (values.length - 1)) * (canvas.width - 40) + 20;
                    const y = canvas.height - 40 - (values[i] / maxVal) * (canvas.height - 80);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    
                    // Draw points
                    ctx.fillStyle = '#00d4ff';
                    ctx.fillRect(x - 3, y - 3, 6, 6);
                }
                ctx.stroke();
                
                // Draw convergence (nurturing equilibrium)
                const ratios = [];
                for (let i = 1; i < values.length; i++) {
                    if (values[i-1] !== 0) {
                        ratios.push(values[i] / values[i-1]);
                    }
                }
                
                const dominant = sequences[seqType].dominant;
                
                // Draw ratio convergence
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < ratios.length; i++) {
                    const x = (i / (ratios.length - 1)) * (canvas.width - 40) + 20;
                    const y = canvas.height / 2 - (ratios[i] - dominant) * 200;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw equilibrium line
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(20, canvas.height / 2);
                ctx.lineTo(canvas.width - 20, canvas.height / 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Labels based on perspective
                ctx.font = '14px monospace';
                ctx.fillStyle = '#4a9eff';
                ctx.fillText(perspectiveMode !== 'unns' ? 'Sequence Growth' : 'Nurturing Evolution', 20, 30);
                ctx.fillStyle = '#FFD700';
                ctx.fillText(perspectiveMode !== 'unns' ? 'Ratio Convergence' : 'Approaching Equilibrium', 20, canvas.height / 2 - 10);
            }
        }

        function buildCustomSequence() {
            const canvas = document.getElementById('builder-canvas');
            const output = document.getElementById('sequence-output');
            
            if (!canvas || !output) return;
            
            const recurrenceInput = document.getElementById('recurrence-input');
            const initialInput = document.getElementById('initial-values');
            
            try {
                const coeffs = parseRecurrence(recurrenceInput.value);
                const initValues = initialInput.value.split(',').map(x => parseFloat(x.trim()));
                
                if (coeffs.length !== initValues.length) {
                    output.textContent = 'Error: Number of coefficients must match initial values';
                    return;
                }
                
                const values = generateCustomSequence(coeffs, initValues, 50);
                
                // Display sequence with UNNS terminology
                output.innerHTML = `
                    <strong>${perspectiveMode !== 'unns' ? 'Generated Sequence' : 'Nurtured Numbers'}:</strong><br>
                    ${perspectiveMode !== 'unns' ? 'Coefficients' : 'Nurturing Weights'}: [${coeffs.join(', ')}]<br>
                    ${perspectiveMode !== 'unns' ? 'Initial Values' : 'Seed Numbers'}: [${initValues.join(', ')}]<br>
                    ${perspectiveMode !== 'unns' ? 'Values' : 'Offspring'}: ${values.slice(0, 15).map(v => v.toFixed(2)).join(', ')}...
                `;
                
                // Draw graph
                drawSequenceGraph(canvas, values, perspectiveMode !== 'unns' ? 'Custom Sequence' : 'Custom Nurturing Pattern');
                
            } catch (error) {
                output.textContent = 'Error: ' + error.message;
            }
        }

        function generateCustomSequence(coeffs, initValues, n) {
            let values = [...initValues];
            const k = coeffs.length;
            
            while (values.length < n) {
                let next = 0;
                for (let i = 0; i < k; i++) {
                    next += coeffs[i] * values[values.length - k + i];
                }
                values.push(next);
            }
            
            return values;
        }

        function drawSequenceGraph(canvas, values, title) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(10, 14, 39, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (values.length === 0) return;
            
            const maxVal = Math.max(...values.map(Math.abs));
            
            // Draw axis
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(20, canvas.height / 2);
            ctx.lineTo(canvas.width - 20, canvas.height / 2);
            ctx.stroke();
            
            // Draw sequence
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < values.length; i++) {
                const x = (i / (values.length - 1)) * (canvas.width - 40) + 20;
                const y = canvas.height / 2 - (values[i] / maxVal) * (canvas.height / 2 - 40);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                // Draw points
                ctx.fillStyle = '#00d4ff';
                ctx.fillRect(x - 2, y - 2, 4, 4);
            }
            ctx.stroke();
            
            // Title
            ctx.fillStyle = '#4a9eff';
            ctx.font = '16px monospace';
            ctx.fillText(title, 20, 30);
        }

        function updateBlendDisplay() {
            const slider = document.getElementById('blend-ratio');
            document.getElementById('blend-display').textContent = slider.value + '%';
        }

        function drawSequenceBlending() {
            const canvas = document.getElementById('blending-canvas');
            if (!canvas) return;
            
            const sourceSelect = document.getElementById('source-sequence');
            const targetSelect = document.getElementById('target-sequence');
            const blendSlider = document.getElementById('blend-ratio');
            
            const source = sourceSelect.value;
            const target = targetSelect.value;
            const blendRatio = parseFloat(blendSlider.value) / 100;
            
            const seq1 = generateSequence(source, 30);
            const seq2 = generateSequence(target, 30);
            
            // Calculate blended sequence
            const blended = [];
            for (let i = 0; i < Math.min(seq1.length, seq2.length); i++) {
                blended.push(blendRatio * seq1[i] + (1 - blendRatio) * seq2[i]);
            }
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(10, 14, 39, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const maxVal = Math.max(...seq1, ...seq2, ...blended);
            
            // Draw sequences
            drawSequenceLine(ctx, canvas, seq1, '#FFD700', sequences[source].name);
            drawSequenceLine(ctx, canvas, seq2, '#FF6B6B', sequences[target].name);
            drawSequenceLine(ctx, canvas, blended, '#4a9eff', 'Blended');
            
            // Legend with UNNS names if applicable
            ctx.font = '14px monospace';
            ctx.fillStyle = '#FFD700';
            const sourceName = perspectiveMode !== 'math' ? sequences[source].unnsName : sequences[source].name;
            ctx.fillText(`Primary: ${sourceName}`, 20, 30);
            ctx.fillStyle = '#FF6B6B';
            const targetName = perspectiveMode !== 'math' ? sequences[target].unnsName : sequences[target].name;
            ctx.fillText(`Secondary: ${targetName}`, 20, 50);
            ctx.fillStyle = '#4a9eff';
            const blendLabel = perspectiveMode !== 'math' ? 'Cross-Nurtured' : 'Blended';
            ctx.fillText(`${blendLabel} (${(blendRatio * 100).toFixed(1)}%)`, 20, 70);
        }

        function drawSequenceLine(ctx, canvas, values, color, label) {
            const maxVal = Math.max(...values);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < values.length; i++) {
                const x = (i / (values.length - 1)) * (canvas.width - 40) + 20;
                const y = canvas.height - 40 - (values[i] / maxVal) * (canvas.height - 80);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function calculateConvergence(sequence, dominantRoot) {
            const ratios = [];
            for (let i = 1; i < sequence.length; i++) {
                if (sequence[i-1] !== 0) {
                    ratios.push(sequence[i] / sequence[i-1]);
                }
            }
            
            const lastRatio = ratios[ratios.length - 1];
            const error = Math.abs(lastRatio - dominantRoot);
            const convergenceRate = ratios.length > 10 ? 
                Math.abs(ratios[ratios.length-1] - ratios[ratios.length-10]) : 0;
            
            return {
                ratios,
                lastRatio,
                error,
                convergenceRate,
                iterations: ratios.length
            };
        }

        function drawConvergenceAnalysis() {
            const canvas = document.getElementById('convergence-canvas');
            const metricsDiv = document.getElementById('error-metrics');
            
            if (!canvas) return;
            
            const seqSelect = document.getElementById('convergence-sequence');
            const seqType = seqSelect.value;
            
            const values = generateSequence(seqType, 50);
            const convergence = calculateConvergence(values, sequences[seqType].dominant);
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(10, 14, 39, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw convergence graph
            const ratios = convergence.ratios;
            const dominant = sequences[seqType].dominant;
            
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < ratios.length; i++) {
                const x = (i / (ratios.length - 1)) * (canvas.width - 40) + 20;
                const y = canvas.height / 2 - (ratios[i] - dominant) * 200;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw target line (equilibrium)
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(20, canvas.height / 2);
            ctx.lineTo(canvas.width - 20, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Update metrics with UNNS terminology
            if (metricsDiv) {
                metricsDiv.innerHTML = `
                    <div class="metric-card">
                        <div class="metric-value">${dominant.toFixed(6)}</div>
                        <div class="metric-label">${perspectiveMode !== 'unns' ? 'Target Ratio' : 'Equilibrium'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${convergence.lastRatio.toFixed(6)}</div>
                        <div class="metric-label">${perspectiveMode !== 'unns' ? 'Current Ratio' : 'Current State'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${convergence.error.toExponential(2)}</div>
                        <div class="metric-label">${perspectiveMode !== 'unns' ? 'Error' : 'Distance'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${convergence.iterations}</div>
                        <div class="metric-label">${perspectiveMode !== 'unns' ? 'Iterations' : 'Generations'}</div>
                    </div>
                `;
            }
        }

        function drawModularPatterns() {
            const canvas = document.getElementById('modular-canvas');
            if (!canvas) return;
            
            const seqSelect = document.getElementById('modular-sequence');
            const seqType = seqSelect.value;
            
            const values = generateSequence(seqType, 100);
            const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(10, 14, 39, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cellSize = 8;
            const startX = 100;
            const startY = 30;
            
            primes.forEach((p, pIndex) => {
                const y = startY + pIndex * 45;
                
                // Prime label
                ctx.fillStyle = '#8892b0';
                ctx.font = '14px monospace';
                ctx.fillText(`mod ${p}:`, 20, y + 20);
                
                // Draw modular values
                for (let i = 0; i < Math.min(values.length, 80); i++) {
                    const mod = values[i] % p;
                    const hue = (mod / p) * 360;
                    const x = startX + i * cellSize;
                    
                    ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.9)`;
                    ctx.fillRect(x, y, cellSize - 1, 30);
                }
                
                // Simple period detection
                const pattern = values.slice(0, 40).map(v => v % p);
                let period = findPeriod(pattern);
                
                if (period > 0) {
                    ctx.fillStyle = '#00d4ff';
                    ctx.font = '12px monospace';
                    const periodLabel = perspectiveMode !== 'unns' ? 'Period' : 'Cycle';
                    ctx.fillText(`${periodLabel}: ${period}`, startX + 650, y + 20);
                }
            });
        }

        function findPeriod(sequence) {
            for (let len = 1; len < sequence.length / 2; len++) {
                let isPattern = true;
                for (let i = 0; i < len && i + len < sequence.length; i++) {
                    if (sequence[i] !== sequence[i + len]) {
                        isPattern = false;
                        break;
                    }
                }
                if (isPattern) return len;
            }
            return 0;
        }

        function drawSpecialFunction() {
            // Placeholder for special function visualization
            const canvas = document.getElementById('function-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(10, 14, 39, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#4a9eff';
            ctx.font = '16px monospace';
            ctx.fillText('Special Function Visualization', 20, 30);
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>