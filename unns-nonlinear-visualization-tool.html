<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Non-Linear Extensions: Complete Interactive System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            position: relative;
        }

        /* Guide Button - Prominent and Always Visible */
        #guideButton {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 10000 !important;
            background: linear-gradient(135deg, #FFD700, #FFA500) !important;
            color: #333 !important;
            border: 3px solid #FFD700 !important;
            border-radius: 50px !important;
            padding: 15px 30px !important;
            font-size: 18px !important;
            font-weight: bold !important;
            cursor: pointer !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8) !important;
            animation: pulseGold 2s infinite !important;
            visibility: visible !important;
            display: block !important;
            opacity: 1 !important;
        }

        @keyframes pulseGold {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: scale(1.05); 
                box-shadow: 0 0 40px rgba(255, 215, 0, 1);
            }
        }

        #guideButton:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 0 50px rgba(255, 215, 0, 1) !important;
        }

        /* Guide Modal */
        .guide-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 20000;
            overflow-y: auto;
            padding: 20px;
        }

        .guide-modal.active {
            display: block;
        }

        .guide-content {
            max-width: 1000px;
            margin: 0 auto;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 0 50px rgba(102, 126, 234, 0.5);
        }

        .guide-header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 3px solid #FFD700;
            padding-bottom: 20px;
        }

        .guide-header h2 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .guide-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .guide-tab {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .guide-tab:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .guide-tab.active {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
            font-weight: bold;
        }

        .guide-section {
            display: none;
            animation: fadeIn 0.5s;
        }

        .guide-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .guide-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .guide-close:hover {
            background: #ff6666;
            transform: rotate(90deg);
        }

        /* Main Container */
        .main-container {
            padding: 80px 20px 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6B6B, #4ECDC4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Panels */
        .panel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .panel h3 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            color: #4ECDC4;
            font-weight: bold;
        }

        input, select {
            padding: 8px 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        /* Buttons */
        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 2px solid transparent;
            padding: 10px 20px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover:before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn.active {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .btn.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .btn.success {
            background: linear-gradient(135deg, #00C851, #00ff00);
        }

        /* Display Areas */
        .display-area {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }

        .display-area::-webkit-scrollbar {
            width: 8px;
        }

        .display-area::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .display-area::-webkit-scrollbar-thumb {
            background: #FFD700;
            border-radius: 4px;
        }

        /* Canvas Container */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .canvas-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Chunk Visualization */
        .chunks-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            min-height: 60px;
        }

        .chunk-item {
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 10px 15px;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .chunk-item:hover {
            transform: scale(1.05);
            border-color: #FFD700;
        }

        .chunk-item.highlighted {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
            animation: bounce 0.5s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Combinator Cards */
        .combinator-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .combinator-card {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .combinator-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-3px);
            border-color: #4ECDC4;
        }

        .combinator-card.selected {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .combinator-card h4 {
            color: #4ECDC4;
            margin-bottom: 5px;
        }

        .combinator-card.selected h4 {
            color: #333;
        }

        .combinator-card .formula {
            font-size: 0.9em;
            opacity: 0.8;
            font-family: 'Courier New', monospace;
        }

        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 2px solid #FFD700;
            z-index: 1000;
        }

        .status-text {
            color: #4ECDC4;
        }

        .status-indicators {
            display: flex;
            gap: 15px;
        }

        .indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .indicator-light {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
        }

        .indicator-light.active {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .panel-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            #guideButton {
                padding: 10px 20px !important;
                font-size: 16px !important;
            }
        }
    </style>
</head>
<body>
    <!-- Guide Button - Always Visible -->
    <button id="guideButton" onclick="UNNSApp.showGuide()">📚 GUIDE</button>

    <!-- Guide Modal -->
    <div id="guideModal" class="guide-modal">
        <div class="guide-content">
            <button class="guide-close" onclick="UNNSApp.hideGuide()">×</button>
            <div class="guide-header">
                <h2>UNNS Complete Guide</h2>
                <p>Master the Non-Linear Extensions</p>
            </div>
            
            <div class="guide-tabs">
                <div class="guide-tab active" onclick="UNNSApp.switchGuideTab('overview')">Overview</div>
                <div class="guide-tab" onclick="UNNSApp.switchGuideTab('sequences')">Sequences</div>
                <div class="guide-tab" onclick="UNNSApp.switchGuideTab('chunks')">Chunks</div>
                <div class="guide-tab" onclick="UNNSApp.switchGuideTab('combinators')">Combinators</div>
                <div class="guide-tab" onclick="UNNSApp.switchGuideTab('visualization')">Visualization</div>
                <div class="guide-tab" onclick="UNNSApp.switchGuideTab('examples')">Examples</div>
                <div class="guide-tab" onclick="UNNSApp.switchGuideTab('theory')">Theory</div>
                <div class="guide-tab" onclick="UNNSApp.switchGuideTab('troubleshooting')">Troubleshooting</div>
            </div>
            
            <div id="guide-overview" class="guide-section active">
                <h3>🌟 Overview</h3>
                <p>Welcome to the UNNS (Unbounded Nested Number Sequences) Non-Linear Extensions tool!</p>
                <br>
                <h4>Key Concepts:</h4>
                <ul>
                    <li><strong>UNNS Framework:</strong> A mathematical system for studying nested number sequences with unbounded growth patterns</li>
                    <li><strong>Non-Linear Extensions:</strong> Advanced operations that go beyond traditional linear transformations</li>
                    <li><strong>Chunk Operations:</strong> Divide sequences into contiguous subsequences for analysis</li>
                    <li><strong>Combinators:</strong> Mathematical functions that combine chunks in non-linear ways</li>
                </ul>
                <br>
                <h4>Quick Start:</h4>
                <ol>
                    <li>Generate a sequence using the Sequence Generator panel</li>
                    <li>Apply chunk operations to divide the sequence</li>
                    <li>Select a combinator to transform chunks</li>
                    <li>Visualize results in 2D and 3D</li>
                    <li>Use animation controls to see dynamic behavior</li>
                </ol>
            </div>
            
            <div id="guide-sequences" class="guide-section">
                <h3>🧬 Sequence Types</h3>
                <h4>Available Generators:</h4>
                <ul>
                    <li><strong>Fibonacci:</strong> Classic recursive sequence (F(n) = F(n-1) + F(n-2))</li>
                    <li><strong>Catalan:</strong> Combinatorial sequence counting binary trees</li>
                    <li><strong>Polynomial:</strong> Customizable polynomial recurrence</li>
                    <li><strong>Prime Sieve:</strong> Sequence of prime numbers</li>
                    <li><strong>Chaotic:</strong> Logistic map with chaos parameter</li>
                </ul>
                <br>
                <h4>Convergence Analysis:</h4>
                <p>The tool automatically calculates convergence ratios to identify limiting behavior.</p>
            </div>
            
            <div id="guide-chunks" class="guide-section">
                <h3>📦 Chunk Operations</h3>
                <h4>Parameters:</h4>
                <ul>
                    <li><strong>Chunk Size:</strong> Number of elements in each chunk (2-8)</li>
                    <li><strong>Shift Amount:</strong> Overlap between consecutive chunks (0 = no overlap)</li>
                </ul>
                <br>
                <h4>Example:</h4>
                <p>Sequence: [1, 2, 3, 4, 5, 6]</p>
                <p>Chunk Size: 3, Shift: 1</p>
                <p>Result: [1,2,3], [2,3,4], [3,4,5], [4,5,6]</p>
            </div>
            
            <div id="guide-combinators" class="guide-section">
                <h3>⚡ Non-Linear Combinators</h3>
                <h4>Types:</h4>
                <ul>
                    <li><strong>Multiplicative:</strong> Element-wise multiplication and sum</li>
                    <li><strong>Exponential:</strong> Power operations with modular reduction</li>
                    <li><strong>Modular:</strong> Sum modulo chunk length</li>
                    <li><strong>Cross-Product:</strong> Cartesian product operations</li>
                    <li><strong>Polynomial:</strong> Custom polynomial transformation</li>
                    <li><strong>Chaos Generator:</strong> Logistic map application</li>
                </ul>
            </div>
            
            <div id="guide-visualization" class="guide-section">
                <h3>📊 Visualization Features</h3>
                <h4>2D Canvas:</h4>
                <ul>
                    <li>Bar chart representation</li>
                    <li>Connecting line plot</li>
                    <li>Color gradient mapping</li>
                    <li>Real-time animation</li>
                </ul>
                <br>
                <h4>3D Spiral:</h4>
                <ul>
                    <li>Three.js powered visualization</li>
                    <li>Spiral arrangement of chunks</li>
                    <li>Rotation controls</li>
                    <li>Multiple camera views</li>
                </ul>
            </div>
            
            <div id="guide-examples" class="guide-section">
                <h3>💡 Examples</h3>
                <h4>Example 1: Fibonacci Chunks</h4>
                <ol>
                    <li>Select "Fibonacci" sequence</li>
                    <li>Set length to 20</li>
                    <li>Generate sequence</li>
                    <li>Set chunk size to 3</li>
                    <li>Apply multiplicative combinator</li>
                </ol>
                <br>
                <h4>Example 2: Chaos Analysis</h4>
                <ol>
                    <li>Select "Chaotic" sequence</li>
                    <li>Generate with length 30</li>
                    <li>Apply chaos generator combinator</li>
                    <li>Observe convergence patterns</li>
                </ol>
            </div>
            
            <div id="guide-theory" class="guide-section">
                <h3>📐 Mathematical Theory</h3>
                <h4>UNNS Formal Definition:</h4>
                <p>A UNNS is a sequence S = {s₀, s₁, s₂, ...} where:</p>
                <ul>
                    <li>Each element can grow unboundedly</li>
                    <li>Nested structure allows recursive definitions</li>
                    <li>Non-linear operations preserve algebraic properties</li>
                </ul>
                <br>
                <h4>Convergence Criteria:</h4>
                <p>For a sequence to converge: lim(n→∞) s_{n+1}/s_n = L</p>
            </div>
            
            <div id="guide-troubleshooting" class="guide-section">
                <h3>🔧 Troubleshooting</h3>
                <h4>Common Issues:</h4>
                <ul>
                    <li><strong>3D not displaying:</strong> Check WebGL support in browser</li>
                    <li><strong>Animation lag:</strong> Reduce sequence length</li>
                    <li><strong>Buttons unresponsive:</strong> Refresh page and check console</li>
                </ul>
                <br>
                <h4>Performance Tips:</h4>
                <ul>
                    <li>Keep sequences under 50 elements for smooth animation</li>
                    <li>Use Chrome/Firefox for best WebGL performance</li>
                    <li>Close other tabs to free memory</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Main Application -->
    <div class="main-container">
        <div class="header">
            <h1>UNNS Non-Linear Extensions</h1>
            <p>Interactive Visualization & Analysis System</p>
        </div>

        <div class="panel-grid">
            <!-- Sequence Generator Panel -->
            <div class="panel">
                <h3>🧬 Sequence Generator</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>Type:</label>
                        <select id="sequenceType">
                            <option value="fibonacci">Fibonacci</option>
                            <option value="catalan">Catalan</option>
                            <option value="polynomial">Polynomial</option>
                            <option value="prime">Prime Sieve</option>
                            <option value="chaotic">Chaotic</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Length:</label>
                        <input type="number" id="sequenceLength" value="20" min="5" max="50">
                    </div>
                    <button class="btn success" onclick="UNNSApp.generateSequence()">Generate</button>
                </div>
                <div id="sequenceDisplay" class="display-area">
                    Ready to generate sequence...
                </div>
            </div>

            <!-- Chunk Operations Panel -->
            <div class="panel">
                <h3>📦 Chunk Operations</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>Size:</label>
                        <input type="number" id="chunkSize" value="3" min="2" max="8">
                    </div>
                    <div class="control-group">
                        <label>Shift:</label>
                        <input type="number" id="shiftAmount" value="1" min="0" max="5">
                    </div>
                    <button class="btn" onclick="UNNSApp.applyChunks()">Apply Chunks</button>
                </div>
                <div id="chunksDisplay" class="chunks-container">
                    Chunks will appear here...
                </div>
                <div id="chunkResults" class="display-area">
                    Chunk operation results...
                </div>
            </div>
        </div>

        <!-- Combinators Panel -->
        <div class="panel">
            <h3>⚡ Non-Linear Combinators</h3>
            <div class="combinator-grid">
                <div class="combinator-card" onclick="UNNSApp.selectCombinator('multiplicative')" id="comb-multiplicative">
                    <h4>Multiplicative</h4>
                    <div class="formula">Π(a×b)</div>
                </div>
                <div class="combinator-card" onclick="UNNSApp.selectCombinator('exponential')" id="comb-exponential">
                    <h4>Exponential</h4>
                    <div class="formula">a^(b mod p)</div>
                </div>
                <div class="combinator-card" onclick="UNNSApp.selectCombinator('modular')" id="comb-modular">
                    <h4>Modular</h4>
                    <div class="formula">Σ mod |C|</div>
                </div>
                <div class="combinator-card" onclick="UNNSApp.selectCombinator('cross')" id="comb-cross">
                    <h4>Cross-Product</h4>
                    <div class="formula">C₁ × C₂</div>
                </div>
                <div class="combinator-card" onclick="UNNSApp.selectCombinator('polynomial')" id="comb-polynomial">
                    <h4>Polynomial</h4>
                    <div class="formula">ax² + bx + c</div>
                </div>
                <div class="combinator-card" onclick="UNNSApp.selectCombinator('chaos')" id="comb-chaos">
                    <h4>Chaos</h4>
                    <div class="formula">rx(1-x)</div>
                </div>
            </div>
        </div>

        <div class="panel-grid">
            <!-- 2D Visualization -->
            <div class="panel">
                <h3>📊 2D Visualization</h3>
                <div class="canvas-container">
                    <canvas id="canvas2D"></canvas>
                </div>
                <div class="controls">
                    <button class="btn" id="animateBtn" onclick="UNNSApp.toggleAnimation()">Start Animation</button>
                    <button class="btn danger" onclick="UNNSApp.resetAnimation()">Reset</button>
                </div>
            </div>

            <!-- 3D Visualization -->
            <div class="panel">
                <h3>🌀 3D Spiral Dynamics</h3>
                <div class="canvas-container" id="container3D"></div>
                <div class="controls">
                    <button class="btn" id="rotateBtn" onclick="UNNSApp.toggle3DRotation()">Stop Rotation</button>
                    <button class="btn" onclick="UNNSApp.changeView()">Change View</button>
                    <button class="btn" onclick="UNNSApp.reset3D()">Reset 3D</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-text" id="statusText">System Ready</div>
        <div class="status-indicators">
            <div class="indicator">
                <div class="indicator-light" id="animLight"></div>
                <span>Animation</span>
            </div>
            <div class="indicator">
                <div class="indicator-light" id="rotLight"></div>
                <span>3D Rotation</span>
            </div>
            <div class="indicator">
                <div class="indicator-light active" id="sysLight"></div>
                <span>System</span>
            </div>
        </div>
    </div>

    <script>
        // Complete UNNS Application Object
        const UNNSApp = {
            // State variables
            sequence: [],
            chunks: [],
            currentCombinator: 'multiplicative',
            animationActive: false,
            animationFrame: null,
            rotation3D: true,
            
            // Three.js variables
            scene: null,
            camera: null,
            renderer: null,
            meshes: [],
            
            // Initialize application
            init() {
                console.log('Initializing UNNS Application...');
                this.initEventListeners();
                this.init3D();
                this.generateSequence();
                this.selectCombinator('multiplicative');
                this.updateStatus('Application initialized successfully');
                
                // Update rotation indicator
                document.getElementById('rotLight').classList.add('active');
            },
            
            // Event listeners
            initEventListeners() {
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.hideGuide();
                    }
                    if (e.key === 'g' && e.ctrlKey) {
                        e.preventDefault();
                        this.showGuide();
                    }
                });
            },
            
            // Guide functions
            showGuide() {
                document.getElementById('guideModal').classList.add('active');
                this.updateStatus('Guide opened');
            },
            
            hideGuide() {
                document.getElementById('guideModal').classList.remove('active');
                this.updateStatus('Guide closed');
            },
            
            switchGuideTab(tabName) {
                // Hide all sections
                document.querySelectorAll('.guide-section').forEach(section => {
                    section.classList.remove('active');
                });
                // Show selected section
                document.getElementById(`guide-${tabName}`).classList.add('active');
                
                // Update tab styling
                document.querySelectorAll('.guide-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                event.target.classList.add('active');
            },
            
            // Sequence generation
            generateSequence() {
                const type = document.getElementById('sequenceType').value;
                const length = parseInt(document.getElementById('sequenceLength').value);
                
                this.sequence = this.generators[type](length);
                this.displaySequence();
                this.visualize2D();
                this.update3D();
                this.updateStatus(`Generated ${type} sequence with ${length} elements`);
            },
            
            generators: {
                fibonacci(n) {
                    const seq = [1, 1];
                    for (let i = 2; i < n; i++) {
                        seq.push(seq[i-1] + seq[i-2]);
                    }
                    return seq;
                },
                
                catalan(n) {
                    const seq = [1];
                    for (let i = 1; i < n; i++) {
                        let val = 0;
                        for (let j = 0; j < i; j++) {
                            val += seq[j] * seq[i-1-j];
                        }
                        seq.push(val);
                    }
                    return seq;
                },
                
                polynomial(n) {
                    const seq = [];
                    for (let i = 0; i < n; i++) {
                        seq.push(Math.floor(i*i + 2*i + 1));
                    }
                    return seq;
                },
                
                prime(n) {
                    const primes = [];
                    let num = 2;
                    while (primes.length < n) {
                        let isPrime = true;
                        for (let i = 2; i <= Math.sqrt(num); i++) {
                            if (num % i === 0) {
                                isPrime = false;
                                break;
                            }
                        }
                        if (isPrime) primes.push(num);
                        num++;
                    }
                    return primes;
                },
                
                chaotic(n) {
                    const r = 3.7;
                    const seq = [0.5];
                    for (let i = 1; i < n; i++) {
                        seq.push(r * seq[i-1] * (1 - seq[i-1]));
                    }
                    return seq.map(x => Math.floor(x * 100));
                }
            },
            
            displaySequence() {
                const display = document.getElementById('sequenceDisplay');
                const formatted = this.sequence.slice(0, 10).map((val, idx) => 
                    `s[${idx}] = ${val}`
                ).join(', ');
                display.textContent = formatted + (this.sequence.length > 10 ? '...' : '');
            },
            
            // Chunk operations
            applyChunks() {
                const chunkSize = parseInt(document.getElementById('chunkSize').value);
                const shift = parseInt(document.getElementById('shiftAmount').value);
                
                this.chunks = [];
                for (let i = 0; i <= this.sequence.length - chunkSize; i += (shift || 1)) {
                    this.chunks.push(this.sequence.slice(i, i + chunkSize));
                }
                
                this.displayChunks();
                this.applyCombinator();
                this.updateStatus(`Created ${this.chunks.length} chunks of size ${chunkSize}`);
            },
            
            displayChunks() {
                const container = document.getElementById('chunksDisplay');
                container.innerHTML = '';
                
                this.chunks.forEach((chunk, idx) => {
                    const elem = document.createElement('div');
                    elem.className = 'chunk-item';
                    elem.textContent = `[${chunk.join(',')}]`;
                    elem.onclick = () => this.highlightChunk(elem, idx);
                    container.appendChild(elem);
                });
            },
            
            highlightChunk(elem, idx) {
                // Remove previous highlights
                document.querySelectorAll('.chunk-item').forEach(item => {
                    item.classList.remove('highlighted');
                });
                
                // Add highlight
                elem.classList.add('highlighted');
                
                // Animate in 2D
                this.animateChunkIn2D(idx);
                
                this.updateStatus(`Selected chunk ${idx}: [${this.chunks[idx].join(', ')}]`);
            },
            
            animateChunkIn2D(chunkIdx) {
                const canvas = document.getElementById('canvas2D');
                const ctx = canvas.getContext('2d');
                const chunk = this.chunks[chunkIdx];
                
                if (!chunk) return;
                
                // Highlight effect
                let alpha = 1.0;
                const animate = () => {
                    this.visualize2D();
                    
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
                    ctx.lineWidth = 3;
                    
                    // Draw highlight box around chunk elements
                    const chunkSize = chunk.length;
                    const shift = parseInt(document.getElementById('shiftAmount').value) || 1;
                    const startIdx = chunkIdx * shift;
                    
                    const barWidth = canvas.width / this.sequence.length;
                    const x = startIdx * barWidth;
                    const width = chunkSize * barWidth;
                    
                    ctx.strokeRect(x, 0, width, canvas.height);
                    ctx.restore();
                    
                    alpha -= 0.02;
                    if (alpha > 0) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            },
            
            // Combinators
            selectCombinator(type) {
                this.currentCombinator = type;
                
                // Update UI
                document.querySelectorAll('.combinator-card').forEach(card => {
                    card.classList.remove('selected');
                });
                document.getElementById(`comb-${type}`).classList.add('selected');
                
                // Apply if chunks exist
                if (this.chunks.length > 0) {
                    this.applyCombinator();
                }
                
                this.updateStatus(`Selected ${type} combinator`);
            },
            
            applyCombinator() {
                if (this.chunks.length < 2) {
                    this.updateStatus('Need at least 2 chunks for combinator');
                    return;
                }
                
                const results = [];
                for (let i = 0; i < this.chunks.length - 1; i++) {
                    const result = this.combinators[this.currentCombinator](
                        this.chunks[i], 
                        this.chunks[i + 1]
                    );
                    results.push(result);
                }
                
                const display = document.getElementById('chunkResults');
                display.textContent = `Combinator Results: [${results.map(r => r.toFixed(2)).join(', ')}]`;
                
                // Calculate convergence
                if (results.length > 1) {
                    const ratio = results[results.length - 1] / results[results.length - 2];
                    display.textContent += `\nConvergence Ratio: ${ratio.toFixed(6)}`;
                }
            },
            
            combinators: {
                multiplicative(c1, c2) {
                    let sum = 0;
                    for (let i = 0; i < Math.min(c1.length, c2.length); i++) {
                        sum += c1[i] * c2[i];
                    }
                    return sum;
                },
                
                exponential(c1, c2) {
                    if (c1.length === 0 || c2.length === 0) return 0;
                    return Math.pow(c1[0], c2[0] % 5) % 1000;
                },
                
                modular(c1, c2) {
                    const sum1 = c1.reduce((a, b) => a + b, 0);
                    const sum2 = c2.reduce((a, b) => a + b, 0);
                    return (sum1 + sum2) % (c1.length + c2.length);
                },
                
                cross(c1, c2) {
                    let product = 0;
                    for (let a of c1) {
                        for (let b of c2) {
                            product += Math.abs(a - b);
                        }
                    }
                    return product % 1000;
                },
                
                polynomial(c1, c2) {
                    if (c1.length < 3) return 0;
                    return c1[0] + 2 * c1[1] + c1[2];
                },
                
                chaos(c1, c2) {
                    if (c1.length === 0) return 0;
                    const r = 3.9;
                    const x = (c1[0] % 100) / 100;
                    return Math.floor(r * x * (1 - x) * 1000);
                }
            },
            
            // 2D Visualization
            visualize2D() {
                const canvas = document.getElementById('canvas2D');
                const ctx = canvas.getContext('2d');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (this.sequence.length === 0) return;
                
                const maxVal = Math.max(...this.sequence);
                const minVal = Math.min(...this.sequence);
                const range = maxVal - minVal || 1;
                
                const barWidth = canvas.width / this.sequence.length;
                
                // Draw bars
                this.sequence.forEach((val, idx) => {
                    const height = ((val - minVal) / range) * (canvas.height - 40) + 20;
                    const x = idx * barWidth;
                    const y = canvas.height - height;
                    
                    // Gradient
                    const gradient = ctx.createLinearGradient(x, y, x, canvas.height);
                    gradient.addColorStop(0, '#FFD700');
                    gradient.addColorStop(1, '#FF6B6B');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth - 2, height);
                });
                
                // Draw line
                ctx.strokeStyle = '#4ECDC4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                this.sequence.forEach((val, idx) => {
                    const height = ((val - minVal) / range) * (canvas.height - 40) + 20;
                    const x = idx * barWidth + barWidth / 2;
                    const y = canvas.height - height;
                    
                    if (idx === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                
                ctx.stroke();
            },
            
            // Animation
            toggleAnimation() {
                this.animationActive = !this.animationActive;
                const btn = document.getElementById('animateBtn');
                const light = document.getElementById('animLight');
                
                if (this.animationActive) {
                    btn.textContent = 'Stop Animation';
                    btn.classList.add('active');
                    light.classList.add('active');
                    this.startAnimation();
                } else {
                    btn.textContent = 'Start Animation';
                    btn.classList.remove('active');
                    light.classList.remove('active');
                    this.stopAnimation();
                }
            },
            
            startAnimation() {
                let frame = 0;
                const animate = () => {
                    if (!this.animationActive) return;
                    
                    // Animate chunks
                    const chunkItems = document.querySelectorAll('.chunk-item');
                    chunkItems.forEach((item, idx) => {
                        item.classList.remove('highlighted');
                        if (idx === frame % chunkItems.length) {
                            item.classList.add('highlighted');
                        }
                    });
                    
                    frame++;
                    this.animationFrame = requestAnimationFrame(animate);
                };
                animate();
                this.updateStatus('Animation started');
            },
            
            stopAnimation() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                this.updateStatus('Animation stopped');
            },
            
            resetAnimation() {
                this.stopAnimation();
                document.querySelectorAll('.chunk-item').forEach(item => {
                    item.classList.remove('highlighted');
                });
                this.animationActive = false;
                document.getElementById('animateBtn').textContent = 'Start Animation';
                document.getElementById('animateBtn').classList.remove('active');
                document.getElementById('animLight').classList.remove('active');
                this.updateStatus('Animation reset');
            },
            
            // 3D Visualization
            init3D() {
                const container = document.getElementById('container3D');
                
                // Scene
                this.scene = new THREE.Scene();
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    container.offsetWidth / container.offsetHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true 
                });
                this.renderer.setSize(container.offsetWidth, container.offsetHeight);
                this.renderer.setClearColor(0x000000, 0);
                container.appendChild(this.renderer.domElement);
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight.position.set(10, 10, 5);
                
                this.scene.add(ambientLight);
                this.scene.add(directionalLight);
                
                // Start render loop
                this.render3D();
            },
            
            update3D() {
                // Clear existing meshes
                this.meshes.forEach(mesh => {
                    this.scene.remove(mesh);
                });
                this.meshes = [];
                
                if (this.sequence.length === 0) return;
                
                const maxVal = Math.max(...this.sequence) || 1;
                
                // Create spiral of spheres
                this.sequence.forEach((val, idx) => {
                    const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                    const material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(
                            (idx / this.sequence.length) * 0.8,
                            0.8,
                            0.6
                        ),
                        emissive: new THREE.Color().setHSL(
                            (idx / this.sequence.length) * 0.8,
                            0.8,
                            0.3
                        ),
                        emissiveIntensity: 0.3
                    });
                    
                    const sphere = new THREE.Mesh(geometry, material);
                    
                    // Position in spiral
                    const t = idx * 0.5;
                    const radius = 1 + (val / maxVal) * 2;
                    sphere.position.x = radius * Math.cos(t);
                    sphere.position.y = (idx / this.sequence.length) * 3 - 1.5;
                    sphere.position.z = radius * Math.sin(t);
                    
                    // Scale based on value
                    const scale = 0.5 + (val / maxVal) * 0.5;
                    sphere.scale.set(scale, scale, scale);
                    
                    this.scene.add(sphere);
                    this.meshes.push(sphere);
                });
                
                // Add connecting lines
                const points = this.meshes.map(mesh => mesh.position);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xFFD700,
                    opacity: 0.5,
                    transparent: true
                });
                const line = new THREE.Line(geometry, material);
                this.scene.add(line);
                this.meshes.push(line);
            },
            
            render3D() {
                requestAnimationFrame(() => this.render3D());
                
                // Rotate scene if enabled
                if (this.rotation3D && this.meshes.length > 0) {
                    this.meshes.forEach(mesh => {
                        if (mesh.type === 'Mesh') {
                            mesh.rotation.x += 0.01;
                            mesh.rotation.y += 0.01;
                        }
                    });
                    
                    // Orbit camera
                    const time = Date.now() * 0.001;
                    this.camera.position.x = Math.cos(time) * 5;
                    this.camera.position.z = Math.sin(time) * 5;
                    this.camera.lookAt(0, 0, 0);
                }
                
                this.renderer.render(this.scene, this.camera);
            },
            
            toggle3DRotation() {
                this.rotation3D = !this.rotation3D;
                const btn = document.getElementById('rotateBtn');
                const light = document.getElementById('rotLight');
                
                if (this.rotation3D) {
                    btn.textContent = 'Stop Rotation';
                    light.classList.add('active');
                } else {
                    btn.textContent = 'Start Rotation';
                    light.classList.remove('active');
                }
                
                this.updateStatus(`3D rotation ${this.rotation3D ? 'enabled' : 'disabled'}`);
            },
            
            changeView() {
                const views = [
                    { pos: [5, 5, 5], look: [0, 0, 0] },
                    { pos: [0, 8, 0], look: [0, 0, 0] },
                    { pos: [8, 0, 0], look: [0, 0, 0] },
                    { pos: [0, 0, 8], look: [0, 0, 0] },
                    { pos: [-5, 5, -5], look: [0, 0, 0] }
                ];
                
                const view = views[Math.floor(Math.random() * views.length)];
                this.camera.position.set(...view.pos);
                this.camera.lookAt(...view.look);
                
                this.updateStatus('Changed 3D view');
            },
            
            reset3D() {
                // Reset camera
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
                
                // Reset rotation
                this.rotation3D = true;
                document.getElementById('rotateBtn').textContent = 'Stop Rotation';
                document.getElementById('rotLight').classList.add('active');
                
                // Regenerate visualization
                this.update3D();
                
                this.updateStatus('3D visualization reset');
            },
            
            // Utilities
            handleResize() {
                // Update 2D canvas
                this.visualize2D();
                
                // Update 3D renderer
                const container = document.getElementById('container3D');
                if (this.camera && this.renderer) {
                    this.camera.aspect = container.offsetWidth / container.offsetHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(container.offsetWidth, container.offsetHeight);
                }
            },
            
            updateStatus(message) {
                const statusText = document.getElementById('statusText');
                statusText.textContent = message;
                console.log(`[UNNS] ${message}`);
                
                // Auto-fade status after 3 seconds
                setTimeout(() => {
                    if (statusText.textContent === message) {
                        statusText.textContent = 'System Ready';
                    }
                }, 3000);
            }
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            UNNSApp.init();
        });

        // Make app accessible globally for debugging
        window.UNNSApp = UNNSApp;
    </script>
</body>
</html>