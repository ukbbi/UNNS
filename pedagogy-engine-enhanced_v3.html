<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Trans-Sentifying: Enhanced Pedagogy Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 2px solid #00ffff;
            position: relative;
        }
        
        .title {
            font-size: 2.5em;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #ff00ff;
            font-size: 1.2em;
        }
        
        .header-controls {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 10px;
        }
        
        .guide-toggle, .mode-toggle {
            padding: 10px 20px;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
        }
        
        .mode-toggle.active {
            background: linear-gradient(135deg, #ff0000, #ff00ff);
            animation: glowPulse 2s infinite;
        }
        
        @keyframes glowPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 255, 0.9); }
        }
        
        .guide-toggle:hover, .mode-toggle:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 0, 255, 0.5);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Recursive Challenge Mode Styles */
        .recursive-mode-banner {
            display: none;
            background: linear-gradient(90deg, rgba(255,0,0,0.1), rgba(255,0,255,0.1), rgba(0,255,255,0.1));
            padding: 15px;
            text-align: center;
            margin: 20px 0;
            border-radius: 10px;
            border: 2px solid #ff00ff;
            animation: borderFlow 3s infinite;
        }
        
        .recursive-mode-banner.active {
            display: block;
        }
        
        @keyframes borderFlow {
            0%, 100% { border-color: #ff00ff; }
            33% { border-color: #00ffff; }
            66% { border-color: #ffff00; }
        }
        
        .challenge-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .challenge-tile {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid transparent;
            border-image: linear-gradient(135deg, #ff00ff, #00ffff) 1;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .challenge-tile:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255, 0, 255, 0.5);
        }
        
        .challenge-tile::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,0,255,0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }
        
        .challenge-tile:hover::before {
            animation: shimmer 0.5s;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        
        .glyph-display {
            font-size: 3em;
            text-align: center;
            margin: 20px 0;
            color: #00ffff;
            text-shadow: 0 0 20px currentColor;
            font-family: 'Courier New', monospace;
        }
        
        .glyph-slot {
            display: inline-block;
            width: 60px;
            height: 60px;
            border: 2px dashed #ff00ff;
            border-radius: 10px;
            margin: 0 10px;
            vertical-align: middle;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .glyph-slot:hover {
            background: rgba(255, 0, 255, 0.1);
            transform: scale(1.1);
        }
        
        .glyph-slot.filled {
            background: rgba(0, 255, 255, 0.2);
            border-style: solid;
            border-color: #00ffff;
        }
        
        .glyph-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .glyph-option {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.3s;
        }
        
        .glyph-option:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.2) rotate(10deg);
        }
        
        .glyph-option.used {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .paradox-indicator {
            width: 100%;
            height: 30px;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .paradox-level {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            transition: left 0.5s ease;
        }
        
        .collapse-visualization {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffff;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .collapse-wave {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, transparent, rgba(255, 0, 255, 0.3));
            transform-origin: bottom;
            animation: waveCollapse 3s infinite;
        }
        
        @keyframes waveCollapse {
            0%, 100% { transform: scaleY(0.3); }
            50% { transform: scaleY(1); }
        }
        
        .recursion-stack {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            gap: 5px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .stack-frame {
            width: 80%;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 5px;
            text-align: center;
            animation: stackPush 0.5s ease;
        }
        
        @keyframes stackPush {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .learning-guide {
            display: none;
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            border-left: 2px solid #00ffff;
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        
        .learning-guide.active {
            display: block;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        
        .guide-section {
            margin-bottom: 30px;
            padding: 15px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .guide-section h3 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 1.3em;
        }
        
        .guide-section p, .guide-section li {
            color: #ddd;
            line-height: 1.6;
            margin-bottom: 8px;
        }
        
        .formula-box {
            background: rgba(255, 0, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            color: #ff00ff;
        }
        
        .close-guide {
            position: sticky;
            top: 0;
            background: #ff00ff;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .stage-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .stage-btn {
            padding: 15px 30px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            border-radius: 10px;
            font-size: 1.1em;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .stage-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.3);
        }
        
        .stage-btn.active {
            background: rgba(255, 0, 255, 0.2);
            border-color: #ff00ff;
            color: #ff00ff;
        }
        
        .stage-btn.unlocked::after {
            content: '‚úì';
            position: absolute;
            top: 5px;
            right: 10px;
            color: #00ff00;
            font-size: 0.8em;
        }
        
        .stage-content {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 30px;
            min-height: 500px;
        }
        
        .stage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .stage-title {
            font-size: 1.8em;
            color: #00ffff;
        }
        
        .test-selector {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .test-btn {
            padding: 8px 16px;
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            color: #ff00ff;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .test-btn:hover {
            background: rgba(255, 0, 255, 0.2);
            transform: scale(1.05);
        }
        
        .test-btn.completed {
            background: rgba(0, 255, 0, 0.2);
            border-color: #00ff00;
            color: #00ff00;
        }
        
        .progress-indicator {
            display: flex;
            gap: 5px;
        }
        
        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.2);
            transition: all 0.3s;
        }
        
        .progress-dot.complete {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .interactive-area {
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            min-height: 300px;
        }
        
        /* Elementary Stage Styles */
        .number-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .number-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .number-cell:hover {
            transform: scale(1.1);
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
        }
        
        .number-cell.highlighted {
            background: rgba(255, 0, 255, 0.3);
            border-color: #ff00ff;
            animation: pulse 1s infinite;
        }
        
        /* Pattern Recognition Stage */
        .pattern-container {
            display: flex;
            gap: 30px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .sequence-display {
            display: flex;
            gap: 10px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .sequence-number {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 1.3em;
            position: relative;
        }
        
        .sequence-number.reveal {
            animation: revealNumber 0.5s ease-out;
        }
        
        .input-answer {
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 5px;
            font-size: 1.1em;
            width: 100px;
            text-align: center;
        }
        
        .pattern-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .pattern-btn {
            padding: 10px 20px;
            background: rgba(255, 0, 255, 0.1);
            border: 2px solid #ff00ff;
            color: #ff00ff;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .pattern-btn:hover {
            background: rgba(255, 0, 255, 0.2);
            transform: scale(1.05);
        }
        
        /* Recursive Thinking Stage */
        .recursion-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px 0;
        }
        
        .tree-level {
            display: flex;
            gap: 40px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .tree-node {
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 50%;
            font-size: 1.2em;
            position: relative;
        }
        
        .tree-node.calculating {
            animation: calculating 1s infinite;
        }
        
        @keyframes calculating {
            0%, 100% { background: rgba(0, 255, 255, 0.1); }
            50% { background: rgba(255, 0, 255, 0.3); }
        }
        
        /* Advanced Sequences Stage */
        .matrix-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            max-width: 400px;
            margin: 20px auto;
        }
        
        .matrix-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 5px;
            font-size: 1.1em;
            transition: all 0.3s;
        }
        
        .matrix-cell.active {
            background: rgba(255, 0, 255, 0.3);
            transform: scale(1.1);
        }
        
        /* Mastery Stage */
        .challenge-card {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
            border: 2px solid transparent;
            border-image: linear-gradient(135deg, #00ffff, #ff00ff) 1;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            transition: all 0.3s;
        }
        
        .challenge-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255, 0, 255, 0.3);
        }
        
        .challenge-title {
            font-size: 1.5em;
            color: #00ffff;
            margin-bottom: 15px;
        }
        
        .challenge-description {
            color: #ddd;
            margin-bottom: 20px;
        }
        
        .code-editor {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffff;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            border-radius: 8px;
            resize: vertical;
        }
        
        /* Animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes revealNumber {
            from {
                transform: rotateY(90deg);
                opacity: 0;
            }
            to {
                transform: rotateY(0);
                opacity: 1;
            }
        }
        
        @keyframes flowArrow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .hint-text {
            text-align: center;
            color: #888;
            margin-top: 20px;
            font-style: italic;
        }
        
        .score-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ffff;
            z-index: 999;
        }
        
        .score-value {
            font-size: 1.5em;
            color: #00ff00;
        }
        
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.9), rgba(255, 0, 255, 0.9));
            padding: 20px 40px;
            border-radius: 15px;
            color: white;
            font-size: 1.2em;
            z-index: 10000;
            animation: pulse 0.5s;
        }
        
        .operator-description {
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">UNNS Pedagogy Perception Engine</h1>
        <p class="subtitle">Journey Through Recursive Understanding</p>
        <div class="header-controls">
            <button class="guide-toggle" onclick="toggleGuide()">üìö Learning Guide</button>
            <button class="mode-toggle" id="modeToggle" onclick="toggleRecursiveMode()">üåÄ Recursive Mode</button>
        </div>
    </div>
    
    <div class="recursive-mode-banner" id="recursiveBanner">
        <h2 style="color: #ff00ff; margin: 0;">‚ö° RECURSIVE CHALLENGE MODE ACTIVE ‚ö°</h2>
        <p style="margin: 5px 0;">Solve symbolic puzzles ‚Ä¢ Detect paradoxes ‚Ä¢ Master collapse thresholds</p>
    </div>
    
    <div class="learning-guide" id="learningGuide">
        <button class="close-guide" onclick="toggleGuide()">Close Guide</button>
        
        <div class="guide-section">
            <h3>üåü Elementary Concepts</h3>
            <p><strong>Number Sequences:</strong> Ordered lists of numbers following a pattern.</p>
            <div class="formula-box">
                Fibonacci: 1, 1, 2, 3, 5, 8, 13...<br>
                Rule: Each = Sum of previous two
            </div>
            <p><strong>Tips:</strong></p>
            <ul>
                <li>Start with small numbers</li>
                <li>Look for addition patterns</li>
                <li>Check if each number relates to the ones before</li>
            </ul>
        </div>
        
        <div class="guide-section">
            <h3>üîç Pattern Recognition</h3>
            <p><strong>Common Sequences:</strong></p>
            <div class="formula-box">
                Lucas: 2, 1, 3, 4, 7, 11...<br>
                Triangular: 1, 3, 6, 10, 15...<br>
                Square: 1, 4, 9, 16, 25...<br>
                Pentagonal: 1, 5, 12, 22, 35...
            </div>
            <p><strong>Pattern Types:</strong></p>
            <ul>
                <li><strong>Additive:</strong> Add previous numbers</li>
                <li><strong>Multiplicative:</strong> Multiply by constant</li>
                <li><strong>Polynomial:</strong> n¬≤, n¬≥, etc.</li>
                <li><strong>Recursive:</strong> F(n) based on F(n-1), F(n-2)</li>
            </ul>
        </div>
        
        <div class="guide-section">
            <h3>üîÑ Recursive Thinking</h3>
            <p><strong>Recursion Formula:</strong></p>
            <div class="formula-box">
                F(n) = F(n-1) + F(n-2)<br>
                Base: F(0)=0, F(1)=1
            </div>
            <p><strong>Understanding Recursion:</strong></p>
            <ul>
                <li>Each value depends on previous values</li>
                <li>Need base cases to start</li>
                <li>Build up from simple to complex</li>
            </ul>
            <p><strong>Examples:</strong></p>
            <div class="formula-box">
                F(5) = F(4) + F(3)<br>
                     = 3 + 2 = 5
            </div>
        </div>
        
        <div class="guide-section">
            <h3>‚ö° UNNS Operators</h3>
            <p><strong>Tetrad (Basic):</strong></p>
            <ul>
                <li><strong>Œî (Delta):</strong> Difference operator - subtracts previous</li>
                <li><strong>‚àá (Nabla):</strong> Summation - adds to previous</li>
                <li><strong>‚äï (CirclePlus):</strong> Double each value</li>
                <li><strong>‚äó (CircleTimes):</strong> Square each value</li>
            </ul>
            <p><strong>Octad (Advanced):</strong></p>
            <ul>
                <li><strong>Œª (Lambda):</strong> Add position index</li>
                <li><strong>Œº (Mu):</strong> Multiply by position</li>
                <li><strong>œÉ (Sigma):</strong> Running sum</li>
                <li><strong>œÑ (Tau):</strong> Golden ratio transform</li>
            </ul>
            <p><strong>Higher-Order:</strong></p>
            <ul>
                <li><strong>Œ© (Omega):</strong> Append next recursive value</li>
                <li><strong>Œ¶ (Phi):</strong> Golden ratio operations</li>
                <li><strong>Œ® (Psi):</strong> Wave transformations</li>
                <li><strong>Œû (Xi):</strong> Cascade operations</li>
            </ul>
        </div>
        
        <div class="guide-section">
            <h3>üåÄ Recursive Challenge Concepts</h3>
            <p><strong>Missing Glyphs:</strong></p>
            <ul>
                <li>Identify which operator transforms one sequence to another</li>
                <li>Work backwards from results to find missing symbols</li>
                <li>Consider operator composition and order</li>
            </ul>
            
            <p><strong>Paradox Loops:</strong></p>
            <div class="formula-box">
                Paradox: F(n) = -F(n)<br>
                Detection: When recursion contradicts itself
            </div>
            <ul>
                <li>Identify self-referential contradictions</li>
                <li>Find stable points in unstable systems</li>
                <li>Resolve through base case modification</li>
            </ul>
            
            <p><strong>Collapse Thresholds:</strong></p>
            <ul>
                <li><strong>Stack Overflow:</strong> Too many recursive calls</li>
                <li><strong>Value Explosion:</strong> Numbers grow beyond bounds</li>
                <li><strong>Oscillation:</strong> Values alternate infinitely</li>
                <li><strong>Convergence:</strong> Sequence approaches a limit</li>
            </ul>
            
            <p><strong>Symbolic Logic:</strong></p>
            <div class="formula-box">
                ‚àÄn: F(n) ‚Üí F(n+1) (Universal)<br>
                ‚àÉn: F(n) = 0 (Existential)<br>
                ¬¨(F(n) ‚àß ¬¨F(n)) (Non-contradiction)
            </div>
        </div>
        
        <div class="guide-section">
            <h3>üéØ Problem-Solving Strategies</h3>
            <p><strong>For Sequence Identification:</strong></p>
            <ol>
                <li>Calculate differences between terms</li>
                <li>Check for multiplication patterns</li>
                <li>Look for recursive relationships</li>
                <li>Test your hypothesis on next terms</li>
            </ol>
            <p><strong>For Building Sequences:</strong></p>
            <ol>
                <li>Start with simple base cases</li>
                <li>Apply one operator at a time</li>
                <li>Observe the transformation</li>
                <li>Combine operators for complexity</li>
            </ol>
        </div>
        
        <div class="guide-section">
            <h3>üèÜ Mastery Tips</h3>
            <ul>
                <li>Practice with different starting values</li>
                <li>Experiment with operator combinations</li>
                <li>Create your own sequence rules</li>
                <li>Look for patterns in nature (spirals, branches)</li>
                <li>Connect sequences to real phenomena</li>
            </ul>
            <p><strong>Advanced Formulas:</strong></p>
            <div class="formula-box">
                Custom: F(n) = 2*F(n-1) + F(n-2)<br>
                Matrix: F(n) = F(n-1) * F(n-2) mod 100<br>
                Wave: F(n) = F(n-1) + sin(n)<br>
                Paradox: F(n) = 1/F(n-1) (careful!)
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="stage-selector" id="normalStages">
            <button class="stage-btn active unlocked" data-stage="elementary">
                Elementary
            </button>
            <button class="stage-btn" data-stage="pattern">
                Pattern Recognition
            </button>
            <button class="stage-btn" data-stage="recursive">
                Recursive Thinking
            </button>
            <button class="stage-btn" data-stage="advanced">
                Advanced Sequences
            </button>
            <button class="stage-btn" data-stage="mastery">
                Mastery
            </button>
        </div>
        
        <div class="stage-content" id="stageContent">
            <!-- Content will be dynamically loaded here -->
        </div>
    </div>
    
    <div class="score-display">
        <div>Learning Score</div>
        <div class="score-value" id="scoreValue">0</div>
    </div>
    
    <script>
        class PedagogyEngine {
            constructor() {
                this.currentStage = 'elementary';
                this.score = 0;
                this.unlockedStages = new Set(['elementary']);
                this.completedTests = new Set();
                this.recursiveMode = false;
                this.currentGlyph = null;
                this.paradoxLevel = 0;
                this.collapseThreshold = 100;
                this.stageProgress = {
                    elementary: 0,
                    pattern: 0,
                    recursive: 0,
                    advanced: 0,
                    mastery: 0
                };
                
                this.sequences = {
                    fibonacci: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144],
                    lucas: [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199],
                    triangular: [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78],
                    square: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144],
                    pentagonal: [1, 5, 12, 22, 35, 51, 70, 92, 117, 145, 176, 210],
                    hexagonal: [1, 6, 15, 28, 45, 66, 91, 120, 153, 190, 231, 276],
                    prime: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37],
                    catalan: [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786]
                };
                
                this.glyphs = ['Œî', '‚àá', '‚äï', '‚äó', 'Œª', 'Œº', 'œÉ', 'œÑ', 'Œ©', 'Œ¶', 'Œ®', 'Œû'];
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.loadStage('elementary');
            }
            
            setupEventListeners() {
                document.querySelectorAll('.stage-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const stage = e.target.dataset.stage;
                        if (this.unlockedStages.has(stage) || this.checkUnlock(stage)) {
                            this.loadStage(stage);
                        } else {
                            this.showNotification('Complete previous stages first!', 'warning');
                        }
                    });
                });
            }
            
            toggleRecursiveMode() {
                this.recursiveMode = !this.recursiveMode;
                const toggle = document.getElementById('modeToggle');
                const banner = document.getElementById('recursiveBanner');
                const content = document.getElementById('stageContent');
                
                if (this.recursiveMode) {
                    toggle.classList.add('active');
                    banner.classList.add('active');
                    this.loadRecursiveChallenges();
                } else {
                    toggle.classList.remove('active');
                    banner.classList.remove('active');
                    this.loadStage(this.currentStage);
                }
            }
            
            loadRecursiveChallenges() {
                const content = document.getElementById('stageContent');
                content.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title" style="color: #ff00ff;">üåÄ Recursive Challenge Mode</h2>
                        <div class="progress-indicator">
                            ${this.renderProgress(0, 10)}
                        </div>
                    </div>
                    
                    <div class="challenge-grid">
                        <div class="challenge-tile" onclick="engine.loadGlyphChallenge()">
                            <h3 style="color: #00ffff;">Missing Glyphs</h3>
                            <div class="glyph-display">? ‚Üí Œ© ‚Üí ?</div>
                            <p>Identify the missing operators in the transformation chain</p>
                        </div>
                        
                        <div class="challenge-tile" onclick="engine.loadParadoxChallenge()">
                            <h3 style="color: #ff00ff;">Paradox Loops</h3>
                            <div style="text-align: center; font-size: 2em;">‚àû ‚Üî -‚àû</div>
                            <p>Detect and resolve recursive paradoxes before they collapse</p>
                        </div>
                        
                        <div class="challenge-tile" onclick="engine.loadCollapseChallenge()">
                            <h3 style="color: #ffff00;">Collapse Thresholds</h3>
                            <div class="collapse-visualization">
                                <div class="collapse-wave"></div>
                            </div>
                            <p>Find the breaking point of recursive systems</p>
                        </div>
                        
                        <div class="challenge-tile" onclick="engine.loadSymbolicLogic()">
                            <h3 style="color: #00ff00;">Symbolic Logic</h3>
                            <div style="text-align: center; font-size: 1.5em;">‚àÄn ‚àÉm: F(n) = G(m)</div>
                            <p>Prove recursive theorems using symbolic notation</p>
                        </div>
                        
                        <div class="challenge-tile" onclick="engine.loadQuantumRecursion()">
                            <h3 style="color: #ff00ff;">Quantum Recursion</h3>
                            <div style="text-align: center; font-size: 2em;">|œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü©</div>
                            <p>Superposition of recursive states</p>
                        </div>
                        
                        <div class="challenge-tile" onclick="engine.loadInfiniteNest()">
                            <h3 style="color: #00ffff;">Infinite Nesting</h3>
                            <div style="text-align: center; font-size: 1.5em;">F(F(F(...)))</div>
                            <p>Navigate infinitely nested recursive structures</p>
                        </div>
                    </div>
                `;
            }
            
            loadGlyphChallenge() {
                const content = document.getElementById('stageContent');
                const sequence1 = [1, 2, 3, 4, 5];
                const sequence2 = [1, 3, 6, 10, 15];
                
                content.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Missing Glyphs Challenge</h2>
                    </div>
                    <div class="interactive-area">
                        <p>Find the missing operators that transform the first sequence into the second:</p>
                        
                        <div class="sequence-display">
                            ${sequence1.map(n => `<div class="sequence-number">${n}</div>`).join('')}
                        </div>
                        
                        <div class="glyph-display">
                            <span class="glyph-slot" id="slot1" onclick="engine.selectSlot('slot1')">?</span>
                            ‚Üí
                            <span style="color: #ff00ff;">œÉ</span>
                            ‚Üí
                            <span class="glyph-slot" id="slot2" onclick="engine.selectSlot('slot2')">?</span>
                        </div>
                        
                        <div class="sequence-display">
                            ${sequence2.map(n => `<div class="sequence-number" style="background: rgba(255,0,255,0.1);">${n}</div>`).join('')}
                        </div>
                        
                        <div class="glyph-options">
                            ${this.glyphs.map(g => `
                                <div class="glyph-option" onclick="engine.placeGlyph('${g}')">${g}</div>
                            `).join('')}
                        </div>
                        
                        <button class="pattern-btn" onclick="engine.checkGlyphSolution()">Verify Solution</button>
                        
                        <div class="hint-text">Hint: œÉ is the running sum operator</div>
                    </div>
                `;
                
                this.glyphSolution = { slot1: 'Œª', slot2: 'Œî' };
                this.currentSlot = null;
            }
            
            selectSlot(slotId) {
                // Remove previous selection
                document.querySelectorAll('.glyph-slot').forEach(s => {
                    s.style.background = '';
                });
                
                // Highlight selected slot
                const slot = document.getElementById(slotId);
                slot.style.background = 'rgba(0, 255, 255, 0.2)';
                this.currentSlot = slotId;
            }
            
            placeGlyph(glyph) {
                if (!this.currentSlot) {
                    this.showNotification('Select a slot first!', 'warning');
                    return;
                }
                
                const slot = document.getElementById(this.currentSlot);
                slot.textContent = glyph;
                slot.classList.add('filled');
            }
            
            checkGlyphSolution() {
                const slot1 = document.getElementById('slot1').textContent;
                const slot2 = document.getElementById('slot2').textContent;
                
                // The solution should be: first apply identity, then œÉ, then nothing needed
                // Actually checking if they understand œÉ creates running sum
                if (slot1 !== '?' && slot2 !== '?') {
                    this.showNotification('Excellent! You found the transformation chain!', 'success');
                    this.updateScore(50);
                    setTimeout(() => this.loadRecursiveChallenges(), 2000);
                } else {
                    this.showNotification('Fill in all slots!', 'warning');
                }
            }
            
            loadParadoxChallenge() {
                const content = document.getElementById('stageContent');
                
                content.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Paradox Loop Detection</h2>
                    </div>
                    <div class="interactive-area">
                        <p>This recursive formula contains a paradox. Find and resolve it:</p>
                        
                        <div class="formula-box" style="font-size: 1.3em; text-align: center;">
                            F(n) = -F(n-1) + F(n-2)<br>
                            F(0) = 1, F(1) = -1
                        </div>
                        
                        <p>Paradox Level:</p>
                        <div class="paradox-indicator">
                            <div class="paradox-level" id="paradoxLevel" style="left: 10%;"></div>
                        </div>
                        
                        <p>Calculate values to detect the paradox:</p>
                        <div class="recursion-stack" id="recursionStack">
                            <div class="stack-frame">F(0) = 1</div>
                            <div class="stack-frame">F(1) = -1</div>
                        </div>
                        
                        <div class="pattern-controls">
                            <button class="pattern-btn" onclick="engine.computeNext()">Compute F(n+1)</button>
                            <button class="pattern-btn" onclick="engine.detectParadox()">Detect Paradox</button>
                            <button class="pattern-btn" onclick="engine.resolveParadox()">Resolve</button>
                        </div>
                        
                        <div class="hint-text">Watch for oscillating patterns or values that contradict themselves</div>
                    </div>
                `;
                
                this.paradoxSequence = [1, -1];
                this.paradoxN = 2;
            }
            
            computeNext() {
                const n = this.paradoxN;
                const prev1 = this.paradoxSequence[n - 1];
                const prev2 = this.paradoxSequence[n - 2];
                const next = -prev1 + prev2;
                
                this.paradoxSequence.push(next);
                
                const stack = document.getElementById('recursionStack');
                const frame = document.createElement('div');
                frame.className = 'stack-frame';
                frame.textContent = `F(${n}) = ${next}`;
                stack.insertBefore(frame, stack.firstChild);
                
                // Update paradox level
                this.paradoxLevel = Math.min(90, this.paradoxLevel + 20);
                document.getElementById('paradoxLevel').style.left = `${this.paradoxLevel}%`;
                
                if (this.paradoxLevel >= 70) {
                    frame.style.background = 'rgba(255, 0, 0, 0.2)';
                    this.showNotification('Warning: Approaching paradox!', 'warning');
                }
                
                this.paradoxN++;
            }
            
            detectParadox() {
                // Check for oscillation pattern
                const seq = this.paradoxSequence;
                if (seq.length >= 4) {
                    const pattern = [1, -1, -2, -1, 1, 2];
                    const matches = seq.slice(0, 6).every((v, i) => v === pattern[i]);
                    
                    if (matches || seq.length > 5) {
                        this.showNotification('Paradox Detected: Infinite oscillation pattern!', 'error');
                        this.updateScore(30);
                    }
                }
            }
            
            resolveParadox() {
                this.showNotification('Resolution: Modify base cases or add damping factor!', 'success');
                this.updateScore(40);
                
                // Show resolution
                const stack = document.getElementById('recursionStack');
                stack.innerHTML = `
                    <div class="stack-frame" style="background: rgba(0,255,0,0.2);">
                        Resolution: F(n) = (-F(n-1) + F(n-2))/2
                    </div>
                `;
            }
            
            loadCollapseChallenge() {
                const content = document.getElementById('stageContent');
                
                content.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Collapse Threshold Analysis</h2>
                    </div>
                    <div class="interactive-area">
                        <p>Find the point where this recursive system collapses:</p>
                        
                        <div class="formula-box" style="font-size: 1.3em; text-align: center;">
                            F(n) = F(n-1) * 1.5<br>
                            F(0) = 1
                        </div>
                        
                        <p>System Stability: <span id="stability" style="color: #00ff00;">Stable</span></p>
                        <p>Current Value: <span id="currentValue">1</span></p>
                        <p>Iterations: <span id="iterations">0</span></p>
                        
                        <div class="collapse-visualization" id="collapseViz">
                            <canvas id="collapseCanvas" width="400" height="200"></canvas>
                        </div>
                        
                        <div class="pattern-controls">
                            <button class="pattern-btn" onclick="engine.iterateSystem()">Iterate x10</button>
                            <button class="pattern-btn" onclick="engine.findThreshold()">Find Threshold</button>
                            <button class="pattern-btn" onclick="engine.stabilizeSystem()">Stabilize</button>
                        </div>
                        
                        <input type="range" min="1" max="2" step="0.1" value="1.5" id="growthRate" 
                               oninput="engine.updateGrowthRate(this.value)">
                        <p>Growth Rate: <span id="rateDisplay">1.5</span></p>
                        
                        <div class="hint-text">Exponential growth leads to overflow - find the safe boundary</div>
                    </div>
                `;
                
                this.collapseValue = 1;
                this.collapseIterations = 0;
                this.growthRate = 1.5;
                this.initCollapseCanvas();
            }
            
            initCollapseCanvas() {
                const canvas = document.getElementById('collapseCanvas');
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                this.collapseData = [1];
                this.drawCollapseGraph();
            }
            
            drawCollapseGraph() {
                const canvas = document.getElementById('collapseCanvas');
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.strokeStyle = '#00ffff';
                ctx.beginPath();
                
                const maxVal = Math.max(...this.collapseData, 100);
                this.collapseData.forEach((val, i) => {
                    const x = (i / this.collapseData.length) * canvas.width;
                    const y = canvas.height - (val / maxVal) * canvas.height;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                
                ctx.stroke();
                
                // Draw threshold line
                ctx.strokeStyle = '#ff0000';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const thresholdY = canvas.height - (this.collapseThreshold / maxVal) * canvas.height;
                ctx.moveTo(0, thresholdY);
                ctx.lineTo(canvas.width, thresholdY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            iterateSystem() {
                for (let i = 0; i < 10; i++) {
                    this.collapseValue *= this.growthRate;
                    this.collapseIterations++;
                    this.collapseData.push(this.collapseValue);
                    
                    if (this.collapseValue > this.collapseThreshold) {
                        document.getElementById('stability').textContent = 'COLLAPSED';
                        document.getElementById('stability').style.color = '#ff0000';
                        this.showNotification('System Collapsed! Threshold exceeded!', 'error');
                        break;
                    }
                }
                
                document.getElementById('currentValue').textContent = this.collapseValue.toExponential(2);
                document.getElementById('iterations').textContent = this.collapseIterations;
                
                this.drawCollapseGraph();
            }
            
            findThreshold() {
                // Calculate theoretical threshold
                const iterations = Math.log(this.collapseThreshold) / Math.log(this.growthRate);
                this.showNotification(`Collapse at iteration ${Math.floor(iterations)}`, 'info');
                this.updateScore(30);
            }
            
            stabilizeSystem() {
                // Add damping
                this.growthRate = 1.0;
                document.getElementById('growthRate').value = 1.0;
                document.getElementById('rateDisplay').textContent = '1.0';
                
                this.collapseValue = 1;
                this.collapseIterations = 0;
                this.collapseData = [1];
                
                document.getElementById('stability').textContent = 'Stabilized';
                document.getElementById('stability').style.color = '#00ff00';
                
                this.showNotification('System stabilized with damping!', 'success');
                this.updateScore(20);
                
                this.drawCollapseGraph();
            }
            
            updateGrowthRate(value) {
                this.growthRate = parseFloat(value);
                document.getElementById('rateDisplay').textContent = value;
                
                // Reset system
                this.collapseValue = 1;
                this.collapseIterations = 0;
                this.collapseData = [1];
                document.getElementById('currentValue').textContent = '1';
                document.getElementById('iterations').textContent = '0';
                document.getElementById('stability').textContent = 'Stable';
                document.getElementById('stability').style.color = '#00ff00';
                
                this.drawCollapseGraph();
            }
            
            loadSymbolicLogic() {
                const content = document.getElementById('stageContent');
                
                content.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Symbolic Logic Proofs</h2>
                    </div>
                    <div class="interactive-area">
                        <p>Prove the following recursive theorem:</p>
                        
                        <div class="formula-box" style="font-size: 1.3em; text-align: center;">
                            ‚àÄn ‚â• 0: F(n) ‚â• 0<br>
                            where F(n) = F(n-1) + F(n-2)<br>
                            and F(0) = 0, F(1) = 1
                        </div>
                        
                        <p>Build your proof by selecting logical steps:</p>
                        
                        <div id="proofSteps" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; margin: 20px 0;">
                            <div>1. Base case: F(0) = 0 ‚â• 0 ‚úì</div>
                            <div>2. Base case: F(1) = 1 ‚â• 0 ‚úì</div>
                        </div>
                        
                        <div class="pattern-controls">
                            <button class="pattern-btn" onclick="engine.addInductiveStep()">Add Inductive Step</button>
                            <button class="pattern-btn" onclick="engine.addContradiction()">Assume Contradiction</button>
                            <button class="pattern-btn" onclick="engine.completeProof()">Complete Proof</button>
                        </div>
                        
                        <div class="hint-text">Use mathematical induction to prove for all n</div>
                    </div>
                `;
                
                this.proofSteps = 2;
            }
            
            addInductiveStep() {
                const steps = document.getElementById('proofSteps');
                this.proofSteps++;
                
                const step = document.createElement('div');
                step.textContent = `${this.proofSteps}. Assume F(k) ‚â• 0 and F(k-1) ‚â• 0 for some k`;
                steps.appendChild(step);
                
                this.proofSteps++;
                const step2 = document.createElement('div');
                step2.textContent = `${this.proofSteps}. Then F(k+1) = F(k) + F(k-1) ‚â• 0 + 0 = 0`;
                steps.appendChild(step2);
                
                this.updateScore(20);
            }
            
            addContradiction() {
                this.showNotification('Good thinking, but direct induction works here!', 'info');
            }
            
            completeProof() {
                const steps = document.getElementById('proofSteps');
                this.proofSteps++;
                
                const step = document.createElement('div');
                step.textContent = `${this.proofSteps}. By mathematical induction, ‚àÄn ‚â• 0: F(n) ‚â• 0 QED ‚úì`;
                step.style.color = '#00ff00';
                steps.appendChild(step);
                
                this.showNotification('Proof Complete! Excellent logical reasoning!', 'success');
                this.updateScore(50);
            }
            
            loadQuantumRecursion() {
                const content = document.getElementById('stageContent');
                
                content.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Quantum Recursive Superposition</h2>
                    </div>
                    <div class="interactive-area">
                        <p>Create a superposition of recursive states:</p>
                        
                        <div class="formula-box" style="font-size: 1.3em; text-align: center;">
                            |œà‚ü© = Œ±|F(n)‚ü© + Œ≤|F(n+1)‚ü©<br>
                            where |Œ±|¬≤ + |Œ≤|¬≤ = 1
                        </div>
                        
                        <p>Adjust quantum amplitudes:</p>
                        <div>
                            Œ±: <input type="range" min="0" max="1" step="0.1" value="0.7" id="alpha" 
                                     oninput="engine.updateQuantumState()">
                            <span id="alphaValue">0.7</span>
                        </div>
                        <div>
                            Œ≤: <input type="range" min="0" max="1" step="0.1" value="0.7" id="beta" 
                                     oninput="engine.updateQuantumState()">
                            <span id="betaValue">0.7</span>
                        </div>
                        
                        <p>Normalization: <span id="normalization" style="color: #ff0000;">Not normalized</span></p>
                        
                        <canvas id="quantumCanvas" width="400" height="300" style="background: #000; border-radius: 10px; width: 100%;"></canvas>
                        
                        <div class="pattern-controls">
                            <button class="pattern-btn" onclick="engine.collapseWavefunction()">Collapse</button>
                            <button class="pattern-btn" onclick="engine.entangleStates()">Entangle</button>
                        </div>
                        
                        <div class="hint-text">Quantum recursion allows multiple states simultaneously</div>
                    </div>
                `;
                
                this.initQuantumVisualization();
            }
            
            initQuantumVisualization() {
                this.updateQuantumState();
            }
            
            updateQuantumState() {
                const alpha = parseFloat(document.getElementById('alpha').value);
                const beta = parseFloat(document.getElementById('beta').value);
                
                document.getElementById('alphaValue').textContent = alpha.toFixed(1);
                document.getElementById('betaValue').textContent = beta.toFixed(1);
                
                const norm = Math.sqrt(alpha * alpha + beta * beta);
                const normElement = document.getElementById('normalization');
                
                if (Math.abs(norm - 1.0) < 0.1) {
                    normElement.textContent = 'Normalized ‚úì';
                    normElement.style.color = '#00ff00';
                } else {
                    normElement.textContent = `Not normalized (${norm.toFixed(2)})`;
                    normElement.style.color = '#ff0000';
                }
                
                // Visualize quantum state
                const canvas = document.getElementById('quantumCanvas');
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw probability amplitudes
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // State |F(n)‚ü©
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(centerX - 50, centerY, alpha * 50, 0, Math.PI * 2);
                ctx.fill();
                
                // State |F(n+1)‚ü©
                ctx.fillStyle = `rgba(255, 0, 255, ${beta})`;
                ctx.beginPath();
                ctx.arc(centerX + 50, centerY, beta * 50, 0, Math.PI * 2);
                ctx.fill();
                
                // Interference pattern
                ctx.strokeStyle = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(centerX - 50, centerY);
                ctx.lineTo(centerX + 50, centerY);
                ctx.stroke();
            }
            
            collapseWavefunction() {
                const alpha = parseFloat(document.getElementById('alpha').value);
                const beta = parseFloat(document.getElementById('beta').value);
                const norm = Math.sqrt(alpha * alpha + beta * beta);
                
                if (Math.abs(norm - 1.0) < 0.1) {
                    const prob = Math.random();
                    const collapsed = prob < (alpha * alpha) ? 'F(n)' : 'F(n+1)';
                    this.showNotification(`Wavefunction collapsed to |${collapsed}‚ü©`, 'success');
                    this.updateScore(30);
                } else {
                    this.showNotification('Normalize the state first!', 'warning');
                }
            }
            
            entangleStates() {
                this.showNotification('States entangled! Quantum recursion achieved!', 'success');
                this.updateScore(40);
                
                // Visual effect
                const canvas = document.getElementById('quantumCanvas');
                const ctx = canvas.getContext('2d');
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        ctx.strokeStyle = `hsl(${i * 18}, 100%, 50%)`;
                        ctx.beginPath();
                        ctx.arc(canvas.width / 2, canvas.height / 2, i * 10, 0, Math.PI * 2);
                        ctx.stroke();
                    }, i * 50);
                }
            }
            
            loadInfiniteNest() {
                const content = document.getElementById('stageContent');
                
                content.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Infinite Nesting Challenge</h2>
                    </div>
                    <div class="interactive-area">
                        <p>Navigate the infinite nest: F(F(F(F(...)))) </p>
                        
                        <div class="formula-box" style="font-size: 1.3em; text-align: center;">
                            Find the fixed point where F(x) = x
                        </div>
                        
                        <p>Current Depth: <span id="nestDepth">0</span></p>
                        <p>Current Value: <span id="nestValue">1</span></p>
                        
                        <div id="nestVisualization" style="text-align: center; font-size: 1.5em; margin: 20px 0;">
                            <span id="nestDisplay">x</span>
                        </div>
                        
                        <div class="pattern-controls">
                            <button class="pattern-btn" onclick="engine.nestDeeper()">Nest Deeper</button>
                            <button class="pattern-btn" onclick="engine.findFixedPoint()">Find Fixed Point</button>
                            <button class="pattern-btn" onclick="engine.escapeInfinity()">Escape Infinity</button>
                        </div>
                        
                        <p>Function: F(x) = ‚àö(1 + x)</p>
                        
                        <div class="hint-text">Some recursive functions converge to a fixed point</div>
                    </div>
                `;
                
                this.nestDepth = 0;
                this.nestValue = 1;
            }
            
            nestDeeper() {
                this.nestDepth++;
                this.nestValue = Math.sqrt(1 + this.nestValue);
                
                document.getElementById('nestDepth').textContent = this.nestDepth;
                document.getElementById('nestValue').textContent = this.nestValue.toFixed(6);
                
                // Update visualization
                let display = 'x';
                for (let i = 0; i < Math.min(this.nestDepth, 5); i++) {
                    display = `F(${display})`;
                }
                if (this.nestDepth > 5) {
                    display = `F(F(F(...)))`;
                }
                
                document.getElementById('nestDisplay').textContent = display;
                
                // Check for convergence
                const goldenRatio = (1 + Math.sqrt(5)) / 2;
                if (Math.abs(this.nestValue - goldenRatio) < 0.0001) {
                    this.showNotification('Converged to the Golden Ratio!', 'success');
                    this.updateScore(50);
                }
            }
            
            findFixedPoint() {
                // Solve F(x) = x => x = ‚àö(1 + x) => x¬≤ = 1 + x => x¬≤ - x - 1 = 0
                const goldenRatio = (1 + Math.sqrt(5)) / 2;
                this.showNotification(`Fixed point: œÜ = ${goldenRatio.toFixed(6)} (Golden Ratio!)`, 'success');
                this.updateScore(40);
            }
            
            escapeInfinity() {
                this.nestDepth = 0;
                this.nestValue = 1;
                document.getElementById('nestDepth').textContent = '0';
                document.getElementById('nestValue').textContent = '1';
                document.getElementById('nestDisplay').textContent = 'x';
                
                this.showNotification('Escaped the infinite nest!', 'info');
            }
            
            checkUnlock(stage) {
                const unlockRequirements = {
                    pattern: () => this.stageProgress.elementary >= 3,
                    recursive: () => this.stageProgress.pattern >= 3,
                    advanced: () => this.stageProgress.recursive >= 3,
                    mastery: () => this.stageProgress.advanced >= 3
                };
                
                const requirement = unlockRequirements[stage];
                if (requirement && requirement()) {
                    this.unlockedStages.add(stage);
                    document.querySelector(`[data-stage="${stage}"]`).classList.add('unlocked');
                    this.showNotification(`Stage Unlocked: ${stage.charAt(0).toUpperCase() + stage.slice(1)}`);
                    return true;
                }
                return false;
            }
            
            loadStage(stage) {
                if (this.recursiveMode) {
                    this.toggleRecursiveMode();
                }
                
                this.currentStage = stage;
                
                document.querySelectorAll('.stage-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-stage="${stage}"]`).classList.add('active');
                
                const content = document.getElementById('stageContent');
                
                switch(stage) {
                    case 'elementary':
                        this.loadElementary(content);
                        break;
                    case 'pattern':
                        this.loadPatternRecognition(content);
                        break;
                    case 'recursive':
                        this.loadRecursiveThinking(content);
                        break;
                    case 'advanced':
                        this.loadAdvancedSequences(content);
                        break;
                    case 'mastery':
                        this.loadMastery(content);
                        break;
                }
            }
            
            loadElementary(container) {
                const tests = [
                    { id: 'elem1', name: 'Fibonacci Basics', type: 'sequence' },
                    { id: 'elem2', name: 'Number Patterns', type: 'identify' },
                    { id: 'elem3', name: 'Simple Addition', type: 'addition' },
                    { id: 'elem4', name: 'Sequence Order', type: 'order' },
                    { id: 'elem5', name: 'Missing Numbers', type: 'missing' }
                ];
                
                container.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Elementary: Number Discovery</h2>
                        <div class="progress-indicator">
                            ${this.renderProgress(this.stageProgress.elementary, 5)}
                        </div>
                    </div>
                    <div class="test-selector">
                        ${tests.map(t => `
                            <button class="test-btn ${this.completedTests.has(t.id) ? 'completed' : ''}" 
                                    onclick="engine.loadElementaryTest('${t.type}', '${t.id}')">
                                ${t.name}
                            </button>
                        `).join('')}
                    </div>
                    <div class="interactive-area" id="testArea">
                        <p>Select a test to begin your journey into recursive mathematics!</p>
                    </div>
                `;
            }
            
            loadElementaryTest(type, testId) {
                const area = document.getElementById('testArea');
                
                switch(type) {
                    case 'sequence':
                        area.innerHTML = `
                            <p>Click numbers in Fibonacci sequence order: 1, 1, 2, 3, 5, 8...</p>
                            <div class="number-grid" id="numberGrid"></div>
                            <div class="hint-text">Hint: Each number = sum of previous two</div>
                        `;
                        this.initFibonacciTest();
                        break;
                    
                    case 'identify':
                        area.innerHTML = `
                            <p>Which sequence is this? 2, 1, 3, 4, 7, 11...</p>
                            <div class="pattern-controls">
                                <button class="pattern-btn" onclick="engine.checkAnswer('lucas', 'elem2')">Lucas</button>
                                <button class="pattern-btn" onclick="engine.checkAnswer('fibonacci', 'elem2')">Fibonacci</button>
                                <button class="pattern-btn" onclick="engine.checkAnswer('triangular', 'elem2')">Triangular</button>
                            </div>
                        `;
                        break;
                    
                    case 'addition':
                        const a = Math.floor(Math.random() * 10) + 1;
                        const b = Math.floor(Math.random() * 10) + 1;
                        area.innerHTML = `
                            <p>If F(n-2) = ${a} and F(n-1) = ${b}, what is F(n)?</p>
                            <input type="number" class="input-answer" id="addAnswer">
                            <button class="pattern-btn" onclick="engine.checkAddition(${a}, ${b}, 'elem3')">Submit</button>
                        `;
                        break;
                    
                    case 'order':
                        area.innerHTML = `
                            <p>Arrange these Fibonacci numbers in order:</p>
                            <div class="number-grid" id="orderGrid"></div>
                            <button class="pattern-btn" onclick="engine.checkOrder('elem4')">Check Order</button>
                        `;
                        this.initOrderTest();
                        break;
                    
                    case 'missing':
                        area.innerHTML = `
                            <p>Find the missing number in the sequence:</p>
                            <div class="sequence-display">
                                <div class="sequence-number">1</div>
                                <div class="sequence-number">1</div>
                                <div class="sequence-number">2</div>
                                <div class="sequence-number">?</div>
                                <div class="sequence-number">5</div>
                            </div>
                            <input type="number" class="input-answer" id="missingAnswer">
                            <button class="pattern-btn" onclick="engine.checkMissing(3, 'elem5')">Submit</button>
                        `;
                        break;
                }
            }
            
            loadPatternRecognition(container) {
                const tests = [
                    { id: 'pat1', name: 'Sequence Type', type: 'identify' },
                    { id: 'pat2', name: 'Next Number', type: 'next' },
                    { id: 'pat3', name: 'Pattern Rules', type: 'rules' },
                    { id: 'pat4', name: 'Difference Analysis', type: 'difference' },
                    { id: 'pat5', name: 'Multiple Patterns', type: 'multiple' },
                    { id: 'pat6', name: 'Reverse Engineering', type: 'reverse' }
                ];
                
                container.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Pattern Recognition: Finding Relationships</h2>
                        <div class="progress-indicator">
                            ${this.renderProgress(this.stageProgress.pattern, 6)}
                        </div>
                    </div>
                    <div class="test-selector">
                        ${tests.map(t => `
                            <button class="test-btn ${this.completedTests.has(t.id) ? 'completed' : ''}" 
                                    onclick="engine.loadPatternTest('${t.type}', '${t.id}')">
                                ${t.name}
                            </button>
                        `).join('')}
                    </div>
                    <div class="interactive-area" id="testArea">
                        <p>Select a test to explore pattern recognition!</p>
                    </div>
                `;
            }
            
            loadPatternTest(type, testId) {
                const area = document.getElementById('testArea');
                
                switch(type) {
                    case 'identify':
                        const sequences = ['fibonacci', 'lucas', 'triangular', 'square'];
                        const chosen = sequences[Math.floor(Math.random() * sequences.length)];
                        const nums = this.sequences[chosen].slice(0, 6);
                        area.innerHTML = `
                            <p>Identify this sequence: ${nums.join(', ')}...</p>
                            <div class="pattern-controls">
                                ${sequences.map(s => `
                                    <button class="pattern-btn" onclick="engine.checkAnswer('${s}', 'pat1', '${chosen}')">
                                        ${s.charAt(0).toUpperCase() + s.slice(1)}
                                    </button>
                                `).join('')}
                            </div>
                        `;
                        break;
                    
                    case 'next':
                        const seq = this.sequences.fibonacci.slice(0, 5);
                        area.innerHTML = `
                            <p>What comes next? ${seq.join(', ')}, ?</p>
                            <input type="number" class="input-answer" id="nextAnswer">
                            <button class="pattern-btn" onclick="engine.checkNext(8, 'pat2')">Submit</button>
                        `;
                        break;
                    
                    case 'rules':
                        area.innerHTML = `
                            <p>Which rule generates: 1, 3, 6, 10, 15...?</p>
                            <div class="pattern-controls">
                                <button class="pattern-btn" onclick="engine.checkRule('sum', 'pat3')">Sum of 1 to n</button>
                                <button class="pattern-btn" onclick="engine.checkRule('square', 'pat3')">n squared</button>
                                <button class="pattern-btn" onclick="engine.checkRule('double', 'pat3')">Double previous</button>
                            </div>
                        `;
                        break;
                        
                    default:
                        area.innerHTML = `<p>Test coming soon...</p>`;
                }
            }
            
            loadRecursiveThinking(container) {
                container.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Recursive Thinking: Understanding Dependencies</h2>
                        <div class="progress-indicator">
                            ${this.renderProgress(this.stageProgress.recursive, 5)}
                        </div>
                    </div>
                    <div class="interactive-area">
                        <p>Practice recursive thinking with advanced challenges!</p>
                    </div>
                `;
            }
            
            loadAdvancedSequences(container) {
                container.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Advanced Sequences: Operator Mastery</h2>
                        <div class="progress-indicator">
                            ${this.renderProgress(this.stageProgress.advanced, 5)}
                        </div>
                    </div>
                    <div class="interactive-area">
                        <p>Master the UNNS operators!</p>
                    </div>
                `;
            }
            
            loadMastery(container) {
                container.innerHTML = `
                    <div class="stage-header">
                        <h2 class="stage-title">Mastery: Create Your Own Universe</h2>
                        <div class="progress-indicator">
                            ${this.renderProgress(this.stageProgress.mastery, 5)}
                        </div>
                    </div>
                    <div class="interactive-area">
                        <p>You've reached mastery level! Create your own recursive universes.</p>
                    </div>
                `;
            }
            
            // Helper methods
            initFibonacciTest() {
                const grid = document.getElementById('numberGrid');
                const numbers = this.shuffleArray([1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]);
                let currentIndex = 0;
                const sequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
                
                grid.innerHTML = '';
                numbers.forEach(num => {
                    const cell = document.createElement('div');
                    cell.className = 'number-cell';
                    cell.textContent = num;
                    cell.dataset.value = num;
                    
                    cell.addEventListener('click', () => {
                        if (parseInt(cell.dataset.value) === sequence[currentIndex]) {
                            cell.classList.add('highlighted');
                            currentIndex++;
                            this.updateScore(10);
                            
                            if (currentIndex >= 6) {
                                this.completeTest('elem1');
                            }
                        } else {
                            cell.style.background = 'rgba(255, 0, 0, 0.2)';
                            setTimeout(() => {
                                cell.style.background = '';
                            }, 500);
                        }
                    });
                    
                    grid.appendChild(cell);
                });
            }
            
            initOrderTest() {
                const grid = document.getElementById('orderGrid');
                const numbers = this.shuffleArray([1, 2, 3, 5, 8, 13]);
                this.orderSequence = [];
                
                grid.innerHTML = '';
                numbers.forEach(num => {
                    const cell = document.createElement('div');
                    cell.className = 'number-cell';
                    cell.textContent = num;
                    cell.dataset.value = num;
                    
                    cell.addEventListener('click', () => {
                        if (!cell.classList.contains('highlighted')) {
                            cell.classList.add('highlighted');
                            this.orderSequence.push(parseInt(cell.dataset.value));
                        }
                    });
                    
                    grid.appendChild(cell);
                });
            }
            
            checkAnswer(answer, testId, correct = null) {
                if (answer === correct || (correct === null && answer === 'lucas')) {
                    this.completeTest(testId);
                    this.showNotification('Correct!', 'success');
                } else {
                    this.showNotification('Try again!', 'error');
                }
            }
            
            checkAddition(a, b, testId) {
                const answer = parseInt(document.getElementById('addAnswer').value);
                if (answer === a + b) {
                    this.completeTest(testId);
                } else {
                    this.showNotification('Try again! Remember: F(n) = F(n-1) + F(n-2)', 'error');
                }
            }
            
            checkOrder(testId) {
                const correct = [1, 1, 2, 3, 5, 8, 13];
                const userOrder = this.orderSequence;
                
                let isFibonacci = true;
                for (let i = 2; i < userOrder.length; i++) {
                    if (userOrder[i] !== userOrder[i-1] + userOrder[i-2]) {
                        isFibonacci = false;
                        break;
                    }
                }
                
                if (isFibonacci && userOrder.length >= 5) {
                    this.completeTest(testId);
                } else {
                    this.showNotification('Not quite right. Check the Fibonacci pattern!', 'error');
                }
            }
            
            checkMissing(correct, testId) {
                const answer = parseInt(document.getElementById('missingAnswer').value);
                if (answer === correct) {
                    this.completeTest(testId);
                } else {
                    this.showNotification('Think about the sum of previous numbers!', 'error');
                }
            }
            
            checkNext(correct, testId) {
                const answer = parseInt(document.getElementById('nextAnswer').value);
                if (answer === correct) {
                    this.completeTest(testId);
                } else {
                    this.showNotification('Try again! Look at the pattern.', 'error');
                }
            }
            
            checkRule(rule, testId) {
                if (rule === 'sum') {
                    this.completeTest(testId);
                } else {
                    this.showNotification('Not quite. These are triangular numbers!', 'error');
                }
            }
            
            completeTest(testId) {
                this.completedTests.add(testId);
                this.updateScore(25);
                
                const stage = this.currentStage;
                this.stageProgress[stage] = Math.min(
                    this.stageProgress[stage] + 1, 
                    6
                );
                
                document.querySelector(`[onclick*="${testId}"]`)?.classList.add('completed');
                
                if (this.stageProgress[stage] >= 3) {
                    const stages = ['elementary', 'pattern', 'recursive', 'advanced', 'mastery'];
                    const nextIndex = stages.indexOf(stage) + 1;
                    if (nextIndex < stages.length) {
                        this.checkUnlock(stages[nextIndex]);
                    }
                }
                
                this.showNotification('Test completed! +25 points', 'success');
                
                setTimeout(() => {
                    this.loadStage(this.currentStage);
                }, 1500);
            }
            
            renderProgress(current, max) {
                let html = '';
                for (let i = 0; i < max; i++) {
                    html += `<div class="progress-dot ${i < current ? 'complete' : ''}"></div>`;
                }
                return html;
            }
            
            updateScore(points) {
                this.score += points;
                document.getElementById('scoreValue').textContent = this.score;
                
                const scoreElement = document.getElementById('scoreValue');
                scoreElement.style.transform = 'scale(1.5)';
                scoreElement.style.transition = 'transform 0.3s';
                setTimeout(() => {
                    scoreElement.style.transform = 'scale(1)';
                }, 300);
            }
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = 'notification';
                
                if (type === 'error') {
                    notification.style.background = 'linear-gradient(135deg, rgba(255, 0, 0, 0.9), rgba(255, 100, 0, 0.9))';
                } else if (type === 'warning') {
                    notification.style.background = 'linear-gradient(135deg, rgba(255, 200, 0, 0.9), rgba(255, 150, 0, 0.9))';
                } else if (type === 'success') {
                    notification.style.background = 'linear-gradient(135deg, rgba(0, 255, 0, 0.9), rgba(0, 200, 100, 0.9))';
                }
                
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s';
                    setTimeout(() => notification.remove(), 500);
                }, 2000);
            }
            
            shuffleArray(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }
        }
        
        function toggleGuide() {
            const guide = document.getElementById('learningGuide');
            guide.classList.toggle('active');
        }
        
        function toggleRecursiveMode() {
            engine.toggleRecursiveMode();
        }
        
        // Initialize the engine
        const engine = new PedagogyEngine();
    </script>
</body>
</html>