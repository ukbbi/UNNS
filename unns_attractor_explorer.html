

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Attractor Explorer - Multiple Frameworks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #2a2f4a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .header-container {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: rgba(20, 25, 45, 0.95);
            border-radius: 20px;
            border: 2px solid #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        h1 {
            font-size: 2.8em;
            background: linear-gradient(90deg, #ffd700, #00ffaa, #4a9eff, #ff4a9e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }

        .subtitle {
            color: #ffd700;
            font-size: 1.4em;
            margin-bottom: 20px;
        }

        .golden-proof {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(0, 255, 170, 0.1));
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border: 1px solid #ffd700;
        }

        .math-formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
            color: #00ffaa;
            text-align: center;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
        }

        section {
            background: rgba(20, 25, 45, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid #3a4f8e;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        h2 {
            color: #00ffaa;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        h3 {
            color: #4a9eff;
            margin: 15px 0 10px 0;
            font-size: 1.3em;
        }

        .fibonacci-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 10px;
            animation: pulse-gold 2s infinite;
        }

        @keyframes pulse-gold {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        label {
            display: block;
            color: #8a9fce;
            margin-bottom: 8px;
        }

        textarea {
            width: 100%;
            height: 100px;
            background: rgba(10, 15, 30, 0.9);
            border: 2px solid #3a4f8e;
            color: #e0e0e0;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        button {
            background: linear-gradient(45deg, #ffd700, #00ffaa);
            color: #0a0e27;
            border: none;
            padding: 12px 24px;
            margin: 10px 5px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }

        canvas {
            border: 2px solid #3a4f8e;
            border-radius: 10px;
            background: rgba(10, 15, 30, 0.9);
            margin: 10px 0;
            display: block;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .result-item {
            background: rgba(74, 158, 255, 0.1);
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #ffd700;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .viz-container {
            background: rgba(10, 15, 30, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #3a4f8e;
        }

        .wiki-container {
            margin-top: 20px;
            border: 2px solid #ffd700;
            border-radius: 10px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.95);
        }

        .wiki-header {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            padding: 10px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        iframe {
            width: 100%;
            height: 400px;
            border: none;
        }

        .golden-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .loading {
            color: #4a9eff;
            font-style: italic;
        }

        .error {
            color: #ff4a9e;
            background: rgba(255, 74, 158, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body> <!-- Help & About Panel -->
<div id="helpPanel" style="background:#1e1e2f;color:#fff;padding:15px;border-radius:10px;margin:15px 0;box-shadow:0 2px 6px rgba(0,0,0,0.4);font-size:16px;">
  <button onclick="toggleHelp()" style="background:#4cafef;border:none;padding:8px 15px;color:#fff;border-radius:6px;cursor:pointer;margin-bottom:10px;">
    üìñ Help & About
  </button>
  <div id="helpContent" style="display:none;line-height:1.6;">
    <h2 style="margin-top:0;">How to Use This Explorer</h2>
    <ol>
      <li><b>Generate a Sequence</b>: Use the buttons (Fibonacci, Lucas, Tribonacci, etc.). Numbers will appear in the input box.</li>
      <li><b>Analyze It</b>: Click <i>Analyze UNNS Attractor</i> to see stats, modular cycles, convergence, and plots update.</li>
      <li><b>Explore Strange Attractors</b>: Select Lorenz, R√∂ssler, or Fibonacci Attractor and click <i>Analyze Attractor</i>.</li>
      <li><b>View Visualizations</b>: Canvases will display growth, golden ratio convergence, modular periodicities, and embeddings.</li>
      <li><b>Learn Alongside</b>: Use the dropdown to read about Fibonacci, Golden Ratio, Strange Attractors, etc.</li>
    </ol>

    <h2>üåå What is Its Significance?</h2>
    <ul>
      <li><b>Proof-of-Concept for UNNS</b>: Demonstrates how Fibonacci, Lucas, and chaotic attractors live within the UNNS framework.</li>
      <li><b>Bridging Order and Chaos</b>: Shows recurrence sequences (predictable) and strange attractors (chaotic) as two sides of the same recursive substrate.</li>
      <li><b>Educational Value</b>: Lets users ‚Äúsee‚Äù convergence to œÜ, modular cycles, and attractor dynamics.</li>
      <li><b>Philosophical Depth</b>: Suggests UNNS as a universal substrate where math, geometry, chaos, and cognition interconnect.</li>
    </ul>
  </div>
</div>

<script>
  function toggleHelp(){
    const content = document.getElementById("helpContent");
    content.style.display = (content.style.display === "none" ? "block" : "none");
  }
</script>

    <div class="header-container">
        <h1>üåü UNNS Attractor Explorer üåü</h1>
        <div class="subtitle">Classical & Custom Sequences in the UNNS System</div>
        
        <div class="golden-proof">
            <h3>üîç Mathematical Proof of Fibonacci Integration</h3>
            <div class="math-formula">œÜ = lim(n‚Üí‚àû) F(n+1)/F(n) = 1.618034...</div>
            <div class="math-formula">Golden Ratio Foundation: Every œÜ usage invokes Fibonacci</div>
            <div class="math-formula">Prime Spiral: angle = prime √ó œÜ</div>
            <div class="math-formula">Market Patterns: Natural Fibonacci Retracements (23.6%, 38.2%, 61.8%)</div>
        </div>
    </div>

    <section>
        <h2>üìä Fibonacci Sequence Generator <span class="fibonacci-badge">œÜ = 1.618</span></h2>
        <label for="sequenceInput">Enter custom sequence or generate Fibonacci(Lucas, Tribunacci, Golden Spiral)-based patterns:</label>
        <textarea id="sequenceInput" placeholder="Example: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144..."></textarea>
        <div>
            <button onclick="generateFibonacci()">üåü Fibonacci</button>
            <button onclick="generateLucas()">‚ú® Lucas</button>
            <button onclick="generateTribonacci()">üî∫ Tribonacci</button>
            <button onclick="generateGoldenSpiral()">üåÄ Golden Spiral</button>
            <button onclick="analyzeSequence()">üîç Analyze UNNS Attractor</button>
        </div>
    </section>

    <section>
        <h2>üìà UNNS Attractor Analysis</h2>
        <div id="sequenceResult" class="result-item"></div>
        <div id="phaseResult" class="result-item"></div>
        <div id="lyapunovResult" class="result-item"></div>
        <div id="ratioResult" class="result-item"></div>
        <div id="fibonacciResult" class="result-item"></div>
        <div id="modularResult" class="result-item"></div>
        <div id="coeffResult" class="result-item"></div>
        <div id="threeBodyResult" class="result-item"></div>
    </section>

    <section>
        <h2>üé® UNNS Attractor Visualizations</h2>
        <div class="visualization-grid">
            <div class="viz-container">
                <h3>Fibonacci Growth Pattern</h3>
                <canvas id="sequencePlot" width="400" height="200"></canvas>
            </div>
            <div class="viz-container">
                <h3>Phase Space Attractor</h3>
                <canvas id="phasePlot" width="400" height="200"></canvas>
            </div>
            <div class="viz-container">
                <h3>Lyapunov Stability</h3>
                <canvas id="lyapunovPlot" width="400" height="200"></canvas>
            </div>
            <div class="viz-container">
                <h3>Golden Ratio Convergence</h3>
                <canvas id="ratioPlot" width="400" height="200"></canvas>
            </div>
            <div class="viz-container">
                <h3>Modular Fibonacci (mod 5)</h3>
                <canvas id="modularPlot" width="400" height="200"></canvas>
            </div>
            <div class="viz-container">
                <h3>Recurrence Relations</h3>
                <canvas id="coeffPlot" width="400" height="200"></canvas>
            </div>
            <div class="viz-container">
                <h3>3D UNNS Attractor</h3>
                <canvas id="threeBodyPlot" width="400" height="400"></canvas>
            </div>
        </div>
    </section>

    <section>
        <h2>üåÄ Strange Attractor Generator</h2>
        <label for="attractorParams">Attractor Parameters (œÉ, œÅ, Œ≤) or Fibonacci scaling:</label>
        <textarea id="attractorParams" placeholder="Default Lorenz: 10, 28, 2.666&#10;Fibonacci: 13, 21, 34">10, 28, 2.666</textarea>
        <div>
            <button onclick="generateLorenzData()">üåä Lorenz Attractor</button>
            <button onclick="generateFibonacciAttractor()">üåü Fibonacci Attractor</button>
            <button onclick="generateRosslerData()">üåä R√∂ssler Attractor</button>
            <button onclick="analyzeAttractor()">üìä Analyze Attractor</button>
        </div>
        <div id="attractorResultX" class="result-item"></div>
        <div id="attractorResultY" class="result-item"></div>
        <div id="attractorResultZ" class="result-item"></div>
        <div id="attractorResultOther" class="result-item"></div>
        <div class="viz-container">
            <h3>UNNS Strange Attractor Projection</h3>
            <canvas id="attractorPlot" width="800" height="400"></canvas>
        </div>
    </section>

    <section>
        <h2>üìö Wikipedia Integration</h2>
        <div class="wiki-container">
            <div class="wiki-header">
                <span>Wikipedia: Sequences</span>
                <select id="wikiTopic" onchange="updateWiki()">
                    <option value="List_of_integer_sequences">List of integer sequences</option>
                    <option value="Fibonacci_number">Fibonacci Numbers</option>
                    <option value="Golden_ratio">Golden Ratio</option>
                    <option value="Strange_attractor">Strange Attractors</option>
                    <option value="Lorenz_system">Lorenz System</option>
                    <option value="Chaos_theory">Chaos Theory</option>
                </select>
            </div>
            <iframe id="wikiFrame" src="https://en.wikipedia.org/wiki/List_of_integer_sequences" 
                    sandbox="allow-same-origin allow-scripts allow-popups allow-forms"
                    title="Wikipedia Content"></iframe>
        </div>
    </section>

    <script>
        // Global variables
        let currentSequence = [];
        let attractorData = { x: [], y: [], z: [] };
        const PHI = 1.618033988749895; // Golden ratio

        // Update Wikipedia iframe
        function updateWiki() {
            const topic = document.getElementById('wikiTopic').value;
            document.getElementById('wikiFrame').src = `https://en.wikipedia.org/wiki/${topic}`;
        }

        // Generate Fibonacci Sequence
        function generateFibonacci() {
            const sequence = [1, 1];
            for (let i = 2; i < 30; i++) {
                sequence.push(sequence[i-1] + sequence[i-2]);
            }
            document.getElementById('sequenceInput').value = sequence.join(', ');
        }

        // Generate Lucas Sequence
        function generateLucas() {
            const sequence = [2, 1];
            for (let i = 2; i < 30; i++) {
                sequence.push(sequence[i-1] + sequence[i-2]);
            }
            document.getElementById('sequenceInput').value = sequence.join(', ');
        }

        // Generate Tribonacci Sequence
        function generateTribonacci() {
            const sequence = [0, 0, 1];
            for (let i = 3; i < 30; i++) {
                sequence.push(sequence[i-1] + sequence[i-2] + sequence[i-3]);
            }
            document.getElementById('sequenceInput').value = sequence.join(', ');
        }

        // Generate Golden Spiral based sequence
        function generateGoldenSpiral() {
            const sequence = [];
            for (let i = 0; i < 30; i++) {
                const angle = i * PHI;
                const radius = Math.pow(PHI, i/10);
                sequence.push(Math.round(radius * 100) / 100);
            }
            document.getElementById('sequenceInput').value = sequence.join(', ');
        }

        // Analyze Sequence
        function analyzeSequence() {
            const input = document.getElementById('sequenceInput').value;
            if (!input.trim()) {
                generateFibonacci();
            }
            
            currentSequence = document.getElementById('sequenceInput').value
                .split(',')
                .map(x => parseFloat(x.trim()))
                .filter(x => !isNaN(x));
            
            if (currentSequence.length < 3) {
                alert('Sequence must have at least 3 values');
                return;
            }
            
            // Calculate all metrics
            calculateSequenceMetrics();
            calculatePhaseSpace();
            calculateLyapunovExponent();
            calculateRatios();
            calculateFibonacciRelation();
            calculateModular();
            calculateRecurrenceCoefficients();
            calculate3DPhase();
            
            // Draw all visualizations
            drawSequencePlot();
            drawPhasePlot();
            drawLyapunovPlot();
            drawRatioPlot();
            drawModularPlot();
            drawCoeffPlot();
            draw3DPhase();
        }

        // Calculate Sequence Metrics
        function calculateSequenceMetrics() {
            const mean = currentSequence.reduce((a, b) => a + b, 0) / currentSequence.length;
            const variance = currentSequence.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / currentSequence.length;
            const stdDev = Math.sqrt(variance);
            
            document.getElementById('sequenceResult').innerHTML = `
                <strong>UNNS Sequence Statistics:</strong><br>
                Length: ${currentSequence.length}<br>
                Mean: ${mean.toFixed(4)}<br>
                Std Dev: ${stdDev.toFixed(4)}<br>
                Range: [${Math.min(...currentSequence).toFixed(2)}, ${Math.max(...currentSequence).toFixed(2)}]<br>
                Golden Ratio Present: ${Math.abs(stdDev/mean - PHI) < 0.1 ? '‚úÖ Yes' : '‚ùå No'}
            `;
        }

        // Calculate Phase Space
        function calculatePhaseSpace() {
            if (currentSequence.length < 2) return;
            
            const deltas = [];
            for (let i = 1; i < currentSequence.length; i++) {
                deltas.push(currentSequence[i] - currentSequence[i-1]);
            }
            
            const maxDelta = Math.max(...deltas);
            const minDelta = Math.min(...deltas);
            
            document.getElementById('phaseResult').innerHTML = `
                <strong>Phase Space Analysis:</strong><br>
                Max Delta: ${maxDelta.toFixed(4)}<br>
                Min Delta: ${minDelta.toFixed(4)}<br>
                Delta Range: ${(maxDelta - minDelta).toFixed(4)}<br>
                Attractor Type: ${maxDelta/minDelta > 10 ? 'Strange Attractor' : 'Regular Attractor'}
            `;
        }

        // Calculate Lyapunov Exponent
        function calculateLyapunovExponent() {
            if (currentSequence.length < 10) {
                document.getElementById('lyapunovResult').innerHTML = 
                    '<strong>Lyapunov Exponent:</strong> Insufficient data';
                return;
            }
            
            let sum = 0;
            let count = 0;
            
            for (let i = 1; i < currentSequence.length - 1; i++) {
                if (currentSequence[i] !== 0) {
                    const derivative = Math.abs((currentSequence[i+1] - currentSequence[i-1]) / (2 * currentSequence[i]));
                    if (derivative > 0) {
                        sum += Math.log(derivative);
                        count++;
                    }
                }
            }
            
            const lyapunov = count > 0 ? sum / count : 0;
            const chaotic = lyapunov > 0 ? "Chaotic (Strange Attractor)" : "Stable";
            
            document.getElementById('lyapunovResult').innerHTML = `
                <strong>Lyapunov Exponent:</strong> ${lyapunov.toFixed(6)}<br>
                System Type: ${chaotic}<br>
                Fibonacci Influence: ${Math.abs(lyapunov - Math.log(PHI)) < 0.5 ? '‚úÖ Detected' : '‚ö†Ô∏è Weak'}
            `;
        }

        // Calculate Ratios with Fibonacci emphasis
        function calculateRatios() {
            if (currentSequence.length < 2) return;
            
            const ratios = [];
            for (let i = 1; i < currentSequence.length; i++) {
                if (currentSequence[i-1] !== 0) {
                    ratios.push(currentSequence[i] / currentSequence[i-1]);
                }
            }
            
            if (ratios.length > 0) {
                const lastRatio = ratios[ratios.length - 1];
                const convergence = ratios.length > 10 ? 
                    Math.abs(ratios[ratios.length-1] - ratios[ratios.length-2]) : null;
                const goldenDistance = Math.abs(lastRatio - PHI);
                
                document.getElementById('ratioResult').innerHTML = `
                    <strong>Golden Ratio Analysis:</strong><br>
                    Last Ratio: ${lastRatio.toFixed(6)}<br>
                    Distance from œÜ: ${goldenDistance.toFixed(6)}<br>
                    ${convergence !== null ? `Convergence Rate: ${convergence.toFixed(8)}` : 'Convergence: Calculating...'}<br>
                    Golden Ratio Match: ${goldenDistance < 0.1 ? 'üåü Excellent' : goldenDistance < 0.5 ? '‚úÖ Good' : '‚ö†Ô∏è Weak'}
                `;
            }
        }

        // Calculate Fibonacci Relation
        function calculateFibonacciRelation() {
            if (currentSequence.length < 5) {
                document.getElementById('fibonacciResult').innerHTML = 
                    '<strong>Fibonacci Relation:</strong> Insufficient data';
                return;
            }
            
            // Check if sequence follows Fibonacci pattern
            let fibScore = 0;
            for (let i = 2; i < Math.min(currentSequence.length, 10); i++) {
                const expected = currentSequence[i-1] + currentSequence[i-2];
                const actual = currentSequence[i];
                const error = Math.abs(expected - actual) / (Math.abs(actual) + 1);
                if (error < 0.1) fibScore++;
            }
            
            const fibPercentage = (fibScore / (Math.min(currentSequence.length, 10) - 2)) * 100;
            
            document.getElementById('fibonacciResult').innerHTML = `
                <strong>Fibonacci Pattern Detection:</strong><br>
                Fibonacci Similarity: ${fibPercentage.toFixed(1)}%<br>
                Pattern Type: ${fibPercentage > 80 ? 'üåü Pure Fibonacci' : 
                              fibPercentage > 50 ? '‚ú® Fibonacci-like' : 
                              fibPercentage > 20 ? '‚ö° Partial Fibonacci' : 'üîÑ Non-Fibonacci'}<br>
                Golden Ratio Presence: ${fibPercentage > 50 ? '‚úÖ Strong' : '‚ö†Ô∏è Weak'}
            `;
        }

        // Calculate Modular Periodicity
        function calculateModular() {
            const mod = 5; // Fibonacci sequences have period 20 mod 5
            const modValues = currentSequence.map(x => Math.abs(Math.round(x)) % mod);
            const period = findPeriod(modValues);
            
            document.getElementById('modularResult').innerHTML = `
                <strong>Modular Analysis (mod ${mod}):</strong><br>
                Period: ${period > 0 ? period : 'No period detected'}<br>
                Fibonacci mod 5 period: ${period === 20 ? '‚úÖ Perfect match!' : `Expected 20, got ${period}`}<br>
                Unique Values: ${[...new Set(modValues)].sort().join(', ')}
            `;
        }

        // Find period in sequence
        function findPeriod(arr) {
            for (let p = 1; p <= Math.floor(arr.length / 2); p++) {
                let isPeriodic = true;
                for (let i = 0; i < arr.length - p; i++) {
                    if (arr[i] !== arr[i + p]) {
                        isPeriodic = false;
                        break;
                    }
                }
                if (isPeriodic) return p;
            }
            return 0;
        }

        // Calculate Recurrence Coefficients
        function calculateRecurrenceCoefficients() {
            if (currentSequence.length < 4) return;
            
            // Try to find recurrence relation a(n) = c1*a(n-1) + c2*a(n-2)
            const n = currentSequence.length;
            if (n >= 4) {
                let sumX1Y = 0, sumX2Y = 0, sumX1X1 = 0, sumX2X2 = 0, sumX1X2 = 0;
                
                for (let i = 2; i < n; i++) {
                    const x1 = currentSequence[i-1];
                    const x2 = currentSequence[i-2];
                    const y = currentSequence[i];
                    
                    sumX1Y += x1 * y;
                    sumX2Y += x2 * y;
                    sumX1X1 += x1 * x1;
                    sumX2X2 += x2 * x2;
                    sumX1X2 += x1 * x2;
                }
                
                const det = sumX1X1 * sumX2X2 - sumX1X2 * sumX1X2;
                if (Math.abs(det) > 0.0001) {
                    const c1 = (sumX2X2 * sumX1Y - sumX1X2 * sumX2Y) / det;
                    const c2 = (sumX1X1 * sumX2Y - sumX1X2 * sumX1Y) / det;
                    
                    const isFibonacci = Math.abs(c1 - 1) < 0.1 && Math.abs(c2 - 1) < 0.1;
                    
                    document.getElementById('coeffResult').innerHTML = `
                        <strong>Recurrence Relation:</strong><br>
                        a(n) ‚âà ${c1.toFixed(4)} * a(n-1) + ${c2.toFixed(4)} * a(n-2)<br>
                        Type: ${isFibonacci ? 'üåü Fibonacci (1,1)' : 
                               Math.abs(c1 + c2 - PHI) < 0.2 ? '‚ú® Golden-like' : 'Custom'}<br>
                        Fibonacci Match: ${isFibonacci ? '‚úÖ Perfect!' : '‚ö†Ô∏è Modified'}
                    `;
                } else {
                    document.getElementById('coeffResult').innerHTML = 
                        '<strong>Recurrence Relation:</strong> Cannot determine';
                }
            }
        }

        // Calculate 3D Phase Space
        function calculate3DPhase() {
            if (currentSequence.length < 3) return;
            
            const embedDim = 3;
            const points = [];
            
            for (let i = 0; i < currentSequence.length - embedDim + 1; i++) {
                points.push([
                    currentSequence[i],
                    currentSequence[i+1],
                    currentSequence[i+2]
                ]);
            }
            
            document.getElementById('threeBodyResult').innerHTML = `
                <strong>3D UNNS Attractor:</strong><br>
                Embedding Dimension: ${embedDim}<br>
                Points Generated: ${points.length}<br>
                Trajectory Type: ${detectTrajectoryType(points)}<br>
                Golden Spiral Detection: ${hasGoldenSpiral(points) ? '‚úÖ Present' : '‚ùå Not detected'}
            `;
        }

        // Detect if trajectory has golden spiral properties
        function hasGoldenSpiral(points) {
            if (points.length < 10) return false;
            
            let ratioSum = 0;
            let count = 0;
            
            for (let i = 1; i < points.length - 1; i++) {
                const dist1 = Math.sqrt(points[i].reduce((sum, val, idx) => 
                    sum + Math.pow(val - points[i-1][idx], 2), 0));
                const dist2 = Math.sqrt(points[i+1].reduce((sum, val, idx) => 
                    sum + Math.pow(val - points[i][idx], 2), 0));
                
                if (dist1 > 0) {
                    ratioSum += dist2 / dist1;
                    count++;
                }
            }
            
            const avgRatio = ratioSum / count;
            return Math.abs(avgRatio - PHI) < 0.3;
        }

        // Detect trajectory type
        function detectTrajectoryType(points) {
            if (points.length < 10) return 'Unknown';
            
            // Calculate variance in each dimension
            const variances = [0, 1, 2].map(dim => {
                const values = points.map(p => p[dim]);
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                return values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            });
            
            const maxVar = Math.max(...variances);
            const minVar = Math.min(...variances);
            const ratio = maxVar / (minVar + 0.0001);
            
            if (ratio > 100) return 'Linear';
            if (ratio > 10) return 'Elliptical';
            if (ratio > 2) return 'Strange Attractor';
            return 'Spherical';
        }

        // Draw Sequence Plot
        function drawSequencePlot() {
            const canvas = document.getElementById('sequencePlot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentSequence.length === 0) return;
            
            const padding = 20;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            const maxVal = Math.max(...currentSequence);
            const minVal = Math.min(...currentSequence);
            const range = maxVal - minVal || 1;
            
            // Draw axes
            ctx.strokeStyle = '#3a4f8e';
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Draw golden ratio line
            ctx.strokeStyle = '#ffd700';
            ctx.setLineDash([5, 5]);
            const goldenY = canvas.height - padding - ((PHI - minVal) / range) * height;
            ctx.beginPath();
            ctx.moveTo(padding, goldenY);
            ctx.lineTo(canvas.width - padding, goldenY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw sequence
            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            currentSequence.forEach((val, i) => {
                const x = padding + (i / (currentSequence.length - 1)) * width;
                const y = canvas.height - padding - ((val - minVal) / range) * height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                // Draw points
                ctx.fillStyle = '#4a9eff';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.strokeStyle = '#00ffaa';
            ctx.stroke();
        }

        // Draw Phase Plot
        function drawPhasePlot() {
            const canvas = document.getElementById('phasePlot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentSequence.length < 2) return;
            
            const padding = 20;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // Create phase space pairs
            const pairs = [];
            for (let i = 0; i < currentSequence.length - 1; i++) {
                pairs.push([currentSequence[i], currentSequence[i+1]]);
            }
            
            const xMax = Math.max(...pairs.map(p => p[0]));
            const xMin = Math.min(...pairs.map(p => p[0]));
            const yMax = Math.max(...pairs.map(p => p[1]));
            const yMin = Math.min(...pairs.map(p => p[1]));
            
            const xRange = xMax - xMin || 1;
            const yRange = yMax - yMin || 1;
            
            // Draw axes
            ctx.strokeStyle = '#3a4f8e';
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height / 2);
            ctx.lineTo(canvas.width - padding, canvas.height / 2);
            ctx.moveTo(canvas.width / 2, padding);
            ctx.lineTo(canvas.width / 2, canvas.height - padding);
            ctx.stroke();
            
            // Draw phase trajectory
            ctx.strokeStyle = '#ff4a9e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            pairs.forEach((pair, i) => {
                const x = padding + ((pair[0] - xMin) / xRange) * width;
                const y = canvas.height - padding - ((pair[1] - yMin) / yRange) * height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                // Color gradient based on golden ratio
                const ratio = pair[1] / (pair[0] + 0.001);
                const hue = Math.abs(ratio - PHI) < 0.5 ? 50 : (i / pairs.length) * 360;
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.strokeStyle = '#ff4a9e';
            ctx.stroke();
        }

        // Draw Lyapunov Plot
        function drawLyapunovPlot() {
            const canvas = document.getElementById('lyapunovPlot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentSequence.length < 10) return;
            
            const padding = 20;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // Calculate running Lyapunov exponents
            const lyapunovs = [];
            for (let k = 10; k < currentSequence.length; k++) {
                let sum = 0;
                let count = 0;
                
                for (let i = 1; i < k - 1; i++) {
                    if (currentSequence[i] !== 0) {
                        const derivative = Math.abs((currentSequence[i+1] - currentSequence[i-1]) / (2 * currentSequence[i]));
                        if (derivative > 0) {
                            sum += Math.log(derivative);
                            count++;
                        }
                    }
                }
                
                lyapunovs.push(count > 0 ? sum / count : 0);
            }
            
            if (lyapunovs.length === 0) return;
            
            const maxL = Math.max(...lyapunovs);
            const minL = Math.min(...lyapunovs);
            const range = maxL - minL || 1;
            
            // Draw zero line
            ctx.strokeStyle = '#3a4f8e';
            ctx.beginPath();
            const zeroY = canvas.height - padding - ((-minL) / range) * height;
            ctx.moveTo(padding, zeroY);
            ctx.lineTo(canvas.width - padding, zeroY);
            ctx.stroke();
            
            // Draw Lyapunov trend
            ctx.strokeStyle = '#ffbe0b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            lyapunovs.forEach((val, i) => {
                const x = padding + (i / (lyapunovs.length - 1)) * width;
                const y = canvas.height - padding - ((val - minL) / range) * height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            
            ctx.stroke();
            
            // Mark chaotic region
            if (maxL > 0) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.fillRect(padding, padding, width, zeroY - padding);
            }
        }

        // Draw Ratio Plot with Golden Ratio emphasis
        function drawRatioPlot() {
            const canvas = document.getElementById('ratioPlot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentSequence.length < 2) return;
            
            const padding = 20;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            const ratios = [];
            for (let i = 1; i < currentSequence.length; i++) {
                if (currentSequence[i-1] !== 0) {
                    ratios.push(currentSequence[i] / currentSequence[i-1]);
                }
            }
            
            if (ratios.length === 0) return;
            
            const maxR = Math.max(...ratios);
            const minR = Math.min(...ratios);
            const range = maxR - minR || 1;
            
            // Draw golden ratio line (thick and golden)
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            const goldenY = canvas.height - padding - ((PHI - minR) / range) * height;
            ctx.beginPath();
            ctx.moveTo(padding, goldenY);
            ctx.lineTo(canvas.width - padding, goldenY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Add label for golden ratio
            ctx.fillStyle = '#ffd700';
            ctx.font = '12px monospace';
            ctx.fillText('œÜ = 1.618', canvas.width - padding - 60, goldenY - 5);
            
            // Draw ratios
            ctx.strokeStyle = '#06ffa5';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            ratios.forEach((val, i) => {
                const x = padding + (i / (ratios.length - 1)) * width;
                const y = canvas.height - padding - ((val - minR) / range) * height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                // Color points based on proximity to golden ratio
                const distance = Math.abs(val - PHI);
                const color = distance < 0.1 ? '#ffd700' : distance < 0.5 ? '#00ffaa' : '#4a9eff';
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.strokeStyle = '#06ffa5';
            ctx.stroke();
        }

        // Draw Modular Plot
        function drawModularPlot() {
            const canvas = document.getElementById('modularPlot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentSequence.length === 0) return;
            
            const padding = 20;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            const mod = 5;
            const modValues = currentSequence.map(x => Math.abs(Math.round(x)) % mod);
            
            // Draw grid lines for each modular value
            ctx.strokeStyle = '#3a4f8e';
            ctx.setLineDash([2, 2]);
            for (let i = 0; i < mod; i++) {
                const y = canvas.height - padding - (i / (mod - 1)) * height;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Draw modular values
            ctx.fillStyle = '#ff4a9e';
            modValues.forEach((val, i) => {
                const x = padding + (i / (modValues.length - 1)) * width;
                const y = canvas.height - padding - (val / (mod - 1)) * height;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Connect points
            ctx.strokeStyle = '#ff4a9e';
            ctx.lineWidth = 1;
            ctx.beginPath();
            modValues.forEach((val, i) => {
                const x = padding + (i / (modValues.length - 1)) * width;
                const y = canvas.height - padding - (val / (mod - 1)) * height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        // Draw Coefficient Plot
        function drawCoeffPlot() {
            const canvas = document.getElementById('coeffPlot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentSequence.length < 4) return;
            
            // Calculate rolling coefficients
            const coeffs = [];
            for (let i = 4; i < currentSequence.length; i++) {
                const x1 = currentSequence[i-1];
                if (x1 !== 0) {
                    coeffs.push(currentSequence[i] / x1);
                }
            }
            
            if (coeffs.length === 0) return;
            
            const padding = 20;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            const maxC = Math.max(...coeffs);
            const minC = Math.min(...coeffs);
            const range = maxC - minC || 1;
            
            // Draw golden ratio line
            ctx.strokeStyle = '#ffd700';
            ctx.setLineDash([5, 5]);
            const goldenY = canvas.height - padding - ((PHI - minC) / range) * height;
            ctx.beginPath();
            ctx.moveTo(padding, goldenY);
            ctx.lineTo(canvas.width - padding, goldenY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw coefficients
            ctx.strokeStyle = '#8338ec';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            coeffs.forEach((val, i) => {
                const x = padding + (i / (coeffs.length - 1)) * width;
                const y = canvas.height - padding - ((val - minC) / range) * height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                // Gradient coloring based on golden ratio proximity
                const distance = Math.abs(val - PHI);
                const hue = distance < 0.5 ? 50 : 280 + (val / maxC) * 60;
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.strokeStyle = '#8338ec';
            ctx.stroke();
        }

        // Draw 3D Phase Space (2D projection) - FIXED negative radius
        function draw3DPhase() {
            const canvas = document.getElementById('threeBodyPlot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentSequence.length < 3) return;
            
            const padding = 40;
            const size = canvas.width - 2 * padding;
            
            // Create 3D embedding
            const points = [];
            for (let i = 0; i < currentSequence.length - 2; i++) {
                points.push({
                    x: currentSequence[i],
                    y: currentSequence[i+1],
                    z: currentSequence[i+2]
                });
            }
            
            // Normalize points
            const xMax = Math.max(...points.map(p => p.x));
            const xMin = Math.min(...points.map(p => p.x));
            const yMax = Math.max(...points.map(p => p.y));
            const yMin = Math.min(...points.map(p => p.y));
            const zMax = Math.max(...points.map(p => p.z));
            const zMin = Math.min(...points.map(p => p.z));
            
            const xRange = xMax - xMin || 1;
            const yRange = yMax - yMin || 1;
            const zRange = zMax - zMin || 1;
            
            // Rotation angle for 3D effect
            const angle = Date.now() * 0.001;
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            
            // Draw 3D axes
            ctx.strokeStyle = '#3a4f8e';
            ctx.lineWidth = 1;
            
            // X axis
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Y axis
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(padding, padding);
            ctx.stroke();
            
            // Z axis (diagonal)
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(padding + size * 0.3, canvas.height - padding - size * 0.3);
            ctx.stroke();
            
            // Draw trajectory
            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            points.forEach((point, i) => {
                // Normalize
                const nx = (point.x - xMin) / xRange;
                const ny = (point.y - yMin) / yRange;
                const nz = (point.z - zMin) / zRange;
                
                // Apply rotation for 3D effect
                const x3d = nx * cosA - nz * sinA;
                const z3d = nx * sinA + nz * cosA;
                
                // Project to 2D
                const perspective = 1 / (1 + z3d * 0.5);
                const x = padding + x3d * size * perspective;
                const y = canvas.height - padding - ny * size * perspective;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                // Color based on golden ratio proximity
                const ratio = point.y / (point.x + 0.001);
                const hue = Math.abs(ratio - PHI) < 0.5 ? 50 : 180 + z3d * 180;
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.beginPath();
                // FIX: Use Math.abs to ensure positive radius
                const radius = Math.abs(2 + z3d * 2);
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.strokeStyle = '#00ffaa';
            ctx.stroke();
        }

        // Generate Fibonacci Attractor
        function generateFibonacciAttractor() {
            // Use Fibonacci numbers as attractor parameters
            const fib = [1, 1, 2, 3, 5, 8, 13, 21, 34];
            const sigma = fib[4]; // 5
            const rho = fib[6];   // 13
            const beta = fib[5] / fib[2]; // 8/2 = 4
            
            generateAttractorWithParams(sigma, rho, beta);
            document.getElementById('attractorParams').value = `Fibonacci: ${sigma}, ${rho}, ${beta}`;
        }

        // Generate Lorenz Data
        function generateLorenzData() {
            const input = document.getElementById('attractorParams').value;
            let sigma = 10, rho = 28, beta = 8/3;
            
            if (input.trim() && !input.includes('Fibonacci')) {
                const params = input.split(',').map(x => parseFloat(x.trim()));
                if (params.length >= 3) {
                    sigma = params[0] || 10;
                    rho = params[1] || 28;
                    beta = params[2] || 8/3;
                }
            }
            
            generateAttractorWithParams(sigma, rho, beta);
        }

        // Generate attractor with specific parameters
        function generateAttractorWithParams(sigma, rho, beta) {
            // Generate Lorenz attractor
            let x = 1, y = 1, z = 1;
            const dt = 0.01;
            const steps = 5000;
            
            attractorData = { x: [], y: [], z: [] };
            
            for (let i = 0; i < steps; i++) {
                const dx = sigma * (y - x);
                const dy = x * (rho - z) - y;
                const dz = x * y - beta * z;
                
                x += dx * dt;
                y += dy * dt;
                z += dz * dt;
                
                if (i % 10 === 0) { // Sample every 10th point
                    attractorData.x.push(x);
                    attractorData.y.push(y);
                    attractorData.z.push(z);
                }
            }
            
            alert('Attractor data generated! Click "Analyze Attractor" to visualize.');
        }

        // Generate R√∂ssler Data
        function generateRosslerData() {
            const a = 0.2, b = 0.2, c = 5.7;
            
            let x = 1, y = 1, z = 1;
            const dt = 0.01;
            const steps = 5000;
            
            attractorData = { x: [], y: [], z: [] };
            
            for (let i = 0; i < steps; i++) {
                const dx = -y - z;
                const dy = x + a * y;
                const dz = b + z * (x - c);
                
                x += dx * dt;
                y += dy * dt;
                z += dz * dt;
                
                if (i % 10 === 0) {
                    attractorData.x.push(x);
                    attractorData.y.push(y);
                    attractorData.z.push(z);
                }
            }
            
            document.getElementById('attractorParams').value = `R√∂ssler: a=${a}, b=${b}, c=${c}`;
            alert('R√∂ssler attractor generated! Click "Analyze Attractor" to visualize.');
        }

        // Analyze Attractor
        function analyzeAttractor() {
            if (attractorData.x.length === 0) {
                alert('Please generate attractor data first');
                return;
            }
            
            // Calculate statistics for each dimension
            const stats = ['x', 'y', 'z'].map(dim => {
                const data = attractorData[dim];
                const mean = data.reduce((a, b) => a + b, 0) / data.length;
                const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
                return {
                    dim: dim,
                    mean: mean,
                    stdDev: Math.sqrt(variance),
                    min: Math.min(...data),
                    max: Math.max(...data)
                };
            });
            
            document.getElementById('attractorResultX').innerHTML = `
                <strong>X Dimension:</strong> 
                Mean: ${stats[0].mean.toFixed(4)}, 
                Std: ${stats[0].stdDev.toFixed(4)}, 
                Range: [${stats[0].min.toFixed(2)}, ${stats[0].max.toFixed(2)}]
            `;
            
            document.getElementById('attractorResultY').innerHTML = `
                <strong>Y Dimension:</strong> 
                Mean: ${stats[1].mean.toFixed(4)}, 
                Std: ${stats[1].stdDev.toFixed(4)}, 
                Range: [${stats[1].min.toFixed(2)}, ${stats[1].max.toFixed(2)}]
            `;
            
            document.getElementById('attractorResultZ').innerHTML = `
                <strong>Z Dimension:</strong> 
                Mean: ${stats[2].mean.toFixed(4)}, 
                Std: ${stats[2].stdDev.toFixed(4)}, 
                Range: [${stats[2].min.toFixed(2)}, ${stats[2].max.toFixed(2)}]
            `;
            
            // Calculate attractor properties
            const volume = stats.reduce((acc, s) => acc * (s.max - s.min), 1);
            const dimension = estimateFractalDimension(attractorData);
            const goldenRatio = stats[0].stdDev / stats[1].stdDev;
            
            document.getElementById('attractorResultOther').innerHTML = `
                <strong>UNNS Attractor Properties:</strong><br>
                Phase Space Volume: ${volume.toFixed(2)}<br>
                Estimated Fractal Dimension: ${dimension.toFixed(3)}<br>
                X/Y Std Ratio: ${goldenRatio.toFixed(4)} ${Math.abs(goldenRatio - PHI) < 0.3 ? '‚úÖ Near œÜ!' : ''}<br>
                Attractor Type: Strange Attractor<br>
                Points: ${attractorData.x.length}
            `;
            
            // Draw attractor
            drawAttractor();
        }

        // Estimate fractal dimension (box-counting)
        function estimateFractalDimension(data) {
            // Simplified box-counting dimension estimate
            const points = data.x.map((x, i) => [x, data.y[i], data.z[i]]);
            const boxes = new Set();
            
            const gridSize = 10;
            points.forEach(p => {
                const box = p.map(coord => Math.floor(coord / gridSize)).join(',');
                boxes.add(box);
            });
            
            // Very rough estimate
            return Math.log(boxes.size) / Math.log(gridSize);
        }

        // Draw Attractor - FIXED negative radius
        function drawAttractor() {
            const canvas = document.getElementById('attractorPlot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (attractorData.x.length === 0) return;
            
            const padding = 40;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // Find bounds
            const xMax = Math.max(...attractorData.x);
            const xMin = Math.min(...attractorData.x);
            const yMax = Math.max(...attractorData.y);
            const yMin = Math.min(...attractorData.y);
            const zMax = Math.max(...attractorData.z);
            const zMin = Math.min(...attractorData.z);
            
            const xRange = xMax - xMin || 1;
            const yRange = yMax - yMin || 1;
            
            // Draw gradient background
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0.1)');
            gradient.addColorStop(0.5, 'rgba(74, 158, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(10, 15, 30, 0.9)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw trajectory with depth coloring
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            attractorData.x.forEach((x, i) => {
                const px = padding + ((x - xMin) / xRange) * width;
                const py = canvas.height - padding - ((attractorData.z[i] - zMin) / (zMax - zMin)) * height;
                
                // Color based on y-depth and golden ratio
                const depth = (attractorData.y[i] - yMin) / yRange;
                const ratio = Math.abs(attractorData.y[i] / (attractorData.x[i] + 0.001));
                const hue = Math.abs(ratio - PHI) < 1 ? 50 : depth * 240 + 120;
                ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                }
                
                // Draw points with varying size based on depth
                if (i % 5 === 0) {
                    ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                    ctx.beginPath();
                    // FIX: Use Math.abs to ensure positive radius
                    const radius = Math.abs(0.5 + depth * 2);
                    ctx.arc(px, py, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.stroke();
        }

        // Auto-rotate 3D visualization
        setInterval(() => {
            if (currentSequence.length >= 3) {
                draw3DPhase();
            }
        }, 50);

        // Initialize with Fibonacci sequence
        window.addEventListener('load', () => {
            generateFibonacci();
            analyzeSequence();
        });
    </script>
</body>
</html>
