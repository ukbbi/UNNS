<!DOCTYPE html>
    <html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced UNNS Equation Registry - Neural Attractor Dynamics</title>
    <style>
        /* Reset and Base Styles - Blogger Compatible */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #2c3e50;
            padding: 20px;
            min-height: 100vh;
            line-height: 1.6;
        }
        
        /* Main Container */
        .registry-container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 20px;
        }
        
        .header h1 {
            font-size: 2.5em;
            color: #2c3e50;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            font-size: 1.2em;
            color: #7f8c8d;
            font-style: italic;
        }
        
        /* Equation Selector */
        .selector-section {
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            border: 2px solid #dee2e6;
        }
        
        .selector-label {
            display: block;
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        select {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            border: 2px solid #ced4da;
            border-radius: 10px;
            background: white;
            color: #495057;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }
        
        select:hover {
            border-color: #adb5bd;
        }
        
        /* Output Container */
        #output {
            min-height: 150px;
            padding: 20px;
            background: white;
            border-radius: 15px;
            border: 2px solid #e9ecef;
            margin-top: 20px;
        }
        
        /* Equation Info Cards */
        .equation-info {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        
        .equation-name {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .equation-description {
            font-size: 1em;
            margin-bottom: 15px;
            opacity: 0.9;
        }
        
        .equation-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .meta-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        
        .meta-label {
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .meta-value {
            color: #ecf0f1;
        }
        
        /* Persona Sections */
        .ritual-block {
            margin: 20px 0;
            padding: 25px;
            background: linear-gradient(45deg, #f1f3f4, #ffffff);
            border-radius: 15px;
            border-left: 5px solid;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .ritual-block.explorer { border-left-color: #e74c3c; }
        .ritual-block.spiral { border-left-color: #9b59b6; }
        .ritual-block.tracer { border-left-color: #3498db; }
        .ritual-block.mapper { border-left-color: #f39c12; }
        
        .persona-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .persona-title.explorer { color: #e74c3c; }
        .persona-title.spiral { color: #9b59b6; }
        .persona-title.tracer { color: #3498db; }
        .persona-title.mapper { color: #f39c12; }
        
        /* Input Groups */
        .input-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .input-row {
            display: flex;
            gap: 10px;
            align-items: end;
            flex-wrap: wrap;
        }
        
        .input-field {
            flex: 1;
            min-width: 120px;
        }
        
        label {
            font-weight: 600;
            color: #495057;
            font-size: 0.95em;
        }
        
        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }
        
        /* Buttons */
        button {
            padding: 12px 20px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 100px;
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3);
        }
        
        button:hover {
            background: linear-gradient(45deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(52, 152, 219, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        /* Canvas Styling */
        canvas {
            border: 3px solid #bdc3c7;
            border-radius: 10px;
            margin: 15px 0;
            display: block;
            background: #2c3e50;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        /* Results */
        .result {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #28a745;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .error {
            color: #e74c3c;
            background: #fadbd8;
            border-left-color: #e74c3c;
            font-weight: 600;
        }
        
        /* Resonance Meter */
        .resonance-section {
            margin: 15px 0;
            padding: 15px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
            border: 2px solid #dee2e6;
        }
        
        .resonance-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
        }
        
        .resonance-meter {
            position: relative;
            height: 30px;
            background: #ecf0f1;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #bdc3c7;
        }
        
        .resonance-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #f1c40f, #27ae60);
            border-radius: 13px;
            transition: width 0.8s ease;
            position: relative;
        }
        
        .resonance-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #2c3e50;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .registry-container {
                margin: 10px;
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .input-row {
                flex-direction: column;
            }
            
            .equation-meta {
                grid-template-columns: 1fr;
            }
        }
        
        /* Animation Classes */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 0.5s ease;
        }
        
        /* Mathematical Notation */
        .math-notation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-weight: bold;
            color: #8e44ad;
        }
        
        /* Placeholder message */
        .placeholder {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 40px;
            background: linear-gradient(45deg, #ecf0f1, #bdc3c7);
            border-radius: 10px;
            border: 2px dashed #95a5a6;
        }
    </style>
</head>
<body>
    <div class="registry-container">
        <header class="header">
            <h1>🧠 UNNS Equation Registry</h1>
            <p class="subtitle">Neural Attractor Dynamics &amp; Mathematical Resonance</p>
        </header>
        
        <section class="selector-section">
            <label class="selector-label">
                🔮 Select a Mathematical Attractor to Explore:
            </label>
            <select aria-label="Select a mathematical equation" id="equation-select">
                <option value="">Choose an Equation...</option>
                <option value="fibonacci">Fibonacci Sequence - φ Golden Attractor</option>
                <option value="tribonacci">Tribonacci Sequence - ψ Tribonacci Constant</option>
                <option value="lucas">Lucas Numbers - φ Enhanced Resonance</option>
                <option value="pell">Pell Numbers - Silver Ratio √2+1</option>
                <option value="padovan">Padovan Sequence - ρ Plastic Number</option>
                <option value="catalan">Catalan Numbers - Combinatorial Growth</option>
                <option value="euler">Euler's Number Approximation - e Transcendental</option>
                <option value="logistic">Logistic Map - Chaotic Dynamics</option>
                <option value="henon">Hénon Map - Strange Attractor</option>
                <option value="feigenbaum">Feigenbaum Map - Universal Scaling</option>
                <option value="mandelbrot">Mandelbrot Set - Fractal Boundary</option>
                <option value="julia">Julia Set - Complex Dynamics</option>
                <option value="golden_spiral">Golden Angle Spiral - φ Phyllotaxis</option>
                <option value="archimedean">Archimedean Spiral - Linear Growth</option>
                <option value="fermat">Fermat Spiral - Parabolic Growth</option>
                <option value="cellular">Cellular Automata - Rule 110</option>
                <option value="collatz">Collatz Conjecture - 3n+1 Problem</option>
                <option value="prime_spiral">Prime Number Spiral - Ulam Spiral</option>
            </select>
        </section>
        
        <main aria-live="polite" id="output" role="region">
            <div class="placeholder">
                <h3>🌟 Welcome to the Neural Attractor Observatory</h3>
                <p>Select an equation above to explore its mathematical properties, symbolic meaning, and neural network applications in the UNNS framework.</p>
            </div>
        </main>
    </div>

    <script>
        // Enhanced utility functions
        function clearAllCanvases() {
            const canvases = document.querySelectorAll('canvas');
            canvases.forEach(canvas => {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            });
        }

        function safeExecute(fn, errorMessage) {
            try {
                fn();
            } catch (e) {
                console.error(errorMessage, e);
                showError(`Error: ${e.message}`);
            }
        }

        function showError(message) {
            const result = document.querySelector('.result');
            if (result) {
                result.innerHTML = `<p class="error">${message}</p>`;
                result.classList.add('error');
            }
        }

        // Enhanced resonance calculation
        function computeResonance(seq, target, isSequence = true) {
            if (!isSequence) return Math.random() * 20 + 75; // Qualitative measure
            if (seq.length < 2) return 0;
            
            const ratio = seq[seq.length-1] / seq[seq.length-2];
            const error = Math.abs(ratio - target) / target;
            const resonance = Math.max(0, 100 - (error * 100));
            return Math.min(100, resonance);
        }

        // Visual resonance meter
        function displayResonanceMeter(resonance, targetName) {
            return `
                <div class="resonance-section">
                    <div class="resonance-title">🎯 Resonance with ${targetName}</div>
                    <div class="resonance-meter">
                        <div class="resonance-fill" style="width: ${resonance}%"></div>
                        <div class="resonance-text">${resonance.toFixed(1)}%</div>
                    </div>
                </div>
            `;
        }

        // Enhanced equation definitions
        const equations = {
            fibonacci: {
                name: 'Fibonacci Sequence: F(n) = F(n-1) + F(n-2)',
                description: 'The fundamental sequence of nature, where each term is the sum of the two preceding ones. Converges to the Golden Ratio φ ≈ 1.6180, appearing in spiral galaxies, flower petals, and shell patterns.',
                symbolic: 'Divine proportion, natural harmony, spiral growth',
                attractor: 'φ (Golden Ratio ≈ 1.6180)',
                layer: 'Quantum-Harmonic',
                application: 'Primary φ-nodes in input layers for harmonic feature extraction and pattern recognition.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="fibonacci-title">
                            <h3 id="fibonacci-title" class="persona-title explorer">🔍 Explorer (Pattern Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="fibonacci-input">Number of terms (1-50):</label>
                                        <input type="number" id="fibonacci-input" placeholder="e.g., 15" min="1" max="50" value="15">
                                    </div>
                                    <button onclick="computeFibonacci()">Generate Sequence</button>
                                </div>
                            </div>
                            <div id="fibonacci-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const n = parseInt(document.getElementById('fibonacci-input').value) || 15;
                        if (n < 1 || n > 50) throw new Error('Number of terms must be between 1 and 50');
                        
                        let seq = [0, 1];
                        for (let i = 2; i < n; i++) {
                            seq[i] = seq[i-1] + seq[i-2];
                        }
                        
                        const ratio = n > 2 ? seq[n-1] / seq[n-2] : 0;
                        const resonance = computeResonance(seq, 1.6180);
                        
                        document.getElementById('fibonacci-result').innerHTML = `
                            <p><strong>Sequence:</strong> ${seq.join(', ')}</p>
                            <p><strong>Convergence to φ:</strong> ${ratio.toFixed(6)}</p>
                            <p><strong>Golden Ratio Target:</strong> 1.618034</p>
                            ${displayResonanceMeter(resonance, 'Golden Ratio φ')}
                        `;
                    }, 'Error computing Fibonacci sequence');
                }
            },
            
            catalan: {
                name: 'Catalan Numbers: C(n) = (2n)! / ((n+1)! × n!)',
                description: 'Counts the number of ways to correctly match parentheses, triangulate polygons, and arrange binary trees. Growth rate approaches 4^n / (n^(3/2) × √π).',
                symbolic: 'Structural enumeration, balanced configurations, recursive partitioning',
                attractor: 'Combinatorial Growth (~4^n/n^(3/2))',
                layer: 'Structural-Combinatorial',
                application: 'Tree-structured neural architectures and hierarchical pattern recognition.',
                persona: 'mapper',
                ritual: function() {
                    return `
                        <section class="ritual-block mapper" aria-labelledby="catalan-title">
                            <h3 id="catalan-title" class="persona-title mapper">🛠️ Mapper (Structure Architect)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="catalan-input">Number of terms (1-15):</label>
                                        <input type="number" id="catalan-input" placeholder="e.g., 10" min="1" max="15" value="10">
                                    </div>
                                    <button onclick="computeCatalan()">Calculate Series</button>
                                </div>
                            </div>
                            <div id="catalan-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const n = parseInt(document.getElementById('catalan-input').value) || 10;
                        if (n < 1 || n > 15) throw new Error('Number of terms must be between 1 and 15');
                        
                        let catalan = [1];
                        for (let i = 1; i < n; i++) {
                            catalan[i] = 0;
                            for (let j = 0; j < i; j++) {
                                catalan[i] += catalan[j] * catalan[i-1-j];
                            }
                        }
                        
                        const growthRatio = n > 1 ? catalan[n-1] / catalan[n-2] : 0;
                        const resonance = computeResonance(catalan, 4, false); // Approximate growth factor
                        
                        document.getElementById('catalan-result').innerHTML = `
                            <p><strong>Catalan Numbers:</strong> ${catalan.join(', ')}</p>
                            <p><strong>Growth Ratio:</strong> ${growthRatio.toFixed(3)}</p>
                            <p><strong>Applications:</strong> ${catalan[n-1]} ways to arrange ${n-1} pairs of parentheses</p>
                            ${displayResonanceMeter(resonance, 'Combinatorial Growth')}
                        `;
                    }, 'Error computing Catalan numbers');
                }
            },

            euler: {
                name: "Euler's Number: e = lim(n→∞) (1 + 1/n)^n",
                description: 'The base of natural logarithms, fundamental to exponential growth and decay. Approximated through the series e = Σ(1/n!) or the limit definition.',
                symbolic: 'Natural growth, exponential emergence, continuous transformation',
                attractor: 'e (Euler\'s Number ≈ 2.71828)',
                layer: 'Exponential-Transcendental',
                application: 'Exponential activation functions and continuous learning rate adaptation.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="euler-title">
                            <h3 id="euler-title" class="persona-title spiral">🌀 Spiral Engine (Growth Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="euler-input">Iterations (1-20):</label>
                                        <input type="number" id="euler-input" placeholder="e.g., 15" min="1" max="20" value="15">
                                    </div>
                                    <button onclick="computeEuler()">Approximate e</button>
                                </div>
                            </div>
                            <div id="euler-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const n = parseInt(document.getElementById('euler-input').value) || 15;
                        if (n < 1 || n > 20) throw new Error('Iterations must be between 1 and 20');
                        
                        // Calculate e using series: e = Σ(1/n!)
                        let e_approx = 1;
                        let factorial = 1;
                        let series = [1];
                        
                        for (let i = 1; i < n; i++) {
                            factorial *= i;
                            const term = 1 / factorial;
                            e_approx += term;
                            series.push(e_approx);
                        }
                        
                        const error = Math.abs(e_approx - Math.E);
                        const resonance = Math.max(0, 100 - (error / Math.E * 1000));
                        
                        document.getElementById('euler-result').innerHTML = `
                            <p><strong>e Approximation:</strong> ${e_approx.toFixed(8)}</p>
                            <p><strong>Actual e:</strong> ${Math.E.toFixed(8)}</p>
                            <p><strong>Error:</strong> ${error.toFixed(8)}</p>
                            <p><strong>Series:</strong> ${series.slice(-5).map(x => x.toFixed(4)).join(', ')}...</p>
                            ${displayResonanceMeter(resonance, "Euler's Number e")}
                        `;
                    }, "Error computing Euler's number");
                }
            },

            henon: {
                name: 'Hénon Map: x_{n+1} = 1 - ax_n² + y_n, y_{n+1} = bx_n',
                description: 'A discrete-time dynamical system that exhibits chaotic behavior. With parameters a=1.4, b=0.3, it produces a strange attractor with fractal structure.',
                symbolic: 'Strange attraction, deterministic chaos, phase space complexity',
                attractor: 'Strange Attractor (Fractal Dimension ≈ 1.26)',
                layer: 'Chaotic-Fractal',
                application: 'Chaotic hidden layers for complex pattern generation and creative AI responses.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="henon-title">
                            <h3 id="henon-title" class="persona-title spiral">🌀 Spiral Engine (Chaos Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="henon-iterations">Iterations (100-2000):</label>
                                        <input type="number" id="henon-iterations" placeholder="e.g., 1000" min="100" max="2000" value="1000">
                                    </div>
                                    <div class="input-field">
                                        <label for="henon-a">Parameter a (1.0-1.6):</label>
                                        <input type="number" id="henon-a" placeholder="1.4" step="0.1" min="1.0" max="1.6" value="1.4">
                                    </div>
                                    <div class="input-field">
                                        <label for="henon-b">Parameter b (0.1-0.5):</label>
                                        <input type="number" id="henon-b" placeholder="0.3" step="0.1" min="0.1" max="0.5" value="0.3">
                                    </div>
                                    <button onclick="computeHenon()">Generate Attractor</button>
                                </div>
                            </div>
                            <canvas id="henon-canvas" width="400" height="400"></canvas>
                            <div id="henon-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const iterations = parseInt(document.getElementById('henon-iterations').value) || 1000;
                        const a = parseFloat(document.getElementById('henon-a').value) || 1.4;
                        const b = parseFloat(document.getElementById('henon-b').value) || 0.3;
                        
                        if (iterations < 100 || iterations > 2000) throw new Error('Iterations must be 100-2000');
                        if (a < 1.0 || a > 1.6 || b < 0.1 || b > 0.5) throw new Error('Parameters out of range');
                        
                        const canvas = document.getElementById('henon-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        let x = 0, y = 0;
                        let points = [];
                        
                        // Skip transient behavior
                        for (let i = 0; i < 100; i++) {
                            const newX = 1 - a * x * x + y;
                            const newY = b * x;
                            x = newX;
                            y = newY;
                        }
                        
                        // Collect points for strange attractor
                        for (let i = 0; i < iterations; i++) {
                            const newX = 1 - a * x * x + y;
                            const newY = b * x;
                            x = newX;
                            y = newY;
                            points.push({x, y});
                        }
                        
                        // Plot the attractor
                        ctx.fillStyle = '#00ff88';
                        points.forEach(point => {
                            const px = (point.x + 2) * canvas.width / 4;
                            const py = (point.y + 2) * canvas.height / 4;
                            ctx.fillRect(px, py, 1, 1);
                        });
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('henon-result').innerHTML = `
                            <p><strong>Hénon Attractor Generated</strong></p>
                            <p><strong>Parameters:</strong> a=${a}, b=${b}</p>
                            <p><strong>Points plotted:</strong> ${iterations}</p>
                            <p><strong>Final coordinates:</strong> (${x.toFixed(4)}, ${y.toFixed(4)})</p>
                            ${displayResonanceMeter(resonance, 'Strange Attractor')}
                        `;
                    }, 'Error computing Hénon map');
                }
            },

            julia: {
                name: 'Julia Set: z_{n+1} = z_n² + c (complex plane)',
                description: 'A fractal set in the complex plane, closely related to the Mandelbrot set. Each complex parameter c generates a unique Julia set with intricate boundary patterns.',
                symbolic: 'Complex beauty, fractal boundaries, infinite detail',
                attractor: 'Julia Set Boundary (Parameter-dependent)',
                layer: 'Complex-Fractal',
                application: 'Complex-valued neural networks and boundary detection algorithms.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="julia-title">
                            <h3 id="julia-title" class="persona-title explorer">🔍 Explorer (Fractal Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="julia-real">Real part of c:</label>
                                        <input type="number" id="julia-real" placeholder="-0.7" step="0.1" min="-2" max="2" value="-0.7">
                                    </div>
                                    <div class="input-field">
                                        <label for="julia-imag">Imaginary part of c:</label>
                                        <input type="number" id="julia-imag" placeholder="0.27015" step="0.01" min="-2" max="2" value="0.27015">
                                    </div>
                                    <div class="input-field">
                                        <label for="julia-iterations">Max iterations:</label>
                                        <input type="number" id="julia-iterations" placeholder="100" min="50" max="200" value="100">
                                    </div>
                                    <button onclick="computeJulia()">Render Julia Set</button>
                                </div>
                            </div>
                            <canvas id="julia-canvas" width="400" height="400"></canvas>
                            <div id="julia-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const cReal = parseFloat(document.getElementById('julia-real').value) || -0.7;
                        const cImag = parseFloat(document.getElementById('julia-imag').value) || 0.27015;
                        const maxIter = parseInt(document.getElementById('julia-iterations').value) || 100;
                        
                        const canvas = document.getElementById('julia-canvas');
                        const ctx = canvas.getContext('2d');
                        const imageData = ctx.createImageData(canvas.width, canvas.height);
                        
                        for (let px = 0; px < canvas.width; px++) {
                            for (let py = 0; py < canvas.height; py++) {
                                const x0 = (px - canvas.width/2) * 4 / canvas.width;
                                const y0 = (py - canvas.height/2) * 4 / canvas.height;
                                
                                let x = x0, y = y0;
                                let iter = 0;
                                
                                while (iter < maxIter && x*x + y*y < 4) {
                                    const xtemp = x*x - y*y + cReal;
                                    y = 2*x*y + cImag;
                                    x = xtemp;
                                    iter++;
                                }
                                
                                const index = (py * canvas.width + px) * 4;
                                if (iter === maxIter) {
                                    imageData.data[index] = 0;
                                    imageData.data[index + 1] = 0;
                                    imageData.data[index + 2] = 0;
                                } else {
                                    const hue = (iter / maxIter) * 360;
                                    const rgb = hslToRgb(hue, 100, 50);
                                    imageData.data[index] = rgb[0];
                                    imageData.data[index + 1] = rgb[1];
                                    imageData.data[index + 2] = rgb[2];
                                }
                                imageData.data[index + 3] = 255;
                            }
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('julia-result').innerHTML = `
                            <p><strong>Julia Set Rendered</strong></p>
                            <p><strong>Parameter c:</strong> ${cReal} + ${cImag}i</p>
                            <p><strong>Max iterations:</strong> ${maxIter}</p>
                            ${displayResonanceMeter(resonance, 'Julia Set Boundary')}
                        `;
                    }, 'Error computing Julia set');
                }
            },

            collatz: {
                name: 'Collatz Conjecture: n→n/2 (even), n→3n+1 (odd)',
                description: 'Also known as the 3n+1 problem. Despite its simple rules, this sequence exhibits complex behavior and always appears to reach 1, though this remains unproven.',
                symbolic: 'Unpredictable convergence, simple rules creating complexity',
                attractor: 'Cycle: 4→2→1→4 (Conjectured Universal)',
                layer: 'Recursive-Conjecture',
                application: 'Testing convergence properties and irregular sequence processing.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="collatz-title">
                            <h3 id="collatz-title" class="persona-title explorer">🔍 Explorer (Sequence Detective)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="collatz-input">Starting number (1-1000):</label>
                                        <input type="number" id="collatz-input" placeholder="e.g., 27" min="1" max="1000" value="27">
                                    </div>
                                    <button onclick="computeCollatz()">Trace Sequence</button>
                                </div>
                            </div>
                            <div id="collatz-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const start = parseInt(document.getElementById('collatz-input').value) || 27;
                        if (start < 1 || start > 1000) throw new Error('Starting number must be between 1 and 1000');
                        
                        let n = start;
                        let sequence = [n];
                        let steps = 0;
                        let maxValue = n;
                        
                        while (n !== 1 && steps < 500) {
                            if (n % 2 === 0) {
                                n = n / 2;
                            } else {
                                n = 3 * n + 1;
                            }
                            sequence.push(n);
                            if (n > maxValue) maxValue = n;
                            steps++;
                        }
                        
                        const converged = n === 1;
                        const resonance = converged ? 100 : 50;
                        
                        const displaySeq = sequence.length > 20 ? 
                            [...sequence.slice(0, 10), '...', ...sequence.slice(-10)] : 
                            sequence;
                        
                        document.getElementById('collatz-result').innerHTML = `
                            <p><strong>Starting value:</strong> ${start}</p>
                            <p><strong>Sequence:</strong> ${displaySeq.join(' → ')}</p>
                            <p><strong>Steps to reach 1:</strong> ${converged ? steps : 'Did not converge (>500 steps)'}</p>
                            <p><strong>Maximum value reached:</strong> ${maxValue}</p>
                            ${displayResonanceMeter(resonance, 'Convergence to 1')}
                        `;
                    }, 'Error computing Collatz sequence');
                }
            },

            prime_spiral: {
                name: 'Ulam Prime Spiral: Arranging integers in spiral, highlighting primes',
                description: 'A visualization method where positive integers are arranged in a spiral pattern, with prime numbers highlighted to reveal unexpected diagonal patterns.',
                symbolic: 'Hidden order in prime distribution, spiral emergence of mathematical truth',
                attractor: 'Prime Number Distribution (Diagonal Patterns)',
                layer: 'Number-Theoretic Patterns',
                application: 'Prime-based hash functions and cryptographic neural networks.',
                persona: 'tracer',
                ritual: function() {
                    return `
                        <section class="ritual-block tracer" aria-labelledby="prime_spiral-title">
                            <h3 id="prime_spiral-title" class="persona-title tracer">🗺️ Graph Tracer (Prime Cartographer)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="prime-size">Spiral size (10-50):</label>
                                        <input type="number" id="prime-size" placeholder="e.g., 25" min="10" max="50" value="25">
                                    </div>
                                    <button onclick="computePrimeSpiral()">Generate Prime Spiral</button>
                                </div>
                            </div>
                            <canvas id="prime-canvas" width="400" height="400"></canvas>
                            <div id="prime-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const size = parseInt(document.getElementById('prime-size').value) || 25;
                        if (size < 10 || size > 50) throw new Error('Spiral size must be between 10 and 50');
                        
                        const canvas = document.getElementById('prime-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Generate spiral coordinates
                        const spiral = [];
                        let x = 0, y = 0;
                        let dx = 0, dy = -1;
                        
                        for (let i = 0; i < size * size; i++) {
                            spiral.push({x: x + Math.floor(size/2), y: y + Math.floor(size/2), num: i + 1});
                            
                            if (x === y || (x < 0 && x === -y) || (x > 0 && x === 1-y)) {
                                [dx, dy] = [-dy, dx];
                            }
                            x += dx;
                            y += dy;
                        }
                        
                        // Helper function to check if number is prime
                        function isPrime(n) {
                            if (n < 2) return false;
                            for (let i = 2; i <= Math.sqrt(n); i++) {
                                if (n % i === 0) return false;
                            }
                            return true;
                        }
                        
                        // Draw the spiral
                        const cellSize = canvas.width / size;
                        let primeCount = 0;
                        
                        spiral.forEach(point => {
                            const px = point.x * cellSize;
                            const py = point.y * cellSize;
                            
                            if (isPrime(point.num)) {
                                ctx.fillStyle = '#ff6b6b';
                                primeCount++;
                            } else {
                                ctx.fillStyle = '#4ecdc4';
                            }
                            
                            ctx.fillRect(px, py, cellSize-1, cellSize-1);
                            
                            // Draw number
                            ctx.fillStyle = '#2c3e50';
                            ctx.font = `${Math.max(8, cellSize/3)}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(point.num, px + cellSize/2, py + cellSize/2 + cellSize/6);
                        });
                        
                        const resonance = (primeCount / (size * size)) * 100;
                        document.getElementById('prime-result').innerHTML = `
                            <p><strong>Ulam Prime Spiral Generated</strong></p>
                            <p><strong>Grid size:</strong> ${size}×${size} (${size*size} numbers)</p>
                            <p><strong>Primes found:</strong> ${primeCount}</p>
                            <p><strong>Prime density:</strong> ${(primeCount/(size*size)*100).toFixed(1)}%</p>
                            ${displayResonanceMeter(resonance, 'Prime Distribution')}
                        `;
                    }, 'Error computing prime spiral');
                }
            },

            feigenbaum: {
                name: 'Feigenbaum Map: x_{n+1} = μx_n(1 - x_n²)',
                description: 'Modified logistic map that exhibits period-doubling route to chaos. The Feigenbaum constant δ ≈ 4.6692 describes universal scaling in chaotic systems.',
                symbolic: 'Universal chaos, scaling emergence, bifurcation cascades',
                attractor: 'Feigenbaum Constant (δ ≈ 4.6692)',
                layer: 'Chaotic-Universal',
                application: 'Universal scaling in chaotic neural layers and bifurcation detection.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="feigenbaum-title">
                            <h3 id="feigenbaum-title" class="persona-title spiral">🌀 Spiral Engine (Chaos Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="feigenbaum-iterations">Iterations (50-200):</label>
                                        <input type="number" id="feigenbaum-iterations" placeholder="100" min="50" max="200" value="100">
                                    </div>
                                    <div class="input-field">
                                        <label for="feigenbaum-mu">μ parameter (2.8-3.2):</label>
                                        <input type="number" id="feigenbaum-mu" placeholder="3.0" step="0.1" min="2.8" max="3.2" value="3.0">
                                    </div>
                                    <button onclick="computeFeigenbaum()">Generate Trajectory</button>
                                </div>
                            </div>
                            <canvas id="feigenbaum-canvas" width="400" height="200"></canvas>
                            <div id="feigenbaum-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const iterations = parseInt(document.getElementById('feigenbaum-iterations').value) || 100;
                        const mu = parseFloat(document.getElementById('feigenbaum-mu').value) || 3.0;
                        
                        if (iterations < 50 || iterations > 200) throw new Error('Iterations must be 50-200');
                        if (mu < 2.8 || mu > 3.2) throw new Error('μ must be 2.8-3.2');
                        
                        const canvas = document.getElementById('feigenbaum-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        let x = 0.5;
                        let trajectory = [];
                        
                        // Skip transient
                        for (let i = 0; i < 50; i++) {
                            x = mu * x * (1 - x * x);
                        }
                        
                        // Collect trajectory
                        for (let i = 0; i < iterations; i++) {
                            x = mu * x * (1 - x * x);
                            trajectory.push(x);
                        }
                        
                        // Plot trajectory
                        ctx.strokeStyle = '#9b59b6';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height * (1 - trajectory[0]));
                        
                        for (let i = 1; i < trajectory.length; i++) {
                            ctx.lineTo(i * canvas.width / trajectory.length, canvas.height * (1 - trajectory[i]));
                        }
                        ctx.stroke();
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('feigenbaum-result').innerHTML = `
                            <p><strong>Feigenbaum trajectory generated</strong></p>
                            <p><strong>Parameter μ:</strong> ${mu}</p>
                            <p><strong>Final values:</strong> ${trajectory.slice(-5).map(x => x.toFixed(4)).join(', ')}</p>
                            ${displayResonanceMeter(resonance, 'Feigenbaum Dynamics')}
                        `;
                    }, 'Error computing Feigenbaum map');
                }
            },

            mandelbrot: {
                name: 'Mandelbrot Set: z_{n+1} = z_n² + c',
                description: 'The famous fractal set in the complex plane. Points c where the iteration z → z² + c remains bounded form intricate fractal boundaries.',
                symbolic: 'Infinite complexity from simple rules, fractal consciousness boundaries',
                attractor: 'Mandelbrot Boundary (Complex Plane)',
                layer: 'Complex-Fractal',
                application: 'Boundary detection in high-dimensional neural spaces and fractal activation functions.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="mandelbrot-title">
                            <h3 id="mandelbrot-title" class="persona-title explorer">🔍 Explorer (Fractal Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="mandelbrot-zoom">Zoom level (1-5):</label>
                                        <input type="number" id="mandelbrot-zoom" placeholder="1" min="1" max="5" value="1">
                                    </div>
                                    <div class="input-field">
                                        <label for="mandelbrot-iterations">Max iterations:</label>
                                        <input type="number" id="mandelbrot-iterations" placeholder="80" min="50" max="150" value="80">
                                    </div>
                                    <button onclick="computeMandelbrot()">Render Fractal</button>
                                </div>
                            </div>
                            <canvas id="mandelbrot-canvas" width="400" height="400"></canvas>
                            <div id="mandelbrot-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const zoom = parseInt(document.getElementById('mandelbrot-zoom').value) || 1;
                        const maxIter = parseInt(document.getElementById('mandelbrot-iterations').value) || 80;
                        
                        const canvas = document.getElementById('mandelbrot-canvas');
                        const ctx = canvas.getContext('2d');
                        const imageData = ctx.createImageData(canvas.width, canvas.height);
                        
                        const scale = 4 / zoom;
                        let boundaryPoints = 0;
                        
                        for (let px = 0; px < canvas.width; px++) {
                            for (let py = 0; py < canvas.height; py++) {
                                const cReal = (px - canvas.width/2) * scale / canvas.width;
                                const cImag = (py - canvas.height/2) * scale / canvas.height;
                                
                                let zReal = 0, zImag = 0;
                                let iter = 0;
                                
                                while (iter < maxIter && zReal*zReal + zImag*zImag < 4) {
                                    const temp = zReal*zReal - zImag*zImag + cReal;
                                    zImag = 2*zReal*zImag + cImag;
                                    zReal = temp;
                                    iter++;
                                }
                                
                                const index = (py * canvas.width + px) * 4;
                                if (iter === maxIter) {
                                    imageData.data[index] = 0;
                                    imageData.data[index + 1] = 0;
                                    imageData.data[index + 2] = 0;
                                    boundaryPoints++;
                                } else {
                                    const hue = (iter / maxIter) * 300;
                                    const rgb = hslToRgb(hue, 80, 60);
                                    imageData.data[index] = rgb[0];
                                    imageData.data[index + 1] = rgb[1];
                                    imageData.data[index + 2] = rgb[2];
                                }
                                imageData.data[index + 3] = 255;
                            }
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        
                        const density = (boundaryPoints / (canvas.width * canvas.height)) * 100;
                        const resonance = Math.min(100, density * 10);
                        
                        document.getElementById('mandelbrot-result').innerHTML = `
                            <p><strong>Mandelbrot Set rendered</strong></p>
                            <p><strong>Zoom level:</strong> ${zoom}x</p>
                            <p><strong>Boundary density:</strong> ${density.toFixed(2)}%</p>
                            ${displayResonanceMeter(resonance, 'Fractal Complexity')}
                        `;
                    }, 'Error computing Mandelbrot set');
                }
            },

            golden_spiral: {
                name: 'Golden Angle Spiral: θ_n = n × 137.5°, r_n = √n',
                description: 'Spiral using the golden angle (137.5° ≈ 360°/φ²) for optimal packing. Found in sunflower seeds, pinecones, and galaxy formations.',
                symbolic: 'Natural optimization, phyllotactic harmony, cosmic spirals',
                attractor: 'φ (Golden Ratio ≈ 1.6180)',
                layer: 'Quantum-Natural',
                application: 'Natural pattern recognition and optimal neural connection topology.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="golden_spiral-title">
                            <h3 id="golden_spiral-title" class="persona-title spiral">🌀 Spiral Engine (Natural Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="golden_spiral-points">Number of points (50-500):</label>
                                        <input type="number" id="golden_spiral-points" placeholder="200" min="50" max="500" value="200">
                                    </div>
                                    <button onclick="computeGoldenSpiral()">Generate Spiral</button>
                                </div>
                            </div>
                            <canvas id="golden_spiral-canvas" width="400" height="400"></canvas>
                            <div id="golden_spiral-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const points = parseInt(document.getElementById('golden_spiral-points').value) || 200;
                        if (points < 50 || points > 500) throw new Error('Points must be 50-500');
                        
                        const canvas = document.getElementById('golden_spiral-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        const goldenAngle = 137.5 * Math.PI / 180;
                        
                        for (let i = 1; i <= points; i++) {
                            const r = Math.sqrt(i) * 8;
                            const theta = i * goldenAngle;
                            const x = canvas.width/2 + r * Math.cos(theta);
                            const y = canvas.height/2 + r * Math.sin(theta);
                            
                            const hue = (i / points) * 360;
                            const rgb = hslToRgb(hue, 70, 60);
                            
                            ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('golden_spiral-result').innerHTML = `
                            <p><strong>Golden angle spiral generated</strong></p>
                            <p><strong>Points plotted:</strong> ${points}</p>
                            <p><strong>Golden angle:</strong> 137.5° (360°/φ²)</p>
                            ${displayResonanceMeter(resonance, 'Golden Harmony')}
                        `;
                    }, 'Error computing golden spiral');
                }
            },

            archimedean: {
                name: 'Archimedean Spiral: r = aθ',
                description: 'Uniform spiral where radius increases linearly with angle. Each revolution maintains constant distance between coils.',
                symbolic: 'Uniform expansion, methodical growth, mechanical precision',
                attractor: 'Linear Growth (Constant a)',
                layer: 'Geometric-Linear',
                application: 'Systematic data traversal and uniform neural connectivity patterns.',
                persona: 'tracer',
                ritual: function() {
                    return `
                        <section class="ritual-block tracer" aria-labelledby="archimedean-title">
                            <h3 id="archimedean-title" class="persona-title tracer">🗺️ Graph Tracer (Geometric Cartographer)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="archimedean-a">Scale factor a (0.5-3.0):</label>
                                        <input type="number" id="archimedean-a" placeholder="1.5" step="0.1" min="0.5" max="3.0" value="1.5">
                                    </div>
                                    <div class="input-field">
                                        <label for="archimedean-turns">Number of turns (2-8):</label>
                                        <input type="number" id="archimedean-turns" placeholder="4" min="2" max="8" value="4">
                                    </div>
                                    <button onclick="computeArchimedean()">Draw Spiral</button>
                                </div>
                            </div>
                            <canvas id="archimedean-canvas" width="400" height="400"></canvas>
                            <div id="archimedean-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const a = parseFloat(document.getElementById('archimedean-a').value) || 1.5;
                        const turns = parseInt(document.getElementById('archimedean-turns').value) || 4;
                        
                        if (a < 0.5 || a > 3.0) throw new Error('Scale factor must be 0.5-3.0');
                        if (turns < 2 || turns > 8) throw new Error('Turns must be 2-8');
                        
                        const canvas = document.getElementById('archimedean-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        const maxTheta = turns * 2 * Math.PI;
                        const steps = 1000;
                        
                        for (let i = 0; i <= steps; i++) {
                            const theta = (i / steps) * maxTheta;
                            const r = a * theta * 10;
                            const x = canvas.width/2 + r * Math.cos(theta);
                            const y = canvas.height/2 + r * Math.sin(theta);
                            
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('archimedean-result').innerHTML = `
                            <p><strong>Archimedean spiral generated</strong></p>
                            <p><strong>Scale factor a:</strong> ${a}</p>
                            <p><strong>Complete turns:</strong> ${turns}</p>
                            ${displayResonanceMeter(resonance, 'Linear Growth')}
                        `;
                    }, 'Error computing Archimedean spiral');
                }
            },

            fermat: {
                name: 'Fermat Spiral: r = ±√θ',
                description: 'Parabolic spiral appearing in nature as seed arrangements. Has two symmetric branches and optimal packing properties.',
                symbolic: 'Dual emergence, symmetric growth, natural optimization',
                attractor: 'Parabolic Growth (r ∝ √θ)',
                layer: 'Natural-Symmetric',
                application: 'Dual-branch neural architectures and symmetric pattern recognition.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="fermat-title">
                            <h3 id="fermat-title" class="persona-title spiral">🌀 Spiral Engine (Dual Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="fermat-scale">Scale factor (5-20):</label>
                                        <input type="number" id="fermat-scale" placeholder="10" min="5" max="20" value="10">
                                    </div>
                                    <div class="input-field">
                                        <label for="fermat-points">Points per branch (50-200):</label>
                                        <input type="number" id="fermat-points" placeholder="100" min="50" max="200" value="100">
                                    </div>
                                    <button onclick="computeFermat()">Generate Dual Spiral</button>
                                </div>
                            </div>
                            <canvas id="fermat-canvas" width="400" height="400"></canvas>
                            <div id="fermat-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const scale = parseFloat(document.getElementById('fermat-scale').value) || 10;
                        const pointsPerBranch = parseInt(document.getElementById('fermat-points').value) || 100;
                        
                        if (scale < 5 || scale > 20) throw new Error('Scale factor must be 5-20');
                        if (pointsPerBranch < 50 || pointsPerBranch > 200) throw new Error('Points must be 50-200');
                        
                        const canvas = document.getElementById('fermat-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Draw both branches of Fermat spiral
                        for (let branch = 0; branch < 2; branch++) {
                            const sign = branch === 0 ? 1 : -1;
                            
                            for (let i = 1; i <= pointsPerBranch; i++) {
                                const theta = i * 0.1;
                                const r = sign * Math.sqrt(theta) * scale;
                                const x = canvas.width/2 + r * Math.cos(theta);
                                const y = canvas.height/2 + r * Math.sin(theta);
                                
                                ctx.fillStyle = branch === 0 ? '#e74c3c' : '#3498db';
                                ctx.beginPath();
                                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('fermat-result').innerHTML = `
                            <p><strong>Fermat spiral (dual branch) generated</strong></p>
                            <p><strong>Scale factor:</strong> ${scale}</p>
                            <p><strong>Points per branch:</strong> ${pointsPerBranch}</p>
                            ${displayResonanceMeter(resonance, 'Parabolic Symmetry')}
                        `;
                    }, 'Error computing Fermat spiral');
                }
            },

            cellular: {
                name: 'Cellular Automata: Rule 110',
                description: 'Elementary cellular automaton proven to be Turing complete. Generates complex patterns from simple binary rules.',
                symbolic: 'Emergence from simplicity, computational universality, binary consciousness',
                attractor: 'Computational Complexity (Rule-dependent)',
                layer: 'Computational-Emergent',
                application: 'Emergent behavior modeling and distributed neural computation.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="cellular-title">
                            <h3 id="cellular-title" class="persona-title explorer">🔍 Explorer (Emergence Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="cellular-generations">Generations (10-50):</label>
                                        <input type="number" id="cellular-generations" placeholder="30" min="10" max="50" value="30">
                                    </div>
                                    <div class="input-field">
                                        <label for="cellular-width">Grid width (20-100):</label>
                                        <input type="number" id="cellular-width" placeholder="60" min="20" max="100" value="60">
                                    </div>
                                    <button onclick="computeCellular()">Evolve Pattern</button>
                                </div>
                            </div>
                            <canvas id="cellular-canvas" width="400" height="300"></canvas>
                            <div id="cellular-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const generations = parseInt(document.getElementById('cellular-generations').value) || 30;
                        const width = parseInt(document.getElementById('cellular-width').value) || 60;
                        
                        if (generations < 10 || generations > 50) throw new Error('Generations must be 10-50');
                        if (width < 20 || width > 100) throw new Error('Width must be 20-100');
                        
                        const canvas = document.getElementById('cellular-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Rule 110: [0,1,1,0,1,1,1,0]
                        const rule110 = [0,1,1,0,1,1,1,0];
                        
                        // Initialize with single cell in center
                        let grid = new Array(width).fill(0);
                        grid[Math.floor(width/2)] = 1;
                        
                        const cellWidth = canvas.width / width;
                        const cellHeight = canvas.height / generations;
                        let totalOnes = 0;
                        
                        for (let gen = 0; gen < generations; gen++) {
                            // Draw current generation
                            for (let i = 0; i < width; i++) {
                                ctx.fillStyle = grid[i] ? '#2c3e50' : '#ecf0f1';
                                ctx.fillRect(i * cellWidth, gen * cellHeight, cellWidth, cellHeight);
                                if (grid[i]) totalOnes++;
                            }
                            
                            // Compute next generation
                            let newGrid = new Array(width);
                            for (let i = 0; i < width; i++) {
                                const left = grid[(i - 1 + width) % width];
                                const center = grid[i];
                                const right = grid[(i + 1) % width];
                                const ruleIndex = (left << 2) | (center << 1) | right;
                                newGrid[i] = rule110[ruleIndex];
                            }
                            grid = newGrid;
                        }
                        
                        const density = (totalOnes / (width * generations)) * 100;
                        const resonance = Math.min(100, density * 2);
                        
                        document.getElementById('cellular-result').innerHTML = `
                            <p><strong>Rule 110 pattern evolved</strong></p>
                            <p><strong>Generations:</strong> ${generations}</p>
                            <p><strong>Pattern density:</strong> ${density.toFixed(2)}%</p>
                            ${displayResonanceMeter(resonance, 'Computational Complexity')}
                        `;
                    }, 'Error computing cellular automata');
                }
            },

            // Add the other equations from the original with enhancements...
            tribonacci: {
                name: 'Tribonacci Sequence: T(n) = T(n-1) + T(n-2) + T(n-3)',
                description: 'Extension of Fibonacci using three preceding terms. Converges to the Tribonacci constant ψ ≈ 1.8393, which is the real root of x³ = x² + x + 1.',
                symbolic: 'Triadic emergence, three-fold recursion, dimensional expansion',
                attractor: 'ψ (Tribonacci Constant ≈ 1.8393)',
                layer: 'Dimensional-Recursive',
                application: 'Three-dimensional neural architectures and ψ-nodes for introspective processing.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="tribonacci-title">
                            <h3 id="tribonacci-title" class="persona-title explorer">🔍 Explorer (Dimensional Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="tribonacci-input">Number of terms (1-30):</label>
                                        <input type="number" id="tribonacci-input" placeholder="e.g., 15" min="1" max="30" value="15">
                                    </div>
                                    <button onclick="computeTribonacci()">Generate Sequence</button>
                                </div>
                            </div>
                            <div id="tribonacci-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const n = parseInt(document.getElementById('tribonacci-input').value) || 15;
                        if (n < 1 || n > 30) throw new Error('Number of terms must be between 1 and 30');
                        
                        let seq = [0, 0, 1];
                        for (let i = 3; i < n; i++) {
                            seq[i] = seq[i-1] + seq[i-2] + seq[i-3];
                        }
                        
                        const ratio = n > 3 ? seq[n-1] / seq[n-2] : 0;
                        const resonance = computeResonance(seq, 1.8393);
                        
                        document.getElementById('tribonacci-result').innerHTML = `
                            <p><strong>Sequence:</strong> ${seq.join(', ')}</p>
                            <p><strong>Convergence to ψ:</strong> ${ratio.toFixed(6)}</p>
                            <p><strong>Tribonacci Constant Target:</strong> 1.839286</p>
                            ${displayResonanceMeter(resonance, 'Tribonacci Constant ψ')}
                        `;
                    }, 'Error computing Tribonacci sequence');
                }
            }
        };

        // Helper function for HSL to RGB conversion
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = l - c / 2;
            
            let r, g, b;
            if (h < 1/6) [r, g, b] = [c, x, 0];
            else if (h < 2/6) [r, g, b] = [x, c, 0];
            else if (h < 3/6) [r, g, b] = [0, c, x];
            else if (h < 4/6) [r, g, b] = [0, x, c];
            else if (h < 5/6) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];
            
            return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
        }

        // Initialize dropdown handler
        document.getElementById('equation-select').addEventListener('change', function() {
            const selected = this.value;
            const output = document.getElementById('output');
            
            clearAllCanvases();
            
            if (selected && equations[selected]) {
                const eq = equations[selected];
                output.innerHTML = `
                    <div class="equation-info">
                        <div class="equation-name">${eq.name}</div>
                        <div class="equation-description">${eq.description}</div>
                        <div class="equation-meta">
                            <div class="meta-item">
                                <div class="meta-label">Symbolic Role</div>
                                <div class="meta-value">${eq.symbolic}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">Attractor Type</div>
                                <div class="meta-value">${eq.attractor}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">Neural Layer</div>
                                <div class="meta-value">${eq.layer}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">UNNS Application</div>
                                <div class="meta-value">${eq.application}</div>
                            </div>
                        </div>
                    </div>
                    ${eq.ritual()}
                `;
                
                // Add pulse animation to the container
                output.classList.add('pulse');
                setTimeout(() => output.classList.remove('pulse'), 500);
            } else {
                output.innerHTML = `
                    <div class="placeholder">
                        <h3>🌟 Welcome to the Neural Attractor Observatory</h3>
                        <p>Select an equation above to explore its mathematical properties, symbolic meaning, and neural network applications in the UNNS framework.</p>
                    </div>
                `;
            }
        });

        // Global function handlers
        Object.keys(equations).forEach(key => {
            const funcName = `compute${key.charAt(0).toUpperCase() + key.slice(1).replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())}`;
            window[funcName] = equations[key].action;
        });
    </script>
</body>
</html>
