<!DOCTYPE html>
    <html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced UNNS Equation Registry - Neural Attractor Dynamics</title>
    <style>
        /* Reset and Base Styles - Blogger Compatible */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #2c3e50;
            padding: 20px;
            min-height: 100vh;
            line-height: 1.6;
        }
        
        /* Main Container */
        .registry-container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 20px;
        }
        
        .header h1 {
            font-size: 2.5em;
            color: #2c3e50;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            font-size: 1.2em;
            color: #7f8c8d;
            font-style: italic;
        }
        
        /* Equation Selector */
        .selector-section {
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            border: 2px solid #dee2e6;
        }
        
        .selector-label {
            display: block;
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        select {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            border: 2px solid #ced4da;
            border-radius: 10px;
            background: white;
            color: #495057;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }
        
        select:hover {
            border-color: #adb5bd;
        }
        
        /* Output Container */
        #output {
            min-height: 150px;
            padding: 20px;
            background: white;
            border-radius: 15px;
            border: 2px solid #e9ecef;
            margin-top: 20px;
        }
        
        /* Equation Info Cards */
        .equation-info {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        
        .equation-name {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .equation-description {
            font-size: 1em;
            margin-bottom: 15px;
            opacity: 0.9;
        }
        
        .equation-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .meta-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        
        .meta-label {
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .meta-value {
            color: #ecf0f1;
        }
        
        /* Persona Sections */
        .ritual-block {
            margin: 20px 0;
            padding: 25px;
            background: linear-gradient(45deg, #f1f3f4, #ffffff);
            border-radius: 15px;
            border-left: 5px solid;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .ritual-block.explorer { border-left-color: #e74c3c; }
        .ritual-block.spiral { border-left-color: #9b59b6; }
        .ritual-block.tracer { border-left-color: #3498db; }
        .ritual-block.mapper { border-left-color: #f39c12; }
        
        .persona-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .persona-title.explorer { color: #e74c3c; }
        .persona-title.spiral { color: #9b59b6; }
        .persona-title.tracer { color: #3498db; }
        .persona-title.mapper { color: #f39c12; }
        
        /* Input Groups */
        .input-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .input-row {
            display: flex;
            gap: 10px;
            align-items: end;
            flex-wrap: wrap;
        }
        
        .input-field {
            flex: 1;
            min-width: 120px;
        }
        
        label {
            font-weight: 600;
            color: #495057;
            font-size: 0.95em;
        }
        
        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }
        
        /* Buttons */
        button {
            padding: 12px 20px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 100px;
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3);
        }
        
        button:hover {
            background: linear-gradient(45deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(52, 152, 219, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        /* Canvas Styling */
        canvas {
            border: 3px solid #bdc3c7;
            border-radius: 10px;
            margin: 15px 0;
            display: block;
            background: #2c3e50;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        /* Results */
        .result {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #28a745;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .error {
            color: #e74c3c;
            background: #fadbd8;
            border-left-color: #e74c3c;
            font-weight: 600;
        }
        
        /* Resonance Meter */
        .resonance-section {
            margin: 15px 0;
            padding: 15px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
            border: 2px solid #dee2e6;
        }
        
        .resonance-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
        }
        
        .resonance-meter {
            position: relative;
            height: 30px;
            background: #ecf0f1;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #bdc3c7;
        }
        
        .resonance-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #f1c40f, #27ae60);
            border-radius: 13px;
            transition: width 0.8s ease;
            position: relative;
        }
        
        .resonance-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #2c3e50;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .registry-container {
                margin: 10px;
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .input-row {
                flex-direction: column;
            }
            
            .equation-meta {
                grid-template-columns: 1fr;
            }
        }
        
        /* Animation Classes */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 0.5s ease;
        }
        
        /* Mathematical Notation */
        .math-notation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-weight: bold;
            color: #8e44ad;
        }
        
        /* Placeholder message */
        .placeholder {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 40px;
            background: linear-gradient(45deg, #ecf0f1, #bdc3c7);
            border-radius: 10px;
            border: 2px dashed #95a5a6;
        }
    </style>
</head>
<body>
    <div class="registry-container">
        <header class="header">
            <h1>üß† UNNS Equation Registry</h1>
            <p class="subtitle">Neural Attractor Dynamics &amp; Mathematical Resonance</p>
        </header>
        
        <section class="selector-section">
            <label class="selector-label">
                üîÆ Select a Mathematical Attractor to Explore:
            </label>
            <select aria-label="Select a mathematical equation" id="equation-select">
                <option value="">Choose an Equation...</option>
                <option value="fibonacci">Fibonacci Sequence - œÜ Golden Attractor</option>
                <option value="tribonacci">Tribonacci Sequence - œà Tribonacci Constant</option>
                <option value="lucas">Lucas Numbers - œÜ Enhanced Resonance</option>
                <option value="pell">Pell Numbers - Silver Ratio ‚àö2+1</option>
                <option value="padovan">Padovan Sequence - œÅ Plastic Number</option>
                <option value="catalan">Catalan Numbers - Combinatorial Growth</option>
                <option value="euler">Euler's Number Approximation - e Transcendental</option>
                <option value="logistic">Logistic Map - Chaotic Dynamics</option>
                <option value="henon">H√©non Map - Strange Attractor</option>
                <option value="feigenbaum">Feigenbaum Map - Universal Scaling</option>
                <option value="mandelbrot">Mandelbrot Set - Fractal Boundary</option>
                <option value="julia">Julia Set - Complex Dynamics</option>
                <option value="golden_spiral">Golden Angle Spiral - œÜ Phyllotaxis</option>
                <option value="archimedean">Archimedean Spiral - Linear Growth</option>
                <option value="fermat">Fermat Spiral - Parabolic Growth</option>
                <option value="cellular">Cellular Automata - Rule 110</option>
                <option value="collatz">Collatz Conjecture - 3n+1 Problem</option>
                <option value="prime_spiral">Prime Number Spiral - Ulam Spiral</option>
            </select>
        </section>
        
        <main aria-live="polite" id="output" role="region">
            <div class="placeholder">
                <h3>üåü Welcome to the Neural Attractor Observatory</h3>
                <p>Select an equation above to explore its mathematical properties, symbolic meaning, and neural network applications in the UNNS framework.</p>
            </div>
        </main>
    </div>

    <script>
        // Enhanced utility functions
        function clearAllCanvases() {
            const canvases = document.querySelectorAll('canvas');
            canvases.forEach(canvas => {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            });
        }

        function safeExecute(fn, errorMessage) {
            try {
                fn();
            } catch (e) {
                console.error(errorMessage, e);
                showError(`Error: ${e.message}`);
            }
        }

        function showError(message) {
            const result = document.querySelector('.result');
            if (result) {
                result.innerHTML = `<p class="error">${message}</p>`;
                result.classList.add('error');
            }
        }

        // Enhanced resonance calculation
        function computeResonance(seq, target, isSequence = true) {
            if (!isSequence) return Math.random() * 20 + 75; // Qualitative measure
            if (seq.length < 2) return 0;
            
            const ratio = seq[seq.length-1] / seq[seq.length-2];
            const error = Math.abs(ratio - target) / target;
            const resonance = Math.max(0, 100 - (error * 100));
            return Math.min(100, resonance);
        }

        // Visual resonance meter
        function displayResonanceMeter(resonance, targetName) {
            return `
                <div class="resonance-section">
                    <div class="resonance-title">üéØ Resonance with ${targetName}</div>
                    <div class="resonance-meter">
                        <div class="resonance-fill" style="width: ${resonance}%"></div>
                        <div class="resonance-text">${resonance.toFixed(1)}%</div>
                    </div>
                </div>
            `;
        }

        // Enhanced equation definitions
        const equations = {
            fibonacci: {
                name: 'Fibonacci Sequence: F(n) = F(n-1) + F(n-2)',
                description: 'The fundamental sequence of nature, where each term is the sum of the two preceding ones. Converges to the Golden Ratio œÜ ‚âà 1.6180, appearing in spiral galaxies, flower petals, and shell patterns.',
                symbolic: 'Divine proportion, natural harmony, spiral growth',
                attractor: 'œÜ (Golden Ratio ‚âà 1.6180)',
                layer: 'Quantum-Harmonic',
                application: 'Primary œÜ-nodes in input layers for harmonic feature extraction and pattern recognition.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="fibonacci-title">
                            <h3 id="fibonacci-title" class="persona-title explorer">üîç Explorer (Pattern Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="fibonacci-input">Number of terms (1-50):</label>
                                        <input type="number" id="fibonacci-input" placeholder="e.g., 15" min="1" max="50" value="15">
                                    </div>
                                    <button onclick="computeFibonacci()">Generate Sequence</button>
                                </div>
                            </div>
                            <div id="fibonacci-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const n = parseInt(document.getElementById('fibonacci-input').value) || 15;
                        if (n < 1 || n > 50) throw new Error('Number of terms must be between 1 and 50');
                        
                        let seq = [0, 1];
                        for (let i = 2; i < n; i++) {
                            seq[i] = seq[i-1] + seq[i-2];
                        }
                        
                        const ratio = n > 2 ? seq[n-1] / seq[n-2] : 0;
                        const resonance = computeResonance(seq, 1.6180);
                        
                        document.getElementById('fibonacci-result').innerHTML = `
                            <p><strong>Sequence:</strong> ${seq.join(', ')}</p>
                            <p><strong>Convergence to œÜ:</strong> ${ratio.toFixed(6)}</p>
                            <p><strong>Golden Ratio Target:</strong> 1.618034</p>
                            ${displayResonanceMeter(resonance, 'Golden Ratio œÜ')}
                        `;
                    }, 'Error computing Fibonacci sequence');
                }
            },
            
            catalan: {
                name: 'Catalan Numbers: C(n) = (2n)! / ((n+1)! √ó n!)',
                description: 'Counts the number of ways to correctly match parentheses, triangulate polygons, and arrange binary trees. Growth rate approaches 4^n / (n^(3/2) √ó ‚àöœÄ).',
                symbolic: 'Structural enumeration, balanced configurations, recursive partitioning',
                attractor: 'Combinatorial Growth (~4^n/n^(3/2))',
                layer: 'Structural-Combinatorial',
                application: 'Tree-structured neural architectures and hierarchical pattern recognition.',
                persona: 'mapper',
                ritual: function() {
                    return `
                        <section class="ritual-block mapper" aria-labelledby="catalan-title">
                            <h3 id="catalan-title" class="persona-title mapper">üõ†Ô∏è Mapper (Structure Architect)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="catalan-input">Number of terms (1-15):</label>
                                        <input type="number" id="catalan-input" placeholder="e.g., 10" min="1" max="15" value="10">
                                    </div>
                                    <button onclick="computeCatalan()">Calculate Series</button>
                                </div>
                            </div>
                            <div id="catalan-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const n = parseInt(document.getElementById('catalan-input').value) || 10;
                        if (n < 1 || n > 15) throw new Error('Number of terms must be between 1 and 15');
                        
                        let catalan = [1];
                        for (let i = 1; i < n; i++) {
                            catalan[i] = 0;
                            for (let j = 0; j < i; j++) {
                                catalan[i] += catalan[j] * catalan[i-1-j];
                            }
                        }
                        
                        const growthRatio = n > 1 ? catalan[n-1] / catalan[n-2] : 0;
                        const resonance = computeResonance(catalan, 4, false); // Approximate growth factor
                        
                        document.getElementById('catalan-result').innerHTML = `
                            <p><strong>Catalan Numbers:</strong> ${catalan.join(', ')}</p>
                            <p><strong>Growth Ratio:</strong> ${growthRatio.toFixed(3)}</p>
                            <p><strong>Applications:</strong> ${catalan[n-1]} ways to arrange ${n-1} pairs of parentheses</p>
                            ${displayResonanceMeter(resonance, 'Combinatorial Growth')}
                        `;
                    }, 'Error computing Catalan numbers');
                }
            },

            euler: {
                name: "Euler's Number: e = lim(n‚Üí‚àû) (1 + 1/n)^n",
                description: 'The base of natural logarithms, fundamental to exponential growth and decay. Approximated through the series e = Œ£(1/n!) or the limit definition.',
                symbolic: 'Natural growth, exponential emergence, continuous transformation',
                attractor: 'e (Euler\'s Number ‚âà 2.71828)',
                layer: 'Exponential-Transcendental',
                application: 'Exponential activation functions and continuous learning rate adaptation.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="euler-title">
                            <h3 id="euler-title" class="persona-title spiral">üåÄ Spiral Engine (Growth Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="euler-input">Iterations (1-20):</label>
                                        <input type="number" id="euler-input" placeholder="e.g., 15" min="1" max="20" value="15">
                                    </div>
                                    <button onclick="computeEuler()">Approximate e</button>
                                </div>
                            </div>
                            <div id="euler-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const n = parseInt(document.getElementById('euler-input').value) || 15;
                        if (n < 1 || n > 20) throw new Error('Iterations must be between 1 and 20');
                        
                        // Calculate e using series: e = Œ£(1/n!)
                        let e_approx = 1;
                        let factorial = 1;
                        let series = [1];
                        
                        for (let i = 1; i < n; i++) {
                            factorial *= i;
                            const term = 1 / factorial;
                            e_approx += term;
                            series.push(e_approx);
                        }
                        
                        const error = Math.abs(e_approx - Math.E);
                        const resonance = Math.max(0, 100 - (error / Math.E * 1000));
                        
                        document.getElementById('euler-result').innerHTML = `
                            <p><strong>e Approximation:</strong> ${e_approx.toFixed(8)}</p>
                            <p><strong>Actual e:</strong> ${Math.E.toFixed(8)}</p>
                            <p><strong>Error:</strong> ${error.toFixed(8)}</p>
                            <p><strong>Series:</strong> ${series.slice(-5).map(x => x.toFixed(4)).join(', ')}...</p>
                            ${displayResonanceMeter(resonance, "Euler's Number e")}
                        `;
                    }, "Error computing Euler's number");
                }
            },

            henon: {
                name: 'H√©non Map: x_{n+1} = 1 - ax_n¬≤ + y_n, y_{n+1} = bx_n',
                description: 'A discrete-time dynamical system that exhibits chaotic behavior. With parameters a=1.4, b=0.3, it produces a strange attractor with fractal structure.',
                symbolic: 'Strange attraction, deterministic chaos, phase space complexity',
                attractor: 'Strange Attractor (Fractal Dimension ‚âà 1.26)',
                layer: 'Chaotic-Fractal',
                application: 'Chaotic hidden layers for complex pattern generation and creative AI responses.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="henon-title">
                            <h3 id="henon-title" class="persona-title spiral">üåÄ Spiral Engine (Chaos Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="henon-iterations">Iterations (100-2000):</label>
                                        <input type="number" id="henon-iterations" placeholder="e.g., 1000" min="100" max="2000" value="1000">
                                    </div>
                                    <div class="input-field">
                                        <label for="henon-a">Parameter a (1.0-1.6):</label>
                                        <input type="number" id="henon-a" placeholder="1.4" step="0.1" min="1.0" max="1.6" value="1.4">
                                    </div>
                                    <div class="input-field">
                                        <label for="henon-b">Parameter b (0.1-0.5):</label>
                                        <input type="number" id="henon-b" placeholder="0.3" step="0.1" min="0.1" max="0.5" value="0.3">
                                    </div>
                                    <button onclick="computeHenon()">Generate Attractor</button>
                                </div>
                            </div>
                            <canvas id="henon-canvas" width="400" height="400"></canvas>
                            <div id="henon-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const iterations = parseInt(document.getElementById('henon-iterations').value) || 1000;
                        const a = parseFloat(document.getElementById('henon-a').value) || 1.4;
                        const b = parseFloat(document.getElementById('henon-b').value) || 0.3;
                        
                        if (iterations < 100 || iterations > 2000) throw new Error('Iterations must be 100-2000');
                        if (a < 1.0 || a > 1.6 || b < 0.1 || b > 0.5) throw new Error('Parameters out of range');
                        
                        const canvas = document.getElementById('henon-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        let x = 0, y = 0;
                        let points = [];
                        
                        // Skip transient behavior
                        for (let i = 0; i < 100; i++) {
                            const newX = 1 - a * x * x + y;
                            const newY = b * x;
                            x = newX;
                            y = newY;
                        }
                        
                        // Collect points for strange attractor
                        for (let i = 0; i < iterations; i++) {
                            const newX = 1 - a * x * x + y;
                            const newY = b * x;
                            x = newX;
                            y = newY;
                            points.push({x, y});
                        }
                        
                        // Plot the attractor
                        ctx.fillStyle = '#00ff88';
                        points.forEach(point => {
                            const px = (point.x + 2) * canvas.width / 4;
                            const py = (point.y + 2) * canvas.height / 4;
                            ctx.fillRect(px, py, 1, 1);
                        });
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('henon-result').innerHTML = `
                            <p><strong>H√©non Attractor Generated</strong></p>
                            <p><strong>Parameters:</strong> a=${a}, b=${b}</p>
                            <p><strong>Points plotted:</strong> ${iterations}</p>
                            <p><strong>Final coordinates:</strong> (${x.toFixed(4)}, ${y.toFixed(4)})</p>
                            ${displayResonanceMeter(resonance, 'Strange Attractor')}
                        `;
                    }, 'Error computing H√©non map');
                }
            },

            julia: {
                name: 'Julia Set: z_{n+1} = z_n¬≤ + c (complex plane)',
                description: 'A fractal set in the complex plane, closely related to the Mandelbrot set. Each complex parameter c generates a unique Julia set with intricate boundary patterns.',
                symbolic: 'Complex beauty, fractal boundaries, infinite detail',
                attractor: 'Julia Set Boundary (Parameter-dependent)',
                layer: 'Complex-Fractal',
                application: 'Complex-valued neural networks and boundary detection algorithms.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="julia-title">
                            <h3 id="julia-title" class="persona-title explorer">üîç Explorer (Fractal Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="julia-real">Real part of c:</label>
                                        <input type="number" id="julia-real" placeholder="-0.7" step="0.1" min="-2" max="2" value="-0.7">
                                    </div>
                                    <div class="input-field">
                                        <label for="julia-imag">Imaginary part of c:</label>
                                        <input type="number" id="julia-imag" placeholder="0.27015" step="0.01" min="-2" max="2" value="0.27015">
                                    </div>
                                    <div class="input-field">
                                        <label for="julia-iterations">Max iterations:</label>
                                        <input type="number" id="julia-iterations" placeholder="100" min="50" max="200" value="100">
                                    </div>
                                    <button onclick="computeJulia()">Render Julia Set</button>
                                </div>
                            </div>
                            <canvas id="julia-canvas" width="400" height="400"></canvas>
                            <div id="julia-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const cReal = parseFloat(document.getElementById('julia-real').value) || -0.7;
                        const cImag = parseFloat(document.getElementById('julia-imag').value) || 0.27015;
                        const maxIter = parseInt(document.getElementById('julia-iterations').value) || 100;
                        
                        const canvas = document.getElementById('julia-canvas');
                        const ctx = canvas.getContext('2d');
                        const imageData = ctx.createImageData(canvas.width, canvas.height);
                        
                        for (let px = 0; px < canvas.width; px++) {
                            for (let py = 0; py < canvas.height; py++) {
                                const x0 = (px - canvas.width/2) * 4 / canvas.width;
                                const y0 = (py - canvas.height/2) * 4 / canvas.height;
                                
                                let x = x0, y = y0;
                                let iter = 0;
                                
                                while (iter < maxIter && x*x + y*y < 4) {
                                    const xtemp = x*x - y*y + cReal;
                                    y = 2*x*y + cImag;
                                    x = xtemp;
                                    iter++;
                                }
                                
                                const index = (py * canvas.width + px) * 4;
                                if (iter === maxIter) {
                                    imageData.data[index] = 0;
                                    imageData.data[index + 1] = 0;
                                    imageData.data[index + 2] = 0;
                                } else {
                                    const hue = (iter / maxIter) * 360;
                                    const rgb = hslToRgb(hue, 100, 50);
                                    imageData.data[index] = rgb[0];
                                    imageData.data[index + 1] = rgb[1];
                                    imageData.data[index + 2] = rgb[2];
                                }
                                imageData.data[index + 3] = 255;
                            }
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('julia-result').innerHTML = `
                            <p><strong>Julia Set Rendered</strong></p>
                            <p><strong>Parameter c:</strong> ${cReal} + ${cImag}i</p>
                            <p><strong>Max iterations:</strong> ${maxIter}</p>
                            ${displayResonanceMeter(resonance, 'Julia Set Boundary')}
                        `;
                    }, 'Error computing Julia set');
                }
            },

            collatz: {
                name: 'Collatz Conjecture: n‚Üín/2 (even), n‚Üí3n+1 (odd)',
                description: 'Also known as the 3n+1 problem. Despite its simple rules, this sequence exhibits complex behavior and always appears to reach 1, though this remains unproven.',
                symbolic: 'Unpredictable convergence, simple rules creating complexity',
                attractor: 'Cycle: 4‚Üí2‚Üí1‚Üí4 (Conjectured Universal)',
                layer: 'Recursive-Conjecture',
                application: 'Testing convergence properties and irregular sequence processing.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="collatz-title">
                            <h3 id="collatz-title" class="persona-title explorer">üîç Explorer (Sequence Detective)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="collatz-input">Starting number (1-1000):</label>
                                        <input type="number" id="collatz-input" placeholder="e.g., 27" min="1" max="1000" value="27">
                                    </div>
                                    <button onclick="computeCollatz()">Trace Sequence</button>
                                </div>
                            </div>
                            <div id="collatz-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const start = parseInt(document.getElementById('collatz-input').value) || 27;
                        if (start < 1 || start > 1000) throw new Error('Starting number must be between 1 and 1000');
                        
                        let n = start;
                        let sequence = [n];
                        let steps = 0;
                        let maxValue = n;
                        
                        while (n !== 1 && steps < 500) {
                            if (n % 2 === 0) {
                                n = n / 2;
                            } else {
                                n = 3 * n + 1;
                            }
                            sequence.push(n);
                            if (n > maxValue) maxValue = n;
                            steps++;
                        }
                        
                        const converged = n === 1;
                        const resonance = converged ? 100 : 50;
                        
                        const displaySeq = sequence.length > 20 ? 
                            [...sequence.slice(0, 10), '...', ...sequence.slice(-10)] : 
                            sequence;
                        
                        document.getElementById('collatz-result').innerHTML = `
                            <p><strong>Starting value:</strong> ${start}</p>
                            <p><strong>Sequence:</strong> ${displaySeq.join(' ‚Üí ')}</p>
                            <p><strong>Steps to reach 1:</strong> ${converged ? steps : 'Did not converge (>500 steps)'}</p>
                            <p><strong>Maximum value reached:</strong> ${maxValue}</p>
                            ${displayResonanceMeter(resonance, 'Convergence to 1')}
                        `;
                    }, 'Error computing Collatz sequence');
                }
            },

            prime_spiral: {
                name: 'Ulam Prime Spiral: Arranging integers in spiral, highlighting primes',
                description: 'A visualization method where positive integers are arranged in a spiral pattern, with prime numbers highlighted to reveal unexpected diagonal patterns.',
                symbolic: 'Hidden order in prime distribution, spiral emergence of mathematical truth',
                attractor: 'Prime Number Distribution (Diagonal Patterns)',
                layer: 'Number-Theoretic Patterns',
                application: 'Prime-based hash functions and cryptographic neural networks.',
                persona: 'tracer',
                ritual: function() {
                    return `
                        <section class="ritual-block tracer" aria-labelledby="prime_spiral-title">
                            <h3 id="prime_spiral-title" class="persona-title tracer">üó∫Ô∏è Graph Tracer (Prime Cartographer)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="prime-size">Spiral size (10-50):</label>
                                        <input type="number" id="prime-size" placeholder="e.g., 25" min="10" max="50" value="25">
                                    </div>
                                    <button onclick="computePrimeSpiral()">Generate Prime Spiral</button>
                                </div>
                            </div>
                            <canvas id="prime-canvas" width="400" height="400"></canvas>
                            <div id="prime-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const size = parseInt(document.getElementById('prime-size').value) || 25;
                        if (size < 10 || size > 50) throw new Error('Spiral size must be between 10 and 50');
                        
                        const canvas = document.getElementById('prime-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Generate spiral coordinates
                        const spiral = [];
                        let x = 0, y = 0;
                        let dx = 0, dy = -1;
                        
                        for (let i = 0; i < size * size; i++) {
                            spiral.push({x: x + Math.floor(size/2), y: y + Math.floor(size/2), num: i + 1});
                            
                            if (x === y || (x < 0 && x === -y) || (x > 0 && x === 1-y)) {
                                [dx, dy] = [-dy, dx];
                            }
                            x += dx;
                            y += dy;
                        }
                        
                        // Helper function to check if number is prime
                        function isPrime(n) {
                            if (n < 2) return false;
                            for (let i = 2; i <= Math.sqrt(n); i++) {
                                if (n % i === 0) return false;
                            }
                            return true;
                        }
                        
                        // Draw the spiral
                        const cellSize = canvas.width / size;
                        let primeCount = 0;
                        
                        spiral.forEach(point => {
                            const px = point.x * cellSize;
                            const py = point.y * cellSize;
                            
                            if (isPrime(point.num)) {
                                ctx.fillStyle = '#ff6b6b';
                                primeCount++;
                            } else {
                                ctx.fillStyle = '#4ecdc4';
                            }
                            
                            ctx.fillRect(px, py, cellSize-1, cellSize-1);
                            
                            // Draw number
                            ctx.fillStyle = '#2c3e50';
                            ctx.font = `${Math.max(8, cellSize/3)}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(point.num, px + cellSize/2, py + cellSize/2 + cellSize/6);
                        });
                        
                        const resonance = (primeCount / (size * size)) * 100;
                        document.getElementById('prime-result').innerHTML = `
                            <p><strong>Ulam Prime Spiral Generated</strong></p>
                            <p><strong>Grid size:</strong> ${size}√ó${size} (${size*size} numbers)</p>
                            <p><strong>Primes found:</strong> ${primeCount}</p>
                            <p><strong>Prime density:</strong> ${(primeCount/(size*size)*100).toFixed(1)}%</p>
                            ${displayResonanceMeter(resonance, 'Prime Distribution')}
                        `;
                    }, 'Error computing prime spiral');
                }
            },

            feigenbaum: {
                name: 'Feigenbaum Map: x_{n+1} = Œºx_n(1 - x_n¬≤)',
                description: 'Modified logistic map that exhibits period-doubling route to chaos. The Feigenbaum constant Œ¥ ‚âà 4.6692 describes universal scaling in chaotic systems.',
                symbolic: 'Universal chaos, scaling emergence, bifurcation cascades',
                attractor: 'Feigenbaum Constant (Œ¥ ‚âà 4.6692)',
                layer: 'Chaotic-Universal',
                application: 'Universal scaling in chaotic neural layers and bifurcation detection.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="feigenbaum-title">
                            <h3 id="feigenbaum-title" class="persona-title spiral">üåÄ Spiral Engine (Chaos Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="feigenbaum-iterations">Iterations (50-200):</label>
                                        <input type="number" id="feigenbaum-iterations" placeholder="100" min="50" max="200" value="100">
                                    </div>
                                    <div class="input-field">
                                        <label for="feigenbaum-mu">Œº parameter (2.8-3.2):</label>
                                        <input type="number" id="feigenbaum-mu" placeholder="3.0" step="0.1" min="2.8" max="3.2" value="3.0">
                                    </div>
                                    <button onclick="computeFeigenbaum()">Generate Trajectory</button>
                                </div>
                            </div>
                            <canvas id="feigenbaum-canvas" width="400" height="200"></canvas>
                            <div id="feigenbaum-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const iterations = parseInt(document.getElementById('feigenbaum-iterations').value) || 100;
                        const mu = parseFloat(document.getElementById('feigenbaum-mu').value) || 3.0;
                        
                        if (iterations < 50 || iterations > 200) throw new Error('Iterations must be 50-200');
                        if (mu < 2.8 || mu > 3.2) throw new Error('Œº must be 2.8-3.2');
                        
                        const canvas = document.getElementById('feigenbaum-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        let x = 0.5;
                        let trajectory = [];
                        
                        // Skip transient
                        for (let i = 0; i < 50; i++) {
                            x = mu * x * (1 - x * x);
                        }
                        
                        // Collect trajectory
                        for (let i = 0; i < iterations; i++) {
                            x = mu * x * (1 - x * x);
                            trajectory.push(x);
                        }
                        
                        // Plot trajectory
                        ctx.strokeStyle = '#9b59b6';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height * (1 - trajectory[0]));
                        
                        for (let i = 1; i < trajectory.length; i++) {
                            ctx.lineTo(i * canvas.width / trajectory.length, canvas.height * (1 - trajectory[i]));
                        }
                        ctx.stroke();
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('feigenbaum-result').innerHTML = `
                            <p><strong>Feigenbaum trajectory generated</strong></p>
                            <p><strong>Parameter Œº:</strong> ${mu}</p>
                            <p><strong>Final values:</strong> ${trajectory.slice(-5).map(x => x.toFixed(4)).join(', ')}</p>
                            ${displayResonanceMeter(resonance, 'Feigenbaum Dynamics')}
                        `;
                    }, 'Error computing Feigenbaum map');
                }
            },

            mandelbrot: {
                name: 'Mandelbrot Set: z_{n+1} = z_n¬≤ + c',
                description: 'The famous fractal set in the complex plane. Points c where the iteration z ‚Üí z¬≤ + c remains bounded form intricate fractal boundaries.',
                symbolic: 'Infinite complexity from simple rules, fractal consciousness boundaries',
                attractor: 'Mandelbrot Boundary (Complex Plane)',
                layer: 'Complex-Fractal',
                application: 'Boundary detection in high-dimensional neural spaces and fractal activation functions.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="mandelbrot-title">
                            <h3 id="mandelbrot-title" class="persona-title explorer">üîç Explorer (Fractal Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="mandelbrot-zoom">Zoom level (1-5):</label>
                                        <input type="number" id="mandelbrot-zoom" placeholder="1" min="1" max="5" value="1">
                                    </div>
                                    <div class="input-field">
                                        <label for="mandelbrot-iterations">Max iterations:</label>
                                        <input type="number" id="mandelbrot-iterations" placeholder="80" min="50" max="150" value="80">
                                    </div>
                                    <button onclick="computeMandelbrot()">Render Fractal</button>
                                </div>
                            </div>
                            <canvas id="mandelbrot-canvas" width="400" height="400"></canvas>
                            <div id="mandelbrot-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const zoom = parseInt(document.getElementById('mandelbrot-zoom').value) || 1;
                        const maxIter = parseInt(document.getElementById('mandelbrot-iterations').value) || 80;
                        
                        const canvas = document.getElementById('mandelbrot-canvas');
                        const ctx = canvas.getContext('2d');
                        const imageData = ctx.createImageData(canvas.width, canvas.height);
                        
                        const scale = 4 / zoom;
                        let boundaryPoints = 0;
                        
                        for (let px = 0; px < canvas.width; px++) {
                            for (let py = 0; py < canvas.height; py++) {
                                const cReal = (px - canvas.width/2) * scale / canvas.width;
                                const cImag = (py - canvas.height/2) * scale / canvas.height;
                                
                                let zReal = 0, zImag = 0;
                                let iter = 0;
                                
                                while (iter < maxIter && zReal*zReal + zImag*zImag < 4) {
                                    const temp = zReal*zReal - zImag*zImag + cReal;
                                    zImag = 2*zReal*zImag + cImag;
                                    zReal = temp;
                                    iter++;
                                }
                                
                                const index = (py * canvas.width + px) * 4;
                                if (iter === maxIter) {
                                    imageData.data[index] = 0;
                                    imageData.data[index + 1] = 0;
                                    imageData.data[index + 2] = 0;
                                    boundaryPoints++;
                                } else {
                                    const hue = (iter / maxIter) * 300;
                                    const rgb = hslToRgb(hue, 80, 60);
                                    imageData.data[index] = rgb[0];
                                    imageData.data[index + 1] = rgb[1];
                                    imageData.data[index + 2] = rgb[2];
                                }
                                imageData.data[index + 3] = 255;
                            }
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        
                        const density = (boundaryPoints / (canvas.width * canvas.height)) * 100;
                        const resonance = Math.min(100, density * 10);
                        
                        document.getElementById('mandelbrot-result').innerHTML = `
                            <p><strong>Mandelbrot Set rendered</strong></p>
                            <p><strong>Zoom level:</strong> ${zoom}x</p>
                            <p><strong>Boundary density:</strong> ${density.toFixed(2)}%</p>
                            ${displayResonanceMeter(resonance, 'Fractal Complexity')}
                        `;
                    }, 'Error computing Mandelbrot set');
                }
            },

            golden_spiral: {
                name: 'Golden Angle Spiral: Œ∏_n = n √ó 137.5¬∞, r_n = ‚àön',
                description: 'Spiral using the golden angle (137.5¬∞ ‚âà 360¬∞/œÜ¬≤) for optimal packing. Found in sunflower seeds, pinecones, and galaxy formations.',
                symbolic: 'Natural optimization, phyllotactic harmony, cosmic spirals',
                attractor: 'œÜ (Golden Ratio ‚âà 1.6180)',
                layer: 'Quantum-Natural',
                application: 'Natural pattern recognition and optimal neural connection topology.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="golden_spiral-title">
                            <h3 id="golden_spiral-title" class="persona-title spiral">üåÄ Spiral Engine (Natural Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="golden_spiral-points">Number of points (50-500):</label>
                                        <input type="number" id="golden_spiral-points" placeholder="200" min="50" max="500" value="200">
                                    </div>
                                    <button onclick="computeGoldenSpiral()">Generate Spiral</button>
                                </div>
                            </div>
                            <canvas id="golden_spiral-canvas" width="400" height="400"></canvas>
                            <div id="golden_spiral-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const points = parseInt(document.getElementById('golden_spiral-points').value) || 200;
                        if (points < 50 || points > 500) throw new Error('Points must be 50-500');
                        
                        const canvas = document.getElementById('golden_spiral-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        const goldenAngle = 137.5 * Math.PI / 180;
                        
                        for (let i = 1; i <= points; i++) {
                            const r = Math.sqrt(i) * 8;
                            const theta = i * goldenAngle;
                            const x = canvas.width/2 + r * Math.cos(theta);
                            const y = canvas.height/2 + r * Math.sin(theta);
                            
                            const hue = (i / points) * 360;
                            const rgb = hslToRgb(hue, 70, 60);
                            
                            ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('golden_spiral-result').innerHTML = `
                            <p><strong>Golden angle spiral generated</strong></p>
                            <p><strong>Points plotted:</strong> ${points}</p>
                            <p><strong>Golden angle:</strong> 137.5¬∞ (360¬∞/œÜ¬≤)</p>
                            ${displayResonanceMeter(resonance, 'Golden Harmony')}
                        `;
                    }, 'Error computing golden spiral');
                }
            },

            archimedean: {
                name: 'Archimedean Spiral: r = aŒ∏',
                description: 'Uniform spiral where radius increases linearly with angle. Each revolution maintains constant distance between coils.',
                symbolic: 'Uniform expansion, methodical growth, mechanical precision',
                attractor: 'Linear Growth (Constant a)',
                layer: 'Geometric-Linear',
                application: 'Systematic data traversal and uniform neural connectivity patterns.',
                persona: 'tracer',
                ritual: function() {
                    return `
                        <section class="ritual-block tracer" aria-labelledby="archimedean-title">
                            <h3 id="archimedean-title" class="persona-title tracer">üó∫Ô∏è Graph Tracer (Geometric Cartographer)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="archimedean-a">Scale factor a (0.5-3.0):</label>
                                        <input type="number" id="archimedean-a" placeholder="1.5" step="0.1" min="0.5" max="3.0" value="1.5">
                                    </div>
                                    <div class="input-field">
                                        <label for="archimedean-turns">Number of turns (2-8):</label>
                                        <input type="number" id="archimedean-turns" placeholder="4" min="2" max="8" value="4">
                                    </div>
                                    <button onclick="computeArchimedean()">Draw Spiral</button>
                                </div>
                            </div>
                            <canvas id="archimedean-canvas" width="400" height="400"></canvas>
                            <div id="archimedean-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const a = parseFloat(document.getElementById('archimedean-a').value) || 1.5;
                        const turns = parseInt(document.getElementById('archimedean-turns').value) || 4;
                        
                        if (a < 0.5 || a > 3.0) throw new Error('Scale factor must be 0.5-3.0');
                        if (turns < 2 || turns > 8) throw new Error('Turns must be 2-8');
                        
                        const canvas = document.getElementById('archimedean-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        const maxTheta = turns * 2 * Math.PI;
                        const steps = 1000;
                        
                        for (let i = 0; i <= steps; i++) {
                            const theta = (i / steps) * maxTheta;
                            const r = a * theta * 10;
                            const x = canvas.width/2 + r * Math.cos(theta);
                            const y = canvas.height/2 + r * Math.sin(theta);
                            
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('archimedean-result').innerHTML = `
                            <p><strong>Archimedean spiral generated</strong></p>
                            <p><strong>Scale factor a:</strong> ${a}</p>
                            <p><strong>Complete turns:</strong> ${turns}</p>
                            ${displayResonanceMeter(resonance, 'Linear Growth')}
                        `;
                    }, 'Error computing Archimedean spiral');
                }
            },

            fermat: {
                name: 'Fermat Spiral: r = ¬±‚àöŒ∏',
                description: 'Parabolic spiral appearing in nature as seed arrangements. Has two symmetric branches and optimal packing properties.',
                symbolic: 'Dual emergence, symmetric growth, natural optimization',
                attractor: 'Parabolic Growth (r ‚àù ‚àöŒ∏)',
                layer: 'Natural-Symmetric',
                application: 'Dual-branch neural architectures and symmetric pattern recognition.',
                persona: 'spiral',
                ritual: function() {
                    return `
                        <section class="ritual-block spiral" aria-labelledby="fermat-title">
                            <h3 id="fermat-title" class="persona-title spiral">üåÄ Spiral Engine (Dual Ritualist)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="fermat-scale">Scale factor (5-20):</label>
                                        <input type="number" id="fermat-scale" placeholder="10" min="5" max="20" value="10">
                                    </div>
                                    <div class="input-field">
                                        <label for="fermat-points">Points per branch (50-200):</label>
                                        <input type="number" id="fermat-points" placeholder="100" min="50" max="200" value="100">
                                    </div>
                                    <button onclick="computeFermat()">Generate Dual Spiral</button>
                                </div>
                            </div>
                            <canvas id="fermat-canvas" width="400" height="400"></canvas>
                            <div id="fermat-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const scale = parseFloat(document.getElementById('fermat-scale').value) || 10;
                        const pointsPerBranch = parseInt(document.getElementById('fermat-points').value) || 100;
                        
                        if (scale < 5 || scale > 20) throw new Error('Scale factor must be 5-20');
                        if (pointsPerBranch < 50 || pointsPerBranch > 200) throw new Error('Points must be 50-200');
                        
                        const canvas = document.getElementById('fermat-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Draw both branches of Fermat spiral
                        for (let branch = 0; branch < 2; branch++) {
                            const sign = branch === 0 ? 1 : -1;
                            
                            for (let i = 1; i <= pointsPerBranch; i++) {
                                const theta = i * 0.1;
                                const r = sign * Math.sqrt(theta) * scale;
                                const x = canvas.width/2 + r * Math.cos(theta);
                                const y = canvas.height/2 + r * Math.sin(theta);
                                
                                ctx.fillStyle = branch === 0 ? '#e74c3c' : '#3498db';
                                ctx.beginPath();
                                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                        
                        const resonance = computeResonance([], 0, false);
                        document.getElementById('fermat-result').innerHTML = `
                            <p><strong>Fermat spiral (dual branch) generated</strong></p>
                            <p><strong>Scale factor:</strong> ${scale}</p>
                            <p><strong>Points per branch:</strong> ${pointsPerBranch}</p>
                            ${displayResonanceMeter(resonance, 'Parabolic Symmetry')}
                        `;
                    }, 'Error computing Fermat spiral');
                }
            },

            cellular: {
                name: 'Cellular Automata: Rule 110',
                description: 'Elementary cellular automaton proven to be Turing complete. Generates complex patterns from simple binary rules.',
                symbolic: 'Emergence from simplicity, computational universality, binary consciousness',
                attractor: 'Computational Complexity (Rule-dependent)',
                layer: 'Computational-Emergent',
                application: 'Emergent behavior modeling and distributed neural computation.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="cellular-title">
                            <h3 id="cellular-title" class="persona-title explorer">üîç Explorer (Emergence Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="cellular-generations">Generations (10-50):</label>
                                        <input type="number" id="cellular-generations" placeholder="30" min="10" max="50" value="30">
                                    </div>
                                    <div class="input-field">
                                        <label for="cellular-width">Grid width (20-100):</label>
                                        <input type="number" id="cellular-width" placeholder="60" min="20" max="100" value="60">
                                    </div>
                                    <button onclick="computeCellular()">Evolve Pattern</button>
                                </div>
                            </div>
                            <canvas id="cellular-canvas" width="400" height="300"></canvas>
                            <div id="cellular-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        clearAllCanvases();
                        const generations = parseInt(document.getElementById('cellular-generations').value) || 30;
                        const width = parseInt(document.getElementById('cellular-width').value) || 60;
                        
                        if (generations < 10 || generations > 50) throw new Error('Generations must be 10-50');
                        if (width < 20 || width > 100) throw new Error('Width must be 20-100');
                        
                        const canvas = document.getElementById('cellular-canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Rule 110: [0,1,1,0,1,1,1,0]
                        const rule110 = [0,1,1,0,1,1,1,0];
                        
                        // Initialize with single cell in center
                        let grid = new Array(width).fill(0);
                        grid[Math.floor(width/2)] = 1;
                        
                        const cellWidth = canvas.width / width;
                        const cellHeight = canvas.height / generations;
                        let totalOnes = 0;
                        
                        for (let gen = 0; gen < generations; gen++) {
                            // Draw current generation
                            for (let i = 0; i < width; i++) {
                                ctx.fillStyle = grid[i] ? '#2c3e50' : '#ecf0f1';
                                ctx.fillRect(i * cellWidth, gen * cellHeight, cellWidth, cellHeight);
                                if (grid[i]) totalOnes++;
                            }
                            
                            // Compute next generation
                            let newGrid = new Array(width);
                            for (let i = 0; i < width; i++) {
                                const left = grid[(i - 1 + width) % width];
                                const center = grid[i];
                                const right = grid[(i + 1) % width];
                                const ruleIndex = (left << 2) | (center << 1) | right;
                                newGrid[i] = rule110[ruleIndex];
                            }
                            grid = newGrid;
                        }
                        
                        const density = (totalOnes / (width * generations)) * 100;
                        const resonance = Math.min(100, density * 2);
                        
                        document.getElementById('cellular-result').innerHTML = `
                            <p><strong>Rule 110 pattern evolved</strong></p>
                            <p><strong>Generations:</strong> ${generations}</p>
                            <p><strong>Pattern density:</strong> ${density.toFixed(2)}%</p>
                            ${displayResonanceMeter(resonance, 'Computational Complexity')}
                        `;
                    }, 'Error computing cellular automata');
                }
            },

            // Add the other equations from the original with enhancements...
            tribonacci: {
                name: 'Tribonacci Sequence: T(n) = T(n-1) + T(n-2) + T(n-3)',
                description: 'Extension of Fibonacci using three preceding terms. Converges to the Tribonacci constant œà ‚âà 1.8393, which is the real root of x¬≥ = x¬≤ + x + 1.',
                symbolic: 'Triadic emergence, three-fold recursion, dimensional expansion',
                attractor: 'œà (Tribonacci Constant ‚âà 1.8393)',
                layer: 'Dimensional-Recursive',
                application: 'Three-dimensional neural architectures and œà-nodes for introspective processing.',
                persona: 'explorer',
                ritual: function() {
                    return `
                        <section class="ritual-block explorer" aria-labelledby="tribonacci-title">
                            <h3 id="tribonacci-title" class="persona-title explorer">üîç Explorer (Dimensional Interpreter)</h3>
                            <div class="input-group">
                                <div class="input-row">
                                    <div class="input-field">
                                        <label for="tribonacci-input">Number of terms (1-30):</label>
                                        <input type="number" id="tribonacci-input" placeholder="e.g., 15" min="1" max="30" value="15">
                                    </div>
                                    <button onclick="computeTribonacci()">Generate Sequence</button>
                                </div>
                            </div>
                            <div id="tribonacci-result" class="result"></div>
                        </section>
                    `;
                },
                action: function() {
                    safeExecute(() => {
                        const n = parseInt(document.getElementById('tribonacci-input').value) || 15;
                        if (n < 1 || n > 30) throw new Error('Number of terms must be between 1 and 30');
                        
                        let seq = [0, 0, 1];
                        for (let i = 3; i < n; i++) {
                            seq[i] = seq[i-1] + seq[i-2] + seq[i-3];
                        }
                        
                        const ratio = n > 3 ? seq[n-1] / seq[n-2] : 0;
                        const resonance = computeResonance(seq, 1.8393);
                        
                        document.getElementById('tribonacci-result').innerHTML = `
                            <p><strong>Sequence:</strong> ${seq.join(', ')}</p>
                            <p><strong>Convergence to œà:</strong> ${ratio.toFixed(6)}</p>
                            <p><strong>Tribonacci Constant Target:</strong> 1.839286</p>
                            ${displayResonanceMeter(resonance, 'Tribonacci Constant œà')}
                        `;
                    }, 'Error computing Tribonacci sequence');
                }
            }
        };

        // Helper function for HSL to RGB conversion
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = l - c / 2;
            
            let r, g, b;
            if (h < 1/6) [r, g, b] = [c, x, 0];
            else if (h < 2/6) [r, g, b] = [x, c, 0];
            else if (h < 3/6) [r, g, b] = [0, c, x];
            else if (h < 4/6) [r, g, b] = [0, x, c];
            else if (h < 5/6) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];
            
            return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
        }

        // Initialize dropdown handler
        document.getElementById('equation-select').addEventListener('change', function() {
            const selected = this.value;
            const output = document.getElementById('output');
            
            clearAllCanvases();
            
            if (selected && equations[selected]) {
                const eq = equations[selected];
                output.innerHTML = `
                    <div class="equation-info">
                        <div class="equation-name">${eq.name}</div>
                        <div class="equation-description">${eq.description}</div>
                        <div class="equation-meta">
                            <div class="meta-item">
                                <div class="meta-label">Symbolic Role</div>
                                <div class="meta-value">${eq.symbolic}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">Attractor Type</div>
                                <div class="meta-value">${eq.attractor}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">Neural Layer</div>
                                <div class="meta-value">${eq.layer}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">UNNS Application</div>
                                <div class="meta-value">${eq.application}</div>
                            </div>
                        </div>
                    </div>
                    ${eq.ritual()}
                `;
                
                // Add pulse animation to the container
                output.classList.add('pulse');
                setTimeout(() => output.classList.remove('pulse'), 500);
            } else {
                output.innerHTML = `
                    <div class="placeholder">
                        <h3>üåü Welcome to the Neural Attractor Observatory</h3>
                        <p>Select an equation above to explore its mathematical properties, symbolic meaning, and neural network applications in the UNNS framework.</p>
                    </div>
                `;
            }
        });

        // Global function handlers
        Object.keys(equations).forEach(key => {
            const funcName = `compute${key.charAt(0).toUpperCase() + key.slice(1).replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())}`;
            window[funcName] = equations[key].action;
        });
    </script>
</body>
</html>
