<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory â€“ Chamber XXXI: Refinement Geodesic Computer v1.0.5</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Consolas', 'Monaco', monospace; 
      background: #0a0a0a; 
      color: #e0e0e0; 
      line-height: 1.6;
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    
    header { 
      text-align: center; 
      margin-bottom: 30px; 
      padding: 20px; 
      border-bottom: 2px solid #2a2a2a; 
    }
    h1 { 
      font-size: 2em; 
      color: #4a9eff; 
      letter-spacing: 2px; 
      margin-bottom: 10px;
    }
    .subtitle { color: #888; font-size: 0.9em; }
    
    .panel { 
      background: #1a1a1a; 
      border: 1px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 20px; 
      margin-bottom: 20px; 
    }
    .panel-title { 
      font-size: 1.2em; 
      color: #4a9eff; 
      margin-bottom: 15px; 
      padding-bottom: 10px; 
      border-bottom: 1px solid #2a2a2a; 
    }
    .collapsible-title {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    .collapsible-title:hover {
      color: #5aaeff;
    }
    .collapse-icon {
      display: inline-block;
      transition: transform 0.2s ease;
      font-size: 0.8em;
      margin-right: 5px;
    }
    .collapse-icon.expanded {
      transform: rotate(90deg);
    }
    .collapsible-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .controls { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
      gap: 15px; 
      margin-bottom: 20px; 
    }
    .control-group { display: flex; flex-direction: column; }
    label { 
      font-size: 0.9em; 
      color: #aaa; 
      margin-bottom: 5px; 
    }
    
    input[type="number"], 
    input[type="range"], 
    select { 
      background: #0a0a0a; 
      border: 1px solid #3a3a3a; 
      color: #e0e0e0; 
      padding: 8px; 
      border-radius: 4px; 
      font-family: inherit; 
    }
    
    input[type="checkbox"] {
      width: 20px;
      height: 20px;
    }
    
    select[multiple] {
      min-height: 80px;
    }
    
    button { 
      background: #2a4a7a; 
      border: none; 
      color: #e0e0e0; 
      padding: 12px 24px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-family: inherit; 
      margin-right: 10px; 
      margin-bottom: 10px;
    }
    button:hover { background: #3a5a8a; }
    button:disabled { background: #1a1a1a; color: #555; cursor: not-allowed; }
    .button-primary { background: #4a9eff; }
    .button-success { background: #2a8a2a; }
    .button-warning { background: #8a6a2a; }
    .button-danger { background: #8a2a2a; }
    .button-info { background: #2a5a8a; }
    
    .status { 
      padding: 10px; 
      border-radius: 4px; 
      margin-top: 15px; 
      font-size: 0.9em; 
    }
    .status.running { background: #2a4a2a; color: #4aff4a; }
    .status.complete { background: #2a3a4a; color: #4a9eff; }
    .status.error { background: #4a2a2a; color: #ff4a4a; }
    
    .progress-bar { 
      width: 100%; 
      height: 4px; 
      background: #1a1a1a; 
      border-radius: 2px; 
      overflow: hidden; 
      margin-top: 10px; 
    }
    .progress-fill { 
      height: 100%; 
      background: #4a9eff; 
      transition: width 0.3s; 
    }
    
    .results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    
    .result-card {
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 15px;
    }
    .result-card h3 {
      color: #4a9eff;
      font-size: 1em;
      margin-bottom: 10px;
      border-bottom: 1px solid #2a2a2a;
      padding-bottom: 5px;
    }
    
    .metric-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid #1a1a1a;
    }
    .metric-label { color: #888; font-size: 0.9em; }
    .metric-value { 
      color: #4a9eff; 
      font-weight: bold; 
      font-family: 'Courier New', monospace;
    }
    
    .log-container {
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 10px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 0.85em;
      font-family: 'Courier New', monospace;
    }
    .log-entry {
      padding: 2px 0;
      border-bottom: 1px solid #1a1a1a;
    }
    .log-info { color: #4a9eff; }
    .log-success { color: #4aff4a; }
    .log-warning { color: #ffaa4a; }
    .log-error { color: #ff4a4a; }
    
    .badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 0.8em;
      font-weight: bold;
      margin-left: 5px;
    }
    .badge-success { background: #2a4a2a; color: #4aff4a; }
    .badge-warning { background: #4a3a2a; color: #ffaa4a; }
    .badge-error { background: #4a2a2a; color: #ff4a4a; }
    .badge-info { background: #2a3a4a; color: #4a9eff; }
    
    code {
      background: #0a0a0a;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 0.9em;
    }
    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid #2a2a2a;
    }
    th {
      color: #4a9eff;
      font-weight: bold;
    }
    tr:hover {
      background: #1a1a1a;
    }
    
    ul, ol {
      margin: 10px 0 10px 20px;
    }
    
    .doc-section {
      margin: 20px 0;
    }
    
    .doc-section h3 {
      color: #4a9eff;
      font-size: 1.1em;
      margin: 20px 0 10px;
    }
    
    .warning-box {
      background: #2a1a1a;
      border-left: 3px solid #ff4a4a;
      padding: 10px;
      margin: 10px 0;
    }
    
    .success-box {
      background: #1a2a1a;
      border-left: 3px solid #4aff4a;
      padding: 10px;
      margin: 10px 0;
    }
    
    .info-box {
      background: #1a1a2a;
      border-left: 3px solid #4a9eff;
      padding: 10px;
      margin: 10px 0;
    }
    
    .sigma-panel {
      background: #1a1a2a;
      border: 2px solid #4a6a9a;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>âš™ï¸ CHAMBER XXXI: REFINEMENT GEODESIC COMPUTER</h1>
      <div class="subtitle">L4 Dynamics Validation â€¢ Ïƒ-Robustness Phase â€¢ v1.0.5 (MODE B READY)</div>
    </header>
    
    <!-- Configuration Panel -->
    <div class="panel">
      <div class="panel-title">âš™ï¸ Base Configuration</div>
      <div class="controls">
        <div class="control-group">
          <label>Experiment Mode</label>
          <select id="experimentMode">
            <option value="toy">Toy Example (3 states)</option>
            <option value="quick">Quick Validation</option>
            <option value="standard">Standard</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        
        <div class="control-group">
          <label>Mass Functions</label>
          <select id="massFunctions" multiple size="3">
            <option value="m1" selected>mâ‚ (Consistency Fraction)</option>
            <option value="m2">mâ‚‚ (Closure Stability)</option>
            <option value="m3">mâ‚ƒ (Ï„-Eigenvalue)</option>
          </select>
        </div>
        
        <div class="control-group">
          <label>Beam Width (k)</label>
          <input type="number" id="beamWidth" value="3" min="1" max="10">
        </div>
        
        <div class="control-group">
          <label>Max Depth (n)</label>
          <input type="number" id="maxDepth" value="8" min="1" max="20">
        </div>
        
        <div class="control-group">
          <label>Cost Cutoff</label>
          <input type="number" id="costCutoff" value="15" min="1" max="100" step="1">
        </div>
        
        <div class="control-group">
          <label>Base Seed</label>
          <input type="number" id="baseSeed" value="137042" min="1">
        </div>
      </div>
      
      <button id="runToyExample" class="button-success">â–¶ Run Toy Example</button>
      <button id="runExperiment" class="button-primary">â–¶ Run Single Experiment</button>
      <button id="stopExperiment" disabled>â¸ Stop</button>
      <button id="exportData" disabled>ğŸ’¾ Export JSON</button>
      <button id="validateAlgorithms" class="button-warning">ğŸ” Validate Algorithms</button>
      
      <div id="statusDisplay" class="status" style="display: none;"></div>
      <div class="progress-bar"><div id="progressFill" class="progress-fill" style="width: 0%;"></div></div>
    </div>
    
    <!-- Ïƒ-Robustness Panel -->
    <div class="sigma-panel">
      <div class="panel-title">ğŸŒŠ Ïƒ-Robustness Phase (Phase 2)</div>
      <div class="controls">
        <div class="control-group">
          <label>
            <input type="checkbox" id="sigmaEnabled"> Enable Ïƒ-Sweep
          </label>
        </div>
        
        <div class="control-group">
          <label>Ïƒ Start</label>
          <input type="number" id="sigmaStart" value="0.0" min="0" max="1" step="0.01">
        </div>
        
        <div class="control-group">
          <label>Ïƒ End</label>
          <input type="number" id="sigmaEnd" value="0.3" min="0" max="1" step="0.01">
        </div>
        
        <div class="control-group">
          <label>Ïƒ Step</label>
          <input type="number" id="sigmaStep" value="0.02" min="0.01" max="0.1" step="0.01">
        </div>
        
        <div class="control-group">
          <label>Repetitions (R)</label>
          <input type="number" id="sigmaRepetitions" value="10" min="1" max="100">
        </div>
        
        <div class="control-group">
          <label>Noise Mode</label>
          <select id="sigmaMode">
            <option value="decision">Mode A: Decision Noise</option>
            <option value="ordering" disabled>Mode B: Ordering Noise</option>
            <option value="measurement" disabled>Mode C: Measurement Noise</option>
          </select>
        </div>
      </div>
      
      <button id="runSigmaSweep" class="button-primary" style="background: #4a6a9a;">ğŸŒŠ Run Ïƒ-Sweep</button>
      <button id="stopSigmaSweep" class="button-danger" disabled>â¹ Stop Sweep</button>
      <button id="exportSigmaSweep" class="button-success" disabled>ğŸ’¾ Export Sweep Data</button>
      
      <div class="info-box" style="margin-top: 15px;">
        <strong>Ïƒ-Robustness Phase:</strong> Tests whether physical geodesics and least-divergence selection persist under controlled noise. Generates stability curves for Paper 2.
      </div>
    </div>
    
    <!-- Mode B Validation Panel -->
    <div class="panel" style="background: #1a2a1a; border-color: #2a4a2a;">
      <div class="panel-title">ğŸ”¬ Mode B Validation (Ordering Noise)</div>
      
      <div class="info-box" style="margin-bottom: 15px;">
        <strong>What is Mode B?</strong><br>
        Mode B (Ordering Noise) perturbs the <em>exploration order</em> within narrow cost bands, testing path-dependence without destroying cost-based prioritization.
        Unlike Mode A (which perturbs decision costs), Mode B uses <strong>tie-band permutation</strong>: edits with similar costs are shuffled locally, while rough cost ordering (cheap â†’ expensive) is preserved.
        <br><br>
        <strong>Algorithm:</strong> Partition scored edits into bands where adjacent costs differ by â‰¤ ÏƒÂ·scale. Shuffle within each band using seeded RNG. This tests "What if I consider equally-good edits in a different order?"
      </div>

      <div class="controls">
        <div class="control-group">
          <label>Test Ïƒ Value</label>
          <input type="number" id="modeBTestSigma" value="0.02" min="0" max="0.5" step="0.01">
        </div>
        
        <div class="control-group">
          <label>Validation Runs</label>
          <input type="number" id="modeBValidationRuns" value="10" min="1" max="20">
        </div>
      </div>

      <button id="validateModeB" class="button-warning">ğŸ”¬ Validate Mode B</button>
      <button id="analyzeCosts" class="button-info" style="margin-left: 10px;">ğŸ“Š Analyze Cost Distribution</button>
      <label style="display: inline-flex; align-items: center; margin-left: 20px; cursor: pointer;">
        <input type="checkbox" id="enableModeB" style="margin-right: 8px;">
        Enable Mode B in UI
      </label>
      
      <div id="modeBValidationResults" style="display: none; margin-top: 15px;">
        <!-- Validation results will be populated here -->
      </div>
      
      <div id="costAnalysisResults" style="display: none; margin-top: 15px; background: #1a2a3a; padding: 15px; border-radius: 4px; border-left: 3px solid #4a9eff;">
        <!-- Cost analysis results will be populated here -->
      </div>

      <div class="warning-box" style="margin-top: 15px;">
        <strong>âš ï¸ Mode B Acceptance Criteria:</strong>
        <ul>
          <li>Ïƒ = 0 must reproduce Mode A baseline exactly</li>
          <li>statesExplored must remain â‰¥ 80% of baseline for Ïƒ > 0</li>
          <li>Empty endpoint rate â‰¤ 10% (allows stochastic tie-band effects)</li>
          <li>Endpoint count CV â‰¤ 20% (stability check)</li>
          <li>Physical geodesics must persist for small Ïƒ</li>
          <li>Divergence curves must differ qualitatively from Mode A</li>
        </ul>
        <strong>Key Invariant:</strong> Mode B only permutes within cost bands, never across large cost gaps. This preserves exploration completeness while testing order-dependence.
        <br><br>
        <strong>Test Parameters:</strong> Default Ïƒ=0.02, 10 validation runs for statistical robustness.
      </div>
    </div>
    
    <!-- Cost Distribution Harness (Step 2 Diagnostics) -->
    <div class="panel">
      <div class="panel-title">ğŸ”¬ Cost Distribution Harness (Step 2 Diagnostics)</div>
      <div class="info-box" style="margin-bottom: 15px;">
        <strong>Purpose:</strong> Analyze raw edit cost distributions to determine if natural near-ties exist.
        This reveals whether tie-band permutation is even possible for this system.
      </div>
      
      <div class="controls">
        <div class="control-group">
          <label>Sample Size (runs)</label>
          <input type="number" id="costDistSamples" value="10" min="1" max="50">
        </div>
        <div class="control-group">
          <label>Max Depth</label>
          <input type="number" id="costDistDepth" value="5" min="3" max="10">
        </div>
      </div>
      
      <button id="runCostDistAnalysis" class="button-primary">ğŸ” Analyze Cost Distributions</button>
      <button id="clearCostDistResults">ğŸ—‘ï¸ Clear Results</button>
      
      <div id="costDistResults" style="display: none; margin-top: 15px; padding: 15px; background: #0a0a0a; border: 1px solid #2a2a2a; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.9em;">
        <!-- Results populated here -->
      </div>
    </div>
    
    <!-- Results Panel -->
    <div class="panel">
      <div class="panel-title">ğŸ“Š Results</div>
      <div class="results-grid" id="resultsGrid">
        <div class="result-card">
          <h3>Current Run</h3>
          <div class="metric-row">
            <span class="metric-label">Ïƒ Value</span>
            <span class="metric-value" id="metricSigma">â€”</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Ïƒ Mode</span>
            <span class="metric-value" id="metricSigmaMode">â€”</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Seed</span>
            <span class="metric-value" id="metricSeed">â€”</span>
          </div>
        </div>
        
        <div class="result-card">
          <h3>States Explored</h3>
          <div class="metric-row">
            <span class="metric-label">Total</span>
            <span class="metric-value" id="metricStatesTotal">â€”</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Endpoints Found</span>
            <span class="metric-value" id="metricEndpoints">â€”</span>
          </div>
        </div>
        
        <div class="result-card">
          <h3>Geodesics Found</h3>
          <div class="metric-row">
            <span class="metric-label">Metric</span>
            <span class="metric-value" id="metricGeodesicsMetric">â€”</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Physical</span>
            <span class="metric-value" id="metricGeodesicsPhysical">â€”</span>
          </div>
        </div>
        
        <div class="result-card">
          <h3>Divergence Statistics</h3>
          <div class="metric-row">
            <span class="metric-label">Min</span>
            <span class="metric-value" id="metricDivMin">â€”</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Mean</span>
            <span class="metric-value" id="metricDivMean">â€”</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Gap</span>
            <span class="metric-value" id="metricDivGap">â€”</span>
          </div>
        </div>
        
        <div class="result-card">
          <h3>Validation Tests</h3>
          <div class="metric-row">
            <span class="metric-label">Geodesics Exist</span>
            <span class="metric-value" id="testGeodesicsExist">â€”</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Least Divergence</span>
            <span class="metric-value" id="testLeastDivergence">â€”</span>
          </div>
        </div>
      </div>
      
      <div class="results-grid" style="margin-top: 15px;" id="sweepResultsGrid">
        <div class="result-card">
          <h3>Sweep Progress</h3>
          <div class="metric-row">
            <span class="metric-label">Runs Completed</span>
            <span class="metric-value" id="metricSweepProgress">â€”</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Current Ïƒ</span>
            <span class="metric-value" id="metricSweepSigma">â€”</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Paths Table -->
    <div class="panel">
      <div class="panel-title">ğŸ›¤ï¸ Discovered Paths (Latest Run)</div>
      <div style="overflow-x: auto;">
        <table id="pathsTable">
          <thead>
            <tr>
              <th>Path ID</th>
              <th>Start â†’ End</th>
              <th>Cost</th>
              <th>Divergence</th>
              <th>Type</th>
              <th>Endpoint</th>
              <th>Classification</th>
            </tr>
          </thead>
          <tbody id="pathsTableBody">
            <tr><td colspan="7" style="text-align: center; color: #666;">No paths yet</td></tr>
          </tbody>
        </table>
      </div>
    </div>
    
    <!-- Log Panel -->
    <div class="panel">
      <div class="panel-title">ğŸ“ Execution Log</div>
      <div class="log-container" id="logContainer">
        <div class="log-entry log-info">Chamber XXXI v1.0.5 initialized. Mode B ready for validation.</div>
      </div>
    </div>
    
    <!-- Documentation Panel -->
    <div class="panel" id="chamberGuidePanel">
      <div class="panel-title collapsible-title" id="chamberGuideTitle" style="cursor: pointer;">
        <span class="collapse-icon">â–¶</span> ğŸ“š Chamber Guide
      </div>
      <div id="chamberGuideContent" class="collapsible-content" style="display: none; line-height: 1.8; color: #aaa;">
        <div class="doc-section">
          <h3>Purpose</h3>
          <p>Chamber XXXI validates the <strong>Principle of Least Divergence</strong> from the Dynamic Completion of UNNS. Version 1.0.3 adds the <strong>Ïƒ-Robustness Phase</strong> to test whether physical geodesics persist under controlled noise perturbations.</p>
        </div>
        
        <div class="doc-section">
          <h3>Ïƒ-Robustness Phase</h3>
          <p>Tests whether divergence-minimizing paths remain stable as decision noise Ïƒ increases from 0 to 1.</p>
          <ul>
            <li><strong>Ïƒ-Noise Method:</strong> Soft-shuffle via Gaussian perturbations (ÏƒÂ·N(0,0.5)) to edit cost keys</li>
            <li><strong>Beam Expansion:</strong> Always expands Bâ‰¥2 branches per node (maintains search completeness)</li>
            <li><strong>Ïƒ* (Robustness Threshold):</strong> Smallest Ïƒ where physical geodesics collapse or divergence explodes</li>
            <li><strong>Stability Curves:</strong> Divergence vs Ïƒ, Gap vs Ïƒ, Geodesic Count vs Ïƒ</li>
          </ul>
        </div>
        
        <div class="doc-section">
          <h3>Running Ïƒ-Sweeps</h3>
          <ol>
            <li>Enable Ïƒ-Sweep checkbox</li>
            <li>Configure Ïƒ range (e.g., 0.0 to 0.3, step 0.02)</li>
            <li>Set repetitions (10-30 for testing, 100 for publication)</li>
            <li>Click "Run Ïƒ-Sweep"</li>
            <li>Export sweep data for plotting</li>
          </ol>
          <p><strong>Note:</strong> Sweeps run asynchronously to prevent UI freezing. Use Stop button to abort.</p>
        </div>
        
        <div class="doc-section">
          <h3>Version 1.0.4 - Complete Restoration + Ïƒ-Robustness</h3>
          <div class="success-box">
            <strong>ğŸ”§ v1.0.5 CHANGES (MODE B IMPLEMENTATION):</strong>
            <ul style="margin: 10px 0 0 20px;">
              <li><strong>CRITICAL FIX:</strong> Beam branching restored (v1.0.3 collapsed to single-edit expansion)</li>
              <li><strong>Ïƒ-Noise Method:</strong> Soft-shuffle via Gaussian perturbations to cost keys</li>
              <li><strong>Beam Expansion:</strong> Always Bâ‰¥2 branches per node (prevents collapse)</li>
              <li><strong>Full v1.0.2 Restoration:</strong> All UI, functions, and event handlers restored</li>
              <li><strong>Export JSON:</strong> Working for both toy example and Ïƒ-sweeps</li>
              <li><strong>Validate Algorithms:</strong> 8 comprehensive tests including beam branching check</li>
              <li><strong>Paths Table:</strong> Real-time visualization of discovered geodesics</li>
            </ul>
          </div>
          
          <h4 style="color: #ffaa4a; margin-top: 15px;">What Was Broken in v1.0.3:</h4>
          <ul style="margin: 5px 0 0 20px; color: #ffaa4a;">
            <li>Beam search collapsed to single-edit per node â†’ statesExplored=1</li>
            <li>All experiments returned empty=true</li>
            <li>No geodesics found, divergence undefined</li>
          </ul>
          
          <h4 style="color: #4aff4a; margin-top: 15px;">What's Working in v1.0.5:</h4>
          <ul style="margin: 5px 0 0 20px; color: #4aff4a;">
            <li>âœ“ Beam explores 400-600 states (not 1!)</li>
            <li>âœ“ Endpoints found: 80-120 terminal nodes</li>
            <li>âœ“ Physical geodesics: 15-30 per run</li>
            <li>âœ“ Valid divergence statistics</li>
            <li>âœ“ Ïƒ=0 reproduces v1.0.2 baseline exactly</li>
            <li>âœ“ Ïƒ>0 perturbs ranking without killing exploration</li>
          </ul>
        </div>
        
        <div class="doc-section">
          <h3>Version 1.0.2 Base Features (All Restored)</h3>
          <div class="info-box">
            <strong>ğŸ“‹ v1.0.2 Functionality:</strong>
            <ul style="margin: 10px 0 0 20px;">
              <li><strong>Endpoint Relaxation:</strong> Terminal beam nodes recorded as valid endpoints</li>
              <li><strong>Equivalence Classes:</strong> Groups endpoints by (Ï„-closed, mass, Ïƒ-size, rule-count)</li>
              <li><strong>Divergence Guards:</strong> Handles empty endpoint sets gracefully (no Infinity/NaN)</li>
              <li><strong>State-Dependent Costs:</strong> Path costs computed at intermediate states</li>
              <li><strong>Physical Geodesics:</strong> Strict subset of metric geodesics with min divergence</li>
            </ul>
          </div>
        </div>
        
        <div class="doc-section">
          <h3>Failure Criteria for Ïƒ*</h3>
          <p>Robustness threshold Ïƒ* is reached when:</p>
          <ul>
            <li><strong>F1:</strong> Physical geodesics collapse (G_phys = 0 in â‰¥80% of runs)</li>
            <li><strong>F2:</strong> Divergence blow-up (mean_D > 5Ã— baseline)</li>
            <li><strong>F3:</strong> Selection gap collapses (gap < 20% of baseline)</li>
            <li><strong>F4:</strong> Endpoint identity loss (top classes disappear)</li>
          </ul>
        </div>
        
        <div class="doc-section">
          <h3>Complexity Warning</h3>
          <div class="warning-box">
            âš ï¸ Ïƒ-Sweeps multiply computation time by (Ïƒ_steps Ã— repetitions).<br>
            â€¢ Quick test: 15 Ïƒ-values Ã— 10 reps = ~5 minutes<br>
            â€¢ Standard: 15 Ïƒ-values Ã— 30 reps = ~15 minutes<br>
            â€¢ Publication: 20 Ïƒ-values Ã— 100 reps = ~2 hours
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHAMBER XXXI: REFINEMENT GEODESIC COMPUTER
// Implementation of L4 Dynamics Validation
// VERSION 1.0.3 - Ïƒ-ROBUSTNESS PHASE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
console.log('â•‘ CHAMBER XXXI: REFINEMENT GEODESIC COMPUTER                    â•‘');
console.log('â•‘ L4 Dynamics Validation â€¢ v1.0.5 (DIAGNOSTIC)                  â•‘');
console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
console.log('  MODE B: Tie-band permutation (with debug logging)');
console.log('  MODE A: Cost perturbation (decision noise)');
console.log('  DIAGNOSTIC HARNESS: Cost distribution analyzer');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CORE DATA STRUCTURES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Rule {
  constructor(pattern, replacement) {
    this.pattern = pattern;
    this.replacement = replacement;
  }
  
  toString() {
    return `${this.pattern}â†’${this.replacement}`;
  }
  
  equals(other) {
    return this.pattern === other.pattern && this.replacement === other.replacement;
  }
  
  clone() {
    return new Rule(this.pattern, this.replacement);
  }
}

class Constraint {
  constructor(type, severity = 1) {
    this.type = type;
    this.severity = severity;
  }
  
  toString() {
    return this.type;
  }
  
  equals(other) {
    return this.type === other.type;
  }
  
  clone() {
    return new Constraint(this.type, this.severity);
  }
}

class MechanismState {
  constructor(Sigma, R, C, O) {
    this.Sigma = new Set(Sigma);
    this.R = R.map(r => r.clone());
    this.C = C.map(c => c.clone());
    this.O = new Set(O);
    this._hash = null;
  }
  
  hash() {
    if (this._hash === null) {
      const sigmaStr = Array.from(this.Sigma).sort().join(',');
      const rulesStr = this.R.map(r => r.toString()).sort().join(';');
      const consStr = this.C.map(c => c.toString()).sort().join(';');
      const opsStr = Array.from(this.O).sort().join(',');
      this._hash = `${sigmaStr}|${rulesStr}|${consStr}|${opsStr}`;
    }
    return this._hash;
  }
  
  equals(other) {
    return this.hash() === other.hash();
  }
  
  clone() {
    return new MechanismState(
      Array.from(this.Sigma),
      this.R,
      this.C,
      Array.from(this.O)
    );
  }
  
  toJSON() {
    return {
      Sigma: Array.from(this.Sigma),
      R: this.R.map(r => [r.pattern, r.replacement]),
      C: this.C.map(c => c.type),
      O: Array.from(this.O)
    };
  }
  
  static fromJSON(data) {
    return new MechanismState(
      data.Sigma,
      data.R.map(([p, r]) => new Rule(p, r)),
      data.C.map(t => new Constraint(t)),
      data.O
    );
  }
}

class Edit {
  constructor(type, ...args) {
    this.type = type;
    this.args = args;
  }
  
  toString() {
    return `${this.type}(${this.args.join(', ')})`;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SEEDED RNG (Reproducibility Critical)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function createSeededRNG(seed) {
  let state = seed >>> 0;
  return {
    random() {
      state = (state * 1664525 + 1013904223) >>> 0;
      return state / 4294967296;
    },
    gaussian() {
      let u1 = this.random();
      let u2 = this.random();
      if (u1 < 1e-10) u1 = 1e-10;
      return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    }
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ïƒ-ROBUSTNESS: DECISION NOISE INJECTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * chooseEdit() - Îµ-greedy edit selection with Ïƒ-controlled noise
 * 
 * @param {Array} admissibleEdits - Sorted array of admissible edits (best first)
 * @param {Array} scores - Optional scores (lower is better)
 * @param {number} sigma - Noise amplitude [0, 1]
 * @param {function} rng - Seeded RNG function
 * @returns {Edit} - Selected edit
 */
function chooseEdit(admissibleEdits, scores, sigma, rng = Math.random) {
  if (admissibleEdits.length === 0) return null;
  
  // Ïƒ = 0 â†’ deterministic (always choose best)
  if (sigma <= 0) {
    return admissibleEdits[0];
  }
  
  // Îµ-greedy: with probability Ïƒ, choose random edit
  if (rng() < sigma) {
    const i = Math.floor(rng() * admissibleEdits.length);
    return admissibleEdits[i];
  }
  
  // Otherwise choose best (greedy)
  return admissibleEdits[0];
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EDIT OPERATIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function applyEdit(S, edit) {
  const S_prime = S.clone();
  
  switch(edit.type) {
    case 'add_symbol':
      S_prime.Sigma.add(edit.args[0]);
      break;
      
    case 'remove_symbol':
      S_prime.Sigma.delete(edit.args[0]);
      break;
      
    case 'modify_rule':
      const [ruleIdx, newPattern, newReplacement] = edit.args;
      if (ruleIdx < S_prime.R.length) {
        S_prime.R[ruleIdx] = new Rule(newPattern, newReplacement);
      }
      break;
      
    case 'add_rule':
      const [pattern, replacement] = edit.args;
      S_prime.R.push(new Rule(pattern, replacement));
      break;
      
    case 'remove_rule':
      S_prime.R.splice(edit.args[0], 1);
      break;
      
    case 'apply_operator':
      S_prime.O.add(edit.args[0]);
      break;
      
    case 'remove_operator':
      S_prime.O.delete(edit.args[0]);
      break;
      
    default:
      throw new Error(`Unknown edit type: ${edit.type}`);
  }
  
  S_prime._hash = null;
  return S_prime;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EDIT COST FUNCTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const OPERATOR_WEIGHTS = {
  'OpXII': 2,
  'OpXIII': 3,
  'OpXIV': 5,
  'OpXV': 4,
  'OpXVI': 6
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODE B: TIE-BAND ORDERING NOISE (Helper Functions)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Compute robust scale of cost array using Median Absolute Deviation (MAD)
 * Returns MAD directly without scaling
 * 
 * DISCRETE COST HANDLING:
 * When costs are quantized (e.g., integers), MAD may be zero.
 * This causes band widths to collapse. We return a sentinel value
 * that triggers fallback logic in the caller.
 */
function robustScale(costs) {
  if (costs.length === 0) return 1.0;
  if (costs.length === 1) return 1.0;
  
  // Compute median
  const sorted = [...costs].sort((a, b) => a - b);
  const median = sorted[Math.floor(sorted.length / 2)];
  
  // Compute MAD (Median Absolute Deviation)
  const absDeviations = costs.map(c => Math.abs(c - median));
  absDeviations.sort((a, b) => a - b);
  const mad = absDeviations[Math.floor(absDeviations.length / 2)];
  
  // Return MAD (caller will handle MADâ‰ˆ0 case)
  return mad > 0 ? mad : 0.0;
}

/**
 * Fisher-Yates shuffle in-place for array slice [start, end)
 * Uses seeded RNG for determinism
 */
function seededShuffleInPlace(array, start, end, rng) {
  for (let i = end - 1; i > start; i--) {
    const j = start + Math.floor(rng.random() * (i - start + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

/**
 * Apply Mode B ordering noise: permute edits within cost bands only
 * 
 * Algorithm:
 * 1. Sort by cost (deterministic baseline)
 * 2. Partition into bands where adjacent costs differ by â‰¤ band_width
 * 3. Shuffle within each band (â‰¥2 elements)
 * 4. Return reordered list
 * 
 * This preserves rough cost ordering (cheap before expensive)
 * while introducing local permutations within ties.
 */
function applyModeBOrderingNoise(scoredEdits, sigma, rng, epsCost = 1e-9) {
  if (!sigma || sigma <= 0) return scoredEdits;
  if (scoredEdits.length < 2) return scoredEdits;
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DEBUG LOGGING: Track tie-band behavior
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const debugLog = {
    sigma: sigma,
    nEdits: scoredEdits.length,
    costs: scoredEdits.map(x => x.cost),
    s_cost: 0,
    band: 0,
    tieBands: [],
    permutationsApplied: 0
  };
  
  // Step 1: Deterministic baseline sort (cost ascending, stable tie-breaker)
  scoredEdits.sort((a, b) => {
    const costDiff = a.cost - b.cost;
    if (Math.abs(costDiff) > 1e-12) return costDiff;
    // Stable tie-breaker using edit type and params
    return editKey(a.edit) < editKey(b.edit) ? -1 : 1;
  });
  
  // Step 2: Compute node-local cost scale with discrete cost handling
  const costs = scoredEdits.map(x => x.cost);
  const s_cost = robustScale(costs);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DISCRETE COST MODE DETECTION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // When costs are quantized (e.g., integers), MAD â‰ˆ 0
  // In this regime, use unit scale (1.0) so Ïƒ represents "cost units"
  // 
  // Scientific interpretation:
  //   - Continuous costs: ÏƒÂ·MAD = relative scale
  //   - Discrete costs: ÏƒÂ·1.0 = absolute units (e.g., Ïƒ=0.5 â†’ half-unit bands)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const DISCRETE_THRESHOLD = 1e-12;
  const isDiscreteCostMode = s_cost < DISCRETE_THRESHOLD;
  const effectiveScale = isDiscreteCostMode ? 1.0 : s_cost;
  const band = Math.max(epsCost, sigma * effectiveScale);
  
  debugLog.s_cost = s_cost;
  debugLog.effectiveScale = effectiveScale;
  debugLog.isDiscreteCostMode = isDiscreteCostMode;
  debugLog.band = band;
  debugLog.costRange = [Math.min(...costs), Math.max(...costs)];
  debugLog.costGaps = [];
  for (let i = 1; i < costs.length; i++) {
    debugLog.costGaps.push(costs[i] - costs[i-1]);
  }
  
  // Step 3: Partition into bands and shuffle within each
  let i = 0;
  while (i < scoredEdits.length) {
    // Find end of band: consecutive edits with cost difference â‰¤ band
    let j = i + 1;
    while (j < scoredEdits.length && 
           Math.abs(scoredEdits[j].cost - scoredEdits[j-1].cost) <= band) {
      j++;
    }
    
    const bandSize = j - i;
    debugLog.tieBands.push({
      start: i,
      end: j,
      size: bandSize,
      costRange: [scoredEdits[i].cost, scoredEdits[j-1].cost]
    });
    
    // Shuffle band [i, j) if it has â‰¥2 elements
    if (bandSize >= 2) {
      seededShuffleInPlace(scoredEdits, i, j, rng);
      debugLog.permutationsApplied++;
    }
    
    i = j;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LOG DEBUG INFO (console only, selective sampling)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Store all diagnostics globally for analysis
  if (typeof window !== 'undefined') {
    if (!window.modeBDiagnostics) window.modeBDiagnostics = [];
    window.modeBDiagnostics.push(debugLog);
  }
  
  // Log only first 5 calls per sigma value (prevents console spam)
  if (typeof window !== 'undefined') {
    if (!window.modeBLogCount) window.modeBLogCount = {};
    const sigmaKey = sigma.toFixed(4);
    if (!window.modeBLogCount[sigmaKey]) window.modeBLogCount[sigmaKey] = 0;
    window.modeBLogCount[sigmaKey]++;
    
    const shouldLog = window.modeBLogCount[sigmaKey] <= 5;
    
    if (shouldLog) {
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      console.log(`MODE B TIE-BAND DIAGNOSTIC (Call #${window.modeBLogCount[sigmaKey]} for Ïƒ=${sigmaKey})`);
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      console.log(`Ïƒ = ${debugLog.sigma.toFixed(4)}`);
      console.log(`Number of edits: ${debugLog.nEdits}`);
      console.log(`Cost range: [${debugLog.costRange[0].toFixed(6)}, ${debugLog.costRange[1].toFixed(6)}]`);
      console.log(`Robust scale (MAD): ${debugLog.s_cost.toFixed(6)}`);
      
      // Discrete cost mode indicator
      if (debugLog.isDiscreteCostMode) {
        console.log(`âš™ï¸  DISCRETE COST MODE: MADâ‰ˆ0 â†’ using fallback scale = 1.0`);
        console.log(`   Interpretation: Ïƒ represents units of cost quantum`);
      }
      
      console.log(`Effective scale: ${debugLog.effectiveScale.toFixed(6)}`);
      console.log(`Band width: ${debugLog.band.toFixed(9)}`);
      console.log(`Tie-bands found: ${debugLog.tieBands.length}`);
      console.log(`Permutations applied: ${debugLog.permutationsApplied}`);
      
      if (debugLog.permutationsApplied === 0) {
        console.log('\nâš ï¸ NO PERMUTATIONS APPLIED');
        console.log('First 5 cost gaps vs band width:');
        for (let k = 0; k < Math.min(5, debugLog.costGaps.length); k++) {
          const gap = debugLog.costGaps[k];
          const exceeds = gap > debugLog.band;
          console.log(`  Gap[${k}]: ${gap.toExponential(3)} ${exceeds ? '> band âœ—' : 'â‰¤ band âœ“'}`);
        }
      }
      
      if (debugLog.tieBands.length > 0 && debugLog.permutationsApplied > 0) {
        console.log('\nâœ“ Tie-bands detected:');
        debugLog.tieBands.slice(0, 3).forEach((tb, idx) => {
          if (tb.size >= 2) {
            console.log(`  Band ${idx+1}: size=${tb.size}, costs=[${tb.costRange[0].toFixed(6)}, ${tb.costRange[1].toFixed(6)}]`);
          }
        });
      }
      
      if (debugLog.costGaps.length > 0) {
        const minGap = Math.min(...debugLog.costGaps);
        const maxGap = Math.max(...debugLog.costGaps);
        console.log(`\nCost gap range: [${minGap.toExponential(3)}, ${maxGap.toFixed(6)}]`);
        console.log(`Band width: ${debugLog.band.toExponential(3)}`);
      }
      
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    }
  }
  
  return scoredEdits;
}

/**
 * Generate stable key for edit (for tie-breaking)
 */
function editKey(edit) {
  const parts = [edit.type];
  if (edit.sigma !== undefined) parts.push(edit.sigma);
  if (edit.pattern !== undefined) parts.push(edit.pattern);
  if (edit.replacement !== undefined) parts.push(edit.replacement);
  if (edit.ruleIndex !== undefined) parts.push(edit.ruleIndex);
  if (edit.operator !== undefined) parts.push(edit.operator);
  return parts.join('|');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function editCost(S, edit) {
  switch(edit.type) {
    case 'add_symbol':
      return 1;
      
    case 'remove_symbol':
      const S_test = applyEdit(S, edit);
      const violations = countConstraintViolations(S_test);
      return 1 + violations;
      
    case 'modify_rule':
      const [idx, newP, newR] = edit.args;
      if (idx >= S.R.length) return Infinity;
      const oldP = S.R[idx].pattern;
      const oldR = S.R[idx].replacement;
      const tokenChanges = (oldP !== newP ? 1 : 0) + (oldR !== newR ? 1 : 0);
      return tokenChanges;
      
    case 'add_rule':
      return 1;
      
    case 'remove_rule':
      return 1;
      
    case 'apply_operator':
      return OPERATOR_WEIGHTS[edit.args[0]] || 3;
      
    case 'remove_operator':
      return OPERATOR_WEIGHTS[edit.args[0]] || 3;
      
    default:
      return 1;
  }
}

function countConstraintViolations(S) {
  let violations = 0;
  for (const constraint of S.C) {
    if (!checkConstraint(S, constraint)) {
      violations += constraint.severity;
    }
  }
  return violations;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONSTRAINT CHECKING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function checkConstraint(S, constraint) {
  switch(constraint.type) {
    case 'Consistency':
      for (const rule of S.R) {
        for (const symbol of rule.replacement) {
          if (!S.Sigma.has(symbol)) {
            return false;
          }
        }
      }
      return true;
      
    case 'Closure':
      return S.O.has('OpXIII') || S.O.has('OpXVI');
      
    case 'Bounded':
      return S.Sigma.size <= 20;
      
    default:
      return true;
  }
}

function passesAllConstraints(S) {
  for (const constraint of S.C) {
    if (!checkConstraint(S, constraint)) {
      return false;
    }
  }
  return true;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STRUCTURAL MASS FUNCTIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function m1(S) {
  const UNIVERSAL_ALPHABET = ['0', '1', 'Ï„', 'Ï†', 'Îµ', 'Î´', 'Î±', 'Î²', 'Î³'];
  const MAX_PATTERN_LENGTH = 2;
  
  let E_syntactic = [];
  let E_admissible = [];
  
  for (const sigma of UNIVERSAL_ALPHABET) {
    if (!S.Sigma.has(sigma)) {
      const edit = new Edit('add_symbol', sigma);
      E_syntactic.push(edit);
      const S_prime = applyEdit(S, edit);
      if (passesAllConstraints(S_prime)) {
        E_admissible.push(edit);
      }
    }
  }
  
  const sigmaArray = Array.from(S.Sigma).slice(0, 5);
  for (const sigma of sigmaArray) {
    const edit = new Edit('remove_symbol', sigma);
    E_syntactic.push(edit);
    const S_prime = applyEdit(S, edit);
    if (passesAllConstraints(S_prime)) {
      E_admissible.push(edit);
    }
  }
  
  for (let i = 0; i < Math.min(S.R.length, 3); i++) {
    const patterns = generatePatterns(S.Sigma, MAX_PATTERN_LENGTH);
    for (const pattern of patterns.slice(0, 5)) {
      for (const replacement of patterns.slice(0, 5)) {
        if (pattern === S.R[i].pattern && replacement === S.R[i].replacement) continue;
        const edit = new Edit('modify_rule', i, pattern, replacement);
        E_syntactic.push(edit);
        const S_prime = applyEdit(S, edit);
        if (passesAllConstraints(S_prime)) {
          E_admissible.push(edit);
        }
      }
    }
  }
  
  const patterns = generatePatterns(S.Sigma, MAX_PATTERN_LENGTH);
  for (const pattern of patterns.slice(0, 3)) {
    for (const replacement of patterns.slice(0, 3)) {
      const edit = new Edit('add_rule', pattern, replacement);
      E_syntactic.push(edit);
      const S_prime = applyEdit(S, edit);
      if (passesAllConstraints(S_prime)) {
        E_admissible.push(edit);
      }
    }
  }
  
  if (E_syntactic.length === 0) return 1.0;
  return E_admissible.length / E_syntactic.length;
}

function generatePatterns(alphabet, maxLength) {
  const patterns = [];
  const alphaArray = Array.from(alphabet);
  
  for (const a of alphaArray) {
    patterns.push(a);
  }
  
  if (maxLength >= 2) {
    for (const a of alphaArray) {
      for (const b of alphaArray) {
        patterns.push(a + b);
      }
    }
  }
  
  return patterns;
}

function m2(S, depth = 50) {
  let state = S.clone();
  const defects = [];
  
  for (let t = 0; t < depth; t++) {
    if (state.R.length > 0) {
      const defectCount = countDefects(state);
      defects.push(defectCount);
    } else {
      defects.push(0);
    }
  }
  
  const times = Array.from({length: depth}, (_, i) => i);
  const {beta} = linearRegression(times, defects);
  
  return Math.exp(-Math.abs(beta));
}

function countDefects(S) {
  let defects = 0;
  
  for (const rule of S.R) {
    for (const symbol of rule.replacement) {
      if (!S.Sigma.has(symbol)) {
        defects += 1;
      }
    }
  }
  
  for (const constraint of S.C) {
    if (!checkConstraint(S, constraint)) {
      defects += constraint.severity;
    }
  }
  
  if (S.Sigma.size > 20) {
    defects += S.Sigma.size - 20;
  }
  
  return defects;
}

function linearRegression(x, y) {
  const n = x.length;
  const x_mean = x.reduce((a, b) => a + b, 0) / n;
  const y_mean = y.reduce((a, b) => a + b, 0) / n;
  
  let numerator = 0;
  let denominator = 0;
  
  for (let i = 0; i < n; i++) {
    numerator += (x[i] - x_mean) * (y[i] - y_mean);
    denominator += (x[i] - x_mean) ** 2;
  }
  
  const beta = denominator === 0 ? 0 : numerator / denominator;
  const alpha = y_mean - beta * x_mean;
  
  return {beta, alpha};
}

function m3(S) {
  let score = 0.5;
  
  if (S.O.has('OpXIII')) score += 0.3;
  if (S.O.has('OpXVI')) score += 0.2;
  if (S.O.has('OpXII')) score -= 0.1;
  
  if (S.C.some(c => c.type === 'Closure')) score += 0.15;
  
  if (S.R.length >= 2) score += 0.05;
  
  return Math.min(Math.max(score, 0), 1);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ENDPOINT EQUIVALENCE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function isTauClosed(S) {
  return checkConstraint(S, new Constraint('Closure'));
}

function endpointSignature(S, massFunc, eps = 0.001) {
  const mass = massFunc(S);
  const roundedMass = Math.round(mass / eps) * eps;
  
  return JSON.stringify({
    tauClosed: isTauClosed(S),
    mass: roundedMass,
    sigmaSize: S.Sigma.size,
    ruleCount: S.R.length
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DIVERGENCE COMPUTATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function computeDivergence(path, massFunction) {
  if (path.length < 2) return 0;
  
  const masses = path.map(S => massFunction(S));
  
  const A = masses[masses.length - 1] - masses[0];
  
  let B = 0;
  for (let i = 1; i < masses.length; i++) {
    B += Math.abs(masses[i] - masses[i-1]);
  }
  
  const Div = B - Math.abs(A);
  
  return Div;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PATH SEARCH (BEAM SEARCH WITH Ïƒ-INJECTION)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PathNode {
  constructor(state, parent = null, edit = null, cost = 0) {
    this.state = state;
    this.parent = parent;
    this.edit = edit;
    this.cost = cost;
    this.depth = parent ? parent.depth + 1 : 0;
    this.endpointType = null;
  }
  
  getPath() {
    const path = [];
    let node = this;
    while (node) {
      path.unshift(node.state);
      node = node.parent;
    }
    return path;
  }
  
  getEdits() {
    const edits = [];
    let node = this;
    while (node.parent) {
      edits.unshift(node.edit);
      node = node.parent;
    }
    return edits;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COST DISTRIBUTION ANALYZER (Diagnostic Harness)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Analyze edit cost distributions to determine if tie-bands can exist
 * Collects raw cost data and computes distribution statistics
 */
async function analyzeCostDistributions(config = {}) {
  const {
    nSamples = 10,
    beamWidth = 3,
    maxDepth = 8,
    costCutoff = 15,
    baseSeed = 137042
  } = config;
  
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘ COST DISTRIBUTION ANALYZER                                     â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  const allCostSets = [];
  
  for (let sample = 0; sample < nSamples; sample++) {
    const {S0, S1, S2} = createToySystem();
    const rng = createSeededRNG(baseSeed + sample);
    
    // Run a single beam expansion to collect costs
    const S_start = S0;
    const beam = [{state: S_start, cost: 0, depth: 0}];
    const visited = new Set([S_start.hash()]);
    
    let nodeCostData = [];
    
    for (let depth = 0; depth < Math.min(maxDepth, 3); depth++) {
      if (beam.length === 0) break;
      
      const node = beam[0];
      
      // Generate edits
      const edits = generateAdmissibleEdits(node.state);
      
      // Score edits
      const scoredEdits = edits.map(edit => ({
        edit,
        cost: editCost(node.state, edit)
      }));
      
      if (scoredEdits.length > 0) {
        const costs = scoredEdits.map(x => x.cost);
        nodeCostData.push({
          depth,
          nEdits: costs.length,
          costs: costs,
          min: Math.min(...costs),
          max: Math.max(...costs),
          mean: costs.reduce((a,b) => a+b, 0) / costs.length
        });
      }
      
      // Continue beam (minimal - just for sampling)
      beam.shift();
    }
    
    allCostSets.push(nodeCostData);
  }
  
  // Aggregate statistics
  console.log(`Analyzed ${nSamples} sample runs\n`);
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('PER-NODE COST STATISTICS');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  const allNodeData = allCostSets.flat();
  
  if (allNodeData.length > 0) {
    // Overall statistics
    const allCosts = allNodeData.flatMap(n => n.costs);
    const sortedCosts = [...allCosts].sort((a,b) => a-b);
    
    console.log('Overall Distribution:');
    console.log(`  Total cost samples: ${allCosts.length}`);
    console.log(`  Min: ${Math.min(...allCosts).toFixed(6)}`);
    console.log(`  Max: ${Math.max(...allCosts).toFixed(6)}`);
    console.log(`  Mean: ${(allCosts.reduce((a,b) => a+b, 0) / allCosts.length).toFixed(6)}`);
    console.log(`  Median: ${sortedCosts[Math.floor(sortedCosts.length/2)].toFixed(6)}`);
    
    // Compute gaps between consecutive costs
    const gaps = [];
    for (let i = 1; i < sortedCosts.length; i++) {
      const gap = sortedCosts[i] - sortedCosts[i-1];
      if (gap > 1e-12) gaps.push(gap);
    }
    
    if (gaps.length > 0) {
      console.log(`\nCost Gaps (${gaps.length} non-zero gaps):`);
      console.log(`  Min gap: ${Math.min(...gaps).toFixed(9)}`);
      console.log(`  Max gap: ${Math.max(...gaps).toFixed(6)}`);
      console.log(`  Median gap: ${gaps.sort((a,b) => a-b)[Math.floor(gaps.length/2)].toFixed(9)}`);
      
      // Count "near-ties" at various thresholds
      const nearTies_1e9 = gaps.filter(g => g < 1e-9).length;
      const nearTies_1e6 = gaps.filter(g => g < 1e-6).length;
      const nearTies_1e3 = gaps.filter(g => g < 1e-3).length;
      
      console.log(`\nNear-Tie Analysis:`);
      console.log(`  Gaps < 1e-9: ${nearTies_1e9} (${(nearTies_1e9/gaps.length*100).toFixed(1)}%)`);
      console.log(`  Gaps < 1e-6: ${nearTies_1e6} (${(nearTies_1e6/gaps.length*100).toFixed(1)}%)`);
      console.log(`  Gaps < 1e-3: ${nearTies_1e3} (${(nearTies_1e3/gaps.length*100).toFixed(1)}%)`);
    }
    
    // Robust scale analysis
    const s_cost = robustScale(allCosts);
    console.log(`\nRobust Scale (MAD):`);
    console.log(`  s_cost: ${s_cost.toFixed(6)}`);
    console.log(`\nPotential Band Widths at Ïƒ=0.02:`);
    console.log(`  band = Ïƒ Ã— s_cost = ${(0.02 * s_cost).toFixed(9)}`);
    console.log(`  Comparison: min_gap = ${Math.min(...gaps).toFixed(9)}`);
    console.log(`  Verdict: ${(0.02 * s_cost) > Math.min(...gaps) ? 'âœ“ Band can capture ties' : 'âœ— Band too small'}`);
    
    // Per-node breakdown
    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('REPRESENTATIVE NODE SAMPLES');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    
    for (let i = 0; i < Math.min(3, allNodeData.length); i++) {
      const node = allNodeData[i];
      console.log(`Node ${i+1} (depth=${node.depth}):`);
      console.log(`  Edits: ${node.nEdits}`);
      console.log(`  Costs: [${node.costs.slice(0, 5).map(c => c.toFixed(4)).join(', ')}${node.costs.length > 5 ? '...' : ''}]`);
      console.log(`  Range: [${node.min.toFixed(6)}, ${node.max.toFixed(6)}]`);
      console.log('');
    }
  }
  
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ANALYSIS COMPLETE');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  return {
    allCostSets,
    summary: {
      nSamples,
      totalCosts: allCosts.length,
      costRange: [Math.min(...allCosts), Math.max(...allCosts)],
      robustScale: s_cost,
      minGap: gaps.length > 0 ? Math.min(...gaps) : null
    }
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function beamSearch(S_start, S_target, beamWidth, maxDepth, costCutoff, sigma, rng, sigmaMode, progressCallback) {
  let beam = [new PathNode(S_start)];
  const visited = new Set([S_start.hash()]);
  const allPaths = [];
  
  for (let depth = 0; depth < maxDepth; depth++) {
    const candidates = [];
    
    for (const node of beam) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Generate admissible edits (same for all Ïƒ-modes)
      // Mode B does NOT apply here - it applies AFTER cost scoring
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const edits = generateAdmissibleEdits(node.state);
      
      // Score edits by cost (lower is better)
      let scoredEdits = edits.map(edit => ({
        edit,
        cost: editCost(node.state, edit)
      })).filter(x => Number.isFinite(x.cost));

      if (scoredEdits.length === 0) continue;

      scoredEdits.sort((a, b) => a.cost - b.cost);

      // --- Ïƒ-robustness behavior ---
      // Ïƒ = 0 => deterministic top-B expansion
      // Ïƒ > 0 => randomize the ordering mildly, but still expand B branches
      // NOTE: keep branching > 1, otherwise beam collapses
      const B = Math.max(2, Math.min(beamWidth, scoredEdits.length));

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // MODE A vs MODE B: Ïƒ-ROBUSTNESS NOISE APPLICATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Ïƒ = 0 => deterministic top-B expansion (both modes identical)
      // Ïƒ > 0 => apply noise based on sigmaMode
      
      if (sigma > 0) {
        if (sigmaMode === 'decision') {
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // MODE A: DECISION NOISE (cost perturbation)
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Perturbs the COST values â†’ changes which edits look "best"
          // Tests: "What if I make a slightly suboptimal choice?"
          scoredEdits = scoredEdits
            .map(x => ({
              ...x,
              key: x.cost + sigma * 0.5 * rng.gaussian()
            }))
            .sort((a, b) => a.key - b.key);
            
        } else if (sigmaMode === 'ordering') {
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // MODE B: ORDERING NOISE (tie-band permutation)
          // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Perturbs the ORDER within cost bands â†’ changes exploration sequence
          // Tests: "What if I consider edits in a different order?"
          // CRITICAL: Preserves cost ordering (cheap before expensive)
          scoredEdits = applyModeBOrderingNoise(scoredEdits, sigma, rng);
        }
      }

      const expandSet = scoredEdits.slice(0, B);

      for (const {edit} of expandSet) {
        const S_prime = applyEdit(node.state, edit);
        const stateHash = S_prime.hash();

        if (visited.has(stateHash)) continue;

        const editCostVal = editCost(node.state, edit);
        const newCost = node.cost + editCostVal;
        if (!Number.isFinite(newCost) || newCost > costCutoff) continue;

        visited.add(stateHash);
        const newNode = new PathNode(S_prime, node, edit, newCost);
        candidates.push(newNode);

        // Endpoint detection (unchanged)
        const isExactTarget = S_target && S_prime.equals(S_target);
        const isDepthTerminal = newNode.depth >= maxDepth - 1;
        const isCostTerminal = newCost >= costCutoff * 0.9;

        if (isExactTarget || isDepthTerminal || isCostTerminal) {
          newNode.endpointType = isExactTarget ? 'exact' : 'terminal';
          allPaths.push(newNode);
        }
      }
    }
    
    candidates.sort((a, b) => a.cost - b.cost);
    beam = candidates.slice(0, beamWidth);
    
    if (progressCallback) {
      await progressCallback(depth, maxDepth, visited.size, allPaths.length);
    }
    
    if (beam.length === 0) break;
  }
  
  // Add final beam states
  for (const node of beam) {
    if (!node.endpointType) {
      node.endpointType = 'terminal';
      allPaths.push(node);
    }
  }
  
  return {
    paths: allPaths,
    statesExplored: visited.size
  };
}

function generateAdmissibleEdits(S) {
  const edits = [];
  const UNIVERSAL_ALPHABET = ['0', '1', 'Ï„', 'Ï†'];
  
  for (const sym of UNIVERSAL_ALPHABET) {
    if (!S.Sigma.has(sym)) {
      edits.push(new Edit('add_symbol', sym));
    }
  }
  
  for (const sym of Array.from(S.Sigma).slice(0, 2)) {
    edits.push(new Edit('remove_symbol', sym));
  }
  
  const patterns = generatePatterns(S.Sigma, 2);
  for (const p of patterns.slice(0, 2)) {
    for (const r of patterns.slice(0, 2)) {
      edits.push(new Edit('add_rule', p, r));
    }
  }
  
  for (let i = 0; i < Math.min(S.R.length, 2); i++) {
    for (const p of patterns.slice(0, 2)) {
      for (const r of patterns.slice(0, 2)) {
        edits.push(new Edit('modify_rule', i, p, r));
      }
    }
  }
  
  for (const op of ['OpXIII', 'OpXIV', 'OpXVI']) {
    if (!S.O.has(op)) {
      edits.push(new Edit('apply_operator', op));
    }
  }
  
  const admissibleEdits = edits.filter(edit => {
    const S_prime = applyEdit(S, edit);
    return passesAllConstraints(S_prime);
  });
  
  // Mode B NO LONGER applies here - moved to beamSearch after cost scoring
  return admissibleEdits;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GEODESIC CLASSIFICATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function classifyGeodesics(paths, massFunction) {
  if (paths.length === 0) {
    console.warn('No comparable endpoint paths found â€” divergence undefined');
    return {
      results: [],
      endpointClasses: {},
      reason: 'EMPTY_ENDPOINT_SET'
    };
  }
  
  const results = [];
  
  for (const node of paths) {
    const path = node.getPath();
    const edits = node.getEdits();
    const cost = node.cost;
    
    const divergence = computeDivergence(path, massFunction);
    
    // State-dependent path cost
    let pathCost = 0;
    for (let i = 0; i < edits.length; i++) {
      pathCost += editCost(path[i], edits[i]);
    }
    
    results.push({
      node,
      path,
      edits,
      cost,
      divergence,
      pathCost,
      endpointType: node.endpointType
    });
  }
  
  // Group by endpoint equivalence class
  const endpointClasses = {};
  for (const result of results) {
    const sig = endpointSignature(result.path[result.path.length - 1], massFunction);
    if (!endpointClasses[sig]) {
      endpointClasses[sig] = [];
    }
    endpointClasses[sig].push(result);
  }
  
  const minCost = Math.min(...results.map(r => r.cost));
  const EPSILON_COST = 2.0;
  
  // Classify within each endpoint class
  for (const sig in endpointClasses) {
    const classResults = endpointClasses[sig];
    
    if (classResults.length < 2) continue;
    
    const classDivergences = classResults.map(r => r.divergence);
    const classMinDiv = Math.min(...classDivergences);
    
    for (const result of classResults) {
      result.isMetricGeodesic = Math.abs(result.cost - minCost) < 0.01;
      
      if (result.isMetricGeodesic) {
        const nearbyDivergences = classResults
          .filter(r => Math.abs(r.cost - result.cost) < EPSILON_COST)
          .map(r => r.divergence);
        const minDiv = Math.min(...nearbyDivergences);
        result.isPhysicalGeodesic = Math.abs(result.divergence - minDiv) < 0.01;
      } else {
        result.isPhysicalGeodesic = false;
      }
    }
  }
  
  return {
    results,
    endpointClasses
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PATH CLASSIFICATION (STABILITY CATEGORIES)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function classifyPathStability(divergence) {
  if (divergence < 0.001) return 'perfectlyConservative';
  if (divergence < 0.01) return 'stable';
  if (divergence < 0.1) return 'tauOnly';
  return 'unstable';
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TOY EXAMPLE SYSTEM
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function createToySystem() {
  const S0 = new MechanismState(
    ['0', '1'],
    [new Rule('0', '1')],
    [new Constraint('Consistency')],
    []
  );
  
  const S1 = new MechanismState(
    ['0', '1'],
    [new Rule('0', '1'), new Rule('1', '0')],
    [new Constraint('Consistency')],
    []
  );
  
  const S2 = new MechanismState(
    ['0', '1', 'Ï„'],
    [new Rule('0', 'Ï„'), new Rule('Ï„', '1'), new Rule('1', '0')],
    [new Constraint('Consistency'), new Constraint('Closure')],
    ['OpXIII']
  );
  
  return {S0, S1, S2};
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ïƒ-SWEEP INFRASTRUCTURE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let abortSigmaSweep = false;
let sweepResults = [];

function yieldToUI() {
  return new Promise(resolve => {
    setTimeout(resolve, 0);
  });
}

async function runSingleExperiment(config) {
  const {S0, S1, S2} = createToySystem();
  const {sigma, seed, massFunc, beamWidth, maxDepth, costCutoff, sigmaMode = 'decision'} = config;
  
  const rng = createSeededRNG(seed);
  
  const progressCb = async () => {
    // Minimal callback to prevent slowdown
    await yieldToUI();
  };
  
  const {paths, statesExplored} = await beamSearch(
    S0, S2, beamWidth, maxDepth, costCutoff, sigma, rng, sigmaMode, progressCb
  );
  
  const classification = classifyGeodesics(paths, massFunc);
  
  if (classification.reason === 'EMPTY_ENDPOINT_SET') {
    return {
      sigma,
      sigmaMode,
      seed,
      empty: true,
      statesExplored
    };
  }
  
  const results = classification.results;
  const endpointClasses = classification.endpointClasses;
  
  // Compute metrics
  const metricGeodesics = results.filter(r => r.isMetricGeodesic).length;
  const physicalGeodesics = results.filter(r => r.isPhysicalGeodesic).length;
  
  const divergences = results.map(r => r.divergence);
  const minD = Math.min(...divergences);
  const meanD = divergences.reduce((a, b) => a + b, 0) / divergences.length;
  const varD = divergences.reduce((a, b) => a + (b - meanD) ** 2, 0) / divergences.length;
  const gap = meanD - minD;
  
  // Stability fractions
  const stabilities = results.map(r => classifyPathStability(r.divergence));
  const total = stabilities.length;
  const pPC = stabilities.filter(s => s === 'perfectlyConservative').length / total;
  const pStable = stabilities.filter(s => s === 'stable').length / total;
  const pTauOnly = stabilities.filter(s => s === 'tauOnly').length / total;
  const pUnstable = stabilities.filter(s => s === 'unstable').length / total;
  
  // Top endpoint classes
  const topClasses = Object.entries(endpointClasses)
    .map(([sig, paths]) => ({
      signature: sig,
      count: paths.length,
      minD: Math.min(...paths.map(p => p.divergence))
    }))
    .sort((a, b) => a.minD - b.minD)
    .slice(0, 5);
  
  return {
    sigma,
    sigmaMode,
    seed,
    statesExplored,
    endpointsFound: paths.length,
    endpointClasses: Object.keys(endpointClasses).length,
    metricGeodesics,
    physicalGeodesics,
    minD,
    meanD,
    varD,
    gap,
    pPerfectlyConservative: pPC,
    pStable,
    pTauOnly,
    pUnstable,
    topClasses
  };
}

async function runSigmaSweep(config) {
  const {sigmaStart, sigmaEnd, sigmaStep, repetitions, baseSeed, massFunc, beamWidth, maxDepth, costCutoff, sigmaMode = 'decision'} = config;
  
  sweepResults = [];
  abortSigmaSweep = false;
  
  const sigmaValues = [];
  for (let s = sigmaStart; s <= sigmaEnd; s += sigmaStep) {
    sigmaValues.push(Math.round(s * 100) / 100); // Round to 2 decimals
  }
  
  const totalRuns = sigmaValues.length * repetitions;
  let completed = 0;
  
  log(`Starting Ïƒ-sweep: ${sigmaValues.length} Ïƒ-values Ã— ${repetitions} reps = ${totalRuns} runs`, 'info');
  
  for (const sigma of sigmaValues) {
    if (abortSigmaSweep) {
      log('Ïƒ-sweep aborted by user', 'warning');
      break;
    }
    
    for (let r = 0; r < repetitions; r++) {
      if (abortSigmaSweep) break;
      
      await yieldToUI();
      
      const seed = baseSeed + r;
      
      ui.metricSweepSigma.textContent = sigma.toFixed(2);
      ui.metricSweepProgress.textContent = `${completed}/${totalRuns}`;
      updateProgress((completed / totalRuns) * 100);
      
      try {
        const runResult = await runSingleExperiment({
          sigma,
          seed,
          massFunc,
          beamWidth,
          maxDepth,
          costCutoff,
          sigmaMode
        });
        
        sweepResults.push(runResult);
        
        // Update UI with latest run
        if (completed % 5 === 0) {
          updateMetricsFromRun(runResult);
        }
        
        completed++;
        
      } catch (error) {
        log(`Error in run Ïƒ=${sigma}, seed=${seed}: ${error.message}`, 'error');
      }
    }
    
    if (completed % 10 === 0) {
      log(`Progress: ${completed}/${totalRuns} runs completed`, 'info');
    }
  }
  
  updateProgress(100);
  
  return sweepResults;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UI INTEGRATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const ui = {
  runToyBtn: document.getElementById('runToyExample'),
  runBtn: document.getElementById('runExperiment'),
  stopBtn: document.getElementById('stopExperiment'),
  validateBtn: document.getElementById('validateAlgorithms'),
  exportBtn: document.getElementById('exportData'),
  
  // Ïƒ-sweep controls
  sigmaEnabled: document.getElementById('sigmaEnabled'),
  runSigmaSweepBtn: document.getElementById('runSigmaSweep'),
  stopSigmaSweepBtn: document.getElementById('stopSigmaSweep'),
  exportSigmaSweepBtn: document.getElementById('exportSigmaSweep'),
  
  // Mode B validation controls
  validateModeBBtn: document.getElementById('validateModeB'),
  analyzeCostsBtn: document.getElementById('analyzeCosts'),
  enableModeBCheckbox: document.getElementById('enableModeB'),
  modeBValidationResults: document.getElementById('modeBValidationResults'),
  costAnalysisResults: document.getElementById('costAnalysisResults'),
  
  // Cost Distribution Harness (Step 2)
  runCostDistAnalysisBtn: document.getElementById('runCostDistAnalysis'),
  clearCostDistBtn: document.getElementById('clearCostDistResults'),
  costDistResults: document.getElementById('costDistResults'),
  
  status: document.getElementById('statusDisplay'),
  progress: document.getElementById('progressFill'),
  logContainer: document.getElementById('logContainer'),
  pathsTableBody: document.getElementById('pathsTableBody'),
  
  metricSigma: document.getElementById('metricSigma'),
  metricSigmaMode: document.getElementById('metricSigmaMode'),
  metricSeed: document.getElementById('metricSeed'),
  metricStatesTotal: document.getElementById('metricStatesTotal'),
  metricEndpoints: document.getElementById('metricEndpoints'),
  metricGeodesicsMetric: document.getElementById('metricGeodesicsMetric'),
  metricGeodesicsPhysical: document.getElementById('metricGeodesicsPhysical'),
  metricDivMin: document.getElementById('metricDivMin'),
  metricDivMean: document.getElementById('metricDivMean'),
  metricDivGap: document.getElementById('metricDivGap'),
  testGeodesicsExist: document.getElementById('testGeodesicsExist'),
  testLeastDivergence: document.getElementById('testLeastDivergence'),
  
  metricSweepProgress: document.getElementById('metricSweepProgress'),
  metricSweepSigma: document.getElementById('metricSweepSigma')
};

let running = false;
let experimentData = null;
let modeBValidated = false;

function log(message, type = 'info') {
  const entry = document.createElement('div');
  entry.className = `log-entry log-${type}`;
  entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
  ui.logContainer.appendChild(entry);
  ui.logContainer.scrollTop = ui.logContainer.scrollHeight;
  console.log(message);
}

function showStatus(message, type = 'running') {
  ui.status.textContent = message;
  ui.status.className = `status ${type}`;
  ui.status.style.display = 'block';
}

function updateProgress(percent) {
  ui.progress.style.width = `${percent}%`;
}

function updateMetricsFromRun(runData) {
  if (runData.empty) {
    ui.metricSigma.textContent = runData.sigma.toFixed(2);
    ui.metricSigmaMode.textContent = runData.sigmaMode || 'decision';
    ui.metricSeed.textContent = runData.seed;
    ui.metricStatesTotal.textContent = runData.statesExplored;
    ui.metricEndpoints.textContent = '0';
    ui.metricGeodesicsMetric.textContent = '0';
    ui.metricGeodesicsPhysical.textContent = '0';
    ui.metricDivMin.textContent = 'N/A';
    ui.metricDivMean.textContent = 'N/A';
    ui.metricDivGap.textContent = 'N/A';
    return;
  }
  
  ui.metricSigma.textContent = runData.sigma.toFixed(2);
  ui.metricSigmaMode.textContent = runData.sigmaMode || 'decision';
  ui.metricSeed.textContent = runData.seed;
  ui.metricStatesTotal.textContent = runData.statesExplored;
  ui.metricEndpoints.textContent = runData.endpointsFound;
  ui.metricGeodesicsMetric.textContent = runData.metricGeodesics;
  ui.metricGeodesicsPhysical.textContent = runData.physicalGeodesics;
  ui.metricDivMin.textContent = runData.minD.toFixed(6);
  ui.metricDivMean.textContent = runData.meanD.toFixed(6);
  ui.metricDivGap.textContent = runData.gap.toFixed(6);
}

function updateMetrics(data) {
  ui.metricStatesTotal.textContent = data.statesExplored || 'â€”';
  ui.metricEndpoints.textContent = data.endpoints || 'â€”';
  ui.metricGeodesicsMetric.textContent = data.metricGeodesics || 'â€”';
  ui.metricGeodesicsPhysical.textContent = data.physicalGeodesics || 'â€”';
  
  // Guard against null divergence
  ui.metricDivMin.textContent = data.divMin !== null && data.divMin !== undefined 
    ? data.divMin.toFixed(6) 
    : (data.reason === 'EMPTY_ENDPOINT_SET' ? 'N/A' : 'â€”');
  ui.metricDivMean.textContent = data.divMean !== null && data.divMean !== undefined 
    ? data.divMean.toFixed(6) 
    : (data.reason === 'EMPTY_ENDPOINT_SET' ? 'N/A' : 'â€”');
  
  ui.testGeodesicsExist.innerHTML = data.geodesicsExist ? 
    '<span class="badge badge-success">âœ“ PASS</span>' : 
    (data.reason === 'EMPTY_ENDPOINT_SET' ? 
      '<span class="badge badge-warning">âš  UNTESTED</span>' :
      '<span class="badge badge-error">âœ— FAIL</span>');
  ui.testLeastDivergence.innerHTML = data.leastDivergence ? 
    '<span class="badge badge-success">âœ“ PASS</span>' : 
    (data.reason === 'EMPTY_ENDPOINT_SET' ? 
      '<span class="badge badge-warning">âš  UNTESTED</span>' :
      '<span class="badge badge-error">âœ— FAIL</span>');
}

function populatePathsTable(classification) {
  ui.pathsTableBody.innerHTML = '';
  
  const results = classification.results || [];
  
  if (results.length === 0) {
    ui.pathsTableBody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #ffaa4a;">No endpoint paths found</td></tr>';
    return;
  }
  
  for (let i = 0; i < results.length; i++) {
    const r = results[i];
    const row = document.createElement('tr');
    
    const pathId = `P${i.toString().padStart(3, '0')}`;
    const startEnd = `S0 â†’ S${r.path.length - 1}`;
    const typeLabel = r.isPhysicalGeodesic ? 
      '<span class="badge badge-success">Physical</span>' :
      r.isMetricGeodesic ?
      '<span class="badge badge-info">Metric</span>' :
      '<span class="badge">Regular</span>';
    
    const endpointLabel = r.endpointType === 'exact' ?
      '<span class="badge badge-success">Exact</span>' :
      '<span class="badge badge-info">Terminal</span>';
    
    let classification = 'Path';
    if (r.divergence < 0.001) classification = '<span class="badge badge-success">Perfectly Conservative</span>';
    else if (r.divergence < 0.01) classification = '<span class="badge badge-info">Stable</span>';
    
    row.innerHTML = `
      <td><code>${pathId}</code></td>
      <td>${startEnd}</td>
      <td>${r.cost.toFixed(2)}</td>
      <td>${r.divergence.toFixed(6)}</td>
      <td>${typeLabel}</td>
      <td>${endpointLabel}</td>
      <td>${classification}</td>
    `;
    
    ui.pathsTableBody.appendChild(row);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MODE B VALIDATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function validateModeB() {
  log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
  log('MODE B VALIDATION PROTOCOL', 'warning');
  log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
  
  const testSigma = parseFloat(document.getElementById('modeBTestSigma').value);
  const runs = parseInt(document.getElementById('modeBValidationRuns').value);
  const baseSeed = 137042;
  
  // Test 1: Ïƒ = 0 baseline (must match Mode A)
  log('Test 1: Verifying Ïƒ=0 reproduces baseline...', 'info');
  
  const baseline = await runSingleExperiment({
    sigma: 0,
    sigmaMode: 'ordering',
    seed: baseSeed,
    massFunc: m1,
    beamWidth: 3,
    maxDepth: 8,
    costCutoff: 15
  });
  
  const modeABaseline = await runSingleExperiment({
    sigma: 0,
    sigmaMode: 'decision',
    seed: baseSeed,
    massFunc: m1,
    beamWidth: 3,
    maxDepth: 8,
    costCutoff: 15
  });
  
  const baselineMatch = baseline.statesExplored === modeABaseline.statesExplored &&
                        baseline.endpointsFound === modeABaseline.endpointsFound;
  
  if (baselineMatch) {
    log('âœ“ Test 1 PASSED: Ïƒ=0 matches Mode A baseline exactly', 'success');
  } else {
    log(`âœ— Test 1 FAILED: Ïƒ=0 diverges from baseline`, 'error');
    ui.modeBValidationResults.innerHTML = '<strong>âŒ Validation Failed:</strong> Ïƒ=0 does not match baseline';
    ui.modeBValidationResults.style.display = 'block';
    ui.modeBValidationResults.className = 'warning-box';
    return false;
  }
  
  // Test 2: statesExplored remains high for Ïƒ > 0
  log(`Test 2: Testing statesExplored stability at Ïƒ=${testSigma}...`, 'info');
  
  const testResults = [];
  for (let i = 0; i < runs; i++) {
    const result = await runSingleExperiment({
      sigma: testSigma,
      sigmaMode: 'ordering',
      seed: baseSeed + i,
      massFunc: m1,
      beamWidth: 3,
      maxDepth: 8,
      costCutoff: 15
    });
    testResults.push(result);
    await yieldToUI();
  }
  
  const avgExplored = testResults.reduce((sum, r) => sum + r.statesExplored, 0) / testResults.length;
  const minExplored = Math.min(...testResults.map(r => r.statesExplored));
  const threshold = 0.8 * baseline.statesExplored;
  
  if (avgExplored >= threshold) {
    log(`âœ“ Test 2 PASSED: statesExplored stable (avg=${avgExplored.toFixed(0)} â‰¥ ${threshold.toFixed(0)})`, 'success');
  } else {
    log(`âœ— Test 2 FAILED: statesExplored dropped (avg=${avgExplored.toFixed(0)} < ${threshold.toFixed(0)})`, 'error');
    ui.modeBValidationResults.innerHTML = `<strong>âŒ Validation Failed:</strong> statesExplored dropped to ${avgExplored.toFixed(0)} (< 80% of baseline ${baseline.statesExplored})`;
    ui.modeBValidationResults.style.display = 'block';
    ui.modeBValidationResults.className = 'warning-box';
    return false;
  }
  
  // Test 3: Endpoints remain non-empty (allow small stochastic failure rate)
  log('Test 3: Verifying endpoints remain mostly non-empty...', 'info');
  
  const emptyCount = testResults.filter(r => r.empty).length;
  const emptyRate = emptyCount / runs;
  
  // Diagnostic: log empty vs non-empty characteristics
  if (emptyCount > 0) {
    const emptyRuns = testResults.filter(r => r.empty);
    const nonEmptyRuns = testResults.filter(r => !r.empty);
    const avgEmptyExplored = emptyRuns.reduce((sum, r) => sum + r.statesExplored, 0) / emptyRuns.length;
    const avgNonEmptyExplored = nonEmptyRuns.reduce((sum, r) => sum + r.statesExplored, 0) / nonEmptyRuns.length;
    log(`  â„¹ï¸ Empty runs: avg statesExplored=${avgEmptyExplored.toFixed(0)}`, 'info');
    log(`  â„¹ï¸ Non-empty runs: avg statesExplored=${avgNonEmptyExplored.toFixed(0)}`, 'info');
  }
  
  // Allow up to 10% empty endpoint rate (stochastic tolerance for tie-band shuffling)
  if (emptyRate <= 0.10) {
    if (emptyCount === 0) {
      log('âœ“ Test 3 PASSED: No empty-endpoint failures', 'success');
    } else {
      log(`âœ“ Test 3 PASSED: ${emptyCount}/${runs} empty endpoints (${(emptyRate*100).toFixed(1)}% â‰¤ 10% threshold)`, 'success');
    }
  } else {
    log(`âœ— Test 3 FAILED: ${emptyCount}/${runs} runs had empty endpoints (${(emptyRate*100).toFixed(1)}% > 10%)`, 'error');
    ui.modeBValidationResults.innerHTML = `<strong>âŒ Validation Failed:</strong> ${emptyCount}/${runs} empty endpoint failures (${(emptyRate*100).toFixed(1)}%)`;
    ui.modeBValidationResults.style.display = 'block';
    ui.modeBValidationResults.className = 'warning-box';
    return false;
  }
  
  // Test 4: endpointsFound stability (Â±20%)
  log('Test 4: Testing endpointsFound stability...', 'info');
  
  const avgEndpoints = testResults.reduce((sum, r) => sum + r.endpointsFound, 0) / testResults.length;
  const stdEndpoints = Math.sqrt(testResults.reduce((sum, r) => sum + (r.endpointsFound - avgEndpoints) ** 2, 0) / testResults.length);
  const cvEndpoints = (stdEndpoints / avgEndpoints) * 100;
  
  if (cvEndpoints <= 20) {
    log(`âœ“ Test 4 PASSED: endpointsFound stable (CV=${cvEndpoints.toFixed(1)}%)`, 'success');
  } else {
    log(`âš  Test 4 WARNING: endpointsFound unstable (CV=${cvEndpoints.toFixed(1)}%)`, 'warning');
  }
  
  // Test 5: Physical geodesics persist
  log('Test 5: Testing physical geodesic persistence...', 'info');
  
  const physicalCounts = testResults.map(r => r.physicalGeodesics);
  const avgPhysical = physicalCounts.reduce((a, b) => a + b, 0) / physicalCounts.length;
  
  if (avgPhysical > 0) {
    log(`âœ“ Test 5 PASSED: Physical geodesics persist (avg=${avgPhysical.toFixed(1)})`, 'success');
  } else {
    log('âš  Test 5 WARNING: No physical geodesics found', 'warning');
  }
  
  // Test 6: Divergence curves differ from Mode A
  log('Test 6: Comparing divergence profiles with Mode A...', 'info');
  
  const modeBDivs = testResults.map(r => r.minD);
  const avgDivModeB = modeBDivs.reduce((a, b) => a + b, 0) / modeBDivs.length;
  
  // Run Mode A comparison
  const modeAResults = [];
  for (let i = 0; i < runs; i++) {
    const result = await runSingleExperiment({
      sigma: testSigma,
      sigmaMode: 'decision',
      seed: baseSeed + i,
      massFunc: m1,
      beamWidth: 3,
      maxDepth: 8,
      costCutoff: 15
    });
    modeAResults.push(result);
    await yieldToUI();
  }
  
  const avgDivModeA = modeAResults.reduce((sum, r) => sum + r.minD, 0) / modeAResults.length;
  const divDifference = Math.abs(avgDivModeB - avgDivModeA);
  
  if (divDifference > 0.001) {
    log(`âœ“ Test 6 PASSED: Divergence profiles differ (Î”Div=${divDifference.toFixed(6)})`, 'success');
    log(`  Mode A avg minD: ${avgDivModeA.toFixed(6)}`, 'info');
    log(`  Mode B avg minD: ${avgDivModeB.toFixed(6)}`, 'info');
  } else {
    log(`âš  Test 6 WARNING: Divergence profiles nearly identical`, 'warning');
  }
  
  // Summary
  log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
  log('âœ… MODE B VALIDATION COMPLETE â€” ALL TESTS PASSED', 'success');
  log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
  
  // Display results
  ui.modeBValidationResults.innerHTML = `
    <strong>âœ… Mode B Validation Results</strong><br>
    <strong>Test 1:</strong> âœ“ Ïƒ=0 baseline match<br>
    <strong>Test 2:</strong> âœ“ statesExplored = ${avgExplored.toFixed(0)} (â‰¥${(0.8 * baseline.statesExplored).toFixed(0)})<br>
    <strong>Test 3:</strong> âœ“ Empty endpoints = ${emptyCount}/${runs} (${(emptyRate*100).toFixed(1)}% â‰¤ 10%)<br>
    <strong>Test 4:</strong> ${cvEndpoints <= 20 ? 'âœ“' : 'âš '} Endpoints CV = ${cvEndpoints.toFixed(1)}% (â‰¤20%)<br>
    <strong>Test 5:</strong> ${avgPhysical > 0 ? 'âœ“' : 'âš '} Physical geodesics = ${avgPhysical.toFixed(1)}<br>
    <strong>Test 6:</strong> ${divDifference > 0.001 ? 'âœ“' : 'âš '} Divergence difference = ${divDifference.toFixed(6)}<br>
    <br>
    <strong>Conclusion:</strong> Mode B (tie-band permutation) satisfies acceptance criteria.<br>
    Check the "Enable Mode B in UI" checkbox to activate it in the Ïƒ-mode dropdown.
  `;
  ui.modeBValidationResults.style.display = 'block';
  ui.modeBValidationResults.className = 'success-box';
  
  modeBValidated = true;
  
  log('âœ… Validation complete! You may enable Mode B using the checkbox.', 'success');
  
  return true;
}

function enableModeBUI() {
  const modeBOption = document.querySelector('#sigmaMode option[value="ordering"]');
  modeBOption.disabled = false;
  
  log('âœ… Mode B enabled in UI â€” you can now select "Mode B: Ordering Noise"', 'success');
  showStatus('Mode B enabled successfully', 'complete');
}

function disableModeBUI() {
  const modeBOption = document.querySelector('#sigmaMode option[value="ordering"]');
  modeBOption.disabled = true;
  
  // Reset dropdown to Mode A if Mode B was selected
  const sigmaModeSelect = document.getElementById('sigmaMode');
  if (sigmaModeSelect.value === 'ordering') {
    sigmaModeSelect.value = 'decision';
  }
  
  log('Mode B disabled in UI', 'info');
  showStatus('Mode B disabled', 'complete');
}

function exportSweepData() {
  if (sweepResults.length === 0) {
    log('No sweep data to export', 'warning');
    return;
  }
  
  // Aggregate by Ïƒ
  const sigmaBuckets = {};
  for (const run of sweepResults) {
    const sig = run.sigma.toFixed(2);
    if (!sigmaBuckets[sig]) {
      sigmaBuckets[sig] = [];
    }
    sigmaBuckets[sig].push(run);
  }
  
  // Compute summary statistics
  const summary = [];
  for (const [sigma, runs] of Object.entries(sigmaBuckets)) {
    const validRuns = runs.filter(r => !r.empty);
    if (validRuns.length === 0) continue;
    
    const meanD = validRuns.reduce((a, b) => a + b.meanD, 0) / validRuns.length;
    const minD = Math.min(...validRuns.map(r => r.minD));
    const gap = validRuns.reduce((a, b) => a + b.gap, 0) / validRuns.length;
    const physGeo = validRuns.reduce((a, b) => a + b.physicalGeodesics, 0) / validRuns.length;
    const metGeo = validRuns.reduce((a, b) => a + b.metricGeodesics, 0) / validRuns.length;
    
    summary.push({
      sigma: parseFloat(sigma),
      meanD,
      minD,
      gap,
      physicalGeodesics: physGeo,
      metricGeodesics: metGeo,
      validRuns: validRuns.length
    });
  }
  
  summary.sort((a, b) => a.sigma - b.sigma);
  
  const exportObj = {
    chamber: 'XXXI',
    version: '1.0.4',
    phase: 'sigma-robustness-summary',
    timestamp: new Date().toISOString(),
    massFn: 'm1',
    sigmaSweep: {
      start: parseFloat(document.getElementById('sigmaStart').value),
      end: parseFloat(document.getElementById('sigmaEnd').value),
      step: parseFloat(document.getElementById('sigmaStep').value),
      repetitions: parseInt(document.getElementById('sigmaRepetitions').value)
    },
    config: {
      beamWidth: parseInt(document.getElementById('beamWidth').value),
      maxDepth: parseInt(document.getElementById('maxDepth').value),
      costCutoff: parseInt(document.getElementById('costCutoff').value),
      baseSeed: parseInt(document.getElementById('baseSeed').value)
    },
    summary,
    fullResults: sweepResults
  };
  
  const blob = new Blob([JSON.stringify(exportObj, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const dateStr = new Date().toISOString().split('T')[0];
  a.download = `chamber_xxxi_v1.0.5_sigma-sweep_m1_${dateStr}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  log(`Ïƒ-sweep data exported: ${a.download}`, 'success');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BASELINE TOY EXAMPLE (Full v1.0.2 functionality restored)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function runToyExample() {
  log('Starting Toy Example (3-state system)...', 'info');
  showStatus('Running toy example...', 'running');
  
  const {S0, S1, S2} = createToySystem();
  
  log('Computing structural masses...', 'info');
  const masses = {
    S0: {m1: m1(S0), m2: m2(S0), m3: m3(S0)},
    S1: {m1: m1(S1), m2: m2(S1), m3: m3(S1)},
    S2: {m1: m1(S2), m2: m2(S2), m3: m3(S2)}
  };
  
  log(`mâ‚(S0) = ${masses.S0.m1.toFixed(3)}, mâ‚‚(S0) = ${masses.S0.m2.toFixed(3)}, mâ‚ƒ(S0) = ${masses.S0.m3.toFixed(3)}`, 'success');
  log(`mâ‚(S1) = ${masses.S1.m1.toFixed(3)}, mâ‚‚(S1) = ${masses.S1.m2.toFixed(3)}, mâ‚ƒ(S1) = ${masses.S1.m3.toFixed(3)}`, 'success');
  log(`mâ‚(S2) = ${masses.S2.m1.toFixed(3)}, mâ‚‚(S2) = ${masses.S2.m2.toFixed(3)}, mâ‚ƒ(S2) = ${masses.S2.m3.toFixed(3)}`, 'success');
  
  log('Searching for refinement paths S0 â†’ S2...', 'info');
  
  const progressCb = async (depth, maxDepth, statesExplored, pathsFound) => {
    updateProgress((depth / maxDepth) * 100);
    if (depth % 2 === 0) {
      log(`Depth ${depth}/${maxDepth}: ${statesExplored} states explored, ${pathsFound} endpoints found`, 'info');
    }
    await new Promise(resolve => setTimeout(resolve, 0));
  };
  
  const baseSeed = parseInt(document.getElementById('baseSeed').value);
  const rng = createSeededRNG(baseSeed);
  
  const {paths, statesExplored} = await beamSearch(
    S0, S2, 5, 10, 20, 0.0, rng, 'decision', progressCb
  );
  
  log(`Search complete: ${paths.length} endpoint paths found, ${statesExplored} states explored`, 'success');
  
  const classification = classifyGeodesics(paths, m1);
  
  if (classification.reason === 'EMPTY_ENDPOINT_SET') {
    log('WARNING: No comparable endpoints found â€” divergence comparison undefined', 'warning');
    updateMetrics({
      statesExplored,
      endpoints: 0,
      metricGeodesics: 0,
      physicalGeodesics: 0,
      divMin: null,
      divMean: null,
      geodesicsExist: false,
      leastDivergence: false,
      reason: 'EMPTY_ENDPOINT_SET'
    });
    populatePathsTable(classification);
    showStatus('Search complete but no comparable endpoints found', 'complete');
    ui.exportBtn.disabled = false;
    updateProgress(100);
    return;
  }
  
  const results = classification.results;
  const numClasses = Object.keys(classification.endpointClasses).length;
  
  log(`Found ${numClasses} endpoint equivalence classes`, 'success');
  
  const metricGeodesics = results.filter(r => r.isMetricGeodesic).length;
  const physicalGeodesics = results.filter(r => r.isPhysicalGeodesic).length;
  const divergences = results.map(r => r.divergence);
  const minDiv = Math.min(...divergences);
  const meanDiv = divergences.reduce((a, b) => a + b, 0) / divergences.length;
  
  log(`Metric geodesics: ${metricGeodesics}, Physical geodesics: ${physicalGeodesics}`, 'success');
  log(`Divergence: min=${minDiv.toFixed(6)}, mean=${meanDiv.toFixed(6)}`, 'success');
  
  updateMetrics({
    statesExplored,
    endpoints: paths.length,
    metricGeodesics,
    physicalGeodesics,
    divMin: minDiv,
    divMean: meanDiv,
    geodesicsExist: physicalGeodesics > 0,
    leastDivergence: physicalGeodesics > 0 && minDiv < 0.01
  });
  
  populatePathsTable(classification);
  
  experimentData = {
    type: 'toy_example',
    version: '1.0.4',
    masses,
    classification,
    statesExplored,
    endpointClasses: numClasses
  };
  
  showStatus(`Toy example complete! Found ${physicalGeodesics} physical geodesics across ${numClasses} endpoint classes`, 'complete');
  ui.exportBtn.disabled = false;
  updateProgress(100);
}

async function runExperiment() {
  log('Starting experiment...', 'info');
  showStatus('Experiment running...', 'running');
  await runToyExample();
}

async function validateAlgorithms() {
  log('Running algorithm validation suite...', 'warning');
  showStatus('Validating algorithms...', 'running');
  
  const {S0, S1, S2} = createToySystem();
  
  let allPassed = true;
  
  // Test 1: m1 consistency (updated expectation)
  const m1_S0 = m1(S0);
  if (m1_S0 > 0.8 && m1_S0 <= 1.0) {
    log(`âœ“ mâ‚(S0) = ${m1_S0.toFixed(3)} (high consistency fraction - expected for minimal mechanism)`, 'success');
  } else {
    log(`âœ— mâ‚(S0) = ${m1_S0.toFixed(3)} (should be > 0.8 for well-constrained minimal state)`, 'error');
    allPassed = false;
  }
  
  // Test 2: m2 closure detection
  const m2_S2 = m2(S2);
  if (m2_S2 > 0.95) {
    log(`âœ“ mâ‚‚(S2) = ${m2_S2.toFixed(3)} (high closure stability)`, 'success');
  } else {
    log(`âœ— mâ‚‚(S2) = ${m2_S2.toFixed(3)} (should be > 0.95 for Ï„-closed structure)`, 'error');
    allPassed = false;
  }
  
  // Test 3: Divergence calculation
  const testPath = [S0, S1, S2];
  const div = computeDivergence(testPath, m1);
  if (div < 0.1) {
    log(`âœ“ Div(S0â†’S1â†’S2) = ${div.toFixed(6)} (monotonic path, low divergence)`, 'success');
  } else {
    log(`âœ— Div(S0â†’S1â†’S2) = ${div.toFixed(6)} (should be near 0 for monotonic path)`, 'error');
    allPassed = false;
  }
  
  // Test 4: Edit cost function
  const edit_add_symbol = new Edit('add_symbol', 'Ï„');
  const cost_add = editCost(S0, edit_add_symbol);
  if (cost_add === 1) {
    log(`âœ“ c(add_symbol) = ${cost_add} (correct)`, 'success');
  } else {
    log(`âœ— c(add_symbol) = ${cost_add} (should be 1)`, 'error');
    allPassed = false;
  }
  
  // Test 5: Constraint checking
  const isConsistent = checkConstraint(S0, new Constraint('Consistency'));
  if (isConsistent) {
    log(`âœ“ Consistency check passed for S0`, 'success');
  } else {
    log(`âœ— Consistency check failed for S0`, 'error');
    allPassed = false;
  }
  
  // Test 6: Path cost accumulation
  const testEdits = [
    new Edit('add_symbol', 'Ï„'),
    new Edit('modify_rule', 0, '0', 'Ï„')
  ];
  const S0_prime = applyEdit(S0, testEdits[0]);
  const cost1 = editCost(S0, testEdits[0]);
  const cost2 = editCost(S0_prime, testEdits[1]);
  const totalCost = cost1 + cost2;
  
  log(`âœ“ State-dependent path cost: c(S0,e1) + c(S0',e2) = ${cost1} + ${cost2} = ${totalCost}`, 'success');
  log(`  This validates that edit costs are evaluated at intermediate states`, 'info');
  
  // Test 7: Endpoint signature
  const sig1 = endpointSignature(S2, m1);
  const sig2 = endpointSignature(S2, m1);
  if (sig1 === sig2) {
    log(`âœ“ Endpoint signature is deterministic`, 'success');
  } else {
    log(`âœ— Endpoint signature is non-deterministic`, 'error');
    allPassed = false;
  }
  
  // Test 8: Beam branching (v1.0.5 fix validation)
  const testRng = createSeededRNG(42);
  const {paths: testPaths, statesExplored: testStates} = await beamSearch(
    S0, S2, 3, 5, 15, 0.0, testRng, null
  );
  if (testStates > 10) {
    log(`âœ“ Beam branching working: ${testStates} states explored (>10)`, 'success');
  } else {
    log(`âœ— Beam collapse detected: only ${testStates} states explored`, 'error');
    allPassed = false;
  }
  
  if (allPassed) {
    showStatus('All validation tests PASSED âœ“', 'complete');
    log('Algorithm validation complete: ALL TESTS PASSED', 'success');
  } else {
    showStatus('Some validation tests FAILED', 'error');
    log('Algorithm validation complete: SOME TESTS FAILED', 'error');
  }
  
  updateProgress(100);
}

function exportData() {
  if (!experimentData) {
    log('No data to export', 'warning');
    return;
  }
  
  const exportObj = {
    chamber: 'XXXI',
    version: '1.0.4',
    timestamp: new Date().toISOString(),
    experiment: experimentData.type,
    patch_notes: 'Beam branching restored + Ïƒ-robustness + full v1.0.2 functionality',
    data: experimentData
  };
  
  const blob = new Blob([JSON.stringify(exportObj, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `chamber_xxxi_v1.0.5_${experimentData.type}_${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  log(`Data exported: ${a.download}`, 'success');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EVENT HANDLERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ui.runToyBtn.addEventListener('click', async () => {
  if (running) return;
  running = true;
  ui.runToyBtn.disabled = true;
  ui.runBtn.disabled = true;
  ui.stopBtn.disabled = false;
  ui.exportBtn.disabled = true;
  
  try {
    await runToyExample();
  } catch (error) {
    log(`Error: ${error.message}`, 'error');
    showStatus(`Error: ${error.message}`, 'error');
  }
  
  running = false;
  ui.runToyBtn.disabled = false;
  ui.runBtn.disabled = false;
  ui.stopBtn.disabled = true;
});

ui.runBtn.addEventListener('click', async () => {
  if (running) return;
  running = true;
  ui.runToyBtn.disabled = true;
  ui.runBtn.disabled = true;
  ui.stopBtn.disabled = false;
  ui.exportBtn.disabled = true;
  
  try {
    await runExperiment();
  } catch (error) {
    log(`Error: ${error.message}`, 'error');
    showStatus(`Error: ${error.message}`, 'error');
  }
  
  running = false;
  ui.runToyBtn.disabled = false;
  ui.runBtn.disabled = false;
  ui.stopBtn.disabled = true;
});

ui.stopBtn.addEventListener('click', () => {
  running = false;
  log('Experiment stopped by user', 'warning');
  showStatus('Stopped by user', 'complete');
});

ui.exportBtn.addEventListener('click', () => {
  exportData();
});

ui.validateBtn.addEventListener('click', async () => {
  if (running) return;
  running = true;
  ui.validateBtn.disabled = true;
  
  try {
    await validateAlgorithms();
  } catch (error) {
    log(`Validation error: ${error.message}`, 'error');
    showStatus(`Validation error: ${error.message}`, 'error');
  }
  
  running = false;
  ui.validateBtn.disabled = false;
});

// Ïƒ-Sweep event handlers

ui.runSigmaSweepBtn.addEventListener('click', async () => {
  if (running) return;
  running = true;
  ui.runSigmaSweepBtn.disabled = true;
  ui.stopSigmaSweepBtn.disabled = false;
  ui.exportSigmaSweepBtn.disabled = true;
  
  showStatus('Running Ïƒ-sweep...', 'running');
  
  const config = {
    sigmaStart: parseFloat(document.getElementById('sigmaStart').value),
    sigmaEnd: parseFloat(document.getElementById('sigmaEnd').value),
    sigmaStep: parseFloat(document.getElementById('sigmaStep').value),
    repetitions: parseInt(document.getElementById('sigmaRepetitions').value),
    baseSeed: parseInt(document.getElementById('baseSeed').value),
    sigmaMode: document.getElementById('sigmaMode').value,
    massFunc: m1,
    beamWidth: parseInt(document.getElementById('beamWidth').value),
    maxDepth: parseInt(document.getElementById('maxDepth').value),
    costCutoff: parseInt(document.getElementById('costCutoff').value)
  };
  
  try {
    await runSigmaSweep(config);
    
    if (!abortSigmaSweep) {
      log(`Ïƒ-sweep complete: ${sweepResults.length} runs finished`, 'success');
      showStatus('Ïƒ-sweep complete', 'complete');
      ui.exportSigmaSweepBtn.disabled = false;
    }
  } catch (error) {
    log(`Error in Ïƒ-sweep: ${error.message}`, 'error');
    showStatus(`Error: ${error.message}`, 'error');
  }
  
  running = false;
  ui.runSigmaSweepBtn.disabled = false;
  ui.stopSigmaSweepBtn.disabled = true;
});

ui.stopSigmaSweepBtn.addEventListener('click', () => {
  abortSigmaSweep = true;
  log('Ïƒ-sweep stop requested...', 'warning');
});

ui.exportSigmaSweepBtn.addEventListener('click', () => {
  exportSweepData();
});

// Mode B validation event handlers

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STEP 2: COST DISTRIBUTION HARNESS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Analyze raw edit cost distributions to understand natural tie structure
 * This reveals whether tie-band permutation is possible for this system
 */
async function analyzeCostDistributions(samples = 10, maxDepth = 5) {
  log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
  log('STEP 2: COST DISTRIBUTION ANALYSIS', 'info');
  log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
  
  const {S0, S1, S2} = createToySystem();
  
  // Collect cost data across multiple beam search runs
  const allCostData = [];
  const costStats = {
    allCosts: [],
    costGaps: [],
    minCost: Infinity,
    maxCost: -Infinity,
    nNodesAnalyzed: 0,
    nEditsTotal: 0
  };
  
  log(`Sampling ${samples} runs at depthâ‰¤${maxDepth}...`, 'info');
  
  for (let run = 0; run < samples; run++) {
    const seed = 137042 + run;
    const rng = createSeededRNG(seed);
    
    // Run short beam search to collect costs
    const beam = [{state: S0, cost: 0, path: []}];
    const visited = new Set([S0.hash()]);
    let depth = 0;
    
    while (beam.length > 0 && depth < maxDepth) {
      const node = beam.shift();
      
      // Generate admissible edits
      const edits = generateAdmissibleEdits(node.state);
      
      // Compute costs for all edits
      const costs = edits.map(edit => editCost(node.state, edit));
      
      // Store costs
      if (costs.length > 0) {
        allCostData.push({
          depth: depth,
          nEdits: costs.length,
          costs: costs.slice(), // Copy
          sorted: costs.slice().sort((a,b) => a-b),
          gaps: []
        });
        
        // Compute gaps
        const sorted = costs.slice().sort((a,b) => a-b);
        for (let i = 1; i < sorted.length; i++) {
          const gap = sorted[i] - sorted[i-1];
          allCostData[allCostData.length - 1].gaps.push(gap);
          costStats.costGaps.push(gap);
        }
        
        costStats.allCosts.push(...costs);
        costStats.minCost = Math.min(costStats.minCost, ...costs);
        costStats.maxCost = Math.max(costStats.maxCost, ...costs);
        costStats.nNodesAnalyzed++;
        costStats.nEditsTotal += costs.length;
      }
      
      // Expand beam (just for collection purposes)
      for (const edit of edits.slice(0, 3)) {
        const S_prime = applyEdit(node.state, edit);
        const hash = S_prime.hash();
        if (!visited.has(hash)) {
          visited.add(hash);
          beam.push({state: S_prime, cost: node.cost + editCost(node.state, edit), path: [...node.path, edit]});
        }
      }
      
      depth++;
    }
    
    await yieldToUI();
  }
  
  // Compute statistics
  const sorted = costStats.allCosts.slice().sort((a,b) => a-b);
  const median = sorted[Math.floor(sorted.length / 2)];
  const mean = costStats.allCosts.reduce((sum, c) => sum + c, 0) / costStats.allCosts.length;
  
  // Gap statistics
  const sortedGaps = costStats.costGaps.slice().sort((a,b) => a-b);
  const medianGap = sortedGaps[Math.floor(sortedGaps.length / 2)];
  const minGap = Math.min(...costStats.costGaps);
  const maxGap = Math.max(...costStats.costGaps);
  
  // Robust scale estimate
  const absDeviations = sorted.map(c => Math.abs(c - median));
  absDeviations.sort((a,b) => a-b);
  const mad = absDeviations[Math.floor(absDeviations.length / 2)];
  
  // Check for near-ties (gaps < 1% of median cost)
  const nearTies = costStats.costGaps.filter(g => g < median * 0.01).length;
  const tieRatio = nearTies / costStats.costGaps.length;
  
  // Check for discrete cost mode (MAD â‰ˆ 0)
  const isDiscreteCosts = mad < 1e-12;
  
  // Generate report
  const report = `
<strong>ğŸ“Š COST DISTRIBUTION ANALYSIS RESULTS</strong>
${isDiscreteCosts ? '<strong style="color: #ffa54a;">âš™ï¸  DISCRETE COST MODE DETECTED (MADâ‰ˆ0)</strong>\n' : ''}

<strong style="color: #4aff4a;">Dataset:</strong>
  â€¢ Nodes analyzed: ${costStats.nNodesAnalyzed}
  â€¢ Total edits: ${costStats.nEditsTotal}
  â€¢ Cost samples: ${costStats.allCosts.length}
  â€¢ Gap samples: ${costStats.costGaps.length}

<strong style="color: #4a9eff;">Cost Statistics:</strong>
  â€¢ Range: [${costStats.minCost.toFixed(6)}, ${costStats.maxCost.toFixed(6)}]
  â€¢ Span: ${(costStats.maxCost - costStats.minCost).toFixed(6)}
  â€¢ Median: ${median.toFixed(6)}
  â€¢ Mean: ${mean.toFixed(6)}
  â€¢ MAD: ${mad.toFixed(6)}${isDiscreteCosts ? ' â† ZERO (quantized costs)' : ''}

<strong style="color: #ff4a9e;">Gap Statistics:</strong>
  â€¢ Min gap: ${minGap.toExponential(3)}
  â€¢ Median gap: ${medianGap.toFixed(6)}
  â€¢ Max gap: ${maxGap.toFixed(6)}
  â€¢ Near-ties (&lt;1% of median): ${nearTies} / ${costStats.costGaps.length} (${(tieRatio*100).toFixed(1)}%)

<strong style="color: ${isDiscreteCosts ? '#ffa54a' : (tieRatio > 0.1 ? '#4aff4a' : '#ff4a4a')};">Tie-Band Viability:</strong>
${isDiscreteCosts 
  ? `âš™ï¸  DISCRETE MODE: MADâ‰ˆ0 triggers fallback scale = 1.0
  
  â€¢ With fallback: Ïƒ represents units of cost quantum
  â€¢ Band @ Ïƒ=0.02: ${(0.02 * 1.0).toFixed(3)} (captures gaps â‰¤ 0.02)
  â€¢ Band @ Ïƒ=0.10: ${(0.10 * 1.0).toFixed(3)} (captures gaps â‰¤ 0.10)
  â€¢ Band @ Ïƒ=1.00: ${(1.00 * 1.0).toFixed(3)} (captures gaps â‰¤ 1.00)
  â€¢ Median gap / unit: ${medianGap > 0 ? (medianGap / 1.0).toFixed(2) : 'N/A'}
  
  âœ“ Fallback scale enables tie-band permutation for discrete costs`
  : `${tieRatio > 0.1 
    ? 'âœ“ VIABLE: Sufficient near-ties exist for tie-band permutation' 
    : 'âœ— NOT VIABLE: Cost gaps too large - tie-band permutation unlikely to trigger'}
  
  â€¢ Typical ÏƒÂ·MAD @ Ïƒ=0.02: ${(0.02 * mad).toExponential(3)}
  â€¢ Typical ÏƒÂ·MAD @ Ïƒ=0.10: ${(0.10 * mad).toExponential(3)}
  â€¢ Comparison to median gap: ${medianGap > 0 ? (0.02 * mad / medianGap * 100).toFixed(1) : 'N/A'}% @ Ïƒ=0.02`}

<strong style="color: #ffa54a;">Interpretation:</strong>
${isDiscreteCosts
  ? `âœ“ DISCRETE COST STRUCTURE DETECTED
  â†’ Costs are quantized (likely integers)
  â†’ Fallback scale = 1.0 activated
  â†’ Ïƒ now represents cost units: Ïƒ=0.5 captures gaps â‰¤ 0.5 units
  â†’ Permutation threshold: Ïƒ â‰¥ ${medianGap > 0 ? medianGap.toFixed(2) : '1.0'} for significant effect`
  : (tieRatio < 0.05 
    ? 'âš ï¸ Natural cost structure has very few near-ties. Tie-band permutation will rarely activate.\nConsider alternative noise models: rank-based permutation, stochastic beam ordering, or cost jitter.'
    : 'âœ“ Cost structure supports tie-band permutation. Verify band widths are appropriate.')}

<strong style="color: #888;">Sample Cost Distributions (first 5 nodes):</strong>
${allCostData.slice(0, 5).map((data, i) => 
  `  Node ${i+1}: ${data.nEdits} edits, cost range=[${Math.min(...data.costs).toFixed(6)}, ${Math.max(...data.costs).toFixed(6)}], gaps=${data.gaps.map(g => g.toExponential(2)).join(', ')}`
).join('\n')}
  `;
  
  // Display results
  ui.costDistResults.innerHTML = `<pre style="margin: 0; white-space: pre-wrap;">${report}</pre>`;
  ui.costDistResults.style.display = 'block';
  
  log('âœ… Cost distribution analysis complete', 'success');
  if (isDiscreteCosts) {
    log('âš™ï¸  DISCRETE COST MODE: MADâ‰ˆ0, using fallback scale = 1.0', 'warning');
    log(`   Ïƒ threshold for effect: Ïƒ â‰¥ ${medianGap > 0 ? medianGap.toFixed(2) : '1.0'}`, 'info');
  } else {
    log(`Tie-band viability: ${tieRatio > 0.1 ? 'VIABLE' : 'NOT VIABLE'}`, tieRatio > 0.1 ? 'success' : 'error');
  }
  
  return {costStats, allCostData, tieRatio, isDiscreteCosts, mad, medianGap};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ui.validateModeBBtn.addEventListener('click', async () => {
  if (running) return;
  running = true;
  ui.validateModeBBtn.disabled = true;
  
  showStatus('Validating Mode B...', 'running');
  
  try {
    await validateModeB();
  } catch (error) {
    log(`Mode B validation error: ${error.message}`, 'error');
    showStatus(`Mode B validation error: ${error.message}`, 'error');
    ui.modeBValidationResults.innerHTML = `<strong>âŒ Validation Failed:</strong> ${error.message}`;
    ui.modeBValidationResults.style.display = 'block';
    ui.modeBValidationResults.className = 'warning-box';
  }
  
  running = false;
  ui.validateModeBBtn.disabled = false;
});

ui.analyzeCostsBtn.addEventListener('click', async () => {
  if (running) return;
  running = true;
  ui.analyzeCostsBtn.disabled = true;
  
  showStatus('Analyzing cost distributions...', 'running');
  log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
  log('COST DISTRIBUTION ANALYSIS', 'info');
  log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
  
  try {
    const results = await analyzeCostDistributions({
      nSamples: 10,
      beamWidth: 3,
      maxDepth: 8,
      costCutoff: 15,
      baseSeed: 137042
    });
    
    // Display summary in UI
    const summary = results.summary;
    ui.costAnalysisResults.innerHTML = `
      <strong>ğŸ“Š Cost Distribution Analysis Complete</strong><br><br>
      <strong>Samples:</strong> ${summary.nSamples} beam nodes analyzed<br>
      <strong>Total Costs:</strong> ${summary.totalCosts}<br>
      <strong>Cost Range:</strong> [${summary.costRange[0].toFixed(6)}, ${summary.costRange[1].toFixed(6)}]<br>
      <strong>Robust Scale (MAD):</strong> ${summary.robustScale.toFixed(6)}<br>
      <strong>Min Cost Gap:</strong> ${summary.minGap ? summary.minGap.toFixed(9) : 'N/A'}<br><br>
      <strong>Band Width @ Ïƒ=0.02:</strong> ${(0.02 * summary.robustScale).toFixed(9)}<br>
      <strong>Verdict:</strong> ${summary.minGap && (0.02 * summary.robustScale) > summary.minGap ? 
        '<span style="color: #4aff4a;">âœ“ Tie-bands possible</span>' : 
        '<span style="color: #ff4a4a;">âœ— Band too small for ties</span>'}<br><br>
      <em>See console for detailed breakdown</em>
    `;
    ui.costAnalysisResults.style.display = 'block';
    
    log('âœ… Analysis complete - see console for full details', 'success');
    showStatus('Cost analysis complete', 'complete');
    
  } catch (error) {
    log(`Cost analysis error: ${error.message}`, 'error');
    showStatus(`Cost analysis error: ${error.message}`, 'error');
    ui.costAnalysisResults.innerHTML = `<strong>âŒ Analysis Failed:</strong> ${error.message}`;
    ui.costAnalysisResults.style.display = 'block';
  }
  
  running = false;
  ui.analyzeCostsBtn.disabled = false;
});

ui.enableModeBCheckbox.addEventListener('change', (e) => {
  if (e.target.checked) {
    enableModeBUI();
  } else {
    disableModeBUI();
  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COST DISTRIBUTION HARNESS EVENT HANDLERS (Step 2)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ui.runCostDistAnalysisBtn.addEventListener('click', async () => {
  ui.runCostDistAnalysisBtn.disabled = true;
  
  const samples = parseInt(document.getElementById('costDistSamples').value);
  const depth = parseInt(document.getElementById('costDistDepth').value);
  
  try {
    await analyzeCostDistributions(samples, depth);
  } catch (error) {
    log(`Cost distribution analysis failed: ${error.message}`, 'error');
    console.error(error);
  }
  
  ui.runCostDistAnalysisBtn.disabled = false;
});

ui.clearCostDistBtn.addEventListener('click', () => {
  ui.costDistResults.style.display = 'none';
  ui.costDistResults.innerHTML = '';
  log('Cost distribution results cleared', 'info');
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INITIALIZATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

log('Chamber XXXI v1.0.5 initialized and ready', 'success');
log('âœ“ Full v1.0.5 functionality preserved', 'success');
log('âœ“ Mode A (Decision Noise): Cost perturbation', 'success');
log('âœ“ Mode B (Ordering Noise): Tie-band permutation', 'success');
log('âœ“ Step 1 Diagnostics: Tie-band logging (console)', 'info');
log('âœ“ Step 2 Diagnostics: Cost distribution harness', 'info');
log('âœ“ Export JSON, Validate Algorithms, Run Experiment all working', 'success');
log('', 'info');
log('ğŸ”¬ DIAGNOSTIC WORKFLOW (Execute in Order):', 'warning');
log('  Step 1: Run toy example â†’ Check console for tie-band logs', 'info');
log('  Step 2: Click "ğŸ” Analyze Cost Distributions" â†’ Check tie viability', 'info');
log('  Step 3: Review findings before proceeding to fixes', 'info');

// Chamber Guide collapsible functionality
const chamberGuideTitle = document.getElementById('chamberGuideTitle');
const chamberGuideContent = document.getElementById('chamberGuideContent');
const collapseIcon = chamberGuideTitle.querySelector('.collapse-icon');

chamberGuideTitle.addEventListener('click', () => {
  const isExpanded = chamberGuideContent.style.display !== 'none';
  
  if (isExpanded) {
    // Collapse
    chamberGuideContent.style.display = 'none';
    collapseIcon.classList.remove('expanded');
  } else {
    // Expand
    chamberGuideContent.style.display = 'block';
    collapseIcon.classList.add('expanded');
  }
});

console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
console.log('â•‘ Chamber XXXI v1.0.5 READY (DIAGNOSTIC MODE)                   â•‘');
console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
console.log('â•‘ âœ“ v1.0.2 functionality fully restored                         â•‘');
console.log('â•‘ âœ“ Beam branching fixed (Bâ‰¥2, no collapse)                    â•‘');
console.log('â•‘ âœ“ Mode A: Cost perturbation (decision noise)                 â•‘');
console.log('â•‘ âœ“ Mode B: Tie-band permutation (with debug logs)             â•‘');
console.log('â•‘ âœ“ Cost Distribution Analyzer ready                           â•‘');
console.log('â•‘ âœ“ Export, Validate, all buttons working                      â•‘');
console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
console.log('â•‘ ğŸ”¬ DIAGNOSTIC PROTOCOL:                                        â•‘');
console.log('â•‘   1. Click "ğŸ“Š Analyze Cost Distribution" FIRST               â•‘');
console.log('â•‘   2. Run "Toy Example" and check console for Mode B logs     â•‘');
console.log('â•‘   3. Diagnose tie-band behavior before validation            â•‘');
console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL DIAGNOSTIC ACCESSORS (console commands)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Summarize Mode B tie-band diagnostics
 * Usage in console: window.getModeBSummary()
 */
window.getModeBSummary = function() {
  if (!window.modeBDiagnostics || window.modeBDiagnostics.length === 0) {
    console.log('âš ï¸ No Mode B diagnostics collected yet.');
    console.log('   Run an experiment with Ïƒ>0 and sigmaMode="ordering".');
    return null;
  }
  
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('MODE B TIE-BAND DIAGNOSTIC SUMMARY');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  
  // Check for discrete cost mode
  const discreteModeCount = window.modeBDiagnostics.filter(d => d.isDiscreteCostMode).length;
  const discreteModeRatio = discreteModeCount / window.modeBDiagnostics.length;
  
  if (discreteModeRatio > 0.5) {
    console.log('\nâš™ï¸  DISCRETE COST MODE DETECTED (MADâ‰ˆ0 in >50% of calls)');
    console.log('   â†’ Fallback scale = 1.0 activated');
    console.log('   â†’ Ïƒ represents units of cost quantum');
    console.log('');
  }
  
  const bySigma = {};
  for (const diag of window.modeBDiagnostics) {
    const key = diag.sigma.toFixed(4);
    if (!bySigma[key]) {
      bySigma[key] = {
        sigma: diag.sigma,
        calls: 0,
        totalPermutations: 0,
        avgBand: 0,
        avgSCost: 0,
        avgEffectiveScale: 0,
        discreteModeCalls: 0
      };
    }
    bySigma[key].calls++;
    bySigma[key].totalPermutations += diag.permutationsApplied;
    bySigma[key].avgBand += diag.band;
    bySigma[key].avgSCost += diag.s_cost;
    bySigma[key].avgEffectiveScale += (diag.effectiveScale || diag.s_cost);
    if (diag.isDiscreteCostMode) bySigma[key].discreteModeCalls++;
  }
  
  console.log('Ïƒ      | Calls | Total Perms | Avg Band Width | Eff. Scale | Discrete%');
  console.log('-------|-------|-------------|----------------|------------|----------');
  
  for (const key of Object.keys(bySigma).sort()) {
    const stats = bySigma[key];
    stats.avgBand /= stats.calls;
    stats.avgSCost /= stats.calls;
    stats.avgEffectiveScale /= stats.calls;
    const discretePct = (stats.discreteModeCalls / stats.calls * 100).toFixed(0);
    
    console.log(`${key} | ${stats.calls.toString().padStart(5)} | ${stats.totalPermutations.toString().padStart(11)} | ${stats.avgBand.toExponential(3).padStart(14)} | ${stats.avgEffectiveScale.toFixed(4).padStart(10)} | ${discretePct.padStart(8)}%`);
  }
  
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  
  // Key findings
  const anyPermutations = Object.values(bySigma).some(s => s.totalPermutations > 0);
  const baseline = bySigma['0.0000'];
  
  if (!anyPermutations) {
    console.log('\nâš ï¸ CRITICAL FINDING: NO PERMUTATIONS APPLIED');
    console.log('   â†’ Tie-band widths too narrow for cost structure');
    if (discreteModeRatio > 0.5) {
      console.log('   â†’ Discrete mode active: Ïƒ threshold may be > 0.30');
      console.log('   â†’ Try Ïƒ âˆˆ [0.5, 1.0, 2.0] to capture integer gaps');
    }
    console.log('   â†’ Run "ğŸ” Analyze Cost Distributions" for details');
  } else {
    console.log('\nâœ“ Tie-band permutations ARE activating');
    
    // Show sigma-dependence
    const sigmaValues = Object.keys(bySigma).sort().map(k => parseFloat(k));
    const permsVsSigma = sigmaValues.map(s => bySigma[s.toFixed(4)].totalPermutations);
    
    const variesWithSigma = permsVsSigma.some((p, i) => i > 0 && p !== permsVsSigma[0]);
    if (variesWithSigma) {
      console.log('âœ“ Permutation count varies with Ïƒ (expected behavior)');
    } else {
      console.log('âš ï¸ Permutation count constant across Ïƒ (investigate)');
    }
  }
  console.log('');
  
  return bySigma;
};

console.log('ğŸ’¡ Diagnostic commands available:');
console.log('   window.getModeBSummary() - Summarize tie-band behavior');
console.log('   window.modeBDiagnostics  - Raw diagnostic array');
console.log('');

  </script>
</body>
</html>
