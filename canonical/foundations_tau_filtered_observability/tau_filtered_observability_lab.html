<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foundations of œÑ-Filtered Observability | UNNS Chamber</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f1729 0%, #1a2332 100%);
            color: #e0e6ed;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .chamber-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .chamber-header {
            background: linear-gradient(135deg, #1a2840 0%, #243447 100%);
            border: 1px solid #2a4a6a;
            border-radius: 8px;
            padding: 30px;
            margin-bottom: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .chamber-title {
            font-size: 2.2em;
            font-weight: 300;
            letter-spacing: 1px;
            color: #4dd4e8;
            margin-bottom: 8px;
        }

        .chamber-subtitle {
            font-size: 1em;
            color: #8aa4bd;
            font-weight: 300;
            margin-bottom: 20px;
        }

        .badge-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 18px;
        }

        .badge {
            padding: 6px 14px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .badge-type {
            background: rgba(77, 212, 232, 0.15);
            border: 1px solid #4dd4e8;
            color: #4dd4e8;
        }

        .badge-phase {
            background: rgba(138, 93, 218, 0.15);
            border: 1px solid #8a5dda;
            color: #a988ea;
        }

        .badge-role {
            background: rgba(64, 224, 208, 0.15);
            border: 1px solid #40e0d0;
            color: #5ff5e3;
        }

        .badge-status {
            background: rgba(255, 193, 7, 0.15);
            border: 1px solid #ffc107;
            color: #ffd54f;
        }

        .chamber-description {
            color: #b0c4d4;
            font-size: 0.95em;
            line-height: 1.8;
            max-width: 900px;
        }

        .panel-container {
            background: #1a2840;
            border: 1px solid #2a4a6a;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .tab-nav {
            display: flex;
            background: #0f1729;
            border-bottom: 2px solid #2a4a6a;
        }

        .tab-button {
            flex: 1;
            padding: 15px;
            background: transparent;
            border: none;
            color: #8aa4bd;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
            border-right: 1px solid #1a2840;
        }

        .tab-button:last-child {
            border-right: none;
        }

        .tab-button:hover {
            background: rgba(77, 212, 232, 0.1);
            color: #4dd4e8;
        }

        .tab-button.active {
            background: #1a2840;
            color: #4dd4e8;
            border-bottom: 2px solid #4dd4e8;
        }

        .tab-content {
            padding: 30px;
            display: none;
            min-height: 400px;
        }

        .tab-content.active {
            display: block;
        }

        .panel-caption {
            font-size: 1.3em;
            color: #4dd4e8;
            margin-bottom: 20px;
            font-weight: 300;
            border-bottom: 1px solid #2a4a6a;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-label {
            display: block;
            color: #8aa4bd;
            font-size: 0.95em;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .input-row {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .input-field {
            flex: 1;
            min-width: 150px;
        }

        input[type="number"],
        input[type="text"],
        select {
            width: 100%;
            padding: 10px;
            background: #0f1729;
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            color: #e0e6ed;
            font-size: 0.95em;
            transition: border-color 0.3s ease;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #4dd4e8;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #2a4a7a 0%, #3a5a8a 100%);
            border: 1px solid #4a6a9a;
            color: #e0e6ed;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        button:hover {
            background: linear-gradient(135deg, #3a5a8a 0%, #4a6a9a 100%);
            border-color: #4dd4e8;
        }

        button:disabled {
            background: #1a2840;
            border-color: #2a4a6a;
            color: #6b7f94;
            cursor: not-allowed;
        }

        .slider-container {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #2a4a6a;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4dd4e8;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #1a2840;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4dd4e8;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #1a2840;
        }

        .slider-value {
            color: #4dd4e8;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            min-width: 80px;
            text-align: right;
        }

        input[type="file"] {
            display: none;
        }

        .export-status {
            background: rgba(138, 93, 218, 0.1);
            border: 1px solid #8a5dda;
            border-radius: 6px;
            padding: 20px;
            margin-top: 20px;
            color: #b0c4d4;
            font-size: 0.9em;
        }

        .results-container {
            margin-top: 30px;
        }

        .plot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .graph-container {
            background: #0f1729;
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            padding: 20px;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info-box {
            background: rgba(77, 212, 232, 0.1);
            border: 1px solid #4dd4e8;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
            color: #b0c4d4;
            font-size: 0.9em;
        }

        .plot-container {
            background: #0f1729;
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .plot-title {
            color: #4dd4e8;
            font-size: 1.1em;
            margin-bottom: 15px;
            font-weight: 500;
        }

        canvas {
            width: 100% !important;
            height: auto !important;
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(42, 74, 106, 0.3);
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
        }

        .stat-box.highlight {
            border-color: #4dd4e8;
            background: rgba(77, 212, 232, 0.15);
        }

        .stat-box.law-box {
            border-color: #5ff5e3;
            background: rgba(95, 245, 227, 0.1);
        }

        .stat-label {
            color: #8aa4bd;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #4dd4e8;
            font-size: 1.5em;
            font-weight: 500;
            font-family: 'Courier New', monospace;
        }

        .stat-value.law-value {
            color: #5ff5e3;
        }

        .toggle-switch {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: rgba(42, 74, 106, 0.3);
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch:hover {
            border-color: #4dd4e8;
            background: rgba(77, 212, 232, 0.15);
        }

        .toggle-switch input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .toggle-switch label {
            color: #b0c4d4;
            cursor: pointer;
            user-select: none;
        }

        .graph-controls {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .path-list {
            background: #0f1729;
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            max-height: 400px;
            overflow-y: auto;
        }

        .path-item {
            padding: 12px;
            border-bottom: 1px solid #2a4a6a;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .path-item:hover {
            background: rgba(77, 212, 232, 0.1);
        }

        .path-item.selected {
            background: rgba(77, 212, 232, 0.2);
            border-left: 3px solid #4dd4e8;
        }

        .path-item.enriched {
            border-left: 3px solid #ffc107;
        }

        .path-item:last-child {
            border-bottom: none;
        }

        .path-header {
            color: #4dd4e8;
            font-size: 0.95em;
            margin-bottom: 5px;
        }

        .path-details {
            color: #8aa4bd;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
        }

        .path-ops {
            color: #8a5dda;
            font-size: 0.85em;
            margin-top: 5px;
        }

        .composition-box {
            background: rgba(138, 93, 218, 0.1);
            border: 1px solid #8a5dda;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }

        .composition-title {
            color: #8a5dda;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .composition-result {
            background: #0f1729;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #b0c4d4;
        }

        .operator-card {
            background: rgba(42, 74, 106, 0.3);
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            padding: 15px;
        }

        .operator-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .operator-card-title {
            color: #4dd4e8;
            font-weight: 500;
        }

        .operator-card-count {
            color: #8a5dda;
            font-family: 'Courier New', monospace;
        }

        .operator-card-phases {
            color: #8aa4bd;
            font-size: 0.85em;
        }

        .chamber-footer {
            text-align: center;
            padding: 20px;
            color: #6b7f94;
            font-size: 0.9em;
            border-top: 1px solid #2a4a6a;
            margin-top: 30px;
        }

        .footer-line {
            margin: 5px 0;
        }

        .chamber-id {
            font-family: 'Courier New', monospace;
            color: #8aa4bd;
        }

        .chamber-guide {
            background: #0f1f2f;
            border: 1px solid #2a4a6a;
            border-radius: 8px;
            margin: 30px 20px;
            overflow: hidden;
        }

        .guide-header {
            background: linear-gradient(135deg, #1a3a5a 0%, #2a4a6a 100%);
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .guide-header:hover {
            background: linear-gradient(135deg, #2a4a6a 0%, #3a5a7a 100%);
        }

        .guide-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #5ff5e3;
        }

        .guide-toggle {
            color: #8aa4bd;
            font-size: 1.3em;
            transition: transform 0.3s;
        }

        .guide-toggle.expanded {
            transform: rotate(180deg);
        }

        .guide-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
            padding: 0 20px;
        }

        .guide-content.expanded {
            max-height: 10000px;
            padding: 20px;
            transition: max-height 0.8s ease-in;
        }

        .guide-section {
            margin-bottom: 25px;
        }

        .guide-section h2 {
            color: #4dd4e8;
            font-size: 1.2em;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a4a6a;
        }

        .guide-section h3 {
            color: #5ff5e3;
            font-size: 1.05em;
            margin: 15px 0 8px 0;
        }

        .guide-section p {
            color: #b0c4d4;
            line-height: 1.7;
            margin-bottom: 12px;
        }

        .guide-section ul {
            color: #b0c4d4;
            line-height: 1.7;
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .guide-section li {
            margin-bottom: 6px;
        }

        .guide-formula {
            background: #0a1a2a;
            border-left: 3px solid #4dd4e8;
            padding: 12px;
            margin: 12px 0;
            font-family: 'Courier New', monospace;
            color: #5ff5e3;
        }

        .guide-downloads {
            background: #1a2a3a;
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }

        .guide-downloads h3 {
            color: #ffc107;
            margin-bottom: 12px;
        }

        .download-link {
            display: inline-block;
            background: #2a4a6a;
            color: #5ff5e3;
            padding: 8px 16px;
            border-radius: 4px;
            text-decoration: none;
            margin: 5px 10px 5px 0;
            transition: background 0.2s;
        }

        .download-link:hover {
            background: #3a5a7a;
            color: #4dd4e8;
        }

        .guide-note {
            background: rgba(95, 245, 227, 0.1);
            border-left: 3px solid #5ff5e3;
            padding: 12px;
            margin: 12px 0;
            color: #b0c4d4;
        }

        .guide-framework-notice {
            background: linear-gradient(135deg, rgba(77, 212, 232, 0.15) 0%, rgba(95, 245, 227, 0.15) 100%);
            border: 2px solid #4dd4e8;
            border-radius: 6px;
            padding: 20px;
            margin: 0 0 25px 0;
            text-align: center;
        }

        .guide-framework-notice strong {
            color: #4dd4e8;
            font-size: 1.1em;
            display: block;
            margin-bottom: 12px;
        }

        .guide-framework-notice p {
            color: #b0c4d4;
            line-height: 1.7;
            margin: 8px 0;
        }

        .guide-framework-link {
            display: inline-block;
            background: #2a4a6a;
            color: #4dd4e8;
            padding: 10px 20px;
            border-radius: 4px;
            text-decoration: none;
            margin-top: 12px;
            font-weight: bold;
            transition: all 0.2s;
            border: 1px solid #4dd4e8;
        }

        .guide-framework-link:hover {
            background: #3a5a7a;
            color: #5ff5e3;
            border-color: #5ff5e3;
            box-shadow: 0 0 10px rgba(77, 212, 232, 0.3);
        }

        .run-queue {
            background: #0f1729;
            border: 1px solid #2a4a6a;
            border-radius: 6px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .run-queue-item {
            padding: 15px;
            border-bottom: 1px solid #2a4a6a;
            transition: all 0.2s ease;
        }

        .run-queue-item:hover {
            background: rgba(77, 212, 232, 0.05);
        }

        .run-queue-item:last-child {
            border-bottom: none;
        }

        .run-queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .run-queue-id {
            color: #4dd4e8;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }

        .run-queue-timestamp {
            color: #8aa4bd;
            font-size: 0.85em;
        }

        .run-queue-params {
            color: #b0c4d4;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
        }

        .run-queue-remove {
            padding: 4px 10px;
            font-size: 0.8em;
            background: rgba(218, 93, 93, 0.2);
            border-color: #da5d5d;
            margin-left: 10px;
        }

        .run-queue-remove:hover {
            background: rgba(218, 93, 93, 0.3);
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }

        .comparison-table th {
            background: rgba(42, 74, 106, 0.3);
            padding: 10px;
            text-align: left;
            color: #4dd4e8;
            border: 1px solid #2a4a6a;
        }

        .comparison-table td {
            padding: 10px;
            border: 1px solid #2a4a6a;
            color: #b0c4d4;
            font-family: 'Courier New', monospace;
        }

        .comparison-table tbody tr:hover {
            background: rgba(77, 212, 232, 0.05);
        }

        .verdict-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .verdict-invariant {
            background: rgba(95, 245, 227, 0.2);
            border: 1px solid #5ff5e3;
            color: #5ff5e3;
        }

        .verdict-stable {
            background: rgba(77, 212, 232, 0.2);
            border: 1px solid #4dd4e8;
            color: #4dd4e8;
        }

        .verdict-fragile {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            color: #ffd54f;
        }

        .verdict-seed-dependent {
            background: rgba(138, 93, 218, 0.2);
            border: 1px solid #8a5dda;
            color: #a988ea;
        }

        .verdict-tau-critical {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid #ff9800;
            color: #ffb74d;
        }

        .verdict-collapse-dominated {
            background: rgba(218, 93, 93, 0.2);
            border: 1px solid #da5d5d;
            color: #ef9a9a;
        }

        .barcode-container {
            height: 30px;
            background: #0f1729;
            border: 1px solid #2a4a6a;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .stripe-container {
            height: 40px;
            background: #0f1729;
            border: 1px solid #2a4a6a;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
        }

        @media (max-width: 768px) {
            .chamber-title {
                font-size: 1.6em;
            }

            .tab-nav {
                flex-wrap: wrap;
            }

            .tab-button {
                flex: 1 1 33%;
                border-right: 1px solid #1a2840;
                border-bottom: 1px solid #1a2840;
            }

            .tab-content {
                padding: 20px;
                min-height: 300px;
            }

            .badge-row {
                gap: 8px;
            }

            .badge {
                font-size: 0.8em;
                padding: 5px 10px;
            }

            .input-row {
                flex-direction: column;
                align-items: stretch;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .graph-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .plot-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="chamber-container">
        <div class="chamber-header">
            <h1 class="chamber-title">œÑ-Filtered Observability ‚Äî Foundations Chamber</h1>
            <div class="chamber-subtitle">Operadic recursion ¬∑ œÑ-coherence ¬∑ collapse-selected dynamics ¬∑ Phase Diagrams (Œõ √ó Œ¥)</div>
            
            <div class="badge-row">
                <span class="badge badge-type">Type: Structural / Foundational</span>
                <span class="badge badge-phase">Phase: œÑ-Filtering + Phase Space</span>
                <span class="badge badge-role">Role: Observability & Selection</span>
                <span class="badge badge-status">Status: Ready</span>
            </div>
            
            <p class="chamber-description">
                This Chamber provides an operational environment for œÑ-filtered observability, operadic dynamics, and collapse-selected recursion.

                It computes Œõ √ó Œ¥ phase diagrams to classify system behavior into stable, transitional, and collapse-dominated regimes across parameter space.
            </p>
        </div>

        <div class="panel-container">
            <div class="tab-nav">
                <button class="tab-button active" data-tab="model">Model</button>
                <button class="tab-button" data-tab="run">Run</button>
                <button class="tab-button" data-tab="filter">œÑ-Filter</button>
                <button class="tab-button" data-tab="diagnostics">Diagnostics</button>
                <button class="tab-button" data-tab="export">Export</button>
                <button class="tab-button" data-tab="compare">Compare</button>
            </div>

            <div id="model" class="tab-content active">
                <div class="panel-caption">Model Configuration</div>
                
                <div class="control-group">
                    <label class="control-label">State Generator: Scalar Drift</label>
                    <div class="input-row">
                        <div class="input-field">
                            <label style="color: #8aa4bd; font-size: 0.85em; display: block; margin-bottom: 5px;">Steps (N)</label>
                            <input type="number" id="steps" value="100" min="10" max="1000" step="10">
                        </div>
                        <div class="input-field">
                            <label style="color: #8aa4bd; font-size: 0.85em; display: block; margin-bottom: 5px;">Drift (Œ¥)</label>
                            <input type="number" id="delta" value="0.01" min="0" max="0.1" step="0.001">
                        </div>
                        <div class="input-field">
                            <label style="color: #8aa4bd; font-size: 0.85em; display: block; margin-bottom: 5px;">Noise (Œµ bound)</label>
                            <input type="number" id="noise" value="0.005" min="0" max="0.05" step="0.001">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Sobtra: Threshold Clamp</label>
                    <div class="input-row">
                        <div class="input-field">
                            <label style="color: #8aa4bd; font-size: 0.85em; display: block; margin-bottom: 5px;">Threshold</label>
                            <input type="number" id="sobtra-threshold" value="0.1" min="0" max="1" step="0.01">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Deterministic Seeding</label>
                    <div class="input-row">
                        <div class="input-field">
                            <label style="color: #8aa4bd; font-size: 0.85em; display: block; margin-bottom: 5px;">Seed</label>
                            <input type="text" id="seed-input" value="1234" placeholder="Enter seed (number or string)">
                        </div>
                    </div>
                    <div class="toggle-switch" style="margin-top: 10px;">
                        <input type="checkbox" id="deterministic-toggle" checked>
                        <label for="deterministic-toggle">Deterministic mode (same seed ‚Üí same run)</label>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Generator:</strong> x<sub>n+1</sub> = x<sub>n</sub> + Œ¥ + Œµ<sub>n</sub><br>
                    <strong>Sobtra:</strong> s<sub>n</sub> = x<sub>n</sub> if |x<sub>n</sub>| &lt; threshold, else 0<br>
                    <strong>Residue:</strong> r<sub>n</sub> = x<sub>n</sub> - s<sub>n</sub><br>
                    <strong>Curvature:</strong> Œ∫<sub>n</sub> = |r<sub>n+1</sub> - r<sub>n</sub>| / (|x<sub>n</sub>| + 10<sup>-9</sup>)<br>
                    <strong>Admissibility:</strong> admissible(n) ‚ü∫ Œ∫<sub>n</sub> ‚â§ Œõ<br>
                    <strong>RNG:</strong> mulberry32 deterministic PRNG
                </div>
            </div>

            <div id="run" class="tab-content">
                <div class="panel-caption">Execution Control</div>
                <div class="control-group">
                    <button id="run-button">Run Simulation</button>
                </div>
                <div id="run-status" style="color: #8aa4bd; margin-top: 15px; font-size: 0.95em;"></div>
                
                <div class="info-box" style="margin-top: 30px;">
                    <strong>Execution Lifecycle:</strong><br><br>
                    1. Click "Run Simulation" to execute generator<br>
                    2. Raw series x(n) is computed with deterministic seed<br>
                    3. Upon completion, switch to <strong>œÑ-Filter</strong> or <strong>Diagnostics</strong> to view results<br>
                    4. Export becomes available once run completes
                </div>
            </div>

            <div id="filter" class="tab-content">
                <div class="panel-caption">œÑ-Threshold Configuration</div>
                <div class="control-group">
                    <label class="control-label">œÑ-threshold (Œõ)</label>
                    <div class="slider-container">
                        <input type="range" id="lambda-slider" min="0" max="100" value="50" step="1">
                        <span class="slider-value" id="lambda-display">0.0500</span>
                    </div>
                </div>
                <div class="info-box">
                    <strong>œÑ-Admissibility Rule:</strong> A transition at step n is admissible if Œ∫<sub>n</sub> ‚â§ Œõ.<br><br>
                    Adjusting Œõ recomputes admissibility for all steps in the current run without 
                    re-executing the generator. Steps with Œ∫<sub>n</sub> = null are always admissible.<br><br>
                    This filtering is <em>descriptive</em> and does not modify the underlying state sequence.
                </div>
                <div id="filter-status" style="margin-top: 20px; padding: 15px; background: rgba(138, 93, 218, 0.1); border: 1px solid #8a5dda; border-radius: 6px; color: #b0c4d4; font-size: 0.9em;">
                    No run available. Execute a simulation to enable œÑ-filtering.
                </div>
                
                <div class="plot-container" id="viz-kappa-vs-n" style="margin-top: 30px;">
                    <div class="plot-title">Œ∫(n) vs n</div>
                    <canvas id="kappaVsN" width="800" height="300"></canvas>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #8aa4bd;">
                        Line color indicates admissibility (cyan = Œ∫ ‚â§ Œõ, red = Œ∫ > Œõ), point alpha ‚àù Œ∫ magnitude
                    </div>
                </div>

                <div class="plot-container" id="viz-admissibility-barcode">
                    <div class="plot-title">œÑ-Admissibility Barcode</div>
                    <div class="barcode-container" id="barcode-display"></div>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #8aa4bd;">
                        <span style="color: #4dd4e8;">‚ñà</span> Admissible (Œ∫ ‚â§ Œõ) &nbsp;&nbsp;
                        <span style="color: #da5d5d;">‚ñà</span> Collapse (Œ∫ > Œõ)
                    </div>
                </div>

                <div class="plot-container" id="viz-trajectory-admissibility">
                    <div class="plot-title">Trajectory with Œ∫ Overlay</div>
                    <canvas id="trajectory-canvas" width="800" height="300"></canvas>
                    <div class="stats-grid" style="margin-top: 15px;">
                        <div class="stat-box">
                            <div class="stat-label">Admissible Steps</div>
                            <div class="stat-value" id="traj-admissible">‚Äî</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Rejected (XII)</div>
                            <div class="stat-value" id="traj-rejected">‚Äî</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Survival Ratio</div>
                            <div class="stat-value" id="traj-survival">‚Äî</div>
                        </div>
                    </div>
                </div>

                <div class="plot-container" id="viz-residue-sobtra">
                    <div class="plot-title">Residue‚ÄìSobtra Contrast</div>
                    <canvas id="residueSobtraPlot" width="800" height="300"></canvas>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #8aa4bd;">
                        Plot shows |residue ‚àí sobtra|, shaded where Œ∫ > Œõ
                    </div>
                </div>
            </div>

            <div id="diagnostics" class="tab-content">
                <div class="panel-caption">œÑ-Filtered Diagnostics & Operadic Laws</div>
                <div id="diagnostics-content"></div>
                
                <div class="plot-container" id="laws-container" style="margin-top: 30px;">
                    <div class="plot-title">Operadic Laws</div>
                    <div id="laws-content"></div>
                </div>
                
                <div class="plot-grid">
                    <div class="graph-container" id="evolution-graph">
                        <canvas id="evolution-canvas" width="800" height="300"></canvas>
                    </div>
                    <div class="graph-container" id="curvature-graph">
                        <canvas id="curvature-canvas" width="800" height="300"></canvas>
                    </div>
                </div>
                
                <div class="plot-container" id="viz-phase-lambda-delta" style="margin-top: 20px;">
                    <div class="plot-title">Phase Diagram: Œõ √ó Œ¥</div>
                    <canvas id="phase-lambda-delta-canvas" width="800" height="500"></canvas>
                    <div id="phase-legend" class="info-box">
                        <strong>Phase Regions:</strong><br>
                        üü¶ <span style="color: #5ff5e3;">œÑ-stable region</span> (high admissibility, survival &gt; 90%)<br>
                        üü© <span style="color: #8a5dda;">Transitional regime</span> (œÑ-critical, survival 30-90%)<br>
                        üü• <span style="color: #da5d5d;">Collapse-dominated</span> (XII absorbing, survival &lt; 30%)
                    </div>
                </div>

                <div class="plot-container" id="viz-kappa-histogram">
                    <div class="plot-title">Œ∫ Distribution vs Œõ</div>
                    <canvas id="kappaHistogram" width="800" height="300"></canvas>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #8aa4bd;">
                        Histogram shows why admissibility collapses: Œ∫ values exceeding Œõ threshold
                    </div>
                </div>

                <div class="plot-container" id="viz-operator-timeline">
                    <div class="plot-title">Operator Dominance Over Time</div>
                    <canvas id="operator-timeline-canvas" width="800" height="300"></canvas>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #8aa4bd;">
                        Stacked area chart showing how operator frequencies evolve
                    </div>
                </div>

                <div class="plot-container" id="viz-kappa-vs-lambda">
                    <div class="plot-title">Œ∫(n) vs Œõ Diagnostic</div>
                    <canvas id="kappa-diagnostic-canvas" width="800" height="300"></canvas>
                    <div class="info-box">
                        <strong>Admissible Region:</strong> Shaded area where Œ∫ ‚â§ Œõ<br>
                        <strong>Collapse Trigger:</strong> Steps where Œ∫ exceeds Œõ threshold (red bars)
                    </div>
                </div>
                
                <div class="plot-container" id="viz-survival-stripe">
                    <div class="plot-title">œÑ-Survival Stripe</div>
                    <div class="stripe-container" id="survival-stripe-display"></div>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #8aa4bd;">
                        <span style="color: #4dd4e8;">‚ñà</span> Œ¶ &nbsp;
                        <span style="color: #8a5dda;">‚ñà</span> Œ® &nbsp;
                        <span style="color: #5ff5e3;">‚ñà</span> œÑ &nbsp;
                        <span style="color: #da5d5d;">‚ñà</span> XII
                    </div>
                </div>
                
                <div class="plot-container" id="transition-plot">
                    <div class="plot-title">œÑ-Filtered Transition Graph</div>
                    <div class="graph-controls">
                        <div class="input-field" style="max-width: 150px;">
                            <label style="color: #8aa4bd; font-size: 0.85em; display: block; margin-bottom: 5px;">State Bins (B)</label>
                            <input type="number" id="state-bins" value="10" min="5" max="50" step="1">
                        </div>
                        <div class="input-field" style="max-width: 150px;">
                            <label style="color: #8aa4bd; font-size: 0.85em; display: block; margin-bottom: 5px;">Max Path Length</label>
                            <input type="number" id="max-path-length" value="5" min="2" max="20" step="1">
                        </div>
                        <button id="update-graph-button">Update Graph</button>
                    </div>
                    <canvas id="transition-canvas" width="800" height="500"></canvas>
                </div>
                
                <div class="plot-container" id="paths-container">
                    <div class="plot-title">œÑ-Admissible Paths</div>
                    <div id="paths-list" class="path-list"></div>
                </div>

                <div class="plot-container" id="operators-container">
                    <div class="plot-title">Operator Statistics</div>
                    <div id="operators-stats"></div>
                </div>
            </div>

            <div id="export" class="tab-content">
                <div class="panel-caption">Data Export & Reproducibility</div>
                
                <div class="control-group">
                    <label class="control-label">Export & Import</label>
                    <div class="input-row">
                        <button id="export-button" disabled>Export JSON</button>
                        <button id="import-button">Import JSON</button>
                        <input type="file" id="file-input" accept=".json">
                    </div>
                </div>

                <div class="export-status" id="export-status">
                    No run data available. Execute a simulation to enable export.
                </div>

                <div class="info-box">
                    <strong>Export Format:</strong> Single JSON file containing chamber version, run configuration, 
                    raw series data, operator tags, derived metrics (graphs, paths, laws).<br><br>
                    <strong>Reproducibility:</strong> Deterministic seeding ensures identical series on rerun. 
                    JSON imports populate UI and allow parameter exploration (Œõ, B, L<sub>max</sub>) 
                    without re-executing the generator.<br><br>
                    <strong>Schema:</strong> UNNS_FOUNDATIONS_RUN/v1
                </div>
            </div>

            <div id="compare" class="tab-content">
                <div class="panel-caption">Step 9: Multi-Run Comparison</div>
                
                <div class="control-group">
                    <label class="control-label">Import Queue Management</label>
                    <div class="input-row">
                        <button id="compare-import-button">Import Run to Queue</button>
                        <button id="clear-queue-button">Clear Queue</button>
                        <button id="export-comparison-button" disabled>Export Comparison</button>
                        <input type="file" id="compare-file-input" accept=".json">
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Loaded Runs (<span id="queue-count">0</span>)</label>
                    <div id="run-queue" class="run-queue">
                        <div style="padding: 30px; text-align: center; color: #8aa4bd;">
                            No runs loaded. Import JSON runs to begin comparison.
                        </div>
                    </div>
                </div>

                <div id="comparison-results" style="display: none;">
                    <div class="control-group">
                        <label class="control-label">Structural Alignment</label>
                        <div class="stats-grid">
                            <div class="stat-box">
                                <div class="stat-label">Aligned Runs</div>
                                <div class="stat-value" id="comp-aligned-runs">‚Äî</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">Common State Bins (B)</div>
                                <div class="stat-value" id="comp-common-bins">‚Äî</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">Max Path Length</div>
                                <div class="stat-value" id="comp-max-path-length">‚Äî</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">Operator Alphabet</div>
                                <div class="stat-value" id="comp-operator-alphabet">Œ¶, Œ®, œÑ, XII</div>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">œÑ-Survival Stability</label>
                        <div class="plot-container">
                            <div class="plot-title">Survival Ratio per Run</div>
                            <canvas id="survival-comparison-canvas" width="800" height="300"></canvas>
                        </div>
                        <div class="stats-grid">
                            <div class="stat-box">
                                <div class="stat-label">Mean Survival Ratio</div>
                                <div class="stat-value" id="comp-mean-survival">‚Äî</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">Variance (œÉ¬≤)</div>
                                <div class="stat-value" id="comp-survival-variance">‚Äî</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">Stability Verdict</div>
                                <div class="stat-value" id="comp-survival-verdict">‚Äî</div>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Path Persistence Analysis</label>
                        <div class="plot-container">
                            <div class="plot-title">Path Intersection Table</div>
                            <div id="path-intersection-table"></div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Operator Dominance Drift</label>
                        <div class="plot-container">
                            <div class="plot-title">Operator Frequency Across Runs</div>
                            <canvas id="operator-drift-canvas" width="800" height="400"></canvas>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Collapse Onset Detection</label>
                        <div class="stats-grid">
                            <div class="stat-box">
                                <div class="stat-label">Runs with XII</div>
                                <div class="stat-value" id="comp-collapse-runs">‚Äî</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">Mean First XII Step</div>
                                <div class="stat-value" id="comp-collapse-onset">‚Äî</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">Seed Sensitivity</div>
                                <div class="stat-value" id="comp-collapse-sensitivity">‚Äî</div>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Structural Verdicts</label>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Metric</th>
                                    <th>Classification</th>
                                    <th>Justification</th>
                                </tr>
                            </thead>
                            <tbody id="verdicts-table-body"></tbody>
                        </table>
                    </div>

                    <div class="control-group">
                        <label class="control-label">œÑ-Envelope Plot</label>
                        <div class="plot-container">
                            <div class="plot-title">Œ∫ Envelope (min / median / max)</div>
                            <canvas id="tau-envelope-canvas" width="800" height="300"></canvas>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Overlay Transition Graph</label>
                        <div class="plot-container">
                            <div class="plot-title">All Runs (Ghosted)</div>
                            <canvas id="overlay-graph-canvas" width="800" height="500"></canvas>
                        </div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Step 9 Purpose:</strong> Compare multiple immutable runs to identify structural invariants.<br><br>
                    <strong>Capabilities:</strong>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>œÑ-Survival Stability: variance across runs</li>
                        <li>Path Persistence: paths present in all/most runs</li>
                        <li>Operator Dominance Drift: frequency deltas</li>
                        <li>Collapse Onset Detection: seed-sensitivity</li>
                        <li>Structural Verdicts: Invariant, Stable, Fragile, œÑ-Critical, Collapse-Dominated</li>
                    </ul>
                    <br>
                    <strong>Schema:</strong> UNNS_FOUNDATIONS_COMPARISON/v1
                </div>
            </div>
        </div>


        <div class="chamber-guide">
            <div class="guide-header" onclick="toggleGuide()">
                <div class="guide-title">üìñ Chamber Operational Guide ‚Äî Foundations of œÑ-Filtered Observability</div>
                <div class="guide-toggle" id="guide-toggle">‚ñº</div>
            </div>
            <div class="guide-content" id="guide-content">
                <div class="guide-framework-notice">
                    <strong>üìö Formal Framework</strong>
                    <p>The Chamber is built around the formal framework developed in:</p>
                    <p style="font-style: italic; color: #5ff5e3;">UNNS as an ‚àû-Operadic Substrate</p>
                    <p>The paper provides the formal operator grammar and recursion logic; this Chamber provides the instrumented execution surface.</p>
                    <a href="https://unns.tech/media/docs/UNNS%20as%20an%20%E2%88%9E-Operadic%20Substrate.pdf" class="guide-framework-link" target="_blank">üìÑ Read the Paper (PDF)</a>
                </div>
                
                <div class="guide-section">
                    <p>This Chamber operationalizes the constructions introduced in "UNNS as an ‚àû-Operadic Substrate" by providing a controlled computational environment in which operadic recursion, œÑ-filtering, and collapse-selected dynamics can be examined step-by-step.</p>
                    <p>The Chamber is designed to produce explicit sequences, operator traces, admissibility masks, and phase-space partitions derived from deterministic recursion rules. All outputs are generated directly from the configured model parameters and exported in structured form.</p>
                </div>

                <div class="guide-section">
                    <h2>1. State Generator (Scalar Drift)</h2>
                    <p>The generator evolves a scalar state sequence according to:</p>
                    <div class="guide-formula">x<sub>n+1</sub> = x<sub>n</sub> + Œ¥ + Œµ<sub>n</sub></div>
                    <p><strong>Where:</strong></p>
                    <ul>
                        <li>Œ¥ is a constant drift parameter</li>
                        <li>Œµ<sub>n</sub> is bounded noise</li>
                        <li>the random number generator is deterministic when seeding is enabled</li>
                    </ul>
                    <p>The generator produces the raw state trajectory x<sub>n</sub>, which is then processed by subsequent operators.</p>
                </div>

                <div class="guide-section">
                    <h2>2. Sobtra Threshold Clamp</h2>
                    <p>Sobtra is the threshold-based projection operator used in the Chamber.</p>
                    <p>It is defined as:</p>
                    <div class="guide-formula">
                        s<sub>n</sub> = x<sub>n</sub> if |x<sub>n</sub>| &lt; Œ∏<br>
                        s<sub>n</sub> = 0 otherwise
                    </div>
                    <p><strong>Where:</strong></p>
                    <ul>
                        <li>Œ∏ is the Sobtra threshold parameter</li>
                    </ul>
                    <p>Sobtra partitions each step into:</p>
                    <ul>
                        <li>a retained component (s<sub>n</sub>)</li>
                        <li>a rejected component captured by the residue</li>
                    </ul>
                    <p>The residue is defined as:</p>
                    <div class="guide-formula">r<sub>n</sub> = x<sub>n</sub> ‚àí s<sub>n</sub></div>
                    <p>This decomposition allows the Chamber to distinguish between locally retained structure and suppressed contributions at each step.</p>
                </div>

                <div class="guide-section">
                    <h2>3. Residue</h2>
                    <p>The residue r<sub>n</sub> records the portion of the state excluded by Sobtra. Residue magnitude directly contributes to curvature and collapse detection.</p>
                    <p>Residue values are visualized in:</p>
                    <ul>
                        <li>Œ∫(n) diagnostics</li>
                        <li>admissibility barcodes</li>
                        <li>collapse overlays</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h2>4. Curvature Œ∫ and Admissibility</h2>
                    <p>Curvature at step n is defined as:</p>
                    <div class="guide-formula">Œ∫<sub>n</sub> = | r<sub>n+1</sub> ‚àí r<sub>n</sub> | / ( |x<sub>n</sub>| + 10<sup>-9</sup> )</div>
                    <p>A step is admissible if:</p>
                    <div class="guide-formula">Œ∫<sub>n</sub> ‚â§ Œõ</div>
                    <p><strong>Where:</strong></p>
                    <ul>
                        <li>Œõ is the admissibility threshold (œÑ-filter parameter)</li>
                    </ul>
                    <p>Admissibility is a binary, local property evaluated independently at each step.</p>
                </div>

                <div class="guide-section">
                    <h2>5. Operator Assignment</h2>
                    <p>Each step is assigned an operator symbol based on its local behavior:</p>
                    <ul>
                        <li><strong>Œ¶</strong> ‚Äî generative continuation</li>
                        <li><strong>Œ®</strong> ‚Äî structural modulation</li>
                        <li><strong>œÑ</strong> ‚Äî admissible evolution</li>
                        <li><strong>XII</strong> ‚Äî collapse (inadmissible step)</li>
                    </ul>
                    <p>Operator assignment is recorded explicitly in the exported data and summarized in dominance charts.</p>
                </div>

                <div class="guide-section">
                    <h2>6. œÑ-Filtering</h2>
                    <p>œÑ-filtering applies the admissibility criterion after generation, without re-executing the generator.</p>
                    <p>This allows:</p>
                    <ul>
                        <li>re-classification of steps under different Œõ values</li>
                        <li>construction of Œõ √ó Œ¥ phase diagrams</li>
                        <li>comparative analysis across thresholds</li>
                    </ul>
                    <p>œÑ-filtering operates purely on recorded state data.</p>
                </div>

                <div class="guide-section">
                    <h2>7. Phase Diagrams (Œõ √ó Œ¥)</h2>
                    <p>The Chamber constructs phase diagrams in the Œõ √ó Œ¥ plane, classifying regions according to:</p>
                    <ul>
                        <li>fraction of admissible steps</li>
                        <li>collapse prevalence</li>
                        <li>transitional regimes</li>
                    </ul>
                    <p>These diagrams are computed directly from admissibility masks and are independent of visual scaling.</p>
                </div>

                <div class="guide-section">
                    <h2>8. Diagnostics</h2>
                    <p>Diagnostics summarize run-level properties, including:</p>
                    <ul>
                        <li>total steps</li>
                        <li>admissible steps</li>
                        <li>survival ratio</li>
                        <li>collapse onset location</li>
                        <li>operator frequencies</li>
                    </ul>
                    <p>All diagnostic values are derived from per-step data and are exported verbatim.</p>
                </div>

                <div class="guide-section">
                    <h2>9. Multi-Run Comparison</h2>
                    <p>The Compare module aligns multiple imported runs by step index and evaluates:</p>
                    <ul>
                        <li>survival ratio stability</li>
                        <li>path persistence</li>
                        <li>operator dominance drift</li>
                        <li>collapse consistency</li>
                    </ul>
                    <p>Comparisons do not recompute any dynamics; they operate solely on imported run data.</p>
                </div>

                <div class="guide-section">
                    <h2>Appendix A ‚Äî How to Read the Outputs</h2>
                    <h3>A.1 Time-Series Plots</h3>
                    <ul>
                        <li>x(n) shows raw state evolution</li>
                        <li>overlays highlight admissible vs collapsed regions</li>
                    </ul>
                    <h3>A.2 Œ∫(n) Diagnostic</h3>
                    <ul>
                        <li>spikes indicate sharp residue variation</li>
                        <li>Œ∫ exceeding Œõ marks inadmissible steps</li>
                    </ul>
                    <h3>A.3 Admissibility Barcode</h3>
                    <ul>
                        <li>binary visualization of admissible vs collapsed steps</li>
                        <li>useful for detecting clustering and regime shifts</li>
                    </ul>
                    <h3>A.4 Trajectory with Overlay</h3>
                    <ul>
                        <li>combines x(n) with admissibility shading</li>
                        <li>visually correlates collapse with state growth</li>
                    </ul>
                    <h3>A.5 Phase Diagram (Œõ √ó Œ¥)</h3>
                    <ul>
                        <li>horizontal slices correspond to fixed Œ¥</li>
                        <li>vertical transitions mark admissibility boundary crossings</li>
                    </ul>
                    <h3>A.6 Operator Dominance Charts</h3>
                    <ul>
                        <li>display relative operator frequencies over time or across runs</li>
                    </ul>
                    <h3>A.7 Structural Verdicts</h3>
                    <ul>
                        <li>summarize invariance or divergence across compared runs</li>
                        <li>derived strictly from computed metrics</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h2>Appendix B ‚Äî Testing & Reproducibility</h2>
                    <p>Two JSON files are provided as reference inputs for testing, validation, and regression checks.</p>
                    
                    <div class="guide-downloads">
                        <h3>Example Run (Single)</h3>
                        <p><strong>test_run_valid.json</strong> ‚Äî Contains a complete single-run export with:</p>
                        <ul>
                            <li>configuration block</li>
                            <li>per-step data</li>
                            <li>diagnostics summary</li>
                        </ul>
                        <p>This file can be imported to:</p>
                        <ul>
                            <li>restore a full run state</li>
                            <li>test Export / Import consistency</li>
                            <li>verify œÑ-filter recomputation</li>
                        </ul>
                        <a href="https://unns.tech/media/json/test_run_valid.json" class="download-link" download>üíæ Download test_run_valid.json</a>
                    </div>

                    <div class="guide-downloads">
                        <h3>Example Comparison</h3>
                        <p><strong>test_run_comparison.json</strong> ‚Äî Contains two compatible runs for the Compare module.</p>
                        <p>This file can be used to:</p>
                        <ul>
                            <li>populate the comparison queue</li>
                            <li>verify alignment logic</li>
                            <li>test comparison export functionality</li>
                        </ul>
                        <a href="https://unns.tech/media/json/test_run_comparison.json" class="download-link" download>üíæ Download test_run_comparison.json</a>
                    </div>

                    <div class="guide-note">
                        <strong>Recommended Usage:</strong><br>
                        1. Import the single-run file<br>
                        2. Inspect œÑ-Filter and Diagnostics<br>
                        3. Import the comparison file<br>
                        4. Export comparison and verify metrics<br><br>
                        These files are suitable as long-term regression references.
                    </div>
                </div>
            </div>
        </div>


        <div class="chamber-footer">
            <div class="footer-line">UNNS Laboratory | Foundations Chamber</div>
            <div class="footer-line">Version 1.10.0 (Step 10: Phase Diagrams) | Build 2025-Q1</div>
            <div class="footer-line chamber-id">Chamber ID: UNNS-FOUND-TAU-FILTER-PHASE-DIAGRAMS</div>
        </div>
    </div>

    <script>
        const CHAMBER_VERSION = '1.10.0';
        const CHAMBER_BUILD = '2025-Q1-STEP10';
        const EXPORT_SCHEMA = 'UNNS_FOUNDATIONS_RUN/v1';
        const COMPARISON_SCHEMA = 'UNNS_FOUNDATIONS_COMPARISON/v1';

        let seedInput = null;
        let seedUint32 = 0;
        let rngState = 0;
        let deterministicMode = true;
        let runLog = null;
        let currentLambda = 0.05;
        let selectedPath = null;

        let runQueue = [];
        let comparisonResults = null;

        function hashStringToUint32(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & 0xFFFFFFFF;
            }
            return hash >>> 0;
        }

        function initRNG(seed) {
            seedInput = seed;
            if (typeof seed === 'string') {
                seedUint32 = hashStringToUint32(seed);
            } else {
                seedUint32 = (seed >>> 0);
            }
            rngState = seedUint32;
        }

        function mulberry32() {
            let t = rngState += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        function randn() {
            const u1 = mulberry32();
            const u2 = mulberry32();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }

        function generateStateStream(config) {
            const { steps, delta, noise } = config;
            const series = [];
            let x = 0;
            
            for (let n = 0; n < steps; n++) {
                const epsilon = randn() * noise;
                x = x + delta + epsilon;
                
                series.push({
                    n: n,
                    x: x,
                    epsilon: epsilon
                });
            }
            
            return series;
        }

        function computeSobtra(series, threshold) {
            for (let i = 0; i < series.length; i++) {
                const x = series[i].x;
                series[i].sobtra = (Math.abs(x) < threshold) ? x : 0;
                series[i].residue = x - series[i].sobtra;
            }
        }

        function computeKappa(series) {
            for (let i = 0; i < series.length; i++) {
                if (i < 2) {
                    series[i].kappa = null;
                } else {
                    const dx1 = series[i].x - series[i - 1].x;
                    const dx0 = series[i - 1].x - series[i - 2].x;
                    series[i].kappa = Math.abs(dx1 - dx0) / (Math.abs(dx0) + 1e-9);
                }
            }
        }

        function computeAdmissibility(series, lambda) {
            for (let i = 0; i < series.length; i++) {
                const kappa = series[i].kappa;
                series[i].admissible = (kappa === null) ? true : (kappa <= lambda);
            }
        }

        function labelOperators(series, lambda) {
            for (let i = 0; i < series.length; i++) {
                const step = series[i];
                
                if (step.kappa === null) {
                    step.operator = 'Œ¶';
                } else if (step.admissible) {
                    if (Math.abs(step.sobtra) > 0) {
                        step.operator = 'Œ®';
                    } else {
                        step.operator = 'œÑ';
                    }
                } else {
                    step.operator = 'XII';
                }
            }
        }

        function createRunLog(config, series) {
            computeSobtra(series, config.sobtraThreshold);
            
            return {
                version: CHAMBER_VERSION,
                schema: EXPORT_SCHEMA,
                timestamp: new Date().toISOString(),
                seed: {
                    input: seedInput,
                    uint32: seedUint32,
                    deterministic: deterministicMode
                },
                config: {
                    steps: config.steps,
                    delta: config.delta,
                    noise: config.noise,
                    sobtraThreshold: config.sobtraThreshold,
                    lambda: currentLambda,
                    stateBins: parseInt(document.getElementById('state-bins').value),
                    maxPathLength: parseInt(document.getElementById('max-path-length').value)
                },
                series: series
            };
        }

        function initTabSwitching() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.getAttribute('data-tab');
                    
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    button.classList.add('active');
                    document.getElementById(targetTab).classList.add('active');
                });
            });
        }

        function drawPhaseDiagram() {
            const canvas = document.getElementById('phase-lambda-delta-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!runLog) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Run a simulation to generate phase diagram', width / 2, height / 2);
                return;
            }
            
            const lambdaMin = 0.01;
            const lambdaMax = 0.15;
            const deltaMin = 0.001;
            const deltaMax = 0.05;
            const gridRes = 30;
            
            const lambdaStep = (lambdaMax - lambdaMin) / gridRes;
            const deltaStep = (deltaMax - deltaMin) / gridRes;
            
            const cellWidth = (width - 2 * padding) / gridRes;
            const cellHeight = (height - 2 * padding) / gridRes;
            
            for (let ly = 0; ly < gridRes; ly++) {
                for (let lx = 0; lx < gridRes; lx++) {
                    const lambda = lambdaMin + lx * lambdaStep;
                    const delta = deltaMax - ly * deltaStep;
                    
                    const tempSeries = JSON.parse(JSON.stringify(runLog.series));
                    computeAdmissibility(tempSeries, lambda);
                    const admissible = tempSeries.filter(s => s.admissible).length;
                    const survivalRatio = admissible / tempSeries.length;
                    
                    let color;
                    if (survivalRatio > 0.9) {
                        color = '#40e0d0';
                    } else if (survivalRatio > 0.3) {
                        color = '#ffbf00';
                    } else {
                        color = '#da5d5d';
                    }
                    
                    const px = padding + lx * cellWidth;
                    const py = padding + ly * cellHeight;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(px, py, cellWidth, cellHeight);
                }
            }
            
            const currentLambdaX = padding + ((currentLambda - lambdaMin) / (lambdaMax - lambdaMin)) * (width - 2 * padding);
            const currentDeltaY = padding + ((deltaMax - runLog.config.delta) / (deltaMax - deltaMin)) * (height - 2 * padding);
            
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(currentLambdaX, padding);
            ctx.lineTo(currentLambdaX, height - padding);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(padding, currentDeltaY);
            ctx.lineTo(width - padding, currentDeltaY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ffc107';
            ctx.beginPath();
            ctx.arc(currentLambdaX, currentDeltaY, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(lambdaMin.toFixed(3), padding, height - padding + 15);
            ctx.textAlign = 'right';
            ctx.fillText(lambdaMax.toFixed(3), width - padding, height - padding + 15);
            ctx.textAlign = 'center';
            ctx.fillText('Œõ (tau threshold)', width / 2, height - 20);
            
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Œ¥ (drift)', 0, 0);
            ctx.restore();
            
            ctx.textAlign = 'left';
            ctx.fillText(deltaMin.toFixed(3), 5, height - padding);
            ctx.fillText(deltaMax.toFixed(3), 5, padding + 15);
        }

        function drawKappaHistogram(series) {
            const canvas = document.getElementById('kappaHistogram');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!series || series.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const kappaValues = series.filter(s => s.kappa !== null).map(s => s.kappa);
            if (kappaValues.length === 0) return;
            
            const bins = 40;
            const minKappa = 0;
            const maxKappa = Math.max(...kappaValues);
            const binWidth = maxKappa / bins;
            
            const histogram = new Array(bins).fill(0);
            kappaValues.forEach(k => {
                const binIdx = Math.min(Math.floor(k / binWidth), bins - 1);
                histogram[binIdx]++;
            });
            
            const maxCount = Math.max(...histogram);
            const barWidth = (width - 2 * padding) / bins;
            const yScale = (height - 2 * padding) / maxCount;
            
            for (let i = 0; i < bins; i++) {
                const binStart = i * binWidth;
                const binEnd = (i + 1) * binWidth;
                
                const isAdmissible = binEnd <= currentLambda;
                ctx.fillStyle = isAdmissible ? 'rgba(77, 212, 232, 0.6)' : 'rgba(218, 93, 93, 0.6)';
                
                const x = padding + i * barWidth;
                const barHeight = histogram[i] * yScale;
                const y = height - padding - barHeight;
                
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }
            
            const lambdaX = padding + (currentLambda / maxKappa) * (width - 2 * padding);
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(lambdaX, padding);
            ctx.lineTo(lambdaX, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Œ∫', width / 2, height - 15);
            
            ctx.fillStyle = '#ffc107';
            ctx.textAlign = 'left';
            ctx.fillText('Œõ = ' + currentLambda.toFixed(4), lambdaX + 5, padding + 15);
        }

        function drawSurvivalStripe(series) {
            const container = document.getElementById('survival-stripe-display');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (!series || series.length === 0) return;
            
            const operatorColors = {
                'Œ¶': '#4dd4e8',
                'Œ®': '#8a5dda',
                'œÑ': '#5ff5e3',
                'XII': '#da5d5d'
            };
            
            series.forEach((step) => {
                const bar = document.createElement('div');
                bar.style.flex = '1';
                bar.style.height = '100%';
                bar.style.backgroundColor = operatorColors[step.operator];
                container.appendChild(bar);
            });
        }

        function drawKappaVsN(series) {
            const canvas = document.getElementById('kappaVsN');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!series || series.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const kappaValues = series.filter(s => s.kappa !== null).map(s => s.kappa);
            if (kappaValues.length === 0) return;
            
            const maxKappa = Math.max(...kappaValues);
            const xScale = (width - 2 * padding) / series.length;
            const yScale = (height - 2 * padding) / (maxKappa * 1.1);
            
            // LAYER 1: Draw collapse segments (background, low alpha)
            for (let i = 1; i < series.length; i++) {
                if (series[i].kappa === null || series[i].admissible) continue;
                
                const x0 = padding + (i - 1) * xScale;
                const y0 = series[i - 1].kappa !== null ? (height - padding - series[i - 1].kappa * yScale) : (height - padding);
                const x1 = padding + i * xScale;
                const y1 = height - padding - series[i].kappa * yScale;
                
                const alpha = Math.max(0.15, Math.min(0.9, Math.log(series[i].kappa + 1)));
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#da5d5d';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
                
                ctx.fillStyle = '#da5d5d';
                ctx.beginPath();
                ctx.arc(x1, y1, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
            
            // LAYER 2: Draw admissible segments (foreground, high contrast)
            for (let i = 1; i < series.length; i++) {
                if (series[i].kappa === null || !series[i].admissible) continue;
                
                const x0 = padding + (i - 1) * xScale;
                const y0 = series[i - 1].kappa !== null ? (height - padding - series[i - 1].kappa * yScale) : (height - padding);
                const x1 = padding + i * xScale;
                const y1 = height - padding - series[i].kappa * yScale;
                
                const alpha = Math.max(0.15, Math.min(0.9, Math.log(series[i].kappa + 1)));
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#4dd4e8';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
                
                ctx.fillStyle = '#4dd4e8';
                ctx.beginPath();
                ctx.arc(x1, y1, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('n (step)', width / 2, height - 15);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Œ∫', 0, 0);
            ctx.restore();
        }

        function drawResidueSobtraPlot(series) {
            const canvas = document.getElementById('residueSobtraPlot');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!series || series.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const contrasts = series.map(s => Math.abs(s.residue - s.sobtra));
            const maxContrast = Math.max(...contrasts);
            const xScale = (width - 2 * padding) / series.length;
            const yScale = (height - 2 * padding) / maxContrast;
            
            for (let i = 0; i < series.length; i++) {
                const x = padding + i * xScale;
                
                if (!series[i].admissible && series[i].kappa !== null) {
                    ctx.fillStyle = 'rgba(218, 93, 93, 0.35)';
                    ctx.fillRect(x, padding, Math.max(2, xScale), height - 2 * padding);
                } else if (series[i].admissible) {
                    ctx.fillStyle = 'rgba(77, 212, 232, 0.10)';
                    ctx.fillRect(x, padding, Math.max(2, xScale), height - 2 * padding);
                }
            }
            
            ctx.strokeStyle = '#8a5dda';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < series.length; i++) {
                const x = padding + i * xScale;
                const y = height - padding - contrasts[i] * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('n (step)', width / 2, height - 15);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('|residue ‚àí sobtra|', 0, 0);
            ctx.restore();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Red shading: Œ∫ > Œõ', padding + 5, padding + 15);
        }

        function drawOperatorTimeline(series) {
            const canvas = document.getElementById('operator-timeline-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!series || series.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const windowSize = 10;
            const numWindows = Math.floor(series.length / windowSize);
            
            const windows = [];
            for (let w = 0; w < numWindows; w++) {
                const start = w * windowSize;
                const end = start + windowSize;
                const window = series.slice(start, end);
                
                const counts = { 'Œ¶': 0, 'Œ®': 0, 'œÑ': 0, 'XII': 0 };
                window.forEach(s => counts[s.operator]++);
                
                windows.push({
                    Phi: Math.sqrt(counts['Œ¶'] / windowSize),
                    Psi: Math.sqrt(counts['Œ®'] / windowSize),
                    Tau: Math.sqrt(counts['œÑ'] / windowSize),
                    XII: Math.sqrt(counts['XII'] / windowSize)
                });
            }
            
            const xScale = (width - 2 * padding) / numWindows;
            const yScale = height - 2 * padding;
            
            const colors = {
                Phi: '#4dd4e8',
                Psi: '#8a5dda',
                Tau: '#5ff5e3',
                XII: '#da5d5d'
            };
            
            const minOpacity = 0.25;
            
            ['Phi', 'Psi', 'Tau', 'XII'].forEach(op => {
                ctx.globalAlpha = Math.max(minOpacity, 1.0);
                ctx.fillStyle = colors[op];
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                
                for (let i = 0; i < windows.length; i++) {
                    const x = padding + i * xScale;
                    
                    let yOffset = 0;
                    ['Phi', 'Psi', 'Tau', 'XII'].forEach(prevOp => {
                        if (prevOp === op) return;
                        if (['Phi', 'Psi', 'Tau', 'XII'].indexOf(prevOp) < ['Phi', 'Psi', 'Tau', 'XII'].indexOf(op)) {
                            yOffset += windows[i][prevOp];
                        }
                    });
                    
                    const y = height - padding - (yOffset + windows[i][op]) * yScale;
                    ctx.lineTo(x, y);
                }
                
                for (let i = windows.length - 1; i >= 0; i--) {
                    const x = padding + i * xScale;
                    
                    let yOffset = 0;
                    ['Phi', 'Psi', 'Tau', 'XII'].forEach(prevOp => {
                        if (prevOp === op) return;
                        if (['Phi', 'Psi', 'Tau', 'XII'].indexOf(prevOp) < ['Phi', 'Psi', 'Tau', 'XII'].indexOf(op)) {
                            yOffset += windows[i][prevOp];
                        }
                    });
                    
                    const y = height - padding - yOffset * yScale;
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Time Window', width / 2, height - 15);
        }

        function drawTrajectoryWithAdmissibility(series) {
            const canvas = document.getElementById('trajectory-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!series || series.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const xValues = series.map(s => s.x);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            const rangeX = maxX - minX;
            
            const xScale = (width - 2 * padding) / series.length;
            const yScale = (height - 2 * padding) / rangeX;
            
            // LAYER 1: Draw localized collapse shading
            for (let i = 0; i < series.length; i++) {
                if (!series[i].admissible && series[i].kappa !== null) {
                    const x = padding + i * xScale;
                    ctx.fillStyle = 'rgba(218, 93, 93, 0.15)';
                    ctx.fillRect(x - xScale/2, padding, xScale * 2, height - 2 * padding);
                }
            }
            
            // LAYER 2: Draw collapse segments (background, muted)
            ctx.globalAlpha = 0.3;
            for (let i = 1; i < series.length; i++) {
                if (series[i].admissible) continue;
                
                const x0 = padding + (i - 1) * xScale;
                const y0 = height - padding - (series[i - 1].x - minX) * yScale;
                const x1 = padding + i * xScale;
                const y1 = height - padding - (series[i].x - minX) * yScale;
                
                ctx.strokeStyle = '#da5d5d';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0;
            
            // LAYER 3: Draw admissible segments (foreground, high contrast)
            for (let i = 1; i < series.length; i++) {
                if (!series[i].admissible) continue;
                
                const x0 = padding + (i - 1) * xScale;
                const y0 = height - padding - (series[i - 1].x - minX) * yScale;
                const x1 = padding + i * xScale;
                const y1 = height - padding - (series[i].x - minX) * yScale;
                
                ctx.strokeStyle = '#5ff5e3';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
            }
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('0', padding - 5, height - padding + 15);
            ctx.textAlign = 'right';
            ctx.fillText(series.length.toString(), width - padding, height - padding + 15);
            ctx.textAlign = 'center';
            ctx.fillText('n (step)', width / 2, height - 15);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('x', 0, 0);
            ctx.restore();
            
            ctx.fillStyle = '#5ff5e3';
            ctx.fillRect(width - 150, 20, 20, 3);
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Admissible', width - 125, 25);
            
            ctx.fillStyle = '#da5d5d';
            ctx.fillRect(width - 150, 40, 20, 3);
            ctx.fillStyle = '#8aa4bd';
            ctx.fillText('Collapse (XII)', width - 125, 45);
            
            const admissible = series.filter(s => s.admissible).length;
            const rejected = series.length - admissible;
            const survivalRatio = (admissible / series.length * 100).toFixed(1);
            
            document.getElementById('traj-admissible').textContent = admissible;
            document.getElementById('traj-rejected').textContent = rejected;
            document.getElementById('traj-survival').textContent = survivalRatio + '%';
        }

        function drawKappaDiagnostic(series) {
            const canvas = document.getElementById('kappa-diagnostic-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!series || series.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const kappaValues = series.filter(s => s.kappa !== null).map(s => s.kappa);
            if (kappaValues.length === 0) return;
            
            const maxKappa = Math.max(...kappaValues, currentLambda * 1.2);
            const xScale = (width - 2 * padding) / series.length;
            const yScale = (height - 2 * padding) / maxKappa;
            
            const lambdaY = height - padding - currentLambda * yScale;
            ctx.fillStyle = 'rgba(77, 212, 232, 0.1)';
            ctx.fillRect(padding, lambdaY, width - 2 * padding, height - padding - lambdaY);
            
            ctx.fillStyle = 'rgba(77, 212, 232, 0.6)';
            for (let i = 0; i < series.length; i++) {
                if (series[i].kappa === null) continue;
                
                const x = padding + i * xScale;
                const barHeight = series[i].kappa * yScale;
                const y = height - padding - barHeight;
                
                if (series[i].admissible) {
                    ctx.fillStyle = 'rgba(77, 212, 232, 0.6)';
                } else {
                    ctx.fillStyle = 'rgba(218, 93, 93, 0.8)';
                }
                
                ctx.fillRect(x, y, Math.max(2, xScale - 1), barHeight);
            }
            
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, lambdaY);
            ctx.lineTo(width - padding, lambdaY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('n (step)', width / 2, height - 15);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Œ∫', 0, 0);
            ctx.restore();
            
            ctx.fillStyle = '#ffc107';
            ctx.textAlign = 'right';
            ctx.font = '12px sans-serif';
            ctx.fillText('Œõ = ' + currentLambda.toFixed(4), width - padding - 5, lambdaY - 5);
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Admissible Region (Œ∫ ‚â§ Œõ)', padding + 5, lambdaY + 15);
        }

        function drawAdmissibilityBarcode(series) {
            const container = document.getElementById('barcode-display');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (!series || series.length === 0) return;
            
            const width = container.offsetWidth;
            const gap = 1;
            const barWidth = Math.max(1, (width / series.length) - gap);
            
            series.forEach((step, idx) => {
                const bar = document.createElement('div');
                bar.style.width = barWidth + 'px';
                bar.style.height = '6px';
                bar.style.display = 'inline-block';
                bar.style.marginRight = gap + 'px';
                bar.style.backgroundColor = step.admissible ? '#4dd4e8' : '#da5d5d';
                container.appendChild(bar);
            });
        }

        function drawEvolutionPlot(series) {
            const canvas = document.getElementById('evolution-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!series || series.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const xValues = series.map(s => s.x);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            const rangeX = maxX - minX;
            
            const xScale = (width - 2 * padding) / series.length;
            const yScale = (height - 2 * padding) / rangeX;
            
            ctx.strokeStyle = '#4dd4e8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < series.length; i++) {
                const x = padding + i * xScale;
                const y = height - padding - (series[i].x - minX) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#8a5dda';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            
            for (let i = 0; i < series.length; i++) {
                const x = padding + i * xScale;
                const y = height - padding - (series[i].sobtra - minX) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('0', padding - 5, height - padding + 15);
            ctx.textAlign = 'right';
            ctx.fillText(series.length.toString(), width - padding, height - padding + 15);
            ctx.textAlign = 'left';
            ctx.fillText(minX.toFixed(3), 5, height - padding + 5);
            ctx.fillText(maxX.toFixed(3), 5, padding);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('x', 0, 0);
            ctx.restore();
            
            ctx.textAlign = 'center';
            ctx.fillText('n (step)', width / 2, height - 15);
            
            ctx.fillStyle = '#4dd4e8';
            ctx.fillRect(width - 150, 20, 15, 3);
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('x(n)', width - 130, 25);
            
            ctx.fillStyle = '#8a5dda';
            ctx.fillRect(width - 150, 40, 15, 3);
            ctx.fillStyle = '#8aa4bd';
            ctx.fillText('sobtra(n)', width - 130, 45);
        }

        function drawCurvaturePlot(series) {
            const canvas = document.getElementById('curvature-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!series || series.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const kappaValues = series.filter(s => s.kappa !== null).map(s => s.kappa);
            if (kappaValues.length === 0) return;
            
            const maxKappa = Math.max(...kappaValues);
            const xScale = (width - 2 * padding) / series.length;
            const yScale = (height - 2 * padding) / maxKappa;
            
            ctx.fillStyle = 'rgba(77, 212, 232, 0.3)';
            for (let i = 0; i < series.length; i++) {
                if (series[i].kappa === null) continue;
                
                const x = padding + i * xScale;
                const barHeight = series[i].kappa * yScale;
                const y = height - padding - barHeight;
                
                if (series[i].admissible) {
                    ctx.fillStyle = 'rgba(77, 212, 232, 0.6)';
                } else {
                    ctx.fillStyle = 'rgba(218, 93, 93, 0.6)';
                }
                
                ctx.fillRect(x, y, Math.max(2, xScale - 1), barHeight);
            }
            
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            const lambdaY = height - padding - currentLambda * yScale;
            ctx.beginPath();
            ctx.moveTo(padding, lambdaY);
            ctx.lineTo(width - padding, lambdaY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('n (step)', width / 2, height - 15);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Œ∫', 0, 0);
            ctx.restore();
            
            ctx.fillStyle = '#ffc107';
            ctx.textAlign = 'right';
            ctx.fillText('Œõ = ' + currentLambda.toFixed(4), width - padding - 5, lambdaY - 5);
        }

        function buildTransitionGraph(series, B) {
            const minX = Math.min(...series.map(s => s.x));
            const maxX = Math.max(...series.map(s => s.x));
            const binWidth = (maxX - minX) / B;
            
            function getBin(x) {
                let bin = Math.floor((x - minX) / binWidth);
                if (bin >= B) bin = B - 1;
                if (bin < 0) bin = 0;
                return bin;
            }
            
            const nodes = new Map();
            const edges = new Map();
            
            for (let i = 0; i < series.length; i++) {
                const bin = getBin(series[i].x);
                const nodeId = bin.toString();
                
                if (!nodes.has(nodeId)) {
                    nodes.set(nodeId, {
                        bin: bin,
                        count: 0,
                        admissible: 0,
                        inadmissible: 0,
                        operators: { 'Œ¶': 0, 'Œ®': 0, 'œÑ': 0, 'XII': 0 }
                    });
                }
                
                const node = nodes.get(nodeId);
                node.count++;
                if (series[i].admissible) node.admissible++;
                else node.inadmissible++;
                node.operators[series[i].operator]++;
                
                if (i > 0) {
                    const prevBin = getBin(series[i - 1].x);
                    const edgeId = `${prevBin}->${bin}`;
                    
                    if (!edges.has(edgeId)) {
                        edges.set(edgeId, {
                            from: prevBin,
                            to: bin,
                            count: 0,
                            admissible: 0,
                            inadmissible: 0
                        });
                    }
                    
                    const edge = edges.get(edgeId);
                    edge.count++;
                    if (series[i].admissible) edge.admissible++;
                    else edge.inadmissible++;
                }
            }
            
            return { nodes, edges, B, minX, maxX, binWidth };
        }

        function extractPaths(series, Lmax) {
            const paths = [];
            
            for (let start = 0; start < series.length; start++) {
                for (let len = 2; len <= Math.min(Lmax, series.length - start); len++) {
                    const end = start + len;
                    const pathSegment = series.slice(start, end);
                    
                    const allAdmissible = pathSegment.every(s => s.admissible);
                    if (!allAdmissible) continue;
                    
                    const nodes = pathSegment.map(s => s.n);
                    const ops = pathSegment.map(s => s.operator);
                    const kappaMax = Math.max(...pathSegment.filter(s => s.kappa !== null).map(s => s.kappa));
                    
                    paths.push({
                        start: start,
                        end: end - 1,
                        length: len,
                        nodes: nodes,
                        operators: ops,
                        kappaMax: kappaMax
                    });
                }
            }
            
            return paths.sort((a, b) => b.length - a.length);
        }

        function drawTransitionGraph(graph, paths) {
            const canvas = document.getElementById('transition-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            
            ctx.clearRect(0, 0, width, height);
            
            if (graph.nodes.size === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No graph data available', width / 2, height / 2);
                return;
            }
            
            const nodeArray = Array.from(graph.nodes.entries());
            const maxCount = Math.max(...nodeArray.map(([_, n]) => n.count));
            
            const nodePositions = new Map();
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;
            
            nodeArray.forEach(([nodeId, node]) => {
                const x = padding + (node.bin / (graph.B - 1)) * plotWidth;
                const y = padding + plotHeight / 2 + (Math.random() - 0.5) * plotHeight * 0.6;
                nodePositions.set(nodeId, { x, y });
            });
            
            graph.edges.forEach((edge) => {
                const fromPos = nodePositions.get(edge.from.toString());
                const toPos = nodePositions.get(edge.to.toString());
                if (!fromPos || !toPos) return;
                
                const isAdmissible = edge.admissible > edge.inadmissible;
                const edgeOpacity = isAdmissible ? 0.8 : 0.2;
                ctx.strokeStyle = isAdmissible 
                    ? `rgba(77, 212, 232, ${edgeOpacity})` 
                    : `rgba(218, 93, 93, ${edgeOpacity})`;
                ctx.lineWidth = Math.max(1, Math.min(5, edge.count / 2));
                ctx.beginPath();
                ctx.moveTo(fromPos.x, fromPos.y);
                ctx.lineTo(toPos.x, toPos.y);
                ctx.stroke();
            });
            
            if (selectedPath) {
                ctx.strokeStyle = '#5ff5e3';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i < selectedPath.nodes.length - 1; i++) {
                    const currStep = runLog.series[selectedPath.nodes[i]];
                    const nextStep = runLog.series[selectedPath.nodes[i + 1]];
                    
                    const currBin = Math.floor((currStep.x - graph.minX) / graph.binWidth);
                    const nextBin = Math.floor((nextStep.x - graph.minX) / graph.binWidth);
                    
                    const fromPos = nodePositions.get(currBin.toString());
                    const toPos = nodePositions.get(nextBin.toString());
                    
                    if (fromPos && toPos) {
                        if (i === 0) ctx.moveTo(fromPos.x, fromPos.y);
                        ctx.lineTo(toPos.x, toPos.y);
                    }
                }
                ctx.stroke();
            }
            
            nodeArray.forEach(([nodeId, node]) => {
                const pos = nodePositions.get(nodeId);
                if (!pos) return;
                
                const isInPath = selectedPath && selectedPath.nodes.some(n => {
                    const step = runLog.series[n];
                    const bin = Math.floor((step.x - graph.minX) / graph.binWidth);
                    return bin.toString() === nodeId;
                });
                
                const admissibleRatio = node.admissible / Math.max(1, node.count);
                const radius = isInPath ? 14 : (4 + 3 * admissibleRatio);
                
                ctx.fillStyle = isInPath ? '#5ff5e3' : '#4dd4e8';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#1a2840';
                ctx.lineWidth = isInPath ? 3 : 2;
                ctx.stroke();
            });
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(graph.minX.toFixed(3), padding, height - padding + 15);
            ctx.textAlign = 'right';
            ctx.fillText(graph.maxX.toFixed(3), width - padding, height - padding + 15);
            ctx.textAlign = 'center';
            ctx.fillText('x (binned)', width / 2, height - padding + 30);
        }

        function updateVisualPerception() {
            if (!runLog || !runLog.series) return;
            
            document.getElementById('viz-kappa-vs-n').style.display = 'block';
            document.getElementById('viz-admissibility-barcode').style.display = 'block';
            document.getElementById('viz-trajectory-admissibility').style.display = 'block';
            document.getElementById('viz-residue-sobtra').style.display = 'block';
            document.getElementById('viz-phase-lambda-delta').style.display = 'block';
            document.getElementById('viz-kappa-histogram').style.display = 'block';
            document.getElementById('viz-survival-stripe').style.display = 'block';
            document.getElementById('viz-operator-timeline').style.display = 'block';
            document.getElementById('viz-kappa-vs-lambda').style.display = 'block';
            
            drawKappaVsN(runLog.series);
            drawAdmissibilityBarcode(runLog.series);
            drawTrajectoryWithAdmissibility(runLog.series);
            drawResidueSobtraPlot(runLog.series);
            drawPhaseDiagram();
            drawKappaHistogram(runLog.series);
            drawSurvivalStripe(runLog.series);
            drawOperatorTimeline(runLog.series);
            drawKappaDiagnostic(runLog.series);
        }

        function updateGraphs() {
            if (!runLog) return;
            
            drawEvolutionPlot(runLog.series);
            drawCurvaturePlot(runLog.series);
            updateVisualPerception();
            
            document.getElementById('laws-container').style.display = 'block';
            document.getElementById('transition-plot').style.display = 'block';
            document.getElementById('paths-container').style.display = 'block';
            document.getElementById('operators-container').style.display = 'block';
            
            const B = runLog.config.stateBins;
            const graph = buildTransitionGraph(runLog.series, B);
            const paths = extractPaths(runLog.series, runLog.config.maxPathLength);
            
            drawTransitionGraph(graph, paths);
        }

        function updatePaths() {
            if (!runLog) return;
            
            const paths = extractPaths(runLog.series, runLog.config.maxPathLength);
            const pathsList = document.getElementById('paths-list');
            
            if (paths.length === 0) {
                pathsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #8aa4bd;">No œÑ-admissible paths found</div>';
                return;
            }
            
            pathsList.innerHTML = '';
            paths.forEach((path, idx) => {
                const pathDiv = document.createElement('div');
                pathDiv.className = 'path-item';
                if (selectedPath === path) pathDiv.classList.add('selected');
                
                pathDiv.innerHTML = `
                    <div class="path-header">Path ${idx + 1}</div>
                    <div class="path-details">
                        Length: ${path.length} | Steps: ${path.start} ‚Üí ${path.end} | Œ∫_max: ${path.kappaMax.toFixed(6)}
                    </div>
                    <div class="path-ops">Operators: ${path.operators.join(' ‚Üí ')}</div>
                `;
                
                pathDiv.addEventListener('click', () => {
                    selectedPath = path;
                    updatePaths();
                    updateGraphs();
                });
                
                pathsList.appendChild(pathDiv);
            });
        }

        function updateOperatorStats() {
            if (!runLog) return;
            
            const opCounts = { 'Œ¶': 0, 'Œ®': 0, 'œÑ': 0, 'XII': 0 };
            runLog.series.forEach(s => {
                opCounts[s.operator]++;
            });
            
            const statsDiv = document.getElementById('operators-stats');
            statsDiv.innerHTML = '';
            
            Object.entries(opCounts).forEach(([op, count]) => {
                const card = document.createElement('div');
                card.className = 'operator-card';
                card.style.marginBottom = '15px';
                
                const pct = (count / runLog.series.length * 100).toFixed(1);
                
                card.innerHTML = `
                    <div class="operator-card-header">
                        <div class="operator-card-title">Operator ${op}</div>
                        <div class="operator-card-count">${count} (${pct}%)</div>
                    </div>
                `;
                
                statsDiv.appendChild(card);
            });
        }

        function updateOperadicLaws() {
            if (!runLog) return;
            
            const lawsDiv = document.getElementById('laws-content');
            lawsDiv.innerHTML = '';
            
            const statsGrid = document.createElement('div');
            statsGrid.className = 'stats-grid';
            
            const admissible = runLog.series.filter(s => s.admissible).length;
            const total = runLog.series.length;
            const survivalRatio = (admissible / total * 100).toFixed(1);
            
            statsGrid.innerHTML = `
                <div class="stat-box law-box">
                    <div class="stat-label">œÑ-Admissible Steps</div>
                    <div class="stat-value law-value">${admissible} / ${total}</div>
                </div>
                <div class="stat-box law-box">
                    <div class="stat-label">Survival Ratio</div>
                    <div class="stat-value law-value">${survivalRatio}%</div>
                </div>
            `;
            
            lawsDiv.appendChild(statsGrid);
            
            const compositionBox = document.createElement('div');
            compositionBox.className = 'composition-box';
            compositionBox.innerHTML = `
                <div class="composition-title">Operadic Composition Example</div>
                <div class="composition-result">
                    Œ¶ ‚àò Œ® ‚Üí œÑ (if Œ∫ ‚â§ Œõ)<br>
                    œÑ ‚àò œÑ ‚Üí œÑ (collapse-free recursion)<br>
                    œÑ ‚àò XII ‚Üí XII (collapse absorbs)
                </div>
            `;
            lawsDiv.appendChild(compositionBox);
        }

        function computeSurvivalStats(series) {
            const admissible = series.filter(s => s.admissible).length;
            const total = series.length;
            return {
                admissible: admissible,
                total: total,
                survivalRatio: (admissible / total * 100)
            };
        }

        function updateDiagnostics(runLog) {
            const diagnosticsDiv = document.getElementById('diagnostics-content');
            
            if (!runLog) {
                diagnosticsDiv.innerHTML = '<div style="color: #8aa4bd; padding: 20px;">No run data available. Execute a simulation to view diagnostics.</div>';
                return;
            }
            
            const survivalStats = computeSurvivalStats(runLog.series);
            
            diagnosticsDiv.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-box highlight">
                        <div class="stat-label">Total Steps</div>
                        <div class="stat-value">${runLog.series.length}</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="stat-label">œÑ-Admissible</div>
                        <div class="stat-value">${survivalStats.admissible}</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="stat-label">Survival Ratio</div>
                        <div class="stat-value">${survivalStats.survivalRatio.toFixed(1)}%</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="stat-label">Current Œõ</div>
                        <div class="stat-value">${currentLambda.toFixed(4)}</div>
                    </div>
                </div>
                
                <div class="info-box" style="margin-top: 20px;">
                    <strong>Interpretation:</strong> At Œõ = ${currentLambda.toFixed(4)}, 
                    ${survivalStats.survivalRatio.toFixed(1)}% of transitions are œÑ-admissible. 
                    Inadmissible transitions (Œ∫ > Œõ) are labeled as Operator XII (collapse).
                </div>
            `;
        }

        function updateExportStatus() {
            const exportStatus = document.getElementById('export-status');
            
            if (!runLog) {
                exportStatus.innerHTML = 'No run data available. Execute a simulation to enable export.';
                exportStatus.style.background = 'rgba(138, 93, 218, 0.1)';
                exportStatus.style.borderColor = '#8a5dda';
                return;
            }
            
            exportStatus.innerHTML = `
                <strong>Ready to export:</strong><br>
                ‚Ä¢ Schema: ${EXPORT_SCHEMA}<br>
                ‚Ä¢ Seed: ${runLog.seed.input} (uint32: ${runLog.seed.uint32})<br>
                ‚Ä¢ Steps: ${runLog.series.length}<br>
                ‚Ä¢ Current Œõ: ${currentLambda.toFixed(4)}<br>
                ‚Ä¢ Timestamp: ${runLog.timestamp}
            `;
            exportStatus.style.background = 'rgba(77, 212, 232, 0.1)';
            exportStatus.style.borderColor = '#4dd4e8';
        }

        function exportToJSON() {
            if (!runLog) return;
            
            const B = runLog.config.stateBins;
            const graph = buildTransitionGraph(runLog.series, B);
            const paths = extractPaths(runLog.series, runLog.config.maxPathLength);
            
            const opCounts = { 'Œ¶': 0, 'Œ®': 0, 'œÑ': 0, 'XII': 0 };
            runLog.series.forEach(s => opCounts[s.operator]++);
            
            // Translate operators: Unicode internal ‚Üí ASCII JSON
            const unicodeToAscii = { 'Œ¶': 'PHI', 'Œ®': 'PSI', 'œÑ': 'TAU', 'XII': 'XII' };
            const asciiSeries = runLog.series.map(step => ({
                ...step,
                operator: unicodeToAscii[step.operator] || step.operator
            }));
            
            const exportData = {
                version: runLog.version,
                schema: runLog.schema,
                timestamp: runLog.timestamp,
                seed: runLog.seed,
                config: runLog.config,
                series: asciiSeries,
                graph: {
                    nodes: Array.from(graph.nodes.entries()),
                    edges: Array.from(graph.edges.entries()),
                    B: graph.B,
                    minX: graph.minX,
                    maxX: graph.maxX
                },
                paths: paths,
                operatorStats: opCounts,
                survivalStats: computeSurvivalStats(runLog.series)
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `foundations_run_${runLog.seed.uint32}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importFromJSON(jsonString) {
            try {
                const data = JSON.parse(jsonString);
                
                // STRICT CONTRACT VALIDATION
                
                // 1. Schema validation
                if (!data.schema || data.schema !== EXPORT_SCHEMA) {
                    throw new Error(`Schema mismatch. Expected "${EXPORT_SCHEMA}", got "${data.schema || 'missing'}"`);
                }
                
                // 2. Config validation
                if (!data.config) {
                    throw new Error('Missing required field: config');
                }
                
                const requiredConfigFields = ['lambda', 'delta', 'noise', 'steps'];
                for (const field of requiredConfigFields) {
                    if (data.config[field] === undefined) {
                        throw new Error(`Missing required config field: ${field}`);
                    }
                }
                
                // 3. Steps array validation (accept "steps" or "series" for backward compat)
                const stepsArray = data.steps || data.series;
                if (!stepsArray || !Array.isArray(stepsArray)) {
                    throw new Error('Missing required field: steps (array)');
                }
                
                if (stepsArray.length === 0) {
                    throw new Error('Steps array is empty');
                }
                
                // 4. Validate each step has required fields
                const requiredStepFields = ['n', 'x', 'kappa', 'admissible', 'operator'];
                const optionalStepFields = ['sobtra', 'sobra', 'residue'];
                
                stepsArray.forEach((step, idx) => {
                    for (const field of requiredStepFields) {
                        if (step[field] === undefined && field !== 'kappa') {
                            throw new Error(`Step ${idx}: missing required field "${field}"`);
                        }
                    }
                    
                    // sobtra or sobra must exist
                    if (step.sobtra === undefined && step.sobra === undefined) {
                        throw new Error(`Step ${idx}: missing required field "sobtra" (or "sobra")`);
                    }
                    
                    // residue must exist
                    if (step.residue === undefined) {
                        throw new Error(`Step ${idx}: missing required field "residue"`);
                    }
                });
                
                // 5. Build normalized series (ONLY field name translation allowed)
                const series = stepsArray.map(step => ({
                    n: step.n,
                    x: step.x,
                    sobtra: step.sobtra !== undefined ? step.sobtra : step.sobra,
                    residue: step.residue,
                    kappa: step.kappa,
                    admissible: step.admissible,
                    operator: step.operator
                }));
                
                // 6. Operator translation: ASCII JSON ‚Üí Unicode internal (ONLY normalization allowed)
                const operatorMap = { 
                    'PHI': 'Œ¶', 
                    'PSI': 'Œ®', 
                    'TAU': 'œÑ', 
                    'XII': 'XII',
                    // Backward compatibility with Unicode input
                    'Œ¶': 'Œ¶', 
                    'Œ®': 'Œ®', 
                    'œÑ': 'œÑ'
                };
                series.forEach(step => {
                    if (step.operator && operatorMap[step.operator]) {
                        step.operator = operatorMap[step.operator];
                    }
                });
                
                // 7. Seed validation
                const seed = data.seed || data.config.seed;
                if (!seed) {
                    throw new Error('Missing required field: seed');
                }
                
                const seedObj = typeof seed === 'number' 
                    ? { input: seed, uint32: seed }
                    : { input: seed.input || seed, uint32: seed.uint32 || seed };
                
                // 8. Build runLog (EXACT contract)
                runLog = {
                    version: data.version || '1.10.0',
                    schema: data.schema,
                    timestamp: data.timestamp || new Date().toISOString(),
                    seed: seedObj,
                    config: {
                        steps: data.config.steps,
                        lambda: data.config.lambda,
                        delta: data.config.delta,
                        noise: data.config.noise,
                        sobtraThreshold: data.config.sobtraThreshold || data.config.sobra_threshold || 0.001,
                        stateBins: data.config.stateBins || data.config.state_bins || 20,
                        maxPathLength: data.config.maxPathLength || data.config.max_path_length || 10
                    },
                    series: series
                };
                
                // Update UI
                currentLambda = runLog.config.lambda;
                document.getElementById('lambda-slider').value = Math.round(currentLambda * 1000);
                document.getElementById('lambda-display').textContent = currentLambda.toFixed(4);
                
                document.getElementById('steps').value = runLog.config.steps;
                document.getElementById('delta').value = runLog.config.delta;
                document.getElementById('noise').value = runLog.config.noise;
                document.getElementById('sobtra-threshold').value = runLog.config.sobtraThreshold;
                document.getElementById('seed-input').value = seedObj.input;
                document.getElementById('state-bins').value = runLog.config.stateBins;
                document.getElementById('max-path-length').value = runLog.config.maxPathLength;
                
                updateGraphs();
                updatePaths();
                updateOperatorStats();
                updateOperadicLaws();
                updateDiagnostics(runLog);
                updateFilterStatus();
                updateExportStatus();
                updateVisualPerception();
                
                document.getElementById('export-button').disabled = false;
                
                alert('‚úì Import successful! Run loaded from ' + data.timestamp);
            } catch (e) {
                alert('‚úó Import failed:\n\n' + e.message + '\n\nPlease check JSON schema contract.');
                console.error('Import error:', e);
            }
        }

        function updateLambda(value) {
            currentLambda = parseFloat((value / 1000).toFixed(4));
            document.getElementById('lambda-display').textContent = currentLambda.toFixed(4);
            
            if (runLog) {
                computeAdmissibility(runLog.series, currentLambda);
                labelOperators(runLog.series, currentLambda);
                runLog.config.lambda = currentLambda;
                updateGraphs();
                updatePaths();
                updateOperatorStats();
                updateOperadicLaws();
                updateDiagnostics(runLog);
                updateFilterStatus();
                updateVisualPerception();
            }
        }

        function updateFilterStatus() {
            const statusDiv = document.getElementById('filter-status');
            
            if (!runLog) {
                statusDiv.innerHTML = 'No run available. Execute a simulation to enable œÑ-filtering.';
                statusDiv.style.background = 'rgba(138, 93, 218, 0.1)';
                statusDiv.style.borderColor = '#8a5dda';
                return;
            }
            
            const survivalStats = computeSurvivalStats(runLog.series);
            
            statusDiv.innerHTML = `
                <strong>œÑ-Filter Active:</strong> Œõ = ${currentLambda.toFixed(4)}<br>
                ${survivalStats.admissible} of ${survivalStats.total} transitions admissible (${survivalStats.survivalRatio.toFixed(1)}%)
            `;
            statusDiv.style.background = 'rgba(77, 212, 232, 0.1)';
            statusDiv.style.borderColor = '#4dd4e8';
        }

        function executeRun() {
            const statusDiv = document.getElementById('run-status');
            const runButton = document.getElementById('run-button');
            
            runButton.disabled = true;
            document.getElementById('export-button').disabled = true;
            
            statusDiv.textContent = 'Executing...';
            statusDiv.style.color = '#ffc107';
            
            setTimeout(() => {
                try {
                    const seed = document.getElementById('seed-input').value;
                    deterministicMode = document.getElementById('deterministic-toggle').checked;
                    
                    if (deterministicMode) {
                        initRNG(seed);
                    } else {
                        const randomSeed = Math.floor(Math.random() * 4294967296);
                        initRNG(randomSeed);
                    }
                    
                    const config = {
                        steps: parseInt(document.getElementById('steps').value),
                        delta: parseFloat(document.getElementById('delta').value),
                        noise: parseFloat(document.getElementById('noise').value),
                        sobtraThreshold: parseFloat(document.getElementById('sobtra-threshold').value)
                    };
                    
                    const series = generateStateStream(config);
                    computeKappa(series);
                    computeAdmissibility(series, currentLambda);
                    labelOperators(series, currentLambda);
                    runLog = createRunLog(config, series);
                    
                    updateGraphs();
                    updatePaths();
                    updateOperatorStats();
                    updateOperadicLaws();
                    updateDiagnostics(runLog);
                    updateFilterStatus();
                    updateExportStatus();
                    updateVisualPerception();
                    
                    document.getElementById('export-button').disabled = false;
                    runButton.disabled = false;
                    
                    statusDiv.textContent = 'Run complete: ' + series.length + ' steps (seed: ' + seedInput + ')';
                    statusDiv.style.color = '#5ff5e3';
                    
                    console.log('Run complete with seed:', seedInput, 'uint32:', seedUint32);
                } catch (error) {
                    console.error('Execution error:', error);
                    statusDiv.textContent = 'Execution failed: ' + error.message;
                    statusDiv.style.color = '#da5d5d';
                    runButton.disabled = false;
                    document.getElementById('export-button').disabled = true;
                }
            }, 100);
        }

        function addRunToQueue(runData) {
            const runId = `run_${runQueue.length + 1}`;
            runQueue.push({
                id: runId,
                data: runData
            });
            
            updateQueueDisplay();
            updateComparisonResults();
        }

        function updateQueueDisplay() {
            const queueDiv = document.getElementById('run-queue');
            const countSpan = document.getElementById('queue-count');
            
            countSpan.textContent = runQueue.length;
            
            if (runQueue.length === 0) {
                queueDiv.innerHTML = '<div style="padding: 30px; text-align: center; color: #8aa4bd;">No runs loaded. Import JSON runs to begin comparison.</div>';
                document.getElementById('export-comparison-button').disabled = true;
                document.getElementById('comparison-results').style.display = 'none';
                return;
            }
            
            queueDiv.innerHTML = '';
            runQueue.forEach((run, idx) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'run-queue-item';
                
                const removeBtn = `<button class="run-queue-remove" onclick="removeRunFromQueue(${idx})">Remove</button>`;
                
                itemDiv.innerHTML = `
                    <div class="run-queue-header">
                        <div class="run-queue-id">${run.id}</div>
                        <div>
                            <span class="run-queue-timestamp">${new Date(run.data.timestamp).toLocaleString()}</span>
                            ${removeBtn}
                        </div>
                    </div>
                    <div class="run-queue-params">
                        Seed: ${run.data.seed.uint32} | Steps: ${run.data.config.steps} | Œ¥: ${run.data.config.delta} | Œµ: ${run.data.config.noise} | Œõ: ${run.data.config.lambda.toFixed(4)}
                    </div>
                `;
                
                queueDiv.appendChild(itemDiv);
            });
            
            if (runQueue.length >= 2) {
                document.getElementById('export-comparison-button').disabled = false;
                document.getElementById('comparison-results').style.display = 'block';
            }
        }

        function removeRunFromQueue(idx) {
            runQueue.splice(idx, 1);
            updateQueueDisplay();
            updateComparisonResults();
        }

        function clearQueue() {
            if (runQueue.length === 0) return;
            if (confirm('Clear all runs from queue?')) {
                runQueue = [];
                updateQueueDisplay();
                updateComparisonResults();
            }
        }

        function alignRuns() {
            if (runQueue.length < 2) return null;
            
            const allBins = runQueue.map(r => r.data.config.stateBins);
            const commonBins = Math.min(...allBins);
            
            const allLengths = runQueue.map(r => r.data.config.maxPathLength);
            const maxPathLength = Math.max(...allLengths);
            
            return {
                runs: runQueue.length,
                commonBins: commonBins,
                maxPathLength: maxPathLength,
                operatorAlphabet: ['Œ¶', 'Œ®', 'œÑ', 'XII']
            };
        }

        function computeSurvivalStability() {
            if (runQueue.length < 2) return null;
            
            const survivalRatios = runQueue.map(r => {
                const stats = computeSurvivalStats(r.data.series);
                return stats.survivalRatio / 100;
            });
            
            const mean = survivalRatios.reduce((a, b) => a + b, 0) / survivalRatios.length;
            const variance = survivalRatios.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / survivalRatios.length;
            const stdDev = Math.sqrt(variance);
            
            let verdict = 'Stable';
            if (stdDev < 0.05) verdict = 'Invariant';
            else if (stdDev > 0.15) verdict = 'Fragile';
            
            return {
                ratios: survivalRatios,
                mean: mean,
                variance: variance,
                stdDev: stdDev,
                verdict: verdict
            };
        }

        function computePathPersistence() {
            if (runQueue.length < 2) return null;
            
            const allPaths = runQueue.map(r => {
                const paths = extractPaths(r.data.series, r.data.config.maxPathLength);
                return paths.map(p => p.operators.join('->'));
            });
            
            const pathCounts = new Map();
            allPaths.forEach(runPaths => {
                const unique = new Set(runPaths);
                unique.forEach(path => {
                    pathCounts.set(path, (pathCounts.get(path) || 0) + 1);
                });
            });
            
            const pathsInAll = [];
            const pathsInMost = [];
            
            pathCounts.forEach((count, path) => {
                if (count === runQueue.length) pathsInAll.push(path);
                else if (count >= runQueue.length / 2) pathsInMost.push(path);
            });
            
            return {
                pathsInAll: pathsInAll,
                pathsInMost: pathsInMost,
                allPathCounts: pathCounts
            };
        }

        function computeOperatorDrift() {
            if (runQueue.length < 2) return null;
            
            const opFreqs = runQueue.map(r => {
                const opCounts = { 'Œ¶': 0, 'Œ®': 0, 'œÑ': 0, 'XII': 0 };
                r.data.series.forEach(s => opCounts[s.operator]++);
                const total = r.data.series.length;
                return {
                    'Œ¶': opCounts['Œ¶'] / total,
                    'Œ®': opCounts['Œ®'] / total,
                    'œÑ': opCounts['œÑ'] / total,
                    'XII': opCounts['XII'] / total
                };
            });
            
            return opFreqs;
        }

        function computeCollapseOnset() {
            if (runQueue.length < 2) return null;
            
            const collapseData = runQueue.map(r => {
                const firstXII = r.data.series.findIndex(s => s.operator === 'XII');
                return {
                    hasCollapse: firstXII !== -1,
                    firstStep: firstXII !== -1 ? firstXII : null
                };
            });
            
            const runsWithCollapse = collapseData.filter(d => d.hasCollapse).length;
            const firstSteps = collapseData.filter(d => d.hasCollapse).map(d => d.firstStep);
            const meanFirstStep = firstSteps.length > 0 ? firstSteps.reduce((a, b) => a + b, 0) / firstSteps.length : null;
            
            const sensitivity = runsWithCollapse / runQueue.length;
            
            return {
                runsWithCollapse: runsWithCollapse,
                meanFirstStep: meanFirstStep,
                sensitivity: sensitivity
            };
        }

        function computeStructuralVerdicts(survivalStability, pathPersistence, collapseOnset) {
            const verdicts = [];
            
            verdicts.push({
                metric: 'Survival Ratio Stability',
                classification: survivalStability.verdict,
                justification: `œÉ = ${survivalStability.stdDev.toFixed(4)}`
            });
            
            if (pathPersistence.pathsInAll.length > 0) {
                verdicts.push({
                    metric: 'Path Persistence',
                    classification: 'Invariant',
                    justification: `${pathPersistence.pathsInAll.length} paths in all runs`
                });
            } else {
                verdicts.push({
                    metric: 'Path Persistence',
                    classification: 'Seed-Dependent',
                    justification: 'No paths common to all runs'
                });
            }
            
            if (collapseOnset.sensitivity === 0) {
                verdicts.push({
                    metric: 'Collapse Presence',
                    classification: 'Stable',
                    justification: 'No collapse in any run'
                });
            } else if (collapseOnset.sensitivity === 1) {
                verdicts.push({
                    metric: 'Collapse Presence',
                    classification: 'Collapse-Dominated',
                    justification: 'Collapse in all runs'
                });
            } else {
                verdicts.push({
                    metric: 'Collapse Presence',
                    classification: 'œÑ-Critical',
                    justification: `Collapse in ${(collapseOnset.sensitivity * 100).toFixed(0)}% of runs`
                });
            }
            
            return verdicts;
        }

        function drawSurvivalComparison(survivalStability) {
            const canvas = document.getElementById('survival-comparison-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!survivalStability || survivalStability.ratios.length === 0) {
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', width / 2, height / 2);
                return;
            }
            
            const barWidth = (width - 2 * padding) / survivalStability.ratios.length;
            
            survivalStability.ratios.forEach((ratio, idx) => {
                const x = padding + idx * barWidth;
                const barHeight = ratio * (height - 2 * padding);
                const y = height - padding - barHeight;
                
                ctx.fillStyle = '#4dd4e8';
                ctx.fillRect(x + 5, y, barWidth - 10, barHeight);
                
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`Run ${idx + 1}`, x + barWidth / 2, height - padding + 15);
            });
            
            const meanY = height - padding - survivalStability.mean * (height - 2 * padding);
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, meanY);
            ctx.lineTo(width - padding, meanY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ffc107';
            ctx.textAlign = 'left';
            ctx.fillText(`Mean: ${(survivalStability.mean * 100).toFixed(1)}%`, padding + 5, meanY - 5);
        }

        function drawOperatorDrift(opFreqs) {
            const canvas = document.getElementById('operator-drift-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (!opFreqs || opFreqs.length === 0) return;
            
            const operators = ['Œ¶', 'Œ®', 'œÑ', 'XII'];
            const colors = {
                'Œ¶': '#4dd4e8',
                'Œ®': '#8a5dda',
                'œÑ': '#5ff5e3',
                'XII': '#da5d5d'
            };
            
            const xScale = (width - 2 * padding) / (opFreqs.length - 1);
            const yScale = height - 2 * padding;
            
            operators.forEach(op => {
                ctx.strokeStyle = colors[op];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                opFreqs.forEach((freq, idx) => {
                    const x = padding + idx * xScale;
                    const y = height - padding - freq[op] * yScale;
                    if (idx === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            ctx.fillStyle = '#8aa4bd';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Run Index', width / 2, height - 15);
            
            let legendY = 20;
            operators.forEach(op => {
                ctx.fillStyle = colors[op];
                ctx.fillRect(width - 80, legendY, 15, 3);
                ctx.fillStyle = '#8aa4bd';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(op, width - 60, legendY + 5);
                legendY += 20;
            });
        }

        function drawTauEnvelope() {
            const canvas = document.getElementById('tau-envelope-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            if (runQueue.length === 0) return;
            
            const maxSteps = Math.max(...runQueue.map(r => r.data.series.length));
            
            const minKappa = new Array(maxSteps).fill(Infinity);
            const maxKappa = new Array(maxSteps).fill(-Infinity);
            
            runQueue.forEach(run => {
                run.data.series.forEach((step, idx) => {
                    if (step.kappa !== null) {
                        minKappa[idx] = Math.min(minKappa[idx], step.kappa);
                        maxKappa[idx] = Math.max(maxKappa[idx], step.kappa);
                    }
                });
            });
            
            const globalMax = Math.max(...maxKappa.filter(k => k !== -Infinity));
            const xScale = (width - 2 * padding) / maxSteps;
            const yScale = (height - 2 * padding) / globalMax;
            
            ctx.fillStyle = 'rgba(77, 212, 232, 0.2)';
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            for (let i = 0; i < maxSteps; i++) {
                const x = padding + i * xScale;
                const y = height - padding - minKappa[i] * yScale;
                ctx.lineTo(x, y);
            }
            for (let i = maxSteps - 1; i >= 0; i--) {
                const x = padding + i * xScale;
                const y = height - padding - maxKappa[i] * yScale;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#4dd4e8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < maxSteps; i++) {
                const x = padding + i * xScale;
                const y = height - padding - (minKappa[i] + maxKappa[i]) / 2 * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
        }

        function drawOverlayGraph() {
            const canvas = document.getElementById('overlay-graph-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            
            ctx.clearRect(0, 0, width, height);
            
            if (runQueue.length === 0) return;
            
            const colors = [
                'rgba(77, 212, 232, 0.3)',
                'rgba(138, 93, 218, 0.3)',
                'rgba(95, 245, 227, 0.3)',
                'rgba(255, 193, 7, 0.3)',
                'rgba(255, 152, 0, 0.3)'
            ];
            
            runQueue.forEach((run, runIdx) => {
                const B = run.data.config.stateBins;
                const graph = buildTransitionGraph(run.data.series, B);
                
                const nodeArray = Array.from(graph.nodes.entries());
                const nodePositions = new Map();
                const plotWidth = width - 2 * padding;
                const plotHeight = height - 2 * padding;
                
                nodeArray.forEach(([nodeId, node]) => {
                    const x = padding + (node.bin / (graph.B - 1)) * plotWidth;
                    const y = padding + plotHeight / 2 + (Math.random() - 0.5) * plotHeight * 0.6;
                    nodePositions.set(nodeId, { x, y });
                });
                
                const color = colors[runIdx % colors.length];
                
                graph.edges.forEach((edge) => {
                    const fromPos = nodePositions.get(edge.from.toString());
                    const toPos = nodePositions.get(edge.to.toString());
                    if (!fromPos || !toPos) return;
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(fromPos.x, fromPos.y);
                    ctx.lineTo(toPos.x, toPos.y);
                    ctx.stroke();
                });
                
                nodeArray.forEach(([nodeId, node]) => {
                    const pos = nodePositions.get(nodeId);
                    if (!pos) return;
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                });
            });
            
            ctx.strokeStyle = '#2a4a6a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
        }

        function updateComparisonResults() {
            if (runQueue.length < 2) {
                document.getElementById('comparison-results').style.display = 'none';
                return;
            }
            
            document.getElementById('comparison-results').style.display = 'block';
            
            const alignment = alignRuns();
            document.getElementById('comp-aligned-runs').textContent = alignment.runs;
            document.getElementById('comp-common-bins').textContent = alignment.commonBins;
            document.getElementById('comp-max-path-length').textContent = alignment.maxPathLength;
            
            const survivalStability = computeSurvivalStability();
            document.getElementById('comp-mean-survival').textContent = (survivalStability.mean * 100).toFixed(1) + '%';
            document.getElementById('comp-survival-variance').textContent = survivalStability.variance.toFixed(6);
            document.getElementById('comp-survival-verdict').textContent = survivalStability.verdict;
            drawSurvivalComparison(survivalStability);
            
            const pathPersistence = computePathPersistence();
            const pathTable = document.getElementById('path-intersection-table');
            pathTable.innerHTML = `
                <div style="padding: 15px;">
                    <strong>Paths in All Runs:</strong> ${pathPersistence.pathsInAll.length}<br>
                    <strong>Paths in ‚â•50% of Runs:</strong> ${pathPersistence.pathsInMost.length}
                </div>
            `;
            
            const opDrift = computeOperatorDrift();
            drawOperatorDrift(opDrift);
            
            const collapseOnset = computeCollapseOnset();
            document.getElementById('comp-collapse-runs').textContent = collapseOnset.runsWithCollapse + ' / ' + runQueue.length;
            document.getElementById('comp-collapse-onset').textContent = collapseOnset.meanFirstStep !== null ? collapseOnset.meanFirstStep.toFixed(1) : 'N/A';
            document.getElementById('comp-collapse-sensitivity').textContent = (collapseOnset.sensitivity * 100).toFixed(0) + '%';
            
            const verdicts = computeStructuralVerdicts(survivalStability, pathPersistence, collapseOnset);
            const verdictsTableBody = document.getElementById('verdicts-table-body');
            verdictsTableBody.innerHTML = '';
            verdicts.forEach(verdict => {
                const row = document.createElement('tr');
                
                let badgeClass = 'verdict-stable';
                if (verdict.classification === 'Invariant') badgeClass = 'verdict-invariant';
                else if (verdict.classification === 'Fragile') badgeClass = 'verdict-fragile';
                else if (verdict.classification === 'Seed-Dependent') badgeClass = 'verdict-seed-dependent';
                else if (verdict.classification === 'œÑ-Critical') badgeClass = 'verdict-tau-critical';
                else if (verdict.classification === 'Collapse-Dominated') badgeClass = 'verdict-collapse-dominated';
                
                row.innerHTML = `
                    <td>${verdict.metric}</td>
                    <td><span class="verdict-badge ${badgeClass}">${verdict.classification}</span></td>
                    <td>${verdict.justification}</td>
                `;
                verdictsTableBody.appendChild(row);
            });
            
            drawTauEnvelope();
            drawOverlayGraph();
            
            comparisonResults = {
                alignment: alignment,
                survivalStability: survivalStability,
                pathPersistence: pathPersistence,
                operatorDrift: opDrift,
                collapseOnset: collapseOnset,
                verdicts: verdicts
            };
        }

        function exportComparison() {
            if (!comparisonResults || runQueue.length < 2) return;
            
            const exportData = {
                version: CHAMBER_VERSION,
                schema: COMPARISON_SCHEMA,
                timestamp: new Date().toISOString(),
                runIds: runQueue.map(r => ({
                    id: r.id,
                    seed: r.data.seed.uint32,
                    timestamp: r.data.timestamp
                })),
                alignment: comparisonResults.alignment,
                survivalStability: comparisonResults.survivalStability,
                pathPersistence: {
                    pathsInAll: comparisonResults.pathPersistence.pathsInAll,
                    pathsInMost: comparisonResults.pathPersistence.pathsInMost
                },
                collapseOnset: comparisonResults.collapseOnset,
                verdicts: comparisonResults.verdicts
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `foundations_comparison_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function toggleGuide() {
            const content = document.getElementById('guide-content');
            const toggle = document.getElementById('guide-toggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log(`UNNS Foundations Chamber v${CHAMBER_VERSION}`);
            console.log(`Build: ${CHAMBER_BUILD}`);
            
            initTabSwitching();
            
            document.getElementById('run-button').addEventListener('click', executeRun);
            
            const lambdaSlider = document.getElementById('lambda-slider');
            lambdaSlider.addEventListener('input', (e) => {
                updateLambda(e.target.value);
            });
            
            document.getElementById('export-button').addEventListener('click', exportToJSON);
            
            document.getElementById('import-button').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });
            
            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        importFromJSON(event.target.result);
                    };
                    reader.readAsText(file);
                }
            });
            
            document.getElementById('update-graph-button').addEventListener('click', () => {
                if (runLog) {
                    runLog.config.stateBins = parseInt(document.getElementById('state-bins').value);
                    runLog.config.maxPathLength = parseInt(document.getElementById('max-path-length').value);
                    updateGraphs();
                    updatePaths();
                }
            });
            
            document.getElementById('compare-import-button').addEventListener('click', () => {
                document.getElementById('compare-file-input').click();
            });
            
            document.getElementById('compare-file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            
                            // STRICT CONTRACT VALIDATION (same as main import)
                            if (!data.schema || data.schema !== EXPORT_SCHEMA) {
                                throw new Error(`Schema mismatch. Expected "${EXPORT_SCHEMA}", got "${data.schema || 'missing'}"`);
                            }
                            
                            if (!data.config) {
                                throw new Error('Missing required field: config');
                            }
                            
                            const requiredConfigFields = ['lambda', 'delta', 'noise'];
                            for (const field of requiredConfigFields) {
                                if (data.config[field] === undefined) {
                                    throw new Error(`Missing required config field: ${field}`);
                                }
                            }
                            
                            const stepsArray = data.steps || data.series;
                            if (!stepsArray || !Array.isArray(stepsArray)) {
                                throw new Error('Missing required field: steps (array)');
                            }
                            
                            if (stepsArray.length === 0) {
                                throw new Error('Steps array is empty');
                            }
                            
                            const series = stepsArray.map(step => ({
                                n: step.n,
                                x: step.x,
                                sobtra: step.sobtra !== undefined ? step.sobtra : step.sobra,
                                residue: step.residue,
                                kappa: step.kappa,
                                admissible: step.admissible,
                                operator: step.operator
                            }));
                            
                            // ASCII ‚Üí Unicode operator translation
                            const operatorMap = { 
                                'PHI': 'Œ¶', 
                                'PSI': 'Œ®', 
                                'TAU': 'œÑ', 
                                'XII': 'XII',
                                'Œ¶': 'Œ¶', 
                                'Œ®': 'Œ®', 
                                'œÑ': 'œÑ'
                            };
                            series.forEach(step => {
                                if (step.operator && operatorMap[step.operator]) {
                                    step.operator = operatorMap[step.operator];
                                }
                            });
                            
                            const seed = data.seed || data.config.seed;
                            if (!seed) {
                                throw new Error('Missing required field: seed');
                            }
                            
                            const seedObj = typeof seed === 'number' 
                                ? { input: seed, uint32: seed }
                                : { input: seed.input || seed, uint32: seed.uint32 || seed };
                            
                            const normalizedData = {
                                version: data.version || '1.10.0',
                                schema: data.schema,
                                timestamp: data.timestamp || new Date().toISOString(),
                                seed: seedObj,
                                config: {
                                    steps: stepsArray.length,
                                    lambda: data.config.lambda,
                                    delta: data.config.delta,
                                    noise: data.config.noise,
                                    sobtraThreshold: data.config.sobtraThreshold || data.config.sobra_threshold || 0.001,
                                    stateBins: data.config.stateBins || data.config.state_bins || 20,
                                    maxPathLength: data.config.maxPathLength || data.config.max_path_length || 10
                                },
                                series: series
                            };
                            
                            addRunToQueue(normalizedData);
                            alert('‚úì Run added to comparison queue');
                        } catch (e) {
                            alert('‚úó Import failed:\n\n' + e.message + '\n\nPlease check JSON schema contract.');
                            console.error('Compare import error:', e);
                        }
                    };
                    reader.readAsText(file);
                }
            });
            
            document.getElementById('clear-queue-button').addEventListener('click', clearQueue);
            document.getElementById('export-comparison-button').addEventListener('click', exportComparison);
            
            updateLambda(lambdaSlider.value);
            updateDiagnostics(null);
            updateExportStatus();
        });

        window.removeRunFromQueue = removeRunFromQueue;
    </script>
</body>
</html>
