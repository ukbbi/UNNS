<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Regime Lens (Œ∫‚ÄìŒõ)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Consolas', 'Monaco', monospace;
      background: #0a0a0a;
      color: #e0e0e0;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      border-bottom: 2px solid #2a2a2a;
    }
    
    h1 {
      font-size: 2em;
      color: #4a9eff;
      letter-spacing: 2px;
      margin-bottom: 10px;
    }
    
    .subtitle {
      color: #888;
      font-size: 0.9em;
    }
    
    .panel {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .panel-title {
      font-size: 1.2em;
      color: #4a9eff;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #2a2a2a;
    }
    
    /* Upload Zone */
    .upload-zone {
      border: 2px dashed #3a3a3a;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      background: #0a0a0a;
    }
    
    .upload-zone:hover, .upload-zone.dragover {
      border-color: #4a9eff;
      background: #1a1a2a;
    }
    
    .upload-zone input[type="file"] {
      display: none;
    }
    
    .upload-icon {
      font-size: 3em;
      color: #4a9eff;
      margin-bottom: 15px;
    }
    
    .upload-text {
      color: #aaa;
      font-size: 1.1em;
    }
    
    .upload-hint {
      color: #666;
      font-size: 0.9em;
      margin-top: 10px;
    }
    
    /* Controls */
    .controls {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 20px;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .slider-group {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .slider-group label {
      color: #4a9eff;
      font-size: 1.1em;
      min-width: 100px;
    }
    
    input[type="range"] {
      flex: 1;
      height: 6px;
      background: #2a2a2a;
      outline: none;
      border-radius: 3px;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #4a9eff;
      cursor: pointer;
      border-radius: 50%;
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #4a9eff;
      cursor: pointer;
      border-radius: 50%;
      border: none;
    }
    
    .value-display {
      font-family: 'Courier New', monospace;
      color: #4aff4a;
      font-size: 1.1em;
      min-width: 80px;
      text-align: right;
    }
    
    button {
      background: #2a4a7a;
      border: none;
      color: #e0e0e0;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.95em;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #3a5a8a;
    }
    
    button:disabled {
      background: #1a1a1a;
      color: #555;
      cursor: not-allowed;
    }
    
    /* Canvas Container */
    .canvas-container {
      position: relative;
      background: #000;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      margin: 20px 0;
      aspect-ratio: 16 / 9;
    }
    
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    /* Legend */
    .legend {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
      padding: 15px;
      background: #0a0a0a;
      border-radius: 4px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .legend-color {
      width: 30px;
      height: 15px;
      border-radius: 2px;
    }
    
    .legend-label {
      color: #aaa;
      font-size: 0.9em;
    }
    
    /* Metrics */
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    
    .metric {
      background: #0a0a0a;
      padding: 15px;
      border-radius: 4px;
      border: 1px solid #2a2a2a;
    }
    
    .metric-label {
      font-size: 0.85em;
      color: #888;
      margin-bottom: 8px;
    }
    
    .metric-value {
      font-size: 1.3em;
      color: #4a9eff;
      font-family: 'Courier New', monospace;
    }
    
    .metric-value.admissible {
      color: #4aff4a;
    }
    
    .metric-value.collapse {
      color: #ff4a9e;
    }
    
    /* Info Display */
    .info-display {
      background: #0a1a2a;
      padding: 12px;
      border-radius: 4px;
      border-left: 3px solid #4a9eff;
      margin-bottom: 15px;
      font-size: 0.9em;
      color: #aaa;
    }
    
    .info-display strong {
      color: #4a9eff;
    }
    
    /* Error/Warning */
    .error-display {
      background: #2a1a1a;
      border-left: 3px solid #ff4a4a;
      padding: 12px;
      border-radius: 4px;
      color: #ff8888;
      margin-bottom: 15px;
    }
    
    .hidden {
      display: none !important;
    }
    
    /* Tooltip */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: #e0e0e0;
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #4a9eff;
      font-size: 0.85em;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
    }
    
    /* Documentation */
    .doc-section {
      line-height: 1.8;
      color: #aaa;
    }
    
    .doc-section h3 {
      color: #4a9eff;
      font-size: 1.1em;
      margin: 20px 0 10px;
    }
    
    .doc-section ul {
      margin-left: 20px;
    }
    
    .doc-section code {
      background: #0a0a0a;
      padding: 2px 6px;
      border-radius: 3px;
      color: #4aff4a;
      font-family: 'Courier New', monospace;
    }
    
    .doc-box {
      background: #0a1a2a;
      padding: 12px;
      border-radius: 4px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üî¨ REGIME LENS (Œ∫‚ÄìŒõ)</h1>
      <div class="subtitle">œÑ-Filtered Observable Sub-‚àû-Category Visualizer</div>
      <div class="subtitle" style="margin-top: 5px; font-size: 0.8em;">v1.2.0 | Autonomous Module | UNNS Laboratory</div>
    </header>
    
    <!-- Upload Panel -->
    <div class="panel">
      <div class="panel-title">Load UNNS Run Data</div>
      <div class="upload-zone" id="uploadZone">
        <input type="file" id="fileInput" accept=".json">
        <div class="upload-icon">üìÅ</div>
        <div class="upload-text">Click to select or drag & drop JSON file</div>
        <div class="upload-hint">Compatible with UNNS_FOUNDATIONS_RUN/v1 schema</div>
      </div>
      <div id="fileInfo" class="info-display hidden"></div>
      <div id="errorDisplay" class="error-display hidden"></div>
    </div>
    
    <!-- Visualization Panel -->
    <div id="vizPanel" class="panel hidden">
      <div class="panel-title">Œ∫‚Çô vs Step Index (Regime Lens)</div>
      
      <div class="controls">
        <div class="slider-group">
          <label for="lambdaSlider">Œõ Threshold:</label>
          <input type="range" id="lambdaSlider" min="0" max="0.2" step="0.001" value="0.05">
          <span class="value-display" id="lambdaValue">0.050</span>
        </div>
        <button id="resetBtn">Reset View</button>
        <button id="clearBtn">Clear Data</button>
      </div>
      
      <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
      </div>
      
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: #4a9eff;"></div>
          <span class="legend-label">Œ∫‚Çô Curve (Discrete Curvature)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #4aff4a;"></div>
          <span class="legend-label">Œõ Threshold Line</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgba(74, 255, 74, 0.15);"></div>
          <span class="legend-label">œÑ-Admissible Regime (Œ∫‚Çô ‚â§ Œõ)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgba(255, 74, 158, 0.15);"></div>
          <span class="legend-label">Collapse-Selected Regime (Œ∫‚Çô > Œõ)</span>
        </div>
      </div>
    </div>
    
    <!-- Metrics Panel -->
    <div id="metricsPanel" class="panel hidden">
      <div class="panel-title">Regime Metrics</div>
      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Total Steps</div>
          <div class="metric-value" id="metricTotal">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">œÑ-Admissible Ratio</div>
          <div class="metric-value admissible" id="metricAdmissibleRatio">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Collapse Ratio</div>
          <div class="metric-value collapse" id="metricCollapseRatio">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">œÑ-Admissible Count</div>
          <div class="metric-value admissible" id="metricAdmissible">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Collapse-Selected Count</div>
          <div class="metric-value collapse" id="metricCollapse">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Contiguous œÑ-Admissible Segments</div>
          <div class="metric-value" id="metricSegments">‚Äî</div>
        </div>
      </div>
    </div>
    
    <!-- Documentation Panel -->
    <div class="panel">
      <div class="panel-title">üìñ Module Documentation</div>
      <div class="doc-section">
        <h3>Purpose</h3>
        <p>The Regime Lens is a deterministic analytical visualizer that exposes the relationship between discrete curvature <code>Œ∫‚Çô</code> and admissibility threshold <code>Œõ</code> in UNNS recursive dynamics.</p>
        
        <div class="doc-box">
          <strong>Core Classification:</strong>
          <ul style="margin-top: 8px;">
            <li><code>Œ∫‚Çô ‚â§ Œõ</code> ‚Üí <strong style="color: #4aff4a;">œÑ-admissible regime</strong> (stable recursion)</li>
            <li><code>Œ∫‚Çô > Œõ</code> ‚Üí <strong style="color: #ff4a9e;">collapse-selected regime</strong> (Operator XII domain)</li>
          </ul>
        </div>
        
        <h3>Autonomy Guarantees</h3>
        <ul>
          <li>Does not depend on any Chamber</li>
          <li>Does not compute <code>Œ∫‚Çô</code> (only visualizes existing data)</li>
          <li>Does not modify input data</li>
          <li>Does not persist state</li>
          <li>May be run as standalone local file</li>
        </ul>
        
        <h3>Input Format</h3>
        <p>Accepts UNNS run JSON files with schema <code>UNNS_FOUNDATIONS_RUN/v1</code>:</p>
        <div class="doc-box">
<pre style="color: #aaa; font-size: 0.85em; line-height: 1.4;">{
  "schema": "UNNS_FOUNDATIONS_RUN/v1",
  "config": { ... },
  "steps": [
    {
      "n": 0,
      "kappa": 0.0000,
      "admissible": true,
      ...
    },
    ...
  ]
}</pre>
        </div>
        <p>Only <code>steps[].n</code> and <code>steps[].kappa</code> are operationally required.</p>
        
        <h3>Controls</h3>
        <ul>
          <li><strong>Œõ Slider:</strong> Adjust admissibility threshold (live updates)</li>
          <li><strong>Reset View:</strong> Return to initial threshold</li>
          <li><strong>Clear Data:</strong> Remove loaded run and start over</li>
        </ul>
        
        <h3>Behavioral Rules</h3>
        <ul>
          <li><code>Œ∫‚Çô</code> is immutable (no smoothing, no normalization, no recomputation)</li>
          <li><code>Œõ</code> is a pure comparator (the only boundary)</li>
          <li>Classification = <code>Œ∫‚Çô > Œõ</code> (no hidden thresholds)</li>
          <li>Idempotent: Same JSON + same Œõ ‚Üí identical output</li>
        </ul>
        
        <h3>Performance</h3>
        <ul>
          <li>‚â§ 1,000 steps: instant</li>
          <li>‚â§ 10,000 steps: ‚â§ 20 ms</li>
          <li>Œõ updates do not trigger re-render of <code>Œ∫‚Çô</code> path</li>
        </ul>
        
        <h3>Conceptual Alignment</h3>
        <p>In UNNS terms, this module exposes:</p>
        <ul>
          <li><strong>œÑ-filtered sub-structures</strong> (observable regimes)</li>
          <li><strong>Collapse as derived boundary</strong> (Œõ demarcation)</li>
          <li><strong>Observability as parametric lens</strong> (Œõ controls what survives)</li>
        </ul>
        <p style="margin-top: 10px; color: #888; font-style: italic;">This is structural analysis, not interpretive modeling.</p>
        
        <h3>Non-Goals (Explicit)</h3>
        <p>The Regime Lens:</p>
        <ul>
          <li>Does not validate UNNS theory</li>
          <li>Does not judge correctness</li>
          <li>Does not predict behavior</li>
          <li>Does not claim physical meaning</li>
          <li>Does not reinterpret ZFC, logic, or collapse</li>
        </ul>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #2a2a2a;">
          <p style="font-size: 0.85em; color: #666;">
            <strong>Version:</strong> 1.2.0 | 
            <strong>Type:</strong> Autonomous Module | 
            <strong>Dependencies:</strong> None | 
            <strong>License:</strong> UNNS Research Collective
          </p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Tooltip element -->
  <div id="tooltip" class="tooltip hidden"></div>
  
  <script>
    // =====================================
    // REGIME LENS MODULE v1.0.0
    // =====================================
    
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë  REGIME LENS (Œ∫‚ÄìŒõ) v1.2.0                       ‚ïë');
    console.log('‚ïë  œÑ-Filtered Observable Sub-‚àû-Category Visualizer ‚ïë');
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    
    // State
    let runData = null;
    let lambda = 0.05;
    let initialLambda = 0.05; // Data-driven initial value
    let lambdaMin = 0;
    let lambdaMax = 0.2;
    
    // Cached scale functions (for tooltip performance)
    let cachedXScale = null;
    let cachedYScale = null;
    let cachedPadding = null;
    let cachedPlotDimensions = null;
    
    // UI Elements
    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const errorDisplay = document.getElementById('errorDisplay');
    const vizPanel = document.getElementById('vizPanel');
    const metricsPanel = document.getElementById('metricsPanel');
    const mainCanvas = document.getElementById('mainCanvas');
    const lambdaSlider = document.getElementById('lambdaSlider');
    const lambdaValue = document.getElementById('lambdaValue');
    const resetBtn = document.getElementById('resetBtn');
    const clearBtn = document.getElementById('clearBtn');
    const tooltip = document.getElementById('tooltip');
    
    // Canvas setup
    const ctx = mainCanvas.getContext('2d');
    let dpr = window.devicePixelRatio || 1;
    
    function setupCanvas() {
      const rect = mainCanvas.getBoundingClientRect();
      mainCanvas.width = rect.width * dpr;
      mainCanvas.height = rect.height * dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform before scaling
      ctx.scale(dpr, dpr);
    }
    
    setupCanvas();
    window.addEventListener('resize', () => {
      setupCanvas();
      if (runData) render();
    });
    
    // =====================================
    // FILE HANDLING
    // =====================================
    
    uploadZone.addEventListener('click', () => fileInput.click());
    
    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.classList.add('dragover');
    });
    
    uploadZone.addEventListener('dragleave', () => {
      uploadZone.classList.remove('dragover');
    });
    
    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadZone.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) loadFile(file);
    });
    
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) loadFile(file);
    });
    
    function loadFile(file) {
      console.log('üìÇ Loading file:', file.name);
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const json = JSON.parse(e.target.result);
          validateAndLoad(json, file.name);
        } catch (err) {
          showError('Invalid JSON: ' + err.message);
        }
      };
      reader.onerror = () => showError('Failed to read file');
      reader.readAsText(file);
    }
    
    function validateAndLoad(json, filename) {
      errorDisplay.classList.add('hidden');
      
      // Validate required fields
      if (!json.steps || !Array.isArray(json.steps)) {
        showError('Missing or invalid "steps" array');
        return;
      }
      
      if (json.steps.length === 0) {
        showError('Empty run: no steps found');
        return;
      }
      
      // Extract kappa values
      const kappaData = [];
      for (let i = 0; i < json.steps.length; i++) {
        const step = json.steps[i];
        
        if (typeof step.n !== 'number') {
          showError(`Step ${i}: missing or invalid "n" field`);
          return;
        }
        
        if (typeof step.kappa !== 'number') {
          showError(`Step ${i}: missing or invalid "kappa" field`);
          return;
        }
        
        kappaData.push({
          n: step.n,
          kappa: step.kappa
        });
      }
      
      // Store data
      runData = {
        filename: filename,
        schema: json.schema || 'unknown',
        config: json.config || {},
        steps: kappaData,
        diagnostics: json.diagnostics || {}
      };
      
      // Auto-adjust lambda range to data
      const kappaValues = kappaData.map(s => s.kappa);
      const maxKappa = Math.max(...kappaValues);
      lambdaMax = Math.max(0.2, maxKappa * 1.2);
      lambdaSlider.max = lambdaMax.toFixed(3);
      
      // Set initial lambda from data-intrinsic statistics (median Œ∫)
      const sortedKappa = [...kappaValues].sort((a, b) => a - b);
      const medianKappa = sortedKappa[Math.floor(sortedKappa.length / 2)];
      initialLambda = medianKappa;
      lambda = initialLambda;
      lambdaSlider.value = lambda;
      lambdaValue.textContent = lambda.toFixed(3);
      
      // Show file info
      fileInfo.innerHTML = `
        <strong>Loaded:</strong> ${filename} | 
        <strong>Schema:</strong> ${runData.schema} | 
        <strong>Steps:</strong> ${kappaData.length} | 
        <strong>Max Œ∫:</strong> ${maxKappa.toFixed(4)}
      `;
      fileInfo.classList.remove('hidden');
      
      // Show visualization
      vizPanel.classList.remove('hidden');
      metricsPanel.classList.remove('hidden');
      
      console.log('‚úÖ Data loaded successfully');
      console.log('   Steps:', kappaData.length);
      console.log('   Œ∫ range:', [Math.min(...kappaValues), maxKappa]);
      
      render();
    }
    
    function showError(message) {
      errorDisplay.textContent = '‚ùå Error: ' + message;
      errorDisplay.classList.remove('hidden');
      console.error('üö´', message);
    }
    
    // =====================================
    // RENDERING
    // =====================================
    
    function render() {
      if (!runData) return;
      
      const rect = mainCanvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      
      ctx.clearRect(0, 0, w, h);
      
      const padding = { top: 40, right: 40, bottom: 50, left: 60 };
      const plotW = w - padding.left - padding.right;
      const plotH = h - padding.top - padding.bottom;
      
      // Cache for tooltip (performance optimization)
      cachedPadding = padding;
      cachedPlotDimensions = { w: plotW, h: plotH };
      
      const steps = runData.steps;
      const nValues = steps.map(s => s.n);
      const kappaValues = steps.map(s => s.kappa);
      
      const nMin = Math.min(...nValues);
      const nMax = Math.max(...nValues);
      const kappaMin = Math.min(...kappaValues);
      const kappaMax = Math.max(...kappaValues);
      
      // Add margin to kappa range
      const kappaRange = kappaMax - kappaMin;
      const kappaPlotMin = Math.max(0, kappaMin - kappaRange * 0.1);
      const kappaPlotMax = kappaMax + kappaRange * 0.1;
      
      // Scale functions
      const xScale = (n) => padding.left + ((n - nMin) / (nMax - nMin)) * plotW;
      const yScale = (k) => padding.top + plotH - ((k - kappaPlotMin) / (kappaPlotMax - kappaPlotMin)) * plotH;
      
      // Cache for tooltip (performance optimization)
      cachedXScale = xScale;
      cachedYScale = yScale;
      
      // Draw axes
      ctx.strokeStyle = '#3a3a3a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, padding.top + plotH);
      ctx.lineTo(padding.left + plotW, padding.top + plotH);
      ctx.stroke();
      
      // Draw grid
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 1;
      const gridLines = 8;
      
      // Horizontal grid lines
      for (let i = 0; i <= gridLines; i++) {
        const y = padding.top + (i / gridLines) * plotH;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(padding.left + plotW, y);
        ctx.stroke();
        
        // Y-axis labels
        const kappaVal = kappaPlotMax - (i / gridLines) * (kappaPlotMax - kappaPlotMin);
        ctx.fillStyle = '#666';
        ctx.font = '11px Consolas';
        ctx.textAlign = 'right';
        ctx.fillText(kappaVal.toFixed(3), padding.left - 10, y + 4);
      }
      
      // Vertical grid lines
      const nStep = Math.max(1, Math.floor((nMax - nMin) / gridLines));
      for (let n = nMin; n <= nMax; n += nStep) {
        const x = xScale(n);
        ctx.beginPath();
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, padding.top + plotH);
        ctx.stroke();
        
        // X-axis labels
        ctx.fillStyle = '#666';
        ctx.font = '11px Consolas';
        ctx.textAlign = 'center';
        ctx.fillText(n.toString(), x, padding.top + plotH + 20);
      }
      
      // Axis labels
      ctx.fillStyle = '#4a9eff';
      ctx.font = '13px Consolas';
      ctx.textAlign = 'center';
      ctx.fillText('Step Index (n)', padding.left + plotW / 2, h - 10);
      
      ctx.save();
      ctx.translate(15, padding.top + plotH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Discrete Curvature (Œ∫‚Çô)', 0, 0);
      ctx.restore();
      
      // Draw regime shading
      drawRegimeShading(steps, xScale, yScale, padding, plotW, plotH);
      
      // Draw Lambda threshold line
      const lambdaY = yScale(lambda);
      ctx.strokeStyle = '#4aff4a';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(padding.left, lambdaY);
      ctx.lineTo(padding.left + plotW, lambdaY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Lambda label
      ctx.fillStyle = '#4aff4a';
      ctx.font = '12px Consolas';
      ctx.textAlign = 'left';
      ctx.fillText(`Œõ = ${lambda.toFixed(3)}`, padding.left + plotW + 5, lambdaY + 4);
      
      // Draw kappa curve
      ctx.strokeStyle = '#4a9eff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < steps.length; i++) {
        const x = xScale(steps[i].n);
        const y = yScale(steps[i].kappa);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      
      // Draw points
      for (let i = 0; i < steps.length; i++) {
        const x = xScale(steps[i].n);
        const y = yScale(steps[i].kappa);
        const isAdmissible = steps[i].kappa <= lambda;
        
        ctx.fillStyle = isAdmissible ? '#4aff4a' : '#ff4a9e';
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
      }
      
      // Update metrics
      updateMetrics();
    }
    
    function drawRegimeShading(steps, xScale, yScale, padding, plotW, plotH) {
      // Group into contiguous admissible/collapse segments
      const segments = [];
      let currentSegment = null;
      
      for (let i = 0; i < steps.length; i++) {
        const isAdmissible = steps[i].kappa <= lambda;
        
        if (!currentSegment || currentSegment.type !== isAdmissible) {
          if (currentSegment) segments.push(currentSegment);
          currentSegment = {
            type: isAdmissible,
            start: i,
            end: i
          };
        } else {
          currentSegment.end = i;
        }
      }
      if (currentSegment) segments.push(currentSegment);
      
      // Draw shading for each segment
      for (const seg of segments) {
        const x1 = xScale(steps[seg.start].n);
        // Extend to next step position, or clamp to plot boundary
        const x2 = seg.end < steps.length - 1
          ? xScale(steps[seg.end + 1].n)
          : padding.left + plotW;
        const y1 = padding.top;
        const y2 = padding.top + plotH;
        
        ctx.fillStyle = seg.type 
          ? 'rgba(74, 255, 74, 0.08)'  // œÑ-admissible (green)
          : 'rgba(255, 74, 158, 0.08)'; // collapse-selected (magenta)
        
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }
    }
    
    function updateMetrics() {
      const steps = runData.steps;
      const total = steps.length;
      let admissibleCount = 0;
      let collapseCount = 0;
      
      // Count regimes
      for (const step of steps) {
        if (step.kappa <= lambda) {
          admissibleCount++;
        } else {
          collapseCount++;
        }
      }
      
      // Count contiguous œÑ-admissible segments
      let segments = 0;
      let inAdmissible = false;
      for (const step of steps) {
        const isAdm = step.kappa <= lambda;
        if (isAdm && !inAdmissible) {
          segments++;
          inAdmissible = true;
        } else if (!isAdm) {
          inAdmissible = false;
        }
      }
      
      // Update display
      document.getElementById('metricTotal').textContent = total;
      document.getElementById('metricAdmissible').textContent = admissibleCount;
      document.getElementById('metricCollapse').textContent = collapseCount;
      document.getElementById('metricAdmissibleRatio').textContent = 
        (admissibleCount / total * 100).toFixed(1) + '%';
      document.getElementById('metricCollapseRatio').textContent = 
        (collapseCount / total * 100).toFixed(1) + '%';
      document.getElementById('metricSegments').textContent = segments;
    }
    
    // =====================================
    // CONTROLS
    // =====================================
    
    lambdaSlider.addEventListener('input', (e) => {
      lambda = parseFloat(e.target.value);
      lambdaValue.textContent = lambda.toFixed(3);
      if (runData) render();
    });
    
    resetBtn.addEventListener('click', () => {
      lambda = initialLambda;
      lambdaSlider.value = lambda;
      lambdaValue.textContent = lambda.toFixed(3);
      if (runData) render();
    });
    
    clearBtn.addEventListener('click', () => {
      runData = null;
      fileInput.value = '';
      fileInfo.classList.add('hidden');
      errorDisplay.classList.add('hidden');
      vizPanel.classList.add('hidden');
      metricsPanel.classList.add('hidden');
      console.log('üßπ Data cleared');
    });
    
    // =====================================
    // TOOLTIP (Hover)
    // =====================================
    
    mainCanvas.addEventListener('mousemove', (e) => {
      if (!runData || !cachedXScale || !cachedYScale) return;
      
      const rect = mainCanvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      const padding = cachedPadding;
      const { w: plotW, h: plotH } = cachedPlotDimensions;
      
      // Check if mouse is in plot area
      if (mouseX < padding.left || mouseX > padding.left + plotW ||
          mouseY < padding.top || mouseY > padding.top + plotH) {
        tooltip.classList.add('hidden');
        return;
      }
      
      // Find nearest point using cached scale functions
      const steps = runData.steps;
      let nearestStep = null;
      let minDist = Infinity;
      
      for (const step of steps) {
        const x = cachedXScale(step.n);
        const y = cachedYScale(step.kappa);
        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        
        if (dist < minDist && dist < 15) {
          minDist = dist;
          nearestStep = step;
        }
      }
      
      if (nearestStep) {
        const regime = nearestStep.kappa <= lambda ? 'œÑ-admissible' : 'collapse-selected';
        const regimeColor = nearestStep.kappa <= lambda ? '#4aff4a' : '#ff4a9e';
        
        tooltip.innerHTML = `
          <strong>Step:</strong> ${nearestStep.n}<br>
          <strong>Œ∫:</strong> ${nearestStep.kappa.toFixed(6)}<br>
          <strong>Regime:</strong> <span style="color: ${regimeColor};">${regime}</span>
        `;
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
        tooltip.classList.remove('hidden');
      } else {
        tooltip.classList.add('hidden');
      }
    });
    
    mainCanvas.addEventListener('mouseleave', () => {
      tooltip.classList.add('hidden');
    });
    
    console.log('‚úÖ Module initialized');
    console.log('üìñ Ready to load UNNS run data');
  </script>
</body>
</html>
