<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory ‚Äî Chamber XXXV + Higgs-Mode (INLINE)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Consolas', 'Monaco', monospace; background: #0a0a0a; color: #e0e0e0; }
    .container { max-width: 1800px; margin: 0 auto; padding: 20px; }
    header { text-align: center; margin-bottom: 30px; padding: 20px; border-bottom: 2px solid #2a2a2a; }
    h1 { font-size: 2em; color: #4a9eff; letter-spacing: 2px; }
    .subtitle { color: #888; margin-top: 10px; font-size: 0.9em; }
    .badges { display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap; }
    .badge { background: #2a2a2a; padding: 5px 15px; border-radius: 15px; font-size: 0.85em; }
    .badge.phase { background: #2a3a4a; color: #4a9eff; }
    .badge.locked { background: #4a2a2a; color: #ff4a4a; }
    .badge.active { background: #2a4a2a; color: #4aff4a; }
    .badge.higgs { background: linear-gradient(135deg, #2a1a3a 0%, #1a2a3a 100%); color: #ff4aff; font-weight: bold; }
    
    .layout { display: grid; grid-template-columns: 320px 1fr; gap: 20px; }
    
    .panel { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 8px; padding: 20px; margin-bottom: 20px; }
    .panel.higgs-mode { border: 2px solid #ff4aff; }
    .panel-title { font-size: 1.2em; color: #4a9eff; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #2a2a2a; }
    
    /* Higgs-mode specific styles */
    .higgs-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 15px;
      background: linear-gradient(135deg, #1a1a2a 0%, #2a1a2a 100%);
      border: 1px solid #4a2a4a;
      border-radius: 6px;
      margin-bottom: 15px;
      cursor: pointer;
      user-select: none;
    }
    .higgs-toggle:hover { background: linear-gradient(135deg, #2a2a3a 0%, #3a2a3a 100%); }
    .higgs-toggle input[type="checkbox"] { 
      width: 20px; 
      height: 20px; 
      cursor: pointer;
      accent-color: #ff4aff;
    }
    .higgs-toggle-label { 
      flex: 1;
      color: #ff4aff;
      font-weight: bold;
      font-size: 1.05em;
    }
    .higgs-hint {
      font-size: 0.75em;
      color: #aaa;
      margin-top: 5px;
      font-style: italic;
    }
    
    .higgs-options {
      display: none;
      margin-top: 10px;
      padding: 15px;
      background: #0a0a1a;
      border: 1px solid #2a2a3a;
      border-radius: 4px;
    }
    .higgs-options.visible { display: block; }
    
    .falsification-matrix {
      background: #0a0a0a;
      border: 2px solid #ff4aff;
      border-radius: 6px;
      padding: 15px;
      margin: 20px 0;
    }
    .falsification-header {
      color: #ff4aff;
      font-size: 1.1em;
      font-weight: bold;
      margin-bottom: 15px;
      text-align: center;
    }
    .falsification-disclaimer {
      background: #2a1a1a;
      border-left: 3px solid #ff4aff;
      padding: 10px;
      margin: 15px 0;
      font-size: 0.85em;
      color: #ccc;
      line-height: 1.5;
    }
    .falsification-grid {
      display: grid;
      grid-template-columns: 2fr 1fr 1fr;
      gap: 8px;
      font-size: 0.9em;
    }
    .falsification-grid-header {
      background: #1a1a2a;
      padding: 10px;
      color: #ff4aff;
      font-weight: bold;
      border-bottom: 2px solid #2a2a3a;
    }
    .falsification-criterion {
      padding: 10px;
      border-bottom: 1px solid #1a1a1a;
    }
    .falsification-status {
      text-align: center;
      padding: 10px;
      border-bottom: 1px solid #1a1a1a;
      font-weight: bold;
    }
    .falsification-status.pass { color: #4aff4a; }
    .falsification-status.fail { color: #ff4a4a; }
    .falsification-status.pending { color: #ffa54a; }
    
    .higgs-classification {
      margin-top: 15px;
      padding: 15px;
      border-radius: 6px;
      text-align: center;
      font-size: 1.2em;
      font-weight: bold;
    }
    .higgs-classification.higgs-like {
      background: linear-gradient(135deg, #1a2a1a 0%, #1a3a2a 100%);
      border: 2px solid #4aff4a;
      color: #4aff4a;
    }
    .higgs-classification.partial {
      background: linear-gradient(135deg, #2a2a1a 0%, #3a3a2a 100%);
      border: 2px solid #ffa54a;
      color: #ffa54a;
    }
    .higgs-classification.not-higgs-like {
      background: linear-gradient(135deg, #2a1a1a 0%, #3a2a2a 100%);
      border: 2px solid #ff4a4a;
      color: #ff4a4a;
    }
    
    .controls { display: flex; flex-direction: column; gap: 15px; }
    .control-group { display: flex; flex-direction: column; }
    .control-group label { font-size: 0.9em; color: #aaa; margin-bottom: 5px; }
    .control-group input[type="number"], 
    .control-group input[type="range"], 
    .control-group select,
    .control-group input[type="text"] { 
      background: #0a0a0a; 
      border: 1px solid #3a3a3a; 
      color: #e0e0e0; 
      padding: 8px; 
      border-radius: 4px; 
      font-family: inherit; 
    }
    .control-group input:disabled,
    .control-group select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .control-group .readonly-note {
      font-size: 0.75em;
      color: #ff4a4a;
      margin-top: 2px;
    }
    
    /* Collapsible sections */
    .collapsible-header {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 0;
    }
    .collapsible-icon {
      color: #4a9eff;
      font-size: 0.9em;
      transition: transform 0.2s;
    }
    .collapsible-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .collapsible-content.expanded {
      max-height: 10000px;
    }
    
    button { 
      background: #2a4a7a; 
      border: none; 
      color: #e0e0e0; 
      padding: 12px 24px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-family: inherit; 
      font-size: 1em;
      transition: background 0.2s;
    }
    button:hover { background: #3a5a8a; }
    button:disabled { background: #1a1a1a; color: #555; cursor: not-allowed; }
    button.primary { background: #4a9eff; }
    button.primary:hover { background: #5aafff; }
    button.higgs { background: linear-gradient(135deg, #4a2a7a 0%, #2a4a7a 100%); }
    button.higgs:hover { background: linear-gradient(135deg, #5a3a8a 0%, #3a5a8a 100%); }
    
    .pipeline-viz { 
      display: flex; 
      align-items: center; 
      justify-content: space-around; 
      padding: 20px; 
      gap: 15px;
    }
    .pipeline-stage { 
      background: #0a0a0a; 
      border: 2px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 15px; 
      min-width: 140px; 
      text-align: center;
    }
    .pipeline-stage.active { border-color: #4aff4a; }
    .stage-label { 
      font-weight: bold; 
      color: #4a9eff; 
      margin-bottom: 10px; 
      font-size: 1.1em;
    }
    .stage-metric { 
      font-size: 0.85em; 
      margin: 5px 0; 
      color: #888;
    }
    .stage-value { color: #e0e0e0; font-weight: bold; }
    .pipeline-arrow { 
      color: #4a9eff; 
      font-size: 2em; 
      font-weight: bold;
    }
    
    .viz-grid { 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 20px; 
    }
    .viz-panel { 
      background: #0a0a0a; 
      border: 1px solid #2a2a2a; 
      border-radius: 4px; 
      padding: 15px;
    }
    .viz-label { 
      color: #4a9eff; 
      margin-bottom: 10px; 
      font-size: 0.9em;
    }
    canvas { 
      width: 100%; 
      height: auto; 
      display: block;
    }
    
    .metrics-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
      gap: 12px; 
    }
    .metric { 
      background: #0a0a0a; 
      padding: 12px; 
      border-radius: 4px; 
      border: 1px solid #2a2a2a; 
    }
    .metric-label { 
      font-size: 0.8em; 
      color: #888; 
      margin-bottom: 5px; 
    }
    .metric-value { 
      font-size: 1.2em; 
      color: #4a9eff; 
      font-weight: bold; 
    }
    .metric-value.good { color: #4aff4a; }
    .metric-value.warn { color: #ffa54a; }
    .metric-value.bad { color: #ff4a4a; }
    
    .verdict-box { 
      background: linear-gradient(135deg, #1a1a2a 0%, #1a2a1a 100%); 
      border: 2px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 20px; 
      margin: 20px 0;
    }
    .verdict-box.pass { 
      border-color: #4aff4a; 
      background: linear-gradient(135deg, #1a2a1a 0%, #2a3a1a 100%); 
    }
    .verdict-box.fail { 
      border-color: #ff4a4a; 
      background: linear-gradient(135deg, #2a1a1a 0%, #3a2a2a 100%); 
    }
    .verdict-title { 
      font-size: 1.5em; 
      font-weight: bold; 
      margin-bottom: 15px; 
    }
    .verdict-title.pass { color: #4aff4a; }
    .verdict-title.fail { color: #ff4a4a; }
    .verdict-content { 
      line-height: 1.8; 
      color: #ccc; 
    }
    
    .log-panel { 
      background: #0a0a0a; 
      border: 1px solid #2a2a2a; 
      border-radius: 4px; 
      padding: 15px; 
      max-height: 400px; 
      overflow-y: auto; 
      font-family: 'Courier New', monospace; 
      font-size: 0.85em;
    }
    .log-entry { 
      margin: 3px 0; 
      line-height: 1.4;
    }
    .log-entry.header { 
      color: #4a9eff; 
      font-weight: bold; 
      margin-top: 10px;
    }
    .log-entry.pass { color: #4aff4a; }
    .log-entry.fail { color: #ff4a4a; }
    .log-entry.warn { color: #ffa54a; }
    .log-entry.higgs { color: #ff4aff; }
    
    .progress-bar { 
      width: 100%; 
      height: 4px; 
      background: #1a1a1a; 
      border-radius: 2px; 
      overflow: hidden; 
      margin-top: 15px; 
    }
    .progress-fill { 
      height: 100%; 
      background: #4a9eff; 
      transition: width 0.3s; 
      width: 0%;
    }
    .progress-fill.higgs { 
      background: linear-gradient(90deg, #ff4aff 0%, #4a9eff 100%);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚öóÔ∏è CHAMBER XXXV: Œ©‚ÜíœÑ + HIGGS-MODE</h1>
      <div class="subtitle">Testing œÑ-Operator Admissibility with Selection-Gated Stabilization Protocol</div>
      <div class="badges">
        <span class="badge phase">Phase F</span>
        <span class="badge locked">Œ©4b Fixed</span>
        <span class="badge active">œÑ Testing</span>
        <span class="badge higgs">Higgs-Mode Active</span>
      </div>
    </header>
    
    <div class="layout">
      <!-- LEFT COLUMN: Controls -->
      <div>
        <div class="panel">
          <div class="panel-title">Ensemble Configuration</div>
          <div class="controls">
            <div class="control-group">
              <label>Ensemble Size M</label>
              <input type="number" id="ensembleSize" value="100" disabled>
              <span class="readonly-note">Inherited from XXXIV</span>
            </div>
            <div class="control-group">
              <label>Node Count n</label>
              <input type="number" id="nodeCount" value="32" disabled>
              <span class="readonly-note">Inherited from XXXIV</span>
            </div>
            <div class="control-group">
              <label>Generator Family</label>
              <select id="generatorFamily" disabled>
                <option value="erdos-renyi">Erd≈ës-R√©nyi</option>
              </select>
              <span class="readonly-note">Locked from XXXIV</span>
            </div>
            <div class="control-group">
              <label>RNG Seed</label>
              <input type="text" id="rngSeed" value="137042">
            </div>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Œ©4b Configuration</div>
          <div class="controls">
            <div class="control-group">
              <label>Keep Fraction f</label>
              <input type="range" id="keepFraction" min="0.1" max="0.5" step="0.05" value="0.3" disabled>
              <span id="keepFractionValue" style="color: #ff4a4a;">0.30 (LOCKED)</span>
            </div>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">œÑ Operator Selection</div>
          <div class="controls">
            <div class="control-group">
              <label>œÑ Family</label>
              <select id="tauFamily">
                <option value="tau_B" selected>œÑB: Spectral Band-Limiter</option>
                <option value="tau_E">œÑE: Multi-Scale</option>
              </select>
            </div>
            <div class="control-group">
              <label>Iterations T</label>
              <input type="number" id="tauIterations" value="10" min="1" max="100">
            </div>
            <div class="control-group">
              <label>Step Size Œª <span id="lambdaValue">0.05</span></label>
              <input type="range" id="tauLambda" min="0.01" max="0.5" step="0.01" value="0.05">
            </div>
            <div class="control-group">
              <label>Constraint Œº <span id="muValue">0.02</span></label>
              <input type="range" id="tauMu" min="0.01" max="0.2" step="0.01" value="0.02">
            </div>
          </div>
        </div>
        
        <div class="panel higgs-mode" id="higgsModePanel">
          <div class="higgs-toggle" onclick="toggleHiggsMode()">
            <input type="checkbox" id="higgsModeToggle" onclick="event.stopPropagation();">
            <div>
              <div class="higgs-toggle-label">üî¨ Higgs-Mode (Extended Protocol)</div>
              <div class="higgs-hint">7-stage Œ©-gated stabilization test with falsification matrix</div>
            </div>
          </div>
          
          <div class="higgs-options" id="higgsOptions">
            <div class="control-group">
              <label>Perturbation Œµ (fragility test)</label>
              <input type="number" id="higgsEpsilon" value="0.05" step="0.01" min="0.01" max="0.2">
            </div>
            <div class="control-group">
              <label>Multi-Seed Count</label>
              <input type="number" id="higgsMultiSeedCount" value="5" min="3" max="10">
            </div>
            <div class="control-group">
              <label>Œ©-Selectivity Test</label>
              <select id="higgsOmegaTest">
                <option value="disabled">Disabled (use Œ©4b only)</option>
                <option value="enabled">Enabled (test multiple Œ© configs)</option>
              </select>
            </div>
            <div class="control-group">
              <label>œÜ-Resonance Analysis</label>
              <select id="higgsPhiResonance">
                <option value="disabled">Disabled</option>
                <option value="enabled" selected>Enabled (link to Chamber XIV)</option>
              </select>
            </div>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Admissibility Guardrails</div>
          <div class="controls">
            <div class="control-group">
              <label>Œî (min residual improvement)</label>
              <input type="number" id="deltaGuardrail" value="0.002" step="0.001" min="0.001" max="0.1">
            </div>
            <div class="control-group">
              <label>Œ¥ (max invariant drift)</label>
              <input type="number" id="driftGuardrail" value="0.05" step="0.01" min="0.01" max="0.2">
            </div>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Run Controls</div>
          <div class="controls">
            <button id="runPipeline" class="primary higgs">‚ñ∂ Run Œ©‚ÜíœÑ Pipeline</button>
            <button id="stopPipeline" disabled>‚è∏ Stop</button>
            <button id="exportData" disabled>üíæ Export Results</button>
            <div class="progress-bar">
              <div id="progressFill" class="progress-fill"></div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- RIGHT COLUMN: Visualization & Results -->
      <div>
        <div class="panel">
          <div class="panel-title">Pipeline Flow</div>
          <div class="pipeline-viz">
            <div class="pipeline-stage" id="stageE">
              <div class="stage-label">E</div>
              <div class="stage-metric">Size: <span class="stage-value" id="sizeE">‚Äî</span></div>
              <div class="stage-metric">R<sub>Œõ</sub>: <span class="stage-value" id="rlE">‚Äî</span></div>
            </div>
            <div class="pipeline-arrow">‚Üí</div>
            <div class="pipeline-stage" id="stageOmega">
              <div class="stage-label">Œ©4b(E)</div>
              <div class="stage-metric">Size: <span class="stage-value" id="sizeOmega">‚Äî</span></div>
              <div class="stage-metric">R<sub>Œõ</sub>: <span class="stage-value" id="rlOmega">‚Äî</span></div>
            </div>
            <div class="pipeline-arrow">‚Üí</div>
            <div class="pipeline-stage" id="stageTau">
              <div class="stage-label">œÑ(E<sub>Œ©</sub>)</div>
              <div class="stage-metric">R<sub>Œõ</sub>: <span class="stage-value" id="rlTau">‚Äî</span></div>
              <div class="stage-metric">CR: <span class="stage-value" id="crTau">‚Äî</span></div>
            </div>
          </div>
        </div>
        
        <div id="higgsFalsificationPanel" style="display: none;">
          <!-- Falsification matrix will be inserted here -->
        </div>
        
        <div class="panel">
          <div class="panel-title">Core Metrics</div>
          <div class="metrics-grid">
            <div class="metric">
              <div class="metric-label">Baseline R<sub>Œõ</sub></div>
              <div class="metric-value" id="metricRL0">‚Äî</div>
            </div>
            <div class="metric">
              <div class="metric-label">Post-Œ© R<sub>Œõ</sub></div>
              <div class="metric-value" id="metricRLOmega">‚Äî</div>
            </div>
            <div class="metric">
              <div class="metric-label">Post-œÑ R<sub>Œõ</sub></div>
              <div class="metric-value" id="metricRLTau">‚Äî</div>
            </div>
            <div class="metric">
              <div class="metric-label">Contraction Ratio</div>
              <div class="metric-value" id="metricCR">‚Äî</div>
            </div>
          </div>
        </div>
        
        <div id="verdictPanel" style="display: none;">
          <!-- Verdict will be inserted here -->
        </div>
        
        <div class="panel">
          <div class="panel-title">Run Log</div>
          <div class="log-panel" id="logPanel">
            <div class="log-entry">Chamber XXXV + Higgs-Mode initialized. Awaiting run...</div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="panel">
      <div class="collapsible-header" onclick="toggleSection('guide')">
        <span class="collapsible-icon" id="guideIcon">‚ñ∂</span>
        <div class="panel-title" style="margin: 0; padding: 0; border: none;">üìö Laboratory Guide + Higgs-Mode Documentation</div>
      </div>
      <div class="collapsible-content" id="guideContent">
        <div style="line-height: 1.6; color: #aaa; padding-top: 15px;">
          <h3 style="color: #4a9eff; font-size: 1.1em; margin-bottom: 10px;">Chamber XXXV: Œ©‚ÜíœÑ Coupled Pipeline</h3>
          
          <p><strong>Purpose:</strong> This chamber tests whether œÑ-operators become admissible only after Œ©4b selection by measuring residual contraction, macro-invariant protection, and œÑ-locking windows.</p>
          
          <h3 style="color: #ff4aff; font-size: 1.2em; margin: 30px 0 15px; border-top: 2px solid #2a2a2a; padding-top: 20px;">üî¨ HIGGS-MODE: Extended Protocol</h3>
          
          <div class="falsification-disclaimer">
            <strong>‚ö†Ô∏è CRITICAL HONESTY GUARDRAIL:</strong><br>
            Higgs-mode tests <em>structural patterns</em> of selection-gated stabilization. It does <strong>NOT</strong>:
            <ul style="margin: 8px 0 0 20px; line-height: 1.6;">
              <li>Compute Higgs mass or couplings from SM parameters</li>
              <li>Map GeV values to seeds or operator parameters</li>
              <li>Replace quantum field theory calculations</li>
              <li>Claim to derive the Standard Model</li>
            </ul>
            <br>
            It tests whether a œÑ-operator exhibits <strong>Higgs-like behavior</strong>: failing pre-Œ©, passing post-Œ©, and showing structural isolation under perturbation.
          </div>
          
          <h4 style="color: #ff4aff; margin: 20px 0 10px;">Seven-Stage Protocol</h4>
          
          <div style="background: #0a0a1a; padding: 15px; border-left: 3px solid #ff4aff; margin: 10px 0;">
            <p style="margin: 8px 0;"><strong>Stage A ‚Äî Pre-Œ© Gate Test:</strong></p>
            <p style="margin: 0 0 0 20px; font-size: 0.9em;">Apply œÑ to raw ensemble E before Œ©4b. Higgs-like expectation: <span style="color: #ff4a4a;">FAIL</span> (destabilization)</p>
            
            <p style="margin: 16px 0 8px;"><strong>Stage B ‚Äî Post-Œ© Admissibility:</strong></p>
            <p style="margin: 0 0 0 20px; font-size: 0.9em;">Standard Chamber XXXV pipeline: E ‚Üí Œ©4b(E) ‚Üí œÑ(Œ©4b(E)). Higgs-like expectation: <span style="color: #4aff4a;">PASS</span></p>
            
            <p style="margin: 16px 0 8px;"><strong>Stage C ‚Äî Structural Fragility:</strong></p>
            <p style="margin: 0 0 0 20px; font-size: 0.9em;">
              C1. Parameter perturbations: Œª, Œº, T variants<br>
              C2. Temporal fragility: depth window testing<br>
              Higgs-like: narrow admissibility region (Fragility Index I ‚â• 0.5)
            </p>
            
            <p style="margin: 16px 0 8px;"><strong>Stage D ‚Äî Multi-Seed Consistency:</strong></p>
            <p style="margin: 0 0 0 20px; font-size: 0.9em;">Repeat A‚ÜíB across N seeds. Higgs-like: consistency ‚â• 0.8 (robust pattern, not lucky seed)</p>
            
            <p style="margin: 16px 0 8px;"><strong>Stage E ‚Äî Œ©-Layer Selectivity:</strong></p>
            <p style="margin: 0 0 0 20px; font-size: 0.9em;">Test œÑ with different Œ© configurations. Higgs-like: low selectivity ‚â§ 0.3 (requires specific Œ© geometry)</p>
            
            <p style="margin: 16px 0 8px;"><strong>Stage F ‚Äî SM-Control Test:</strong></p>
            <p style="margin: 0 0 0 20px; font-size: 0.9em;">Generate random ensembles with same statistics as SM-like. Higgs-like: œÑ passes on structured, fails on most random</p>
            
            <p style="margin: 16px 0 8px;"><strong>Stage G ‚Äî œÜ-Resonance Probe (Experimental):</strong></p>
            <p style="margin: 0 0 0 20px; font-size: 0.9em;">Link to Chamber XIV: check if optimal parameters show golden ratio (œÜ ‚âà 1.618) signatures</p>
          </div>
          
          <h4 style="color: #ff4aff; margin: 20px 0 10px;">Falsification Criteria</h4>
          
          <p>All 7 criteria must pass for "HIGGS-LIKE" classification:</p>
          <ol style="margin: 10px 0 10px 20px; line-height: 1.8;">
            <li><strong>F1:</strong> Pre-Œ© FAIL (gate dependence)</li>
            <li><strong>F2:</strong> Post-Œ© PASS (admissibility emerges)</li>
            <li><strong>F3:</strong> Fragility I ‚â• 0.5 (structural isolation)</li>
            <li><strong>F4:</strong> CR ‚â§ 0.3 (strong contraction)</li>
            <li><strong>F5:</strong> Multi-seed consistency ‚â• 0.8</li>
            <li><strong>F6:</strong> Œ©-selectivity ‚â§ 0.3 (geometry-specific)</li>
            <li><strong>F7:</strong> SM-control specificity (not generic)</li>
          </ol>
          
          <p style="margin-top: 15px;"><strong>Classification:</strong></p>
          <ul style="margin: 5px 0 15px 20px;">
            <li><span style="color: #4aff4a;">HIGGS-LIKE:</span> All 7 criteria pass</li>
            <li><span style="color: #ffa54a;">PARTIAL:</span> 5-6 criteria pass</li>
            <li><span style="color: #ff4a4a;">NOT HIGGS-LIKE:</span> ‚â§4 criteria pass</li>
          </ul>
          
          <div class="falsification-disclaimer">
            <strong>What This Result Would Mean:</strong><br><br>
            If a œÑ-operator is classified as HIGGS-LIKE, this suggests:<br>
            ‚Ä¢ Mass-generating stabilization is <em>structurally constrained</em>, not arbitrary<br>
            ‚Ä¢ Higgs-like behavior requires <em>prior selection</em> (Œ©-gating)<br>
            ‚Ä¢ Extensions are <em>structurally isolated</em> (explains null BSM results post-2012)<br>
            ‚Ä¢ This does NOT compute particle masses, it constrains <em>which stabilizations are possible</em><br><br>
            <strong>Falsification:</strong> Discovery of multiple Higgs doublets, continuous coupling deviations, or large Higgs portal physics would falsify the isolation claim.
          </div>
          
          <h3 style="color: #4a9eff; font-size: 1.1em; margin: 20px 0 10px;">Recommended Workflow</h3>
          
          <ol style="margin: 10px 0 10px 20px; line-height: 1.8;">
            <li><strong>Standard Mode:</strong> Higgs-mode OFF, run normal Œ©‚ÜíœÑ pipeline for validation</li>
            <li><strong>Higgs-Mode Quick Test:</strong> Enable Higgs-mode, use default seeds (5), all stages enabled</li>
            <li><strong>Publication Run:</strong> Multi-seed count = 10, both œÑB and œÑE tested, export JSON for each</li>
            <li><strong>Cross-Chamber Validation:</strong> If œÜ-resonance detected, compare with Chamber XIV results</li>
          </ol>
        </div>
      </div>
    </div>
  </div>
  
  <script>
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('UNNS Phase F | Chamber XXXV + Higgs-Mode');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

// ========================================
// GRAPH CLASS
// ========================================

class Graph {
  constructor(n) {
    this.n = n;
    this.adj = Array(n).fill(null).map(() => Array(n).fill(0));
    this.degrees = Array(n).fill(0);
  }
  
  addEdge(i, j) {
    if (this.adj[i][j] === 0) {
      this.adj[i][j] = 1;
      this.adj[j][i] = 1;
      this.degrees[i]++;
      this.degrees[j]++;
    }
  }
  
  removeEdge(i, j) {
    if (this.adj[i][j] === 1) {
      this.adj[i][j] = 0;
      this.adj[j][i] = 0;
      this.degrees[i]--;
      this.degrees[j]--;
    }
  }
  
  getSpectralRadius() {
    // Power iteration for largest eigenvalue
    const A = this.adj;
    const n = this.n;
    let v = Array(n).fill(1 / Math.sqrt(n));
    
    for (let iter = 0; iter < 50; iter++) {
      const v_new = Array(n).fill(0);
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          v_new[i] += A[i][j] * v[j];
        }
      }
      const norm = Math.sqrt(v_new.reduce((s, x) => s + x*x, 0));
      if (norm < 1e-10) break;
      v = v_new.map(x => x / norm);
    }
    
    let lambda = 0;
    for (let i = 0; i < n; i++) {
      let Av_i = 0;
      for (let j = 0; j < n; j++) {
        Av_i += A[i][j] * v[j];
      }
      lambda += v[i] * Av_i;
    }
    
    return Math.abs(lambda);
  }
  
  getLaplacianTrace() {
    return this.degrees.reduce((s, d) => s + d, 0);
  }
  
  getDegreeEntropy() {
    const total = this.degrees.reduce((s, d) => s + d, 0);
    if (total === 0) return 0;
    const probs = this.degrees.map(d => d / total);
    let entropy = 0;
    for (const p of probs) {
      if (p > 0) entropy -= p * Math.log(p);
    }
    return entropy;
  }
  
  clone() {
    const g = new Graph(this.n);
    for (let i = 0; i < this.n; i++) {
      for (let j = 0; j < this.n; j++) {
        g.adj[i][j] = this.adj[i][j];
      }
      g.degrees[i] = this.degrees[i];
    }
    return g;
  }
}

// ========================================
// SEEDED RNG
// ========================================

class SeededRNG {
  constructor(seed) {
    this.state = seed >>> 0;
  }
  
  random() {
    this.state = (this.state * 1664525 + 1013904223) >>> 0;
    return this.state / 4294967296;
  }
  
  gaussian() {
    let u1 = this.random();
    let u2 = this.random();
    if (u1 < 1e-10) u1 = 1e-10;
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  
  randomInt(max) {
    return Math.floor(this.random() * max);
  }
}

// ========================================
// ENSEMBLE ENGINE
// ========================================

class EnsembleEngine {
  constructor(config) {
    this.M = config.ensemble_size || 100;
    this.n = config.node_count || 32;
    this.generator = config.generator || 'erdos-renyi';
    this.seed = config.seed || 137042;
    this.rng = new SeededRNG(this.seed);
    
    this.ensemble = [];
    this.V_values = [];
    this.I_values = [];
    this.V_target = null;
    
    // Œ©4b parameters
    this.omega_keep_fraction = config.omega_keep_fraction || 0.3;
    this.omega_ensemble = null;
    this.omega_indices = null;
    
    // œÑ parameters
    this.tau_ensemble = null;
  }
  
  generateEnsemble() {
    log('Generating ensemble...', 'header');
    this.ensemble = [];
    
    for (let i = 0; i < this.M; i++) {
      const g = this.generateGraph();
      this.ensemble.push(g);
    }
    
    this.computeObservables();
    log(`Generated ${this.M} structures (n=${this.n})`);
  }
  
  generateGraph() {
    const g = new Graph(this.n);
    
    if (this.generator === 'erdos-renyi') {
      const p = 0.2;
      for (let i = 0; i < this.n; i++) {
        for (let j = i + 1; j < this.n; j++) {
          if (this.rng.random() < p) {
            g.addEdge(i, j);
          }
        }
      }
    }
    
    return g;
  }
  
  computeObservables() {
    this.V_values = [];
    this.I_values = [];
    
    for (const g of this.ensemble) {
      const rho = g.getSpectralRadius();
      const trL = g.getLaplacianTrace();
      const H = g.getDegreeEntropy();
      
      const alpha = 1.0, beta = 0.5, gamma = 0.3;
      const V = alpha * (rho / g.n) + beta * (trL / g.n) + gamma * H;
      this.V_values.push(V);
      
      const I = {
        scaled_spectral_radius: rho / g.n,
        energy_per_node: trL / g.n,
        degree_entropy: H
      };
      this.I_values.push(I);
    }
    
    const sorted = [...this.V_values].sort((a, b) => a - b);
    this.V_target = sorted[Math.floor(sorted.length / 2)];
    
    log(`V_target = ${this.V_target.toFixed(6)} (median)`);
  }
  
  computeRL(V_values) {
    const V_mean = V_values.reduce((s, v) => s + v, 0) / V_values.length;
    const epsilon = 1e-6;
    return Math.abs(V_mean - this.V_target) / Math.max(Math.abs(this.V_target), epsilon);
  }
  
  applyOmega4b() {
    log('Applying Œ©4b selection...', 'header');
    
    const scores = this.V_values.map(V => -Math.abs(V - this.V_target));
    const indexed = scores.map((score, idx) => ({score, idx}));
    indexed.sort((a, b) => b.score - a.score);
    
    const k = Math.floor(this.omega_keep_fraction * this.M);
    this.omega_indices = indexed.slice(0, k).map(item => item.idx);
    this.omega_ensemble = this.omega_indices.map(idx => this.ensemble[idx]);
    
    const accept_rate = this.omega_indices.length / this.M;
    log(`Œ©4b: kept ${this.omega_indices.length}/${this.M} structures (${(accept_rate*100).toFixed(1)}%)`);
    
    return {
      ensemble: this.omega_ensemble,
      indices: this.omega_indices,
      accept_rate: accept_rate
    };
  }
  
  applyTau(tau_family, tau_params, source_ensemble = null) {
    log(`Applying œÑ operator: ${tau_family}...`, 'header');
    
    const ensemble = source_ensemble || this.omega_ensemble;
    if (!ensemble) {
      log('ERROR: No source ensemble', 'fail');
      return null;
    }
    
    const result = ensemble.map(g => {
      if (tau_family === 'tau_B') return this.tau_B_spectral(g, tau_params);
      if (tau_family === 'tau_E') return this.tau_E_multiscale(g, tau_params);
      return g.clone();
    });
    
    if (!source_ensemble) {
      this.tau_ensemble = result;
    }
    
    log(`œÑ operator applied to ${result.length} structures`);
    return result;
  }
  
  tau_B_spectral(g, params) {
    const g_new = g.clone();
    const lambda = params.lambda || 0.1;
    const T = Math.min(params.iterations || 10, 100);
    
    for (let t = 0; t < T; t++) {
      const avg_deg = g_new.degrees.reduce((s, d) => s + d, 0) / g_new.n;
      const high_deg_nodes = [];
      const low_deg_nodes = [];
      
      for (let i = 0; i < g_new.n; i++) {
        if (g_new.degrees[i] > avg_deg * 1.5) high_deg_nodes.push(i);
        else if (g_new.degrees[i] < avg_deg * 0.5) low_deg_nodes.push(i);
      }
      
      if (high_deg_nodes.length === 0 || low_deg_nodes.length === 0) break;
      
      const rewires = Math.min(3, high_deg_nodes.length, low_deg_nodes.length);
      for (let r = 0; r < rewires; r++) {
        const hi = high_deg_nodes[this.rng.randomInt(high_deg_nodes.length)];
        const lo = low_deg_nodes[this.rng.randomInt(low_deg_nodes.length)];
        
        for (let j = 0; j < g_new.n; j++) {
          if (g_new.adj[hi][j] === 1 && j !== lo) {
            g_new.removeEdge(hi, j);
            g_new.addEdge(lo, j);
            break;
          }
        }
      }
    }
    
    return g_new;
  }
  
  tau_E_multiscale(g, params) {
    const g_new = g.clone();
    const T = Math.min(params.iterations || 10, 100);
    
    for (let t = 0; t < T; t++) {
      if (this.rng.random() < 0.5) {
        const i = this.rng.randomInt(g_new.n);
        const j = this.rng.randomInt(g_new.n);
        if (i !== j) {
          if (g_new.adj[i][j] === 0) g_new.addEdge(i, j);
          else g_new.removeEdge(i, j);
        }
      }
    }
    
    return g_new;
  }
  
  computeInvariants(ensemble) {
    return ensemble.map(g => ({
      scaled_spectral_radius: g.getSpectralRadius() / g.n,
      energy_per_node: g.getLaplacianTrace() / g.n,
      degree_entropy: g.getDegreeEntropy()
    }));
  }
}

// ========================================
// HIGGS-MODE ENGINE
// ========================================

class HiggsModeEngine {
  constructor(base_engine, config) {
    this.engine = base_engine;
    this.config = config;
    this.results = {
      stageA: null,
      stageB: null,
      stageC: null,
      stageD: null,
      stageE: null,
      stageF: null,
      stageG: null,
      falsification: {
        F1_preOmegaFail: false,
        F2_postOmegaPass: false,
        F3_fragility: false,
        F4_strongContraction: false,
        F5_multiSeed: false,
        F6_omegaSelectivity: false,
        F7_smControl: false
      },
      classification: 'PENDING'
    };
  }
  
  async runFullProtocol(tau_family, tau_params, guardrails, onProgress) {
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'higgs');
    log('HIGGS-MODE: 7-Stage Protocol', 'higgs');
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'higgs');
    
    // Stage A: Pre-Œ© Gate Test
    await this.stageA_preOmegaTest(tau_family, tau_params, guardrails);
    onProgress('A', 15);
    
    // Stage B: Post-Œ© Admissibility (standard pipeline)
    await this.stageB_postOmegaTest(tau_family, tau_params, guardrails);
    onProgress('B', 30);
    
    // Stage C: Structural Fragility
    await this.stageC_fragility(tau_family, tau_params, guardrails);
    onProgress('C', 50);
    
    // Stage D: Multi-Seed Consistency
    if (this.config.multiSeedCount > 1) {
      await this.stageD_multiSeed(tau_family, tau_params, guardrails);
      onProgress('D', 65);
    } else {
      log('Stage D: Skipped (multi-seed disabled)', 'warn');
      this.results.stageD = { skipped: true };
    }
    
    // Stage E: Œ©-Selectivity
    if (this.config.omegaSelectivity) {
      await this.stageE_omegaSelectivity(tau_family, tau_params, guardrails);
      onProgress('E', 80);
    } else {
      log('Stage E: Skipped (Œ©-selectivity disabled)', 'warn');
      this.results.stageE = { skipped: true };
    }
    
    // Stage F: SM-Control
    await this.stageF_smControl(tau_family, tau_params, guardrails);
    onProgress('F', 90);
    
    // Stage G: œÜ-Resonance
    if (this.config.phiResonance) {
      await this.stageG_phiResonance(tau_family, tau_params);
      onProgress('G', 95);
    } else {
      log('Stage G: Skipped (œÜ-resonance disabled)', 'warn');
      this.results.stageG = { skipped: true };
    }
    
    // Compute Final Classification
    this.computeClassification();
    onProgress('Complete', 100);
    
    return this.results;
  }
  
  async stageA_preOmegaTest(tau_family, tau_params, guardrails) {
    log('Stage A: Pre-Œ© Gate Test', 'higgs');
    
    // Apply œÑ directly to raw ensemble (before Œ©4b)
    const raw_ensemble = this.engine.ensemble;
    const tau_raw = this.engine.applyTau(tau_family, tau_params, raw_ensemble);
    
    // Compute metrics
    const V_raw = this.computeVValues(raw_ensemble);
    const V_tau_raw = this.computeVValues(tau_raw);
    const RL0 = this.engine.computeRL(V_raw);
    const RL_tau = this.engine.computeRL(V_tau_raw);
    
    const improvement = RL0 - RL_tau;
    const CR = RL_tau / RL0;
    
    // Check failure criteria
    const failed = CR >= 1.0 || improvement < guardrails.delta || CR > 0.9;
    
    this.results.stageA = {
      RL_baseline: RL0,
      RL_post_tau: RL_tau,
      CR: CR,
      improvement: improvement,
      pass: !failed
    };
    
    this.results.falsification.F1_preOmegaFail = failed;
    
    log(`Pre-Œ©: CR=${CR.toFixed(3)}, ${failed ? 'FAIL ‚úì' : 'PASS ‚úó'}`, failed ? 'pass' : 'fail');
  }
  
  async stageB_postOmegaTest(tau_family, tau_params, guardrails) {
    log('Stage B: Post-Œ© Admissibility', 'higgs');
    
    // Standard Œ©‚ÜíœÑ pipeline
    const omega_result = this.engine.applyOmega4b();
    const V_omega = this.computeVValues(this.engine.omega_ensemble);
    const RL_omega = this.engine.computeRL(V_omega);
    
    const tau_ensemble = this.engine.applyTau(tau_family, tau_params);
    const V_tau = this.computeVValues(tau_ensemble);
    const RL_tau = this.engine.computeRL(V_tau);
    
    const improvement = RL_omega - RL_tau;
    const CR = RL_tau / RL_omega;
    
    // Check pass criteria
    const passed = CR < 1.0 && improvement >= guardrails.delta;
    
    this.results.stageB = {
      RL_omega: RL_omega,
      RL_tau: RL_tau,
      CR: CR,
      improvement: improvement,
      pass: passed
    };
    
    this.results.falsification.F2_postOmegaPass = passed;
    this.results.falsification.F4_strongContraction = CR <= 0.3;
    
    log(`Post-Œ©: CR=${CR.toFixed(3)}, ${passed ? 'PASS ‚úì' : 'FAIL ‚úó'}`, passed ? 'pass' : 'fail');
  }
  
  async stageC_fragility(tau_family, tau_params, guardrails) {
    log('Stage C: Structural Fragility', 'higgs');
    
    const epsilon = this.config.epsilon;
    const variants = [];
    
    // Parameter perturbations
    for (const lambda_mult of [1-epsilon, 1, 1+epsilon]) {
      for (const mu_mult of [1-epsilon, 1, 1+epsilon]) {
        const params_variant = {
          ...tau_params,
          lambda: tau_params.lambda * lambda_mult,
          mu: tau_params.mu * mu_mult
        };
        
        // Test this variant
        const tau_variant = this.engine.applyTau(tau_family, params_variant, this.engine.omega_ensemble);
        const V_variant = this.computeVValues(tau_variant);
        const RL_variant = this.engine.computeRL(V_variant);
        const CR_variant = RL_variant / this.results.stageB.RL_omega;
        
        const passed = CR_variant < 1.0 && (this.results.stageB.RL_omega - RL_variant) >= guardrails.delta;
        
        variants.push({
          lambda_mult,
          mu_mult,
          CR: CR_variant,
          pass: passed
        });
      }
    }
    
    const pass_count = variants.filter(v => v.pass).length;
    const total = variants.length;
    const fragility_index = 1 - (pass_count / total);
    
    this.results.stageC = {
      variants: variants,
      pass_count: pass_count,
      total: total,
      fragility_index: fragility_index
    };
    
    this.results.falsification.F3_fragility = fragility_index >= 0.5;
    
    log(`Fragility: I=${fragility_index.toFixed(3)} (${pass_count}/${total} pass), ${fragility_index >= 0.5 ? '‚úì' : '‚úó'}`, fragility_index >= 0.5 ? 'pass' : 'fail');
  }
  
  async stageD_multiSeed(tau_family, tau_params, guardrails) {
    log('Stage D: Multi-Seed Consistency', 'higgs');
    
    const base_seed = this.engine.seed;
    const consistent_seeds = [];
    
    for (let i = 0; i < this.config.multiSeedCount; i++) {
      const test_seed = base_seed + i * 1000;
      
      // Create new engine with this seed
      const test_engine = new EnsembleEngine({
        ensemble_size: this.engine.M,
        node_count: this.engine.n,
        generator: this.engine.generator,
        seed: test_seed,
        omega_keep_fraction: this.engine.omega_keep_fraction
      });
      
      test_engine.generateEnsemble();
      
      // Test pre-Œ©
      const raw_tau = test_engine.applyTau(tau_family, tau_params, test_engine.ensemble);
      const V_raw = this.computeVValues(test_engine.ensemble);
      const V_tau_raw = this.computeVValues(raw_tau);
      const CR_pre = test_engine.computeRL(V_tau_raw) / test_engine.computeRL(V_raw);
      const pre_fail = CR_pre >= 1.0;
      
      // Test post-Œ©
      test_engine.applyOmega4b();
      const tau_post = test_engine.applyTau(tau_family, tau_params);
      const V_omega = this.computeVValues(test_engine.omega_ensemble);
      const V_tau = this.computeVValues(tau_post);
      const CR_post = test_engine.computeRL(V_tau) / test_engine.computeRL(V_omega);
      const post_pass = CR_post < 1.0;
      
      if (pre_fail && post_pass) {
        consistent_seeds.push(test_seed);
      }
    }
    
    const consistency = consistent_seeds.length / this.config.multiSeedCount;
    
    this.results.stageD = {
      tested_seeds: this.config.multiSeedCount,
      consistent_count: consistent_seeds.length,
      consistency: consistency
    };
    
    this.results.falsification.F5_multiSeed = consistency >= 0.8;
    
    log(`Multi-Seed: ${consistent_seeds.length}/${this.config.multiSeedCount} consistent (${(consistency*100).toFixed(0)}%), ${consistency >= 0.8 ? '‚úì' : '‚úó'}`, consistency >= 0.8 ? 'pass' : 'fail');
  }
  
  async stageE_omegaSelectivity(tau_family, tau_params, guardrails) {
    log('Stage E: Œ©-Layer Selectivity', 'higgs');
    
    // Test with different keep fractions
    const omega_variants = [0.2, 0.25, 0.3, 0.35, 0.4];
    const passing_omegas = [];
    
    for (const f of omega_variants) {
      const test_engine = new EnsembleEngine({
        ensemble_size: this.engine.M,
        node_count: this.engine.n,
        generator: this.engine.generator,
        seed: this.engine.seed,
        omega_keep_fraction: f
      });
      
      test_engine.generateEnsemble();
      test_engine.applyOmega4b();
      
      const tau_variant = test_engine.applyTau(tau_family, tau_params);
      const V_omega = this.computeVValues(test_engine.omega_ensemble);
      const V_tau = this.computeVValues(tau_variant);
      const CR = test_engine.computeRL(V_tau) / test_engine.computeRL(V_omega);
      
      if (CR < 1.0) {
        passing_omegas.push(f);
      }
    }
    
    const selectivity = passing_omegas.length / omega_variants.length;
    
    this.results.stageE = {
      omega_variants: omega_variants,
      passing_count: passing_omegas.length,
      selectivity: selectivity
    };
    
    this.results.falsification.F6_omegaSelectivity = selectivity <= 0.3;
    
    log(`Œ©-Selectivity: ${passing_omegas.length}/${omega_variants.length} pass (S=${selectivity.toFixed(2)}), ${selectivity <= 0.3 ? '‚úì' : '‚úó'}`, selectivity <= 0.3 ? 'pass' : 'fail');
  }
  
  async stageF_smControl(tau_family, tau_params, guardrails) {
    log('Stage F: SM-Control Ensemble Test', 'higgs');
    
    // Generate random control ensembles
    const n_controls = 5;
    const passing_controls = [];
    
    for (let i = 0; i < n_controls; i++) {
      const control_engine = new EnsembleEngine({
        ensemble_size: this.engine.M,
        node_count: this.engine.n,
        generator: 'erdos-renyi',
        seed: this.engine.seed + (i+1)*10000,
        omega_keep_fraction: this.engine.omega_keep_fraction
      });
      
      control_engine.generateEnsemble();
      control_engine.applyOmega4b();
      
      const tau_control = control_engine.applyTau(tau_family, tau_params);
      const V_omega = this.computeVValues(control_engine.omega_ensemble);
      const V_tau = this.computeVValues(tau_control);
      const CR = control_engine.computeRL(V_tau) / control_engine.computeRL(V_omega);
      
      if (CR < 1.0) {
        passing_controls.push(i);
      }
    }
    
    const specificity = passing_controls.length / n_controls;
    
    this.results.stageF = {
      n_controls: n_controls,
      passing_count: passing_controls.length,
      specificity: specificity
    };
    
    this.results.falsification.F7_smControl = specificity < 0.5;
    
    log(`SM-Control: ${passing_controls.length}/${n_controls} pass (S=${specificity.toFixed(2)}), ${specificity < 0.5 ? '‚úì' : '‚úó'}`, specificity < 0.5 ? 'pass' : 'fail');
  }
  
  async stageG_phiResonance(tau_family, tau_params) {
    log('Stage G: œÜ-Resonance Analysis (Experimental)', 'higgs');
    
    const phi = 1.618033988749895;
    
    // Check if optimal parameters from Stage C show œÜ signatures
    const optimal_lambda = tau_params.lambda;
    const optimal_mu = tau_params.mu;
    const optimal_T = tau_params.iterations;
    
    const lambda_ratio = optimal_lambda / (tau_params.lambda * 0.95);
    const mu_ratio = optimal_mu / (tau_params.mu * 0.95);
    
    const phi_signatures = [];
    if (Math.abs(lambda_ratio - phi) / phi < 0.05) phi_signatures.push('Œª');
    if (Math.abs(mu_ratio - phi) / phi < 0.05) phi_signatures.push('Œº');
    
    const phi_score = phi_signatures.length > 0 ? 'DETECTED' : 'NONE';
    
    this.results.stageG = {
      phi_signatures: phi_signatures,
      lambda_ratio: lambda_ratio,
      mu_ratio: mu_ratio,
      phi_score: phi_score
    };
    
    log(`œÜ-Resonance: ${phi_score} (${phi_signatures.join(', ') || 'no signatures'})`, phi_score === 'DETECTED' ? 'pass' : '');
  }
  
  computeClassification() {
    const f = this.results.falsification;
    const criteria_met = [
      f.F1_preOmegaFail,
      f.F2_postOmegaPass,
      f.F3_fragility,
      f.F4_strongContraction,
      f.F5_multiSeed,
      f.F6_omegaSelectivity,
      f.F7_smControl
    ].filter(Boolean).length;
    
    if (criteria_met === 7) {
      this.results.classification = 'HIGGS-LIKE';
    } else if (criteria_met >= 5) {
      this.results.classification = 'PARTIAL';
    } else {
      this.results.classification = 'NOT HIGGS-LIKE';
    }
    
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'higgs');
    log(`CLASSIFICATION: ${this.results.classification} (${criteria_met}/7)`, this.results.classification === 'HIGGS-LIKE' ? 'pass' : 'warn');
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'higgs');
  }
  
  computeVValues(ensemble) {
    return ensemble.map(g => {
      const rho = g.getSpectralRadius();
      const trL = g.getLaplacianTrace();
      const H = g.getDegreeEntropy();
      const alpha = 1.0, beta = 0.5, gamma = 0.3;
      return alpha * (rho / g.n) + beta * (trL / g.n) + gamma * H;
    });
  }
}

// ========================================
// UI STATE
// ========================================

let engine = null;
let higgsEngine = null;
let running = false;
let results = null;
let higgsMode = false;

const ui = {
  runBtn: document.getElementById('runPipeline'),
  stopBtn: document.getElementById('stopPipeline'),
  exportBtn: document.getElementById('exportData'),
  logPanel: document.getElementById('logPanel'),
  progressFill: document.getElementById('progressFill'),
  verdictPanel: document.getElementById('verdictPanel'),
  higgsFalsificationPanel: document.getElementById('higgsFalsificationPanel'),
  higgsModeToggle: document.getElementById('higgsModeToggle'),
  higgsOptions: document.getElementById('higgsOptions')
};

// ========================================
// UI FUNCTIONS
// ========================================

function log(message, type = '') {
  const entry = document.createElement('div');
  entry.className = `log-entry ${type}`;
  entry.textContent = message;
  ui.logPanel.appendChild(entry);
  ui.logPanel.scrollTop = ui.logPanel.scrollHeight;
}

function toggleHiggsMode() {
  higgsMode = ui.higgsModeToggle.checked;
  ui.higgsOptions.classList.toggle('visible', higgsMode);
  if (higgsMode) {
    ui.progressFill.classList.add('higgs');
    log('Higgs-Mode ENABLED', 'higgs');
  } else {
    ui.progressFill.classList.remove('higgs');
    log('Higgs-Mode DISABLED', 'warn');
  }
}

function toggleSection(section) {
  const content = document.getElementById(section + 'Content');
  const icon = document.getElementById(section + 'Icon');
  if (content.classList.contains('expanded')) {
    content.classList.remove('expanded');
    icon.textContent = '‚ñ∂';
  } else {
    content.classList.add('expanded');
    icon.textContent = '‚ñº';
  }
}

function updatePipelineStage(stage, data) {
  const stageEl = document.getElementById(`stage${stage}`);
  if (data.size !== undefined) {
    document.getElementById(`size${stage}`).textContent = data.size;
  }
  if (data.RL !== undefined) {
    document.getElementById(`rl${stage}`).textContent = typeof data.RL === 'number' ? data.RL.toFixed(4) : data.RL;
  }
  if (data.CR !== undefined) {
    document.getElementById(`crTau`).textContent = typeof data.CR === 'number' ? data.CR.toFixed(3) : data.CR;
  }
  if (stageEl) stageEl.classList.add('active');
}

function renderFalsificationMatrix(higgs_results) {
  const f = higgs_results.falsification;
  const classification = higgs_results.classification;
  
  const criteria = [
    { label: 'F1: Pre-Œ© FAIL', status: f.F1_preOmegaFail },
    { label: 'F2: Post-Œ© PASS', status: f.F2_postOmegaPass },
    { label: 'F3: Fragility I ‚â• 0.5', status: f.F3_fragility },
    { label: 'F4: CR ‚â§ 0.3', status: f.F4_strongContraction },
    { label: 'F5: Multi-Seed ‚â• 0.8', status: f.F5_multiSeed },
    { label: 'F6: Œ©-Selectivity ‚â§ 0.3', status: f.F6_omegaSelectivity },
    { label: 'F7: SM-Control', status: f.F7_smControl }
  ];
  
  let html = `
    <div class="falsification-matrix">
      <div class="falsification-header">FALSIFICATION CRITERIA (7-Stage Protocol)</div>
      <div class="falsification-disclaimer">
        ‚ö†Ô∏è This classifies structural patterns of Œ©-gated stabilization. It does NOT map SM parameters to seeds.
      </div>
      <div class="falsification-grid">
        <div class="falsification-grid-header">Criterion</div>
        <div class="falsification-grid-header">Required</div>
        <div class="falsification-grid-header">Status</div>
  `;
  
  criteria.forEach(c => {
    html += `
      <div class="falsification-criterion">${c.label}</div>
      <div class="falsification-criterion" style="text-align: center;">Yes</div>
      <div class="falsification-status ${c.status ? 'pass' : 'fail'}">${c.status ? '‚úì PASS' : '‚úó FAIL'}</div>
    `;
  });
  
  html += `</div>`;
  
  const classLabels = {
    'HIGGS-LIKE': '‚úì HIGGS-LIKE',
    'PARTIAL': '‚ö† PARTIAL',
    'NOT HIGGS-LIKE': '‚úó NOT HIGGS-LIKE'
  };
  
  html += `
    <div class="higgs-classification ${classification.toLowerCase().replace(/ /g, '-')}">
      ${classLabels[classification]} (${Object.values(f).filter(Boolean).length}/7 criteria met)
    </div>
  </div>
  `;
  
  ui.higgsFalsificationPanel.innerHTML = html;
  ui.higgsFalsificationPanel.style.display = 'block';
}

function renderVerdict(verdict) {
  const verdictClass = verdict.pass ? 'pass' : 'fail';
  const verdictTitle = verdict.pass ? '‚úì ADMISSIBLE' : '‚úó INADMISSIBLE';
  
  let html = `
    <div class="verdict-box ${verdictClass}">
      <div class="verdict-title ${verdictClass}">${verdictTitle}</div>
      <div class="verdict-content">
        ${verdict.message}
      </div>
    </div>
  `;
  
  ui.verdictPanel.innerHTML = html;
  ui.verdictPanel.style.display = 'block';
}

// ========================================
// MAIN PIPELINE
// ========================================

ui.runBtn.addEventListener('click', async () => {
  running = true;
  ui.runBtn.disabled = true;
  ui.stopBtn.disabled = false;
  ui.exportBtn.disabled = true;
  ui.progressFill.style.width = '0%';
  ui.verdictPanel.style.display = 'none';
  ui.higgsFalsificationPanel.style.display = 'none';
  
  log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
  log(`Starting ${higgsMode ? 'HIGGS-MODE' : 'STANDARD'} Pipeline`, 'header');
  log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
  
  try {
    // Parse seed
    const seedInput = document.getElementById('rngSeed').value.trim();
    let seed = parseInt(seedInput);
    if (isNaN(seed) || seedInput.length > 10) {
      log('Hashing large seed...', 'warn');
      seed = hashSeed(seedInput);
    }
    
    // Configuration
    const config = {
      ensemble_size: parseInt(document.getElementById('ensembleSize').value),
      node_count: parseInt(document.getElementById('nodeCount').value),
      generator: document.getElementById('generatorFamily').value,
      seed: seed,
      omega_keep_fraction: parseFloat(document.getElementById('keepFraction').value)
    };
    
    const tau_family = document.getElementById('tauFamily').value;
    const tau_params = {
      lambda: parseFloat(document.getElementById('tauLambda').value),
      mu: parseFloat(document.getElementById('tauMu').value),
      iterations: parseInt(document.getElementById('tauIterations').value)
    };
    
    const guardrails = {
      delta: parseFloat(document.getElementById('deltaGuardrail').value),
      drift: parseFloat(document.getElementById('driftGuardrail').value)
    };
    
    // Generate ensemble
    engine = new EnsembleEngine(config);
    engine.generateEnsemble();
    
    const RL_baseline = engine.computeRL(engine.V_values);
    updatePipelineStage('E', { size: config.ensemble_size, RL: RL_baseline });
    document.getElementById('metricRL0').textContent = RL_baseline.toFixed(4);
    ui.progressFill.style.width = '20%';
    
    if (higgsMode) {
      // HIGGS-MODE PROTOCOL
      const higgs_config = {
        epsilon: parseFloat(document.getElementById('higgsEpsilon').value),
        multiSeedCount: parseInt(document.getElementById('higgsMultiSeedCount').value),
        omegaSelectivity: document.getElementById('higgsOmegaTest').value === 'enabled',
        phiResonance: document.getElementById('higgsPhiResonance').value === 'enabled'
      };
      
      higgsEngine = new HiggsModeEngine(engine, higgs_config);
      
      const higgs_results = await higgsEngine.runFullProtocol(
        tau_family, 
        tau_params, 
        guardrails,
        (stage, progress) => {
          ui.progressFill.style.width = `${progress}%`;
        }
      );
      
      // Update UI with results
      updatePipelineStage('Omega', { 
        size: engine.omega_ensemble.length, 
        RL: higgs_results.stageB.RL_omega 
      });
      updatePipelineStage('Tau', { 
        RL: higgs_results.stageB.RL_tau,
        CR: higgs_results.stageB.CR
      });
      
      // Update Core Metrics boxes
      document.getElementById('metricRL0').textContent = higgs_results.stageA.RL_baseline.toFixed(4);
      document.getElementById('metricRLOmega').textContent = higgs_results.stageB.RL_omega.toFixed(4);
      document.getElementById('metricRLTau').textContent = higgs_results.stageB.RL_tau.toFixed(4);
      const crElement = document.getElementById('metricCR');
      crElement.textContent = higgs_results.stageB.CR.toFixed(3);
      // Color code CR based on strength
      if (higgs_results.stageB.CR <= 0.3) {
        crElement.className = 'metric-value good'; // Strong contraction
      } else if (higgs_results.stageB.CR <= 0.7) {
        crElement.className = 'metric-value warn'; // Moderate
      } else {
        crElement.className = 'metric-value bad'; // Weak
      }
      
      // Render falsification matrix
      renderFalsificationMatrix(higgs_results);
      
      // Render verdict
      const verdict_message = `
        <strong>Higgs-Mode Classification: ${higgs_results.classification}</strong><br><br>
        Criteria Met: ${Object.values(higgs_results.falsification).filter(Boolean).length}/7<br>
        Pre-Œ©: ${higgs_results.stageA.pass ? 'PASS' : 'FAIL'} (CR=${higgs_results.stageA.CR.toFixed(3)})<br>
        Post-Œ©: ${higgs_results.stageB.pass ? 'PASS' : 'FAIL'} (CR=${higgs_results.stageB.CR.toFixed(3)})<br>
        Fragility Index: ${higgs_results.stageC.fragility_index.toFixed(3)}<br>
        ${higgs_results.stageD && !higgs_results.stageD.skipped ? `Multi-Seed Consistency: ${(higgs_results.stageD.consistency*100).toFixed(0)}%<br>` : ''}
        ${higgs_results.stageG && !higgs_results.stageG.skipped ? `œÜ-Resonance: ${higgs_results.stageG.phi_score}` : ''}
      `;
      
      renderVerdict({
        pass: higgs_results.classification === 'HIGGS-LIKE',
        message: verdict_message
      });
      
      results = {
        mode: 'HIGGS',
        higgs_results: higgs_results,
        config: config,
        tau: { family: tau_family, params: tau_params },
        guardrails: guardrails
      };
      
    } else {
      // STANDARD MODE
      engine.applyOmega4b();
      const V_omega = engine.V_values.filter((_, i) => engine.omega_indices.includes(i));
      const RL_omega = engine.computeRL(V_omega);
      
      updatePipelineStage('Omega', { size: engine.omega_ensemble.length, RL: RL_omega });
      ui.progressFill.style.width = '50%';
      
      engine.applyTau(tau_family, tau_params);
      const I_tau = engine.computeInvariants(engine.tau_ensemble);
      const V_tau = I_tau.map(inv => {
        const alpha = 1.0, beta = 0.5, gamma = 0.3;
        return alpha * inv.scaled_spectral_radius + beta * inv.energy_per_node + gamma * inv.degree_entropy;
      });
      const RL_tau = engine.computeRL(V_tau);
      const CR = RL_tau / RL_omega;
      
      updatePipelineStage('Tau', { RL: RL_tau, CR: CR });
      ui.progressFill.style.width = '100%';
      
      // Update Core Metrics boxes
      const RL_baseline = engine.computeRL(engine.V_values);
      document.getElementById('metricRL0').textContent = RL_baseline.toFixed(4);
      document.getElementById('metricRLOmega').textContent = RL_omega.toFixed(4);
      document.getElementById('metricRLTau').textContent = RL_tau.toFixed(4);
      const crElement = document.getElementById('metricCR');
      crElement.textContent = CR.toFixed(3);
      // Color code CR
      if (CR <= 0.3) {
        crElement.className = 'metric-value good';
      } else if (CR <= 0.7) {
        crElement.className = 'metric-value warn';
      } else {
        crElement.className = 'metric-value bad';
      }
      
      const improvement = RL_omega - RL_tau;
      const passed = CR < 1.0 && improvement >= guardrails.delta;
      
      const verdict_message = `
        Contraction Ratio: ${CR.toFixed(3)}<br>
        Residual Improvement: ${improvement.toFixed(4)}<br>
        Status: ${passed ? 'PASS' : 'FAIL'}
      `;
      
      renderVerdict({
        pass: passed,
        message: verdict_message
      });
      
      results = {
        mode: 'STANDARD',
        RL_omega: RL_omega,
        RL_tau: RL_tau,
        CR: CR,
        config: config,
        tau: { family: tau_family, params: tau_params }
      };
    }
    
    ui.exportBtn.disabled = false;
    log('Pipeline complete!', 'pass');
    
  } catch (error) {
    log(`ERROR: ${error.message}`, 'fail');
    console.error(error);
  } finally {
    running = false;
    ui.runBtn.disabled = false;
    ui.stopBtn.disabled = true;
  }
});

// Export button
ui.exportBtn.addEventListener('click', () => {
  if (!results) {
    log('No results to export', 'warn');
    return;
  }
  
  const export_data = {
    meta: {
      chamber: 'XXXV',
      mode: results.mode,
      timestamp: new Date().toISOString(),
      version: '1.0.0-higgs'
    },
    ...results
  };
  
  const blob = new Blob([JSON.stringify(export_data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const mode_suffix = results.mode === 'HIGGS' ? 'HIGGS' : 'STD';
  a.download = `LPF-OmegaTau-${mode_suffix}_${results.tau.family}_${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  log(`Exported: ${a.download}`, 'pass');
});

// Helper: Hash large seeds
function hashSeed(str) {
  let hash = 2166136261;
  for (let i = 0; i < str.length; i++) {
    hash ^= str.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}

// Lambda/Mu sliders
document.getElementById('tauLambda').addEventListener('input', (e) => {
  document.getElementById('lambdaValue').textContent = parseFloat(e.target.value).toFixed(2);
});

document.getElementById('tauMu').addEventListener('input', (e) => {
  document.getElementById('muValue').textContent = parseFloat(e.target.value).toFixed(2);
});

// Initialize
ui.higgsModeToggle.checked = false;
log('‚úÖ Chamber XXXV + Higgs-Mode ready!', 'pass');
  </script>
</body>
</html>
