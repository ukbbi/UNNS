<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory ‚Äì Chamber XXXIV (Œ©-ONLY)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Consolas', 'Monaco', monospace; background: #0a0a0a; color: #e0e0e0; }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    header { text-align: center; margin-bottom: 30px; padding: 20px; border-bottom: 2px solid #2a2a2a; }
    h1 { font-size: 2em; color: #ff4a9e; letter-spacing: 2px; }
    .subtitle { color: #888; margin-top: 10px; font-size: 0.9em; }
    .phase-tag { display: inline-block; background: #2a1a4a; color: #ff4aff; padding: 4px 12px; border-radius: 4px; font-size: 0.85em; margin-top: 8px; }
    .panel { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 8px; padding: 20px; margin-bottom: 20px; }
    .panel-title { font-size: 1.2em; color: #ff4a9e; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #2a2a2a; }
    .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; }
    .control-group { display: flex; flex-direction: column; }
    label { font-size: 0.9em; color: #aaa; margin-bottom: 5px; }
    input[type="number"], input[type="range"], select { background: #0a0a0a; border: 1px solid #3a3a3a; color: #e0e0e0; padding: 8px; border-radius: 4px; font-family: inherit; }
    button { background: #2a4a7a; border: none; color: #e0e0e0; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-family: inherit; margin-right: 10px; margin-bottom: 10px; }
    button:hover { background: #3a5a8a; }
    button:disabled { background: #1a1a1a; color: #555; cursor: not-allowed; }
    .button-primary { background: #ff4a9e; }
    .button-primary:hover { background: #ff5aae; }
    .visualization { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
    .canvas-container { position: relative; background: #000; border: 1px solid #2a2a2a; min-height: 300px; }
    canvas { width: 100%; height: 100%; }
    .canvas-label { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 3px; font-size: 0.9em; color: #ff4a9e; }
    .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin-top: 15px; }
    .metric { background: #0a0a0a; padding: 10px; border-radius: 4px; border: 1px solid #2a2a2a; }
    .metric-label { font-size: 0.8em; color: #888; margin-bottom: 5px; }
    .metric-value { font-size: 1.2em; color: #ff4a9e; font-weight: bold; }
    .metric-value.good { color: #4aff4a; }
    .metric-value.warn { color: #ffa54a; }
    .metric-value.bad { color: #ff4a4a; }
    .status { padding: 10px; border-radius: 4px; margin-top: 15px; font-size: 0.9em; }
    .status.running { background: #2a4a2a; color: #4aff4a; }
    .status.complete { background: #2a3a4a; color: #4a9eff; }
    .status.pass { background: #1a3a1a; color: #4aff4a; border-left: 4px solid #4aff4a; }
    .status.fail { background: #3a1a1a; color: #ff4a4a; border-left: 4px solid #ff4a4a; }
    .progress-bar { width: 100%; height: 4px; background: #1a1a1a; border-radius: 2px; overflow: hidden; margin-top: 10px; }
    .progress-fill { height: 100%; background: #ff4a9e; transition: width 0.3s; }
    table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 0.9em; }
    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #2a2a2a; }
    th { color: #ff4a9e; }
    .info-box { background: #0a1a2a; border-left: 3px solid #4a9eff; padding: 12px; margin: 15px 0; border-radius: 4px; }
    .warning-box { background: #2a1a1a; border-left: 3px solid #ff4a4a; padding: 12px; margin: 15px 0; border-radius: 4px; }
    code { background: #0a0a0a; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚öõÔ∏è CHAMBER XXXIV: Œ©-ONLY EXPLORATORY</h1>
      <div class="subtitle">Global Mode Selection & Vacuum Admissibility</div>
      <div class="phase-tag">PHASE F: EXPLORATORY</div>
    </header>
    
    <div class="panel">
      <div class="panel-title">Configuration</div>
      
      <h3 style="color: #4a9eff; margin-bottom: 10px;">Ensemble Generation</h3>
      <div class="controls">
        <div class="control-group">
          <label>Ensemble Size (M)</label>
          <input type="number" id="ensembleSize" value="100" min="20" max="500">
        </div>
        <div class="control-group">
          <label>Nodes per Structure (n)</label>
          <input type="number" id="nodeCount" value="50" min="20" max="300">
        </div>
        <div class="control-group">
          <label>Generator Family</label>
          <select id="generatorFamily">
            <option value="lattice-lr">Lattice + Long-Range</option>
            <option value="small-world">Small-World</option>
            <option value="scale-free">Scale-Free</option>
          </select>
        </div>
        <div class="control-group">
          <label>Long-Range Edge Prob <span id="lrProbValue">0.05</span></label>
          <input type="range" id="lrProb" min="0" max="0.2" step="0.01" value="0.05">
        </div>
        <div class="control-group">
          <label>RNG Seed</label>
          <input type="number" id="rngSeed" value="137042">
        </div>
      </div>
      
      <h3 style="color: #4a9eff; margin: 20px 0 10px;">Œ© Selection Operator</h3>
      <div class="controls">
        <div class="control-group">
          <label>Œ© Mode</label>
          <select id="omegaMode">
            <option value="omega1">Œ©‚ÇÅ: Zero-Mode Culling</option>
            <option value="omega2">Œ©‚ÇÇ: Holonomy Bandpass</option>
            <option value="omega3">Œ©‚ÇÉ: Spectral Gap Floor</option>
            <option value="omega4a">Œ©‚ÇÑa: Min-V (Exploratory)</option>
            <option value="omega4b" selected>Œ©‚ÇÑb: V-Bandpass (RŒõ-Aligned)</option>
          </select>
        </div>
        <div class="control-group">
          <label>Z‚ÇÄ Max (Œ©‚ÇÅ) <span id="z0MaxValue">0.15</span></label>
          <input type="range" id="z0Max" min="0.05" max="0.3" step="0.01" value="0.15">
        </div>
        <div class="control-group">
          <label>Gap Min (Œ©‚ÇÉ) <span id="gapMinValue">0.05</span></label>
          <input type="range" id="gapMin" min="0.01" max="0.2" step="0.01" value="0.05">
        </div>
        <div class="control-group">
          <label>Cycle Min <span id="cycleMinValue">0.05</span></label>
          <input type="range" id="cycleMin" min="0" max="0.5" step="0.01" value="0.05">
        </div>
        <div class="control-group">
          <label>Cycle Max <span id="cycleMaxValue">0.4</span></label>
          <input type="range" id="cycleMax" min="0.1" max="1.0" step="0.01" value="0.4">
        </div>
        <div class="control-group">
          <label>Keep Fraction (Œ©‚ÇÑ) <span id="keepFractionValue">30%</span></label>
          <input type="range" id="keepFraction" min="10" max="90" step="5" value="30">
        </div>
      </div>
      
      <h3 style="color: #4a9eff; margin: 20px 0 10px;">Vacuum Proxy Weights</h3>
      <div class="controls">
        <div class="control-group">
          <label>Œ± (Z‚ÇÄ weight) <span id="alphaValue">1.0</span></label>
          <input type="range" id="alphaWeight" min="0" max="2" step="0.1" value="1.0">
        </div>
        <div class="control-group">
          <label>Œ≤ (Gap weight) <span id="betaValue">1.0</span></label>
          <input type="range" id="betaWeight" min="0" max="2" step="0.1" value="1.0">
        </div>
        <div class="control-group">
          <label>Œ≥ (Cycle weight) <span id="gammaValue">0.5</span></label>
          <input type="range" id="gammaWeight" min="0" max="2" step="0.1" value="0.5">
        </div>
      </div>
      
      <button id="runExperiment" class="button-primary">‚ñ∂ Run Experiment</button>
      <button id="stopExperiment" disabled>‚è∏ Stop</button>
      <button id="exportData" disabled>üíæ Export Data</button>
      
      <div id="statusDisplay" class="status" style="display: none;"></div>
      <div class="progress-bar"><div id="progressFill" class="progress-fill" style="width: 0%;"></div></div>
    </div>
    
    <div class="panel">
      <div class="panel-title">Visualization</div>
      <div class="visualization">
        <div class="canvas-container">
          <canvas id="canvasHistogram"></canvas>
          <div class="canvas-label">V(S) Distribution: Baseline vs Œ©-Filtered</div>
        </div>
        <div class="canvas-container">
          <canvas id="canvasScatter"></canvas>
          <div class="canvas-label">Z‚ÇÄ vs Gap: Accept/Reject Scatter</div>
        </div>
      </div>
    </div>
    
    <div class="panel">
      <div class="panel-title">Results Summary</div>
      
      <h3 style="color: #4a9eff; margin-bottom: 10px;">Baseline vs Œ©-Filtered</h3>
      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Acceptance Rate</div>
          <div class="metric-value" id="metricAcceptRate">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">RŒõ Baseline</div>
          <div class="metric-value" id="metricRLambdaBase">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">RŒõ Filtered</div>
          <div class="metric-value" id="metricRLambdaOmega">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">RŒõ Reduction</div>
          <div class="metric-value" id="metricRLambdaReduction">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">VÃÑ Baseline</div>
          <div class="metric-value" id="metricVBarBase">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">VÃÑ Filtered</div>
          <div class="metric-value" id="metricVBarOmega">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Var(V) Baseline</div>
          <div class="metric-value" id="metricVarBase">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Var(V) Filtered</div>
          <div class="metric-value" id="metricVarOmega">‚Äî</div>
        </div>
      </div>
      
      <h3 style="color: #4a9eff; margin: 20px 0 10px;">Protected Macro Invariants (œÑ-derived)</h3>
      <table>
        <thead>
          <tr>
            <th>Invariant</th>
            <th>Baseline</th>
            <th>Œ©-Filtered</th>
            <th>Drift %</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="macroInvariantsTable">
          <tr><td colspan="5" style="text-align: center; color: #666;">Run experiment to populate...</td></tr>
        </tbody>
      </table>
      
      <div id="verdictDisplay" class="status" style="display: none; margin-top: 20px;"></div>
    </div>
    
    <div class="panel">
      <div class="panel-title">üìö Chamber Guide</div>
      <div style="line-height: 1.6; color: #aaa;">
        <h3 style="color: #ff4a9e; font-size: 1.1em; margin-bottom: 10px;">Purpose</h3>
        <p>Chamber XXXIV tests whether a <strong>global selection layer (Œ©)</strong> can measurably reduce vacuum residuals (<code>RŒõ</code>) while keeping œÑ-scale macro invariants stable. This is an <em>Œ©-only</em> exploratory chamber‚Äîno internal confinement operators (œÉ/Œ∫), just pure ensemble selection.</p>
        
        <h3 style="color: #ff4a9e; font-size: 1.1em; margin: 20px 0 10px;">Key Question</h3>
        <div class="info-box">
          <strong>Does Œ© signature exist?</strong> Can global mode selection reduce vacuum residual proxies without destabilizing protected metrics?
        </div>
        
        <h3 style="color: #ff4a9e; font-size: 1.1em; margin: 20px 0 10px;">Operational Model</h3>
        <p><strong>Ensemble E = {S‚ÇÅ, S‚ÇÇ, ..., S‚Çò}:</strong> Collection of graph structures generated under controlled constraints</p>
        <p><strong>Vacuum Proxy V(S):</strong> Global observable combining:</p>
        <ul style="margin: 10px 0 10px 20px;">
          <li><code>Z‚ÇÄ(S)</code> = Zero-mode mass (near-null eigenvalue count / n)</li>
          <li><code>Gap(S)</code> = Spectral gap (Fiedler value Œª‚ÇÇ of Laplacian)</li>
          <li><code>CycleT(S)</code> = Cycle tension (|E| - |V| + components) / n</li>
        </ul>
        <p style="margin-top: 10px;"><strong>Formula:</strong> <code>V(S) = Œ±¬∑Z‚ÇÄ(S) + Œ≤¬∑(1/(Gap(S)+Œµ)) + Œ≥¬∑CycleT(S)</code></p>
        
        <p style="margin-top: 15px;"><strong>Œõ Residual Proxy:</strong> <code>RŒõ = |VÃÑ - V_target| / max(|V_target|, Œµ)</code></p>
        <p>Measures how far the ensemble-averaged <code>VÃÑ</code> deviates from expected stationary vacuum band.</p>
        
        <h3 style="color: #ff4a9e; font-size: 1.1em; margin: 20px 0 10px;">Œ© Operators</h3>
        <table style="font-size: 0.95em;">
          <tr>
            <th>Operator</th>
            <th>Mechanism</th>
            <th>Interpretation</th>
          </tr>
          <tr>
            <td><strong>Œ©‚ÇÅ</strong></td>
            <td>Zero-Mode Culling</td>
            <td>Reject if Z‚ÇÄ(S) > z‚ÇÄ_max</td>
          </tr>
          <tr>
            <td><strong>Œ©‚ÇÇ</strong></td>
            <td>Holonomy Bandpass</td>
            <td>Keep only if c_min ‚â§ CycleT(S) ‚â§ c_max</td>
          </tr>
          <tr>
            <td><strong>Œ©‚ÇÉ</strong></td>
            <td>Spectral Gap Floor</td>
            <td>Reject if Gap(S) < gap_min</td>
          </tr>
          <tr>
            <td><strong>Œ©‚ÇÑa</strong></td>
            <td>Min-V (Exploratory)</td>
            <td>Select lowest V(S) structures (may worsen RŒõ)</td>
          </tr>
          <tr>
            <td><strong>Œ©‚ÇÑb</strong></td>
            <td>V-Bandpass (RŒõ-Aligned)</td>
            <td>Select structures closest to V_target (guaranteed RŒõ reduction)</td>
          </tr>
        </table>
        
        <div class="info-box" style="margin-top: 15px;">
          <strong style="color: #ff4a9e;">‚ö†Ô∏è Œ©‚ÇÑa vs Œ©‚ÇÑb ‚Äî Important Distinction</strong>
          <p style="margin: 10px 0 5px;"><strong>Œ©‚ÇÑa (Minimum-V):</strong> Exploratory operator that selects structures with lowest V(S) values regardless of baseline V_target. This can reduce VÃÑ but may <em>increase</em> RŒõ (vacuum residual), which is scientifically valid behavior for an exploratory selector. PASS/FAIL verdicts both meaningful.</p>
          <p style="margin: 5px 0;"><strong>Œ©‚ÇÑb (V-Bandpass):</strong> Canonical operator that selects structures closest to V_target (baseline median). Guaranteed to reduce RŒõ by construction. This is the RŒõ-aligned operator ‚Äî PASS verdict indicates true Œ©‚ÜíœÑ compatibility.</p>
          <p style="margin: 5px 0 0;"><strong>Key Insight:</strong> Only Œ©‚ÇÑb is aligned with the vacuum residual metric RŒõ. Œ©‚ÇÑa serves as an exploratory selector testing a different hypothesis (minimum absolute vacuum proxy) and may legitimately worsen RŒõ while still being admissible.</p>
        </div>
        
        <h3 style="color: #ff4a9e; font-size: 1.1em; margin: 20px 0 10px;">Success Criteria</h3>
        <div class="info-box">
          <p style="margin-bottom: 8px;"><strong>Œ© Signature Detected if:</strong></p>
          <ul style="margin: 0 0 0 20px; line-height: 1.8;">
            <li><code>RŒõ_Œ© < RŒõ‚ÇÄ - Œ¥</code> (meaningful reduction, Œ¥ > 5%)</li>
            <li>Macro invariant drift ‚â§ 10% (stability preserved)</li>
            <li>Acceptance rate: 10‚Äì60% (coherent band, not degenerate)</li>
            <li>Stable across seeds (reproducible)</li>
          </ul>
        </div>
        
        <h3 style="color: #ff4a9e; font-size: 1.1em; margin: 20px 0 10px;">Protected Metrics (ADM Framework)</h3>
        <p>These œÑ-derived macro invariants <strong>must remain stable</strong> (drift ‚â§ 10%):</p>
        <ul style="margin: 10px 0 10px 20px;">
          <li><strong>scaled_spectral_radius:</strong> Ensemble mean of œÅ(A)/n</li>
          <li><strong>energy_per_node:</strong> Tr(L)/n averaged over ensemble</li>
          <li><strong>entropy_degree:</strong> -Œ£ p·µ¢ log(p·µ¢) from degree distribution (total entropy, not per-edge)</li>
        </ul>
        
        <h3 style="color: #ff4a9e; font-size: 1.1em; margin: 20px 0 10px;">Interpretation</h3>
        <p>If Œ© signature is detected with stable protected metrics, this suggests:</p>
        <ul style="margin: 10px 0 10px 20px; line-height: 1.8;">
          <li><strong>Global selection</strong> can structure vacuum admissibility</li>
          <li><strong>Vacuum residuals</strong> are sensitive to global mode constraints</li>
          <li><strong>Œ© layer</strong> is a legitimate addition to UNNS operator suite</li>
          <li>Foundation for <strong>Chamber XXXV</strong>: Coupled Œ©‚ÜíœÑ pipeline</li>
        </ul>
        
        <div class="warning-box">
          <p><strong>‚ö†Ô∏è Important Notes:</strong></p>
          <ul style="margin: 8px 0 0 20px; line-height: 1.6;">
            <li>XXXIV is <em>exploratory</em>‚Äînull results are valuable</li>
            <li>If acceptance rate ‚Üí 0% or 100%, Œ© parameters need tuning</li>
            <li>Variance reduction alone is not sufficient‚ÄîRŒõ must decrease</li>
            <li>Protected metrics must stay stable for valid Œ© signature</li>
          </ul>
        </div>
        
        <h3 style="color: #ff4a9e; font-size: 1.1em; margin: 20px 0 10px;">Recommended Workflow</h3>
        <ol style="margin: 10px 0 10px 20px; line-height: 1.8;">
          <li><strong>Quick Test:</strong> M=50, n=30, Œ©‚ÇÑ with default weights (~30sec)</li>
          <li><strong>Balanced Run:</strong> M=100, n=50, test all Œ© modes (~2-3min)</li>
          <li><strong>Production Run:</strong> M=200, n=100, Œ©‚ÇÑ optimal parameters (~8-10min)</li>
          <li><strong>Multi-Seed:</strong> Repeat with seeds [137042, 137043, 137044] for reproducibility</li>
          <li><strong>Generator Comparison:</strong> Test across lattice-lr, small-world, scale-free</li>
          <li><strong>Export & Analyze:</strong> Save JSON for each configuration</li>
        </ol>
        
        <p style="margin-top: 20px; font-size: 0.85em; color: #666; border-top: 1px solid #2a2a2a; padding-top: 15px;">
          <strong>Version:</strong> 1.1.0 (Bug Fixes) | <strong>Phase:</strong> F (Exploratory) | <strong>Status:</strong> Production Ready
        </p>
        
        <div style="margin-top: 15px; padding: 12px; background: #1a2a1a; border-left: 3px solid #4aff4a; border-radius: 4px;">
          <strong style="color: #4aff4a;">v1.1.0 Changelog (Critical Fixes):</strong>
          <ul style="margin: 8px 0 0 20px; line-height: 1.6; font-size: 0.85em;">
            <li><strong>Fixed Z‚ÇÄ:</strong> Now uses exact component count / n (was incorrect eigenvalue-based)</li>
            <li><strong>Fixed Gap:</strong> Proper Fiedler value approximation via Rayleigh quotient (was largest eigenvalue)</li>
            <li><strong>Fixed RŒõ:</strong> Shared baseline V_target for filtered ensemble (was incomparable)</li>
            <li><strong>Fixed energy_per_node:</strong> Exact trace(L) = 2|E| / n (was partial eigenvalue sum)</li>
            <li><strong>Fixed entropy:</strong> Total degree entropy with robust drift calculation (denominator floor)</li>
            <li><strong>Fixed lattice generator:</strong> Uses actualN to avoid isolated nodes when n not perfect square</li>
            <li><strong>Fixed small-world:</strong> True rewiring (removes old edge before adding new)</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  
  <script>
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('UNNS Phase F | Chamber XXXIV ‚Äî Œ©-Only | v1.1.0 (Bug Fixes)');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

// ============================================
// SEEDED RNG
// ============================================

class SeededRNG {
  constructor(seed) {
    this.state = seed >>> 0;
  }
  
  random() {
    this.state = (this.state * 1664525 + 1013904223) >>> 0;
    return this.state / 4294967296;
  }
  
  gaussian() {
    let u1 = this.random();
    let u2 = this.random();
    if (u1 < 1e-10) u1 = 1e-10;
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
}

// ============================================
// GRAPH STRUCTURE
// ============================================

class GraphStructure {
  constructor(n, seed = 0) {
    this.n = n;
    this.edges = [];
    this.adj = Array(n).fill(null).map(() => []);
    this.seed = seed;
    this.rng = new SeededRNG(seed);
  }
  
  addEdge(i, j) {
    if (i === j) return; // No self-loops
    if (!this.adj[i].includes(j)) {
      this.adj[i].push(j);
      this.adj[j].push(i);
      this.edges.push([i, j]);
    }
  }
  
  removeEdge(i, j) {
    // Remove from adjacency lists
    const idx_i = this.adj[i].indexOf(j);
    if (idx_i !== -1) {
      this.adj[i].splice(idx_i, 1);
    }
    const idx_j = this.adj[j].indexOf(i);
    if (idx_j !== -1) {
      this.adj[j].splice(idx_j, 1);
    }
    // Remove from edges list
    this.edges = this.edges.filter(e => 
      !(e[0] === i && e[1] === j) && !(e[0] === j && e[1] === i)
    );
  }
  
  getLaplacian() {
    const L = Array(this.n).fill(null).map(() => Array(this.n).fill(0));
    
    // Fill adjacency part
    for (let i = 0; i < this.n; i++) {
      for (let j of this.adj[i]) {
        L[i][j] = -1;
      }
      L[i][i] = this.adj[i].length; // Degree on diagonal
    }
    
    return L;
  }
  
  getAdjacencyMatrix() {
    const A = Array(this.n).fill(null).map(() => Array(this.n).fill(0));
    for (let i = 0; i < this.n; i++) {
      for (let j of this.adj[i]) {
        A[i][j] = 1;
      }
    }
    return A;
  }
  
  getComponentCount() {
    const visited = Array(this.n).fill(false);
    let count = 0;
    
    const dfs = (node) => {
      visited[node] = true;
      for (let neighbor of this.adj[node]) {
        if (!visited[neighbor]) dfs(neighbor);
      }
    };
    
    for (let i = 0; i < this.n; i++) {
      if (!visited[i]) {
        dfs(i);
        count++;
      }
    }
    
    return count;
  }
}

// ============================================
// ENSEMBLE GENERATOR
// ============================================

class EnsembleGenerator {
  constructor(config) {
    this.M = config.ensembleSize || 200;
    this.n = config.nodeCount || 100;
    this.family = config.generatorFamily || 'lattice-lr';
    this.lrProb = config.lrProb || 0.05;
    this.seed = config.seed || 137042;
    this.rng = new SeededRNG(this.seed);
  }
  
  generate() {
    const ensemble = [];
    
    for (let i = 0; i < this.M; i++) {
      const structSeed = this.seed + i;
      let structure;
      
      switch (this.family) {
        case 'lattice-lr':
          structure = this.generateLatticeLongRange(structSeed);
          break;
        case 'small-world':
          structure = this.generateSmallWorld(structSeed);
          break;
        case 'scale-free':
          structure = this.generateScaleFree(structSeed);
          break;
        default:
          structure = this.generateLatticeLongRange(structSeed);
      }
      
      ensemble.push(structure);
    }
    
    return ensemble;
  }
  
  generateLatticeLongRange(seed) {
    // Create 2D lattice topology
    const gridSize = Math.floor(Math.sqrt(this.n));
    const actualN = gridSize * gridSize;
    
    // CRITICAL: Create graph with actualN nodes, not this.n
    // This prevents isolated nodes when this.n is not a perfect square
    const graph = new GraphStructure(actualN, seed);
    const rng = new SeededRNG(seed);
    
    // Nearest-neighbor connections
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const idx = x + y * gridSize;
        // Right neighbor
        if (x < gridSize - 1) {
          graph.addEdge(idx, idx + 1);
        }
        // Down neighbor
        if (y < gridSize - 1) {
          graph.addEdge(idx, idx + gridSize);
        }
        // Periodic boundary
        if (x === gridSize - 1) {
          graph.addEdge(idx, y * gridSize);
        }
        if (y === gridSize - 1) {
          graph.addEdge(idx, x);
        }
      }
    }
    
    // Add long-range edges
    const numLR = Math.floor(actualN * this.lrProb);
    for (let k = 0; k < numLR; k++) {
      const i = Math.floor(rng.random() * actualN);
      const j = Math.floor(rng.random() * actualN);
      if (i !== j) {
        graph.addEdge(i, j);
      }
    }
    
    return graph;
  }
  
  generateSmallWorld(seed) {
    const graph = new GraphStructure(this.n, seed);
    const rng = new SeededRNG(seed);
    const k = 4; // Nearest neighbors
    
    // Ring lattice
    for (let i = 0; i < this.n; i++) {
      for (let j = 1; j <= k / 2; j++) {
        graph.addEdge(i, (i + j) % this.n);
      }
    }
    
    // Rewire with probability (true Watts-Strogatz model)
    for (let i = 0; i < this.n; i++) {
      const neighbors = [...graph.adj[i]];
      for (let j of neighbors) {
        if (j > i && rng.random() < this.lrProb) {
          // True rewiring: remove old edge (i, j) and add new edge (i, newTarget)
          let newTarget = Math.floor(rng.random() * this.n);
          while (newTarget === i || graph.adj[i].includes(newTarget)) {
            newTarget = Math.floor(rng.random() * this.n);
          }
          graph.removeEdge(i, j); // Remove old edge
          graph.addEdge(i, newTarget); // Add new edge
        }
      }
    }
    
    return graph;
  }
  
  generateScaleFree(seed) {
    const graph = new GraphStructure(this.n, seed);
    const rng = new SeededRNG(seed);
    const m0 = 3; // Initial complete graph size
    const m = 2;  // Edges per new node
    
    // Start with complete graph
    for (let i = 0; i < m0; i++) {
      for (let j = i + 1; j < m0; j++) {
        graph.addEdge(i, j);
      }
    }
    
    // Preferential attachment
    for (let newNode = m0; newNode < this.n; newNode++) {
      const degrees = graph.adj.map(adj => adj.length);
      const totalDegree = degrees.reduce((a, b) => a + b, 0);
      
      const targets = new Set();
      while (targets.size < Math.min(m, newNode)) {
        const r = rng.random() * totalDegree;
        let sum = 0;
        for (let i = 0; i < newNode; i++) {
          sum += degrees[i];
          if (sum >= r && !targets.has(i)) {
            targets.add(i);
            break;
          }
        }
      }
      
      for (let target of targets) {
        graph.addEdge(newNode, target);
      }
    }
    
    return graph;
  }
}

// ============================================
// LANCZOS Œª‚ÇÇ COMPUTATION (Robust Spectral Gap)
// ============================================

/**
 * Laplacian-vector multiply (implicit operator)
 * L = D - A where D is degree matrix
 */
function laplacianMultiply(adj, v) {
  const n = adj.length;
  const out = new Array(n).fill(0);
  
  for (let i = 0; i < n; i++) {
    const deg = adj[i].length;
    let sum = deg * v[i];
    for (const j of adj[i]) {
      sum -= v[j];
    }
    out[i] = sum;
  }
  return out;
}

/**
 * Vector utilities
 */
function dot(a, b) {
  let s = 0;
  for (let i = 0; i < a.length; i++) s += a[i] * b[i];
  return s;
}

function norm(v) {
  return Math.sqrt(dot(v, v));
}

function normalize(v) {
  const n = norm(v);
  if (n === 0) return v.slice();
  return v.map(x => x / n);
}

function randomUnitVector(n, seed = 0) {
  const rng = new SeededRNG(seed);
  const v = new Array(n);
  for (let i = 0; i < n; i++) v[i] = rng.random() - 0.5;
  return normalize(v);
}

/**
 * Project out constant vector (removes Œª‚ÇÅ = 0 mode)
 * Critical for Laplacian spectral analysis
 */
function projectOutConstant(v) {
  const n = v.length;
  const mean = v.reduce((a, b) => a + b, 0) / n;
  return v.map(x => x - mean);
}

/**
 * Lanczos iteration for Œª‚ÇÇ (Fiedler value)
 * Builds tridiagonal reduction and extracts smallest positive eigenvalue
 */
function lanczosLambda2(adj, opts = {}) {
  const n = adj.length;
  const maxIter = opts.maxIter || 40;
  const tol = opts.tol || 1e-6;
  const seed = opts.seed || 0;
  
  // Initial vector (orthogonal to constant)
  let q = projectOutConstant(randomUnitVector(n, seed));
  q = normalize(q);
  
  let qPrev = new Array(n).fill(0);
  let alpha = [];
  let beta = [];
  
  let betaPrev = 0;
  
  for (let k = 0; k < maxIter; k++) {
    // w = L q_k
    let w = laplacianMultiply(adj, q);
    
    // alpha_k = q_k^T w
    const a = dot(q, w);
    alpha.push(a);
    
    // w = w - alpha_k q_k - beta_{k-1} q_{k-1}
    for (let i = 0; i < n; i++) {
      w[i] -= a * q[i] + betaPrev * qPrev[i];
    }
    
    // Remove constant component again (numerical safety)
    w = projectOutConstant(w);
    
    const b = norm(w);
    beta.push(b);
    
    if (b < tol) break;
    
    // Shift vectors
    qPrev = q;
    q = w.map(x => x / b);
    betaPrev = b;
  }
  
  // Build tridiagonal T
  const m = alpha.length;
  const T = Array.from({ length: m }, (_, i) =>
    Array.from({ length: m }, (_, j) => {
      if (i === j) return alpha[i];
      if (j === i + 1) return beta[i];
      if (i === j + 1) return beta[j];
      return 0;
    })
  );
  
  // Solve eigenvalues of small T
  const eigs = symmetricEigenvalues(T);
  eigs.sort((a, b) => a - b);
  
  // Œª‚ÇÇ is smallest positive eigenvalue
  for (const Œª of eigs) {
    if (Œª > tol) return Œª;
  }
  
  return 0;
}

/**
 * --- Œª‚ÇÇ confidence sampling (v1.2.0) ---
 * Repeats Lanczos with different seeds to estimate mean + 95% CI.
 * Designed for n ‚â§ 300 and m ‚â§ 40.
 */
function mean(arr) {
  return arr.reduce((a, b) => a + b, 0) / arr.length;
}

function stddev(arr, mu) {
  if (arr.length < 2) return 0;
  const v = arr.reduce((s, x) => s + (x - mu) * (x - mu), 0) / (arr.length - 1);
  return Math.sqrt(v);
}

// 95% t critical values (two-sided) for small df; falls back to 1.96
const T_CRITICAL_95 = {
  4: 2.776, 5: 2.571, 6: 2.447, 7: 2.365, 8: 2.306, 9: 2.262,
  10: 2.228, 11: 2.201, 12: 2.179, 13: 2.160, 14: 2.145, 15: 2.131,
  16: 2.120, 17: 2.110, 18: 2.101, 19: 2.093, 20: 2.086
};

function tCritical95(df) {
  if (df <= 0) return 1.96;
  if (df in T_CRITICAL_95) return T_CRITICAL_95[df];
  if (df < 4) return 2.776; // conservative
  return 1.96;
}

function sampleLambda2(adj, opts = {}) {
  const runs = opts.runs || 12;
  const maxIter = opts.maxIter || 40;
  const tol = opts.tol || 1e-6;
  const baseSeed = opts.seed || 0;

  const values = [];
  for (let i = 0; i < runs; i++) {
    // decorrelate seeds deterministically
    const s = (baseSeed + 104729 * (i + 1)) >>> 0;
    const lam = lanczosLambda2(adj, { maxIter, tol, seed: s });
    if (isFinite(lam) && lam >= 0) values.push(lam);
  }
  return values;
}

function lambda2WithCI(adj, opts = {}) {
  const vals = sampleLambda2(adj, opts);
  if (vals.length === 0) {
    return { mean: 0, std: 0, ciLow: null, ciHigh: null, samples: 0 };
  }
  const mu = mean(vals);
  const sd = stddev(vals, mu);
  const n = vals.length;
  if (n < 3) {
    return { mean: mu, std: sd, ciLow: null, ciHigh: null, samples: n };
  }
  const t = tCritical95(n - 1);
  const half = t * sd / Math.sqrt(n);
  return {
    mean: mu,
    std: sd,
    ciLow: Math.max(0, mu - half),
    ciHigh: mu + half,
    samples: n
  };
}

 /**
 * Symmetric eigenvalue solver for small tridiagonal matrix
 * Uses QR iteration (stable for m ‚â§ 40)
 */
function symmetricEigenvalues(A) {
  const n = A.length;
  if (n === 0) return [];
  let M = A.map(row => row.slice());
  
  for (let iter = 0; iter < 100; iter++) {
    // QR decomposition (Gram-Schmidt)
    let Q = Array.from({ length: n }, () => new Array(n).fill(0));
    let R = Array.from({ length: n }, () => new Array(n).fill(0));
    
    for (let j = 0; j < n; j++) {
      let v = M.map(row => row[j]);
      
      for (let i = 0; i < j; i++) {
        R[i][j] = dot(Q.map(row => row[i]), v);
        for (let k = 0; k < n; k++) {
          v[k] -= R[i][j] * Q[k][i];
        }
      }
      
      R[j][j] = norm(v);
      if (R[j][j] === 0) continue;
      for (let k = 0; k < n; k++) {
        Q[k][j] = v[k] / R[j][j];
      }
    }
    
    // M = R Q
    const next = Array.from({ length: n }, () => new Array(n).fill(0));
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < n; k++) {
          next[i][j] += R[i][k] * Q[j][k];
        }
      }
    }
    M = next;
  }
  
  // Eigenvalues ‚âà diagonal
  return M.map((row, i) => row[i]);
}

/**
 * Spectral radius via power iteration (for adjacency matrix)
 */
function spectralRadius(A) {
  const n = A.length;
  let v = Array(n).fill(0).map((_, i) => Math.sin(i * 0.1));
  v = normalize(v);
  
  for (let iter = 0; iter < 50; iter++) {
    // A * v  
    const Av = A.map(row => dot(row, v));
    const lambda = dot(v, Av);
    const normAv = norm(Av);
    if (normAv < 1e-12) break;
    v = Av.map(x => x / normAv);
  }
  
  const Av = A.map(row => dot(row, v));
  return Math.abs(dot(v, Av));
}

// ============================================
// STRUCTURE METRICS
// ============================================

class StructureMetrics {
  static computeAll(graph, config = {}) {
    const alpha = config.alpha || 1.0;
    const beta = config.beta || 1.0;
    const gamma = config.gamma || 0.5;
    const eps = 1e-10;
    
    const A = graph.getAdjacencyMatrix();
    
    // Zero-mode mass (exact: number of connected components)
    const Z0 = graph.getComponentCount() / graph.n;
    
    // Spectral gap (Fiedler value Œª‚ÇÇ) via Lanczos + confidence sampling (v1.2.0)
    const gapStats = lambda2WithCI(graph.adj, {
      runs: config.gapRuns || 12,
      maxIter: config.gapMaxIter || 40,
      tol: config.gapTol || 1e-6,
      seed: graph.seed || 0
    });
    const Gap = gapStats.mean;
    
    // Cycle tension
    const numEdges = graph.edges.length;
    const numComponents = graph.getComponentCount();
    const CycleT = Math.max(0, (numEdges - graph.n + numComponents) / graph.n);
    
    // Vacuum proxy V(S)
    const V = alpha * Z0 + beta * (1.0 / (Gap + eps)) + gamma * CycleT;
    
    // œÑ-derived macro invariants (for protected metrics)
    const rho = spectralRadius(A);
    
    // Exact trace(L) = sum of degrees = 2|E|
    const trL = graph.adj.reduce((sum, neighbors) => sum + neighbors.length, 0);
    
    // Entropy from degree distribution
    const degrees = graph.adj.map(adj => adj.length);
    const maxDeg = Math.max(...degrees, 1);
    const degreeHist = Array(maxDeg + 1).fill(0);
    degrees.forEach(d => degreeHist[d]++);
    const degreeProbs = degreeHist.map(count => count / graph.n).filter(p => p > 0);
    const entropy = -degreeProbs.reduce((sum, p) => sum + p * Math.log(p + eps), 0);
    
    return {
      Z0,
      Gap,
      CycleT,
      V,
      scaled_spectral_radius: rho / graph.n,
      energy_per_node: trL / graph.n,
      entropy_degree: entropy,
      Gap_ci_low: gapStats.ciLow,
      Gap_ci_high: gapStats.ciHigh,
      Gap_std: gapStats.std,
      Gap_samples: gapStats.samples
    };
  }
}

// ============================================
// Œ© OPERATORS
// ============================================

class OmegaOperator {
  static apply(ensemble, mode, config) {
    switch (mode) {
      case 'omega1':
        return this.omega1_zeroCull(ensemble, config);
      case 'omega2':
        return this.omega2_holonomyBandpass(ensemble, config);
      case 'omega3':
        return this.omega3_gapFloor(ensemble, config);
      case 'omega4':
      case 'omega4a':
        return this.omega4a_minV(ensemble, config);
      case 'omega4b':
        return this.omega4b_bandpass(ensemble, config);
      default:
        return ensemble.map(() => true); // Accept all
    }
  }
  
  static omega1_zeroCull(ensemble, config) {
    const z0Max = config.z0Max || 0.15;
    return ensemble.map(s => s.metrics.Z0 <= z0Max);
  }
  
  static omega2_holonomyBandpass(ensemble, config) {
    const cycleMin = config.cycleMin || 0.05;
    const cycleMax = config.cycleMax || 0.4;
    return ensemble.map(s => {
      const c = s.metrics.CycleT;
      return c >= cycleMin && c <= cycleMax;
    });
  }
  
  static omega3_gapFloor(ensemble, config) {
    const gapMin = config.gapMin || 0.05;
    const useCI = !!config.gapUseCI;
    return ensemble.map(s => {
      if (useCI && s.metrics.Gap_ci_low != null) {
        return s.metrics.Gap_ci_low >= gapMin; // conservative acceptance
      }
      return s.metrics.Gap >= gapMin;
    });
  }
  
  static omega4a_minV(ensemble, config) {
    // Œ©‚ÇÑa: Minimum-V selector (exploratory)
    // Selects structures with lowest V(S) regardless of V_target
    // May reduce VÃÑ but can increase RŒõ (exploratory operator)
    
    const alpha = config.alpha || 1.0;
    const beta = config.beta || 1.0;
    const gamma = config.gamma || 0.5;
    const keepFraction = config.keepFraction || 0.3;
    
    // Compute Œ© scores
    const scores = ensemble.map(s => {
      const m = s.metrics;
      // Lower V is better, so invert
      return -(alpha * m.Z0 + beta * (1.0 / (m.Gap + 1e-10)) + gamma * m.CycleT);
    });
    
    // Sort by score (higher is better = lower V)
    const sorted = scores.map((score, idx) => ({score, idx}))
      .sort((a, b) => b.score - a.score);
    
    const keepCount = Math.floor(ensemble.length * keepFraction);
    const keepIndices = new Set(sorted.slice(0, keepCount).map(s => s.idx));
    
    return ensemble.map((s, idx) => keepIndices.has(idx));
  }
  
  static omega4b_bandpass(ensemble, config) {
    // Œ©‚ÇÑb: V-bandpass selector (RŒõ-aligned)
    // Selects structures closest to V_target (vacuum stationarity)
    // Guaranteed to reduce RŒõ by construction (canonical operator)
    
    const keepFraction = config.keepFraction || 0.3;
    const V_target = config.V_target_baseline;
    
    if (V_target == null) {
      console.warn('Œ©‚ÇÑb requires V_target_baseline; falling back to Œ©‚ÇÑa (min-V)');
      return this.omega4a_minV(ensemble, config);
    }
    
    // Score by proximity to V_target
    const scores = ensemble.map(s => {
      const V = s.metrics.V;
      return -Math.abs(V - V_target);  // Higher is better (closer to target)
    });
    
    // Sort by score (higher = closer to V_target)
    const sorted = scores.map((score, idx) => ({score, idx}))
      .sort((a, b) => b.score - a.score);
    
    const keepCount = Math.floor(ensemble.length * keepFraction);
    const keepIndices = new Set(sorted.slice(0, keepCount).map(s => s.idx));
    
    return ensemble.map((s, idx) => keepIndices.has(idx));
  }
}

// ============================================
// EXPERIMENT RUNNER
// ============================================

class ExperimentRunner {
  constructor(config) {
    this.config = config;
    this.running = false;
    this.results = null;
  }
  
  async run(progressCallback) {
    this.running = true;
    
    try {
      // Step A: Generate ensemble
      progressCallback(0.1, 'Generating ensemble...');
      await this.sleep(10); // Allow UI update
      
      const generator = new EnsembleGenerator(this.config);
      const structures = generator.generate();
      console.log(`‚úì Generated ${structures.length} structures`);
      
      // Step B: Compute metrics for baseline
      progressCallback(0.3, `Computing baseline metrics (0/${structures.length})...`);
      await this.sleep(10);
      
      const ensemble = [];
      for (let i = 0; i < structures.length; i++) {
        if (!this.running) throw new Error('Stopped by user');
        
        const metrics = StructureMetrics.computeAll(structures[i], this.config);
        ensemble.push({
          graph: structures[i],
          metrics,
          accepted: true
        });
        
        if (i % 20 === 0 || i === structures.length - 1) {
          progressCallback(0.3 + 0.25 * (i / structures.length), 
            `Computing baseline metrics (${i+1}/${structures.length})...`);
          await this.sleep(1); // Keep UI responsive
        }
      }
      
      console.log(`‚úì Computed baseline metrics`);
      const baselineStats = this.computeEnsembleStats(ensemble);
      console.log(`  VÃÑ = ${baselineStats.V_mean.toFixed(4)}, RŒõ = ${baselineStats.RLambda.toFixed(4)}`);
      
      // Save baseline V_target for filtered comparison
      const V_target_baseline = baselineStats.V_target;
      
      // Step C: Apply Œ© selection
      progressCallback(0.6, 'Applying Œ© selection...');
      await this.sleep(10);
      
      // Provide V_target to Œ© operators (needed for Œ©‚ÇÑb bandpass)
      this.config.V_target_baseline = V_target_baseline;
      
      const acceptMask = OmegaOperator.apply(ensemble, this.config.omegaMode, this.config);
      ensemble.forEach((s, i) => s.accepted = acceptMask[i]);
      
      const filteredEnsemble = ensemble.filter(s => s.accepted);
      console.log(`‚úì Œ© selected ${filteredEnsemble.length}/${ensemble.length} structures`);
      
      const filteredStats = this.computeEnsembleStats(filteredEnsemble, V_target_baseline);
      console.log(`  VÃÑ = ${filteredStats.V_mean.toFixed(4)}, RŒõ = ${filteredStats.RLambda.toFixed(4)}`);
      
      // Step D: Compute acceptance rate
      const acceptanceRate = filteredEnsemble.length / ensemble.length;
      
      // Step E: Verdict
      progressCallback(0.9, 'Computing verdict...');
      await this.sleep(10);
      
      const verdict = this.computeVerdict(baselineStats, filteredStats, acceptanceRate);
      console.log(`‚úì Verdict: ${verdict.status}`);
      
      progressCallback(1.0, 'Complete!');
      
      this.results = {
        baseline: baselineStats,
        filtered: filteredStats,
        acceptanceRate,
        verdict,
        ensemble,
        config: this.config
      };
      
      return this.results;
      
    } catch (error) {
      console.error('Experiment error:', error);
      throw error;
    }
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  computeEnsembleStats(ensemble, sharedV_target = null) {
    if (ensemble.length === 0) {
      throw new Error('Empty ensemble - no structures to analyze');
    }
    
    const metrics = ensemble.map(s => s.metrics);
    
    const V_values = metrics.map(m => m.V);
    const V_mean = V_values.reduce((a, b) => a + b, 0) / V_values.length;
    const V_var = V_values.reduce((sum, v) => sum + (v - V_mean) ** 2, 0) / V_values.length;
    
    // Œõ residual proxy
    // If sharedV_target provided (for filtered ensemble), use it
    // Otherwise compute from this ensemble's median (for baseline)
    let V_target;
    if (sharedV_target !== null) {
      V_target = sharedV_target;
    } else {
      const V_sorted = [...V_values].sort((a, b) => a - b);
      V_target = V_sorted[Math.floor(V_sorted.length / 2)];
    }
    const RLambda = Math.abs(V_mean - V_target) / Math.max(Math.abs(V_target), 1e-10);
    
    // Macro invariants
    const macroInvariants = {
      scaled_spectral_radius: metrics.reduce((sum, m) => sum + m.scaled_spectral_radius, 0) / metrics.length,
      energy_per_node: metrics.reduce((sum, m) => sum + m.energy_per_node, 0) / metrics.length,
      entropy_degree: metrics.reduce((sum, m) => sum + m.entropy_degree, 0) / metrics.length
    };
    
    // Gap CI statistics (v1.2.0)
    const gapStatistics = {
      mean: metrics.reduce((sum, m) => sum + m.Gap, 0) / metrics.length,
      ci_low_mean: metrics.reduce((sum, m) => sum + (m.Gap_ci_low || m.Gap), 0) / metrics.length,
      ci_high_mean: metrics.reduce((sum, m) => sum + (m.Gap_ci_high || m.Gap), 0) / metrics.length,
      std_mean: metrics.reduce((sum, m) => sum + (m.Gap_std || 0), 0) / metrics.length,
      samples_mean: metrics.reduce((sum, m) => sum + (m.Gap_samples || 1), 0) / metrics.length
    };
    
    return {
      V_mean,
      V_var,
      V_target,
      RLambda,
      macroInvariants,
      gapStatistics,  // NEW: Œª‚ÇÇ CI statistics
      metrics // Full metrics for plotting
    };
  }
  
  computeVerdict(baseline, filtered, acceptanceRate) {
    const RLambda_reduction = ((baseline.RLambda - filtered.RLambda) / baseline.RLambda) * 100;
    
    // Check protected metrics drift with robust denominator
    const drifts = {};
    let maxDrift = 0;
    for (let key in baseline.macroInvariants) {
      const base = baseline.macroInvariants[key];
      const filt = filtered.macroInvariants[key];
      // Use denominator floor to prevent tiny values from causing huge % drift
      const denom = Math.max(Math.abs(base), 1e-3);
      const drift = Math.abs((filt - base) / denom) * 100;
      drifts[key] = drift;
      maxDrift = Math.max(maxDrift, drift);
    }
    
    // Verdict logic
    const significantReduction = RLambda_reduction > 5; // > 5% reduction
    const stableMetrics = maxDrift <= 10; // ‚â§ 10% drift
    const coherentBand = acceptanceRate >= 0.1 && acceptanceRate <= 0.9;
    
    let status = 'FAIL';
    let message = '';
    
    if (significantReduction && stableMetrics && coherentBand) {
      status = 'PASS';
      message = `Œ© signature DETECTED: ${RLambda_reduction.toFixed(1)}% RŒõ reduction, ${(acceptanceRate*100).toFixed(1)}% acceptance, max drift ${maxDrift.toFixed(1)}%`;
    } else if (!significantReduction) {
      status = 'FAIL';
      message = `No significant RŒõ reduction (${RLambda_reduction.toFixed(1)}% < 5% threshold)`;
    } else if (!stableMetrics) {
      status = 'FAIL';
      message = `Protected metrics unstable: max drift ${maxDrift.toFixed(1)}% > 10% tolerance`;
    } else if (!coherentBand) {
      status = 'FAIL';
      message = `Degenerate acceptance rate: ${(acceptanceRate*100).toFixed(1)}% (should be 10-90%)`;
    }
    
    return {
      status,
      message,
      RLambda_reduction,
      maxDrift,
      acceptanceRate,
      drifts
    };
  }
  
  stop() {
    this.running = false;
  }
}

// ============================================
// VISUALIZATION
// ============================================

function renderHistogram(canvas, baseline, filtered) {
  const ctx = canvas.getContext('2d');
  const rect = canvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;
  
  ctx.clearRect(0, 0, w, h);
  
  if (!baseline || !filtered) return;
  
  const V_base = baseline.metrics.map(m => m.V);
  const V_filt = filtered.metrics.map(m => m.V);
  
  const allV = [...V_base, ...V_filt];
  const vMin = Math.min(...allV);
  const vMax = Math.max(...allV);
  
  const numBins = 30;
  const binWidth = (vMax - vMin) / numBins;
  
  const bins_base = Array(numBins).fill(0);
  const bins_filt = Array(numBins).fill(0);
  
  V_base.forEach(v => {
    const bin = Math.min(Math.floor((v - vMin) / binWidth), numBins - 1);
    bins_base[bin]++;
  });
  
  V_filt.forEach(v => {
    const bin = Math.min(Math.floor((v - vMin) / binWidth), numBins - 1);
    bins_filt[bin]++;
  });
  
  const maxCount = Math.max(...bins_base, ...bins_filt);
  
  const padding = 40;
  const plotW = w - 2 * padding;
  const plotH = h - 2 * padding;
  const barW = plotW / numBins;
  
  // Draw baseline (semi-transparent)
  ctx.fillStyle = 'rgba(74, 158, 255, 0.5)';
  for (let i = 0; i < numBins; i++) {
    const barH = (bins_base[i] / maxCount) * plotH;
    ctx.fillRect(padding + i * barW, padding + plotH - barH, barW - 1, barH);
  }
  
  // Draw filtered (solid)
  ctx.fillStyle = 'rgba(255, 74, 158, 0.8)';
  for (let i = 0; i < numBins; i++) {
    const barH = (bins_filt[i] / maxCount) * plotH;
    ctx.fillRect(padding + i * barW, padding + plotH - barH, barW - 1, barH);
  }
  
  // Labels
  ctx.fillStyle = '#4a9eff';
  ctx.font = '12px Consolas';
  ctx.fillText('Baseline', padding, padding - 5);
  
  ctx.fillStyle = '#ff4a9e';
  ctx.fillText('Œ©-Filtered', padding + 80, padding - 5);
}

function renderScatter(canvas, ensemble) {
  const ctx = canvas.getContext('2d');
  const rect = canvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;
  
  ctx.clearRect(0, 0, w, h);
  
  if (!ensemble || ensemble.length === 0) return;
  
  const Z0_values = ensemble.map(s => s.metrics.Z0);
  const Gap_values = ensemble.map(s => s.metrics.Gap);
  
  const z0Min = Math.min(...Z0_values);
  const z0Max = Math.max(...Z0_values);
  const gapMin = Math.min(...Gap_values);
  const gapMax = Math.max(...Gap_values);
  
  const padding = 40;
  const plotW = w - 2 * padding;
  const plotH = h - 2 * padding;
  
  ensemble.forEach(s => {
    const x = padding + ((s.metrics.Z0 - z0Min) / (z0Max - z0Min)) * plotW;
    const y = padding + plotH - ((s.metrics.Gap - gapMin) / (gapMax - gapMin)) * plotH;
    
    ctx.fillStyle = s.accepted ? '#4aff4a' : '#ff4a4a';
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, 2 * Math.PI);
    ctx.fill();
  });
  
  // Axes labels
  ctx.fillStyle = '#aaa';
  ctx.font = '11px Consolas';
  ctx.fillText('Z‚ÇÄ', w - padding + 5, padding + plotH / 2);
  ctx.fillText('Gap', padding, padding - 5);
}

// ============================================
// UI CONTROLLER
// ============================================

let running = false;
let currentExperiment = null;

const ui = {
  runBtn: document.getElementById('runExperiment'),
  stopBtn: document.getElementById('stopExperiment'),
  exportBtn: document.getElementById('exportData'),
  status: document.getElementById('statusDisplay'),
  progress: document.getElementById('progressFill'),
  canvasHistogram: document.getElementById('canvasHistogram'),
  canvasScatter: document.getElementById('canvasScatter'),
  verdictDisplay: document.getElementById('verdictDisplay')
};

// Setup canvases
function setupCanvases() {
  const dpr = window.devicePixelRatio || 1;
  [ui.canvasHistogram, ui.canvasScatter].forEach(canvas => {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
  });
}
setupCanvases();

// Value display updates
document.getElementById('lrProb').addEventListener('input', e => {
  document.getElementById('lrProbValue').textContent = parseFloat(e.target.value).toFixed(2);
});

document.getElementById('z0Max').addEventListener('input', e => {
  document.getElementById('z0MaxValue').textContent = parseFloat(e.target.value).toFixed(2);
});

document.getElementById('gapMin').addEventListener('input', e => {
  document.getElementById('gapMinValue').textContent = parseFloat(e.target.value).toFixed(2);
});

document.getElementById('cycleMin').addEventListener('input', e => {
  document.getElementById('cycleMinValue').textContent = parseFloat(e.target.value).toFixed(2);
});

document.getElementById('cycleMax').addEventListener('input', e => {
  document.getElementById('cycleMaxValue').textContent = parseFloat(e.target.value).toFixed(2);
});

document.getElementById('keepFraction').addEventListener('input', e => {
  document.getElementById('keepFractionValue').textContent = e.target.value + '%';
});

document.getElementById('alphaWeight').addEventListener('input', e => {
  document.getElementById('alphaValue').textContent = parseFloat(e.target.value).toFixed(1);
});

document.getElementById('betaWeight').addEventListener('input', e => {
  document.getElementById('betaValue').textContent = parseFloat(e.target.value).toFixed(1);
});

document.getElementById('gammaWeight').addEventListener('input', e => {
  document.getElementById('gammaValue').textContent = parseFloat(e.target.value).toFixed(1);
});

// Run experiment
ui.runBtn.addEventListener('click', async () => {
  console.log('üöÄ Starting Œ© experiment');
  running = true;
  ui.runBtn.disabled = true;
  ui.stopBtn.disabled = false;
  ui.exportBtn.disabled = true;
  
  const config = {
    ensembleSize: parseInt(document.getElementById('ensembleSize').value),
    nodeCount: parseInt(document.getElementById('nodeCount').value),
    generatorFamily: document.getElementById('generatorFamily').value,
    lrProb: parseFloat(document.getElementById('lrProb').value),
    seed: parseInt(document.getElementById('rngSeed').value),
    omegaMode: document.getElementById('omegaMode').value,
    z0Max: parseFloat(document.getElementById('z0Max').value),
    gapMin: parseFloat(document.getElementById('gapMin').value),
    cycleMin: parseFloat(document.getElementById('cycleMin').value),
    cycleMax: parseFloat(document.getElementById('cycleMax').value),
    keepFraction: parseFloat(document.getElementById('keepFraction').value) / 100,
    alpha: parseFloat(document.getElementById('alphaWeight').value),
    beta: parseFloat(document.getElementById('betaWeight').value),
    gamma: parseFloat(document.getElementById('gammaWeight').value)
  };
  
  currentExperiment = new ExperimentRunner(config);
  
  const progressCallback = (progress, message) => {
    ui.progress.style.width = `${progress * 100}%`;
    ui.status.textContent = message;
    ui.status.className = 'status running';
    ui.status.style.display = 'block';
  };
  
  try {
    const results = await currentExperiment.run(progressCallback);
    
    if (running) {
      displayResults(results);
    }
  } catch (error) {
    console.error('Experiment error:', error);
    ui.status.textContent = `Error: ${error.message}`;
    ui.status.className = 'status fail';
  }
  
  ui.runBtn.disabled = false;
  ui.stopBtn.disabled = true;
  ui.exportBtn.disabled = false;
  running = false;
});

// Stop experiment
ui.stopBtn.addEventListener('click', () => {
  running = false;
  if (currentExperiment) {
    currentExperiment.stop();
  }
  ui.status.textContent = 'Stopped by user';
  console.log('‚è∏Ô∏è Experiment stopped');
});

// Display results
function displayResults(results) {
  // Update metrics
  document.getElementById('metricAcceptRate').textContent = 
    `${(results.acceptanceRate * 100).toFixed(1)}%`;
  document.getElementById('metricRLambdaBase').textContent = 
    results.baseline.RLambda.toFixed(4);
  document.getElementById('metricRLambdaOmega').textContent = 
    results.filtered.RLambda.toFixed(4);
  
  const reduction = ((results.baseline.RLambda - results.filtered.RLambda) / results.baseline.RLambda) * 100;
  const reductionElem = document.getElementById('metricRLambdaReduction');
  reductionElem.textContent = reduction.toFixed(1) + '%';
  reductionElem.className = 'metric-value ' + (reduction > 5 ? 'good' : 'warn');
  
  document.getElementById('metricVBarBase').textContent = 
    results.baseline.V_mean.toFixed(4);
  document.getElementById('metricVBarOmega').textContent = 
    results.filtered.V_mean.toFixed(4);
  document.getElementById('metricVarBase').textContent = 
    results.baseline.V_var.toFixed(4);
  document.getElementById('metricVarOmega').textContent = 
    results.filtered.V_var.toFixed(4);
  
  // Update macro invariants table
  const tbody = document.getElementById('macroInvariantsTable');
  tbody.innerHTML = '';
  
  for (let key in results.baseline.macroInvariants) {
    const base = results.baseline.macroInvariants[key];
    const filt = results.filtered.macroInvariants[key];
    const drift = Math.abs((filt - base) / base) * 100;
    
    const row = tbody.insertRow();
    row.innerHTML = `
      <td>${key.replace(/_/g, ' ')}</td>
      <td>${base.toFixed(6)}</td>
      <td>${filt.toFixed(6)}</td>
      <td>${drift.toFixed(2)}%</td>
      <td style="color: ${drift <= 10 ? '#4aff4a' : '#ff4a4a'}">${drift <= 10 ? '‚úì' : '‚úó'}</td>
    `;
  }
  
  // Display verdict
  const verdict = results.verdict;
  ui.verdictDisplay.textContent = verdict.message;
  ui.verdictDisplay.className = `status ${verdict.status.toLowerCase()}`;
  ui.verdictDisplay.style.display = 'block';
  
  // Render visualizations
  renderHistogram(ui.canvasHistogram, results.baseline, results.filtered);
  renderScatter(ui.canvasScatter, results.ensemble);
  
  ui.status.textContent = 'Experiment complete!';
  ui.status.className = 'status complete';
  
  console.log('‚úÖ Experiment complete:', verdict.status);
  console.log(`   RŒõ reduction: ${verdict.RLambda_reduction.toFixed(1)}%`);
  console.log(`   Max drift: ${verdict.maxDrift.toFixed(1)}%`);
  console.log(`   Acceptance: ${(verdict.acceptanceRate * 100).toFixed(1)}%`);
}

// Export data
ui.exportBtn.addEventListener('click', () => {
  if (!currentExperiment || !currentExperiment.results) {
    console.warn('No results to export');
    return;
  }
  
  const results = currentExperiment.results;
  const exportData = {
    version: '1.2.0',
    chamber: 'XXXIV',
    operator: 'Omega',
    phase: 'F',
    timestamp: new Date().toISOString(),
    config: results.config,
    V_target: results.baseline.V_target, // Shared target for RŒõ calculation
    baseline: {
      V_mean: results.baseline.V_mean,
      V_var: results.baseline.V_var,
      V_target: results.baseline.V_target,
      RLambda: results.baseline.RLambda,
      macroInvariants: results.baseline.macroInvariants,
      gapStatistics: results.baseline.gapStatistics  // v1.2.0: Œª‚ÇÇ CI stats
    },
    filtered: {
      V_mean: results.filtered.V_mean,
      V_var: results.filtered.V_var,
      V_target: results.filtered.V_target, // Same as baseline (for audit)
      RLambda: results.filtered.RLambda,
      macroInvariants: results.filtered.macroInvariants,
      gapStatistics: results.filtered.gapStatistics  // v1.2.0: Œª‚ÇÇ CI stats
    },
    acceptanceRate: results.acceptanceRate,
    verdict: results.verdict
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const datestamp = exportData.timestamp.split('T')[0];
  a.download = `LPF-Omega_${datestamp}_seed${exportData.config.seed}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  console.log('üíæ Data exported:', a.download);
});

console.log('‚úÖ Chamber XXXIV ready!');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  </script>
</body>
</html>
