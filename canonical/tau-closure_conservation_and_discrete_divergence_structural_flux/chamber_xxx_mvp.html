<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chamber XXX: Conservation Testing (MVP)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Consolas', 'Monaco', monospace; 
      background: #0a0a0a; 
      color: #e0e0e0; 
      padding: 20px;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    header { 
      text-align: center; 
      margin-bottom: 30px; 
      padding: 20px; 
      border-bottom: 2px solid #2a2a2a; 
    }
    h1 { 
      font-size: 2em; 
      color: #4a9eff; 
      letter-spacing: 2px; 
      margin-bottom: 10px;
    }
    .subtitle { 
      color: #888; 
      font-size: 0.9em; 
    }
    .panel { 
      background: #1a1a1a; 
      border: 1px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 20px; 
      margin-bottom: 20px; 
    }
    .panel-title { 
      font-size: 1.2em; 
      color: #4a9eff; 
      margin-bottom: 15px; 
      padding-bottom: 10px; 
      border-bottom: 1px solid #2a2a2a; 
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
    }
    label {
      font-size: 0.9em;
      color: #aaa;
      margin-bottom: 5px;
    }
    select, input[type="number"] {
      background: #0a0a0a;
      border: 1px solid #3a3a3a;
      color: #e0e0e0;
      padding: 8px;
      border-radius: 4px;
      font-family: inherit;
    }
    button {
      background: #2a4a7a;
      border: none;
      color: #e0e0e0;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      margin-right: 10px;
    }
    button:hover {
      background: #3a5a8a;
    }
    button.primary {
      background: #4a9eff;
    }
    button:disabled {
      background: #1a1a1a;
      color: #555;
      cursor: not-allowed;
    }
    .status { 
      padding: 10px; 
      border-radius: 4px; 
      margin-bottom: 15px; 
      font-size: 0.9em; 
    }
    .status.success { 
      background: #2a4a2a; 
      color: #4aff4a; 
    }
    .status.error { 
      background: #4a2a2a; 
      color: #ff4a4a; 
    }
    .status.info { 
      background: #2a3a4a; 
      color: #4a9eff; 
    }
    pre { 
      background: #0a0a0a; 
      padding: 15px; 
      border-radius: 4px; 
      overflow-x: auto; 
      font-size: 0.85em;
      border: 1px solid #2a2a2a;
      margin: 10px 0;
      max-height: 400px;
      overflow-y: auto;
    }
    .downloads { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
      gap: 10px; 
      margin-top: 15px; 
    }
    .download-btn { 
      background: #2a4a7a; 
      border: none; 
      color: #e0e0e0; 
      padding: 12px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-family: inherit; 
      text-align: center;
      text-decoration: none;
      display: block;
    }
    .download-btn:hover { 
      background: #3a5a8a; 
    }
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    .metric {
      background: #0a0a0a;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #2a2a2a;
    }
    .metric-label {
      font-size: 0.8em;
      color: #888;
      margin-bottom: 5px;
    }
    .metric-value {
      font-size: 1.2em;
      color: #4a9eff;
      font-weight: bold;
    }
    .badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 0.85em;
      margin: 2px;
    }
    .badge.green {
      background: #2a4a2a;
      color: #4aff4a;
    }
    .badge.red {
      background: #4a2a2a;
      color: #ff4a4a;
    }
    .badge.blue {
      background: #2a3a4a;
      color: #4a9eff;
    }
    .badge.gray {
      background: #2a2a2a;
      color: #888;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>âš™ï¸ CHAMBER XXX: Conservation Testing</h1>
      <div class="subtitle">General Mechanism Evaluation</div>
      <div class="subtitle" style="margin-top: 5px; font-size: 0.8em;">
        Discrete Divergence & Structural Flux Analysis
      </div>
    </header>
    
    <div class="panel">
      <div class="panel-title">Mechanism Configuration</div>
      <div class="controls">
        <div class="control-group">
          <label>Mechanism Preset</label>
          <select id="mechanismSelect">
            <option value="M_leak">M_leak (Minimal falsifier)</option>
            <option value="A_pure_cycle">A: Pure Cycle (Positive control)</option>
            <option value="B_expansion">B: Expansion (Negative control)</option>
            <option value="C_balanced_leak">C: Balanced Leak (False-positive guard)</option>
            <option value="M_conservative">M_conservative (Alternative)</option>
            <option value="M_collapse">M_collapse (Collapse)</option>
            <option value="custom">Custom JSON...</option>
          </select>
        </div>
        <div class="control-group">
          <label>Refinement Steps</label>
          <input type="number" id="refineSteps" value="20" min="1" max="1000">
        </div>
        <div class="control-group">
          <label>Seed (deterministic)</label>
          <input type="number" id="seed" value="137042">
        </div>
      </div>
      <button id="runBtn" class="primary">â–¶ Run Evaluation</button>
      <button id="exportBtn" disabled>ğŸ’¾ Export Bundle</button>
      <div id="statusBadges" style="margin-top: 15px;"></div>
    </div>
    
    <div class="panel">
      <div class="panel-title">Execution Status</div>
      <div id="statusContainer"></div>
    </div>
    
    <div class="panel">
      <div class="panel-title">Key Metrics</div>
      <div class="metrics" id="metricsContainer">
        <div class="metric"><div class="metric-label">Mechanism</div><div class="metric-value" id="metricMech">â€”</div></div>
        <div class="metric"><div class="metric-label">States (|V|)</div><div class="metric-value" id="metricStates">â€”</div></div>
        <div class="metric"><div class="metric-label">Edges (|E|)</div><div class="metric-value" id="metricEdges">â€”</div></div>
        <div class="metric"><div class="metric-label">Cycles Detected</div><div class="metric-value" id="metricCycles">â€”</div></div>
        <div class="metric"><div class="metric-label">Witnesses Found</div><div class="metric-value" id="metricWitnesses">â€”</div></div>
        <div class="metric"><div class="metric-label">Conservation</div><div class="metric-value" id="metricConservation">â€”</div></div>
      </div>
    </div>
    
    <div class="panel">
      <div class="panel-title">Divergence Report</div>
      <pre id="divergenceReport">Run evaluation to generate report...</pre>
    </div>
    
    <div class="panel">
      <div class="panel-title">Witness Analysis</div>
      <pre id="witnessReport">Run evaluation to detect witnesses...</pre>
    </div>
    
    <div class="panel">
      <div class="panel-title">Download Outputs</div>
      <div class="downloads" id="downloadLinks"></div>
    </div>
  </div>
  
  <script>
// ============================================================================
// CHAMBER XXX MVP: General Conservation Testing Instrument
// ============================================================================
// General mechanisms, arbitrary graphs, structural witnesses
// Calibration-locked invariants from XXX-mini
// ============================================================================

console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
console.log('Chamber XXX MVP: Conservation Testing');
console.log('General Mechanism Evaluation');
console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

// ============================================================================
// CALIBRATION-LOCKED INVARIANTS (Do Not Modify)
// ============================================================================

const INVARIANTS = Object.freeze({
  divergence_formula: "(âˆ‡Â·J)(v) = Î£_out J(vâ†’w) - Î£_in J(uâ†’v)",
  flux_nature: "structural, non-numerical carriers in group A",
  falsifier_pattern: "two-cycle + strict closure-relevant leak",
  independence_theorem: "proto-closure does not imply Ï„-conservation",
  carrier_group: "Z[O,R,P]" // Free abelian group on {O, R, P}
});

console.log('Invariants loaded:', INVARIANTS);

// ============================================================================
// CANONICALIZATION INTERFACE (CanonV0)
// ============================================================================

/**
 * CanonV0: String-based canonicalization (calibrated implementation)
 * 
 * Interface contract:
 *   canonize(state) â†’ { canon_id, canon_repr, original }
 * 
 * Invariants:
 *   - Same structure â†’ same canon_id (deterministic)
 *   - Renaming-invariant (symbol order normalized)
 *   - Idempotent: canonize(canonize(s)) = canonize(s)
 */

function hash_fnv1a(str) {
  let hash = 2166136261;
  for (let i = 0; i < str.length; i++) {
    hash ^= str.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return (hash >>> 0).toString(16).padStart(8, '0');
}

const CanonV0 = {
  name: 'CanonV0',
  version: '1.0.0',
  description: 'String-based canonicalization (calibrated)',
  
  canonize(state_repr) {
    // Normalize: sort symbols, remove whitespace
    const normalized = String(state_repr).trim().split('').sort().join('');
    const canon_id = hash_fnv1a(normalized);
    
    return {
      canon_id: canon_id,
      canon_repr: normalized,
      original: state_repr
    };
  },
  
  test() {
    const tests = [
      { input: 'a', expected_repr: 'a' },
      { input: 'ba', expected_repr: 'ab' },
      { input: ' a ', expected_repr: 'a' }
    ];
    
    const results = tests.map(t => {
      const c = this.canonize(t.input);
      return {
        ...t,
        got: c.canon_repr,
        pass: c.canon_repr === t.expected_repr
      };
    });
    
    const a1 = this.canonize('a');
    const a2 = this.canonize('a');
    const deterministic = (a1.canon_id === a2.canon_id);
    
    return {
      tests: results,
      deterministic: deterministic,
      all_pass: results.every(r => r.pass) && deterministic
    };
  }
};

// ============================================================================
// MECHANISM DEFINITION & LOADER
// ============================================================================

/**
 * Mechanism JSON Schema (simplified for MVP)
 * 
 * {
 *   "meta": { "name": "...", "description": "..." },
 *   "sigma": ["symbol1", "symbol2", ...],
 *   "rules": [
 *     { "id": "r1", "repr": "a => b", "tags": ["cycle"|"leak"|...] }
 *   ],
 *   "constraints": [
 *     { "id": "C0", "level": 0, "blocks": ["r3"], "description": "..." }
 *   ],
 *   "ordering": { "id": "...", "repr": "..." },
 *   "refinement_schedule": [
 *     { "step": 0, "constraint_level": 0, "iterations": 10 },
 *     { "step": 10, "constraint_level": 1, "iterations": 5 }
 *   ]
 * }
 */

const MechanismLoader = {
  load(json_or_preset) {
    if (typeof json_or_preset === 'string') {
      // Load preset
      return this.loadPreset(json_or_preset);
    } else {
      // Parse JSON
      return this.parseJSON(json_or_preset);
    }
  },
  
  loadPreset(name) {
    const presets = {
      'M_leak': PRESET_M_LEAK,
      'A_pure_cycle': PRESET_A_PURE_CYCLE,
      'B_expansion': PRESET_B_EXPANSION,
      'C_balanced_leak': PRESET_C_BALANCED_LEAK,
      'M_conservative': PRESET_M_CONSERVATIVE,
      'M_collapse': PRESET_M_COLLAPSE
    };
    
    if (!presets[name]) {
      throw new Error(`Unknown preset: ${name}`);
    }
    
    return presets[name];
  },
  
  parseJSON(json) {
    // Validate required fields
    if (!json.sigma || !json.rules || !json.constraints || !json.ordering) {
      throw new Error('Invalid mechanism JSON: missing required fields');
    }
    
    return {
      meta: json.meta || { name: 'Unknown', description: '' },
      sigma: json.sigma,
      rules: json.rules,
      constraints: json.constraints,
      ordering: json.ordering,
      refinement_schedule: json.refinement_schedule || []
    };
  }
};

// ============================================================================
// MECHANISM PRESETS
// ============================================================================

const PRESET_M_LEAK = {
  meta: {
    name: "M_leak",
    description: "Two-cycle with closure-relevant leak (falsifies conservation)",
    source: "Paper Section 6.3",
    expected_verdict: {
      closure: "proto-closed",
      conservation: "falsified"
    },
    instrument_stage: "implementation"
  },
  sigma: ['a', 'b'],
  rules: [
    { id: 'r1', repr: 'a => b', tags: ['cycle'], type: 'O' },
    { id: 'r2', repr: 'b => a', tags: ['cycle'], type: 'O' },
    { id: 'r3', repr: 'a => aa', tags: ['leak'], type: 'P' }
  ],
  constraints: [
    { id: 'C0', level: 0, blocks: ['r3'], description: 'Forbid r3 (cycle only)' },
    { id: 'C1', level: 1, blocks: [], description: 'Admit r3 (leak enabled)' }
  ],
  ordering: { id: 'sequential', repr: 'One rule per step' },
  refinement_schedule: [
    { step: 0, constraint_level: 0, iterations: 10 },
    { step: 10, constraint_level: 1, iterations: 1 }
  ],
  exact_steps: 11  // Minimal falsifier: 10 cycle + 1 leak, then STOP
};

const PRESET_A_PURE_CYCLE = {
  meta: {
    name: "A_pure_cycle",
    description: "Pure recurrent closure (positive control - conservative)",
    expected_verdict: {
      closure: "proto-closed",
      conservation: "holds"
    },
    instrument_stage: "implementation"
  },
  sigma: ['a', 'b'],
  rules: [
    { id: 'r1', repr: 'a => b', tags: ['cycle'], type: 'O' },
    { id: 'r2', repr: 'b => a', tags: ['cycle'], type: 'O' }
  ],
  constraints: [
    { id: 'C', level: 0, blocks: [], description: 'No expansion, no branching' }
  ],
  ordering: { id: 'sequential', repr: 'One rule per step' },
  refinement_schedule: [
    { step: 0, constraint_level: 0, iterations: 10 }
  ],
  exact_steps: 10
};

const PRESET_B_EXPANSION = {
  meta: {
    name: "B_expansion",
    description: "Closure-free divergence (negative control - structural collapse)",
    expected_verdict: {
      closure: "structural-collapse",
      conservation: "n/a"
    },
    instrument_stage: "implementation"
  },
  sigma: ['a'],
  rules: [
    { id: 'r1', repr: 'a => aa', tags: ['expand'], type: 'P' }
  ],
  constraints: [
    { id: 'C', level: 0, blocks: [], description: 'No constraints' }
  ],
  ordering: { id: 'sequential', repr: 'Apply r1 whenever possible' },
  refinement_schedule: [
    { step: 0, constraint_level: 0, iterations: 10 }
  ],
  exact_steps: 10
};

const PRESET_C_BALANCED_LEAK = {
  meta: {
    name: "C_balanced_leak",
    description: "Balanced leak with return path (false-positive guard)",
    expected_verdict: {
      closure: "proto-closed",
      conservation: "holds"
    },
    instrument_stage: "implementation"
  },
  sigma: ['a', 'b', 'c'],
  rules: [
    { id: 'r1', repr: 'a => b', tags: ['cycle'], type: 'O' },
    { id: 'r2', repr: 'b => a', tags: ['cycle'], type: 'O' },
    { id: 'r3', repr: 'a => c', tags: ['branch'], type: 'P' },
    { id: 'r4', repr: 'c => a', tags: ['return'], type: 'P' }
  ],
  constraints: [
    { id: 'C', level: 0, blocks: [], description: 'All rules admissible' }
  ],
  ordering: { id: 'sequential', repr: 'One rule per step' },
  refinement_schedule: [
    { step: 0, constraint_level: 0, iterations: 10 }
  ],
  exact_steps: 10
};

const PRESET_M_CONSERVATIVE = {
  meta: {
    name: "M_conservative",
    description: "Balanced cycle with compensated branches (proto-closed & conservative)",
    expected_verdict: {
      closure: "proto-closed",
      conservation: "holds"
    },
    instrument_stage: "implementation"
  },
  sigma: ['x', 'y'],
  rules: [
    { id: 'r1', repr: 'x => y', tags: ['cycle'], type: 'O' },
    { id: 'r2', repr: 'y => x', tags: ['cycle'], type: 'O' },
    { id: 'r3', repr: 'x => xx', tags: ['branch'], type: 'P' },
    { id: 'r4', repr: 'xx => x', tags: ['return'], type: 'P' }
  ],
  constraints: [
    { id: 'C0', level: 0, blocks: ['r3', 'r4'], description: 'Cycle only' },
    { id: 'C1', level: 1, blocks: [], description: 'Branch enabled' }
  ],
  ordering: { id: 'sequential', repr: 'One rule per step' },
  refinement_schedule: [
    { step: 0, constraint_level: 0, iterations: 8 },
    { step: 8, constraint_level: 1, iterations: 2 },
    { step: 10, constraint_level: 1, iterations: 2 }
  ],
  exact_steps: 12
};

const PRESET_M_COLLAPSE = {
  meta: {
    name: "M_collapse",
    description: "Unbounded expansion (structural collapse, no closure)",
    expected_verdict: {
      closure: "structural-collapse",
      conservation: "n/a"
    },
    instrument_stage: "implementation"
  },
  sigma: ['z'],
  rules: [
    { id: 'r1', repr: 'z => zz', tags: ['expand'], type: 'R' }
  ],
  constraints: [
    { id: 'C0', level: 0, blocks: [], description: 'No constraints' }
  ],
  ordering: { id: 'sequential', repr: 'One rule per step' },
  refinement_schedule: [
    { step: 0, constraint_level: 0, iterations: 10 }
  ],
  exact_steps: 10
};

// ============================================================================
// REFINEMENT EXECUTOR
// ============================================================================

class RefinementExecutor {
  constructor(mechanism, seed = 137042) {
    this.mechanism = mechanism;
    this.seed = seed;
    this.rng = this.createRNG(seed);
    this.trace = {
      steps: [],
      states: new Map()
    };
    this.current_state = null;
    this.step_counter = 0;
  }
  
  createRNG(seed) {
    let state = seed >>> 0;
    return {
      random() {
        state = (state * 1664525 + 1013904223) >>> 0;
        return state / 4294967296;
      }
    };
  }
  
  initialize() {
    // Initialize with first symbol from sigma
    this.current_state = this.mechanism.sigma[0];
    this.recordState(this.current_state);
  }
  
  recordState(state_repr) {
    const canon = CanonV0.canonize(state_repr);
    if (!this.trace.states.has(canon.canon_id)) {
      this.trace.states.set(canon.canon_id, {
        canon_id: canon.canon_id,
        canon_repr: canon.canon_repr,
        first_seen: this.step_counter
      });
    }
    return canon;
  }
  
  execute(total_steps) {
    this.initialize();
    
    const schedule = this.mechanism.refinement_schedule;
    let schedule_idx = 0;
    let iterations_in_phase = 0;
    let current_constraint_level = schedule[0]?.constraint_level || 0;
    
    for (let step = 0; step < total_steps; step++) {
      // Check if we need to advance to next schedule phase
      if (schedule_idx < schedule.length) {
        const phase = schedule[schedule_idx];
        if (iterations_in_phase >= phase.iterations) {
          schedule_idx++;
          iterations_in_phase = 0;
          if (schedule_idx < schedule.length) {
            current_constraint_level = schedule[schedule_idx].constraint_level;
          }
        }
      }
      
      // Get active constraints
      const active_constraints = this.mechanism.constraints
        .filter(c => c.level === current_constraint_level);
      
      // Get blocked rules
      const blocked_rules = new Set(
        active_constraints.flatMap(c => c.blocks || [])
      );
      
      // Get admissible rules
      const admissible_rules = this.mechanism.rules
        .filter(r => !blocked_rules.has(r.id))
        .filter(r => this.ruleApplies(r, this.current_state));
      
      if (admissible_rules.length === 0) {
        console.log(`  Step ${step}: No admissible rules, stopping`);
        break;
      }
      
      // Choose rule (deterministically based on ordering policy)
      const rule = this.chooseRule(admissible_rules);
      
      // Apply rule
      const before = this.recordState(this.current_state);
      const new_state = this.applyRule(rule, this.current_state);
      this.current_state = new_state;
      const after = this.recordState(new_state);
      
      // Record step
      const is_leak = rule.tags && rule.tags.includes('leak');
      this.trace.steps.push({
        i: this.step_counter,
        u: before.canon_id,
        v: after.canon_id,
        u_repr: before.canon_repr,
        v_repr: after.canon_repr,
        action: rule.id,
        action_repr: rule.repr,
        rule_type: rule.type || 'O',
        constraint_level: current_constraint_level,
        is_leak: is_leak,
        closure_relevant: is_leak || (rule.tags && rule.tags.includes('closure_relevant'))
      });
      
      this.step_counter++;
      iterations_in_phase++;
    }
    
    return this.trace;
  }
  
  ruleApplies(rule, state) {
    // Simple pattern matching: "a => b" means state must contain 'a'
    const parts = rule.repr.split('=>').map(p => p.trim());
    const lhs = parts[0];
    return state.includes(lhs);
  }
  
  applyRule(rule, state) {
    // Simple rewrite: replace first occurrence of LHS with RHS
    const parts = rule.repr.split('=>').map(p => p.trim());
    const lhs = parts[0];
    const rhs = parts[1];
    return state.replace(lhs, rhs);
  }
  
  chooseRule(rules) {
    // Priority 1: Closure-relevant leak if admissible
    // This ensures falsifier patterns are explored when constraints permit
    const leak = rules.find(r => r.tags && r.tags.includes('leak'));
    if (leak) {
      console.log(`    â†’ Prioritizing closure-relevant leak: ${leak.id}`);
      return leak;
    }
    
    // Priority 2: Closure-relevant tagged rules
    const closure_relevant = rules.find(r => r.tags && r.tags.includes('closure_relevant'));
    if (closure_relevant) {
      return closure_relevant;
    }
    
    // Priority 3: Deterministic fallback (first admissible rule)
    return rules[0];
  }
}

// ============================================================================
// GRAPH BUILDER (From Calibrated Mini)
// ============================================================================

function buildGraph(trace) {
  const V = Array.from(trace.states.values());
  const E = trace.steps.map(step => ({
    u: step.u,
    v: step.v,
    action: step.action,
    action_repr: step.action_repr,
    rule_type: step.rule_type,
    is_leak: step.is_leak || false,
    closure_relevant: step.closure_relevant || false
  }));
  
  // Compute metrics
  const in_degree = new Map();
  const out_degree = new Map();
  
  for (const v of V) {
    in_degree.set(v.canon_id, 0);
    out_degree.set(v.canon_id, 0);
  }
  
  for (const e of E) {
    out_degree.set(e.u, (out_degree.get(e.u) || 0) + 1);
    in_degree.set(e.v, (in_degree.get(e.v) || 0) + 1);
  }
  
  const metrics = {
    num_vertices: V.length,
    num_edges: E.length,
    in_degree: Object.fromEntries(in_degree),
    out_degree: Object.fromEntries(out_degree)
  };
  
  console.log('Graph constructed:');
  console.log(`  |V| = ${metrics.num_vertices}`);
  console.log(`  |E| = ${metrics.num_edges}`);
  
  return { V, E, metrics };
}

// ============================================================================
// FLUX ASSIGNMENT (Calibrated)
// ============================================================================

function assignFlux(edge) {
  // Map rule_type to carrier basis element
  const type_map = {
    'O': { O: 1, R: 0, P: 0 }, // Orthogonal
    'R': { O: 0, R: 1, P: 0 }, // Relaxation
    'P': { O: 0, R: 0, P: 1 }  // Projection
  };
  
  return type_map[edge.rule_type] || { O: 0, R: 0, P: 0 };
}

function isZeroFlux(flux) {
  return flux.O === 0 && flux.R === 0 && flux.P === 0;
}

function addFlux(f1, f2) {
  return {
    O: f1.O + f2.O,
    R: f1.R + f2.R,
    P: f1.P + f2.P
  };
}

function subtractFlux(f1, f2) {
  return {
    O: f1.O - f2.O,
    R: f1.R - f2.R,
    P: f1.P - f2.P
  };
}

function formatFlux(flux) {
  return `{O:${flux.O}, R:${flux.R}, P:${flux.P}}`;
}

// ============================================================================
// DIVERGENCE COMPUTATION (Calibrated)
// ============================================================================

function computeDivergence(graph) {
  const div_map = new Map();
  const flux_cache = new Map();
  
  // Initialize
  for (const v of graph.V) {
    div_map.set(v.canon_id, { O: 0, R: 0, P: 0 });
  }
  
  // Assign and cache flux
  for (const edge of graph.E) {
    const flux = assignFlux(edge);
    flux_cache.set(`${edge.u}->${edge.v}`, flux);
  }
  
  // Accumulate divergence
  for (const edge of graph.E) {
    const flux = flux_cache.get(`${edge.u}->${edge.v}`);
    
    // Outgoing from u
    const u_div = div_map.get(edge.u);
    div_map.set(edge.u, addFlux(u_div, flux));
    
    // Incoming to v
    const v_div = div_map.get(edge.v);
    div_map.set(edge.v, subtractFlux(v_div, flux));
  }
  
  console.log('Divergence computed for all vertices');
  
  return { div_map, flux_cache };
}

// ============================================================================
// FALSIFIER DETECTION (Generalized)
// ============================================================================

function detectFalsifier(graph, div_result) {
  const witnesses = [];
  const seen_patterns = new Set(); // Track unique patterns
  
  console.log('Searching for cycle-with-leak patterns...');
  
  // Find all cycles (not just 2-cycles)
  const cycles = findCycles(graph);
  console.log(`  Found ${cycles.length} cycles`);
  
  // For each cycle, look for leak edges
  for (const cycle of cycles) {
    const cycle_nodes = new Set(cycle.nodes);
    
    // Find outgoing edges not part of cycle
    const leak_edges = graph.E.filter(e => {
      const from_cycle = cycle_nodes.has(e.u);
      const not_in_cycle = !cycle_nodes.has(e.v);
      return from_cycle && not_in_cycle;
    });
    
    for (const leak of leak_edges) {
      const leak_flux = div_result.flux_cache.get(`${leak.u}->${leak.v}`);
      const is_nonzero = !isZeroFlux(leak_flux);
      const is_closure_relevant = leak.closure_relevant || false;
      
      if (is_nonzero && is_closure_relevant) {
        // Create pattern signature for deduplication
        const pattern_sig = `cycle:${cycle.nodes.sort().join(',')}|leak:${leak.u}->${leak.v}`;
        
        if (!seen_patterns.has(pattern_sig)) {
          seen_patterns.add(pattern_sig);
          
          const source_node = leak.u;
          const div_at_source = div_result.div_map.get(source_node);
          const div_is_nonzero = !isZeroFlux(div_at_source);
          
          witnesses.push({
            type: 'cycle-with-leak',
            cycle_size: cycle.nodes.length,
            cycle_nodes: cycle.nodes,
            leak_source: source_node,
            leak_target: leak.v,
            leak_edge: leak,
            leak_flux: leak_flux,
            divergence_at_source: div_at_source,
            falsifies_conservation: div_is_nonzero,
            pattern_signature: pattern_sig
          });
          
          console.log(`  âœ“ Witness detected: ${cycle.nodes.length}-cycle with leak`);
        }
      }
    }
  }
  
  console.log(`\nâœ“ Falsifier detection complete: ${witnesses.length} unique witnesses`);
  
  return witnesses;
}

function findCycles(graph) {
  // Simple cycle detection: find all 2-cycles and 3-cycles
  // (Can be extended to arbitrary cycle length with DFS)
  const cycles = [];
  
  // Find 2-cycles
  for (let i = 0; i < graph.E.length; i++) {
    const e1 = graph.E[i];
    for (let j = i + 1; j < graph.E.length; j++) {
      const e2 = graph.E[j];
      if (e1.u === e2.v && e1.v === e2.u) {
        cycles.push({
          size: 2,
          nodes: [e1.u, e1.v],
          edges: [e1, e2]
        });
      }
    }
  }
  
  // Find 3-cycles
  for (const e1 of graph.E) {
    for (const e2 of graph.E) {
      for (const e3 of graph.E) {
        if (e1.v === e2.u && e2.v === e3.u && e3.v === e1.u) {
          const nodes = [e1.u, e2.u, e3.u];
          cycles.push({
            size: 3,
            nodes: nodes,
            edges: [e1, e2, e3]
          });
        }
      }
    }
  }
  
  // Deduplicate cycles
  const unique_cycles = [];
  const seen = new Set();
  
  for (const cycle of cycles) {
    const sig = cycle.nodes.sort().join(',');
    if (!seen.has(sig)) {
      seen.add(sig);
      unique_cycles.push(cycle);
    }
  }
  
  return unique_cycles;
}

// ============================================================================
// REPORT GENERATION
// ============================================================================

function generateDivergenceReport(mechanism, graph, div_result) {
  let report = `DIVERGENCE REPORT\n`;
  report += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;
  
  report += `Mechanism: ${mechanism.meta.name}\n`;
  report += `Description: ${mechanism.meta.description}\n`;
  report += `Total vertices: ${graph.V.length}\n`;
  report += `Total edges: ${graph.E.length}\n`;
  report += `Carrier group: ${INVARIANTS.carrier_group}\n\n`;
  
  report += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
  report += `Per-Vertex Divergence:\n`;
  report += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
  
  for (const v of graph.V) {
    const div = div_result.div_map.get(v.canon_id);
    const is_zero = isZeroFlux(div);
    
    report += `Node ${v.canon_id} (state '${v.canon_repr}'):\n`;
    
    const out_edges = graph.E.filter(e => e.u === v.canon_id);
    const in_edges = graph.E.filter(e => e.v === v.canon_id);
    
    let out_flux = { O: 0, R: 0, P: 0 };
    for (const e of out_edges) {
      const f = div_result.flux_cache.get(`${e.u}->${e.v}`);
      out_flux = addFlux(out_flux, f);
    }
    
    let in_flux = { O: 0, R: 0, P: 0 };
    for (const e of in_edges) {
      const f = div_result.flux_cache.get(`${e.u}->${e.v}`);
      in_flux = addFlux(in_flux, f);
    }
    
    report += `  Outgoing: ${formatFlux(out_flux)} (${out_edges.length} edges)\n`;
    report += `  Incoming: ${formatFlux(in_flux)} (${in_edges.length} edges)\n`;
    report += `  Divergence: ${formatFlux(div)} ${is_zero ? 'â† ZERO' : 'â† NONZERO'}\n\n`;
  }
  
  const nonzero = graph.V.filter(v => !isZeroFlux(div_result.div_map.get(v.canon_id)));
  report += `\nSummary: ${nonzero.length}/${graph.V.length} vertices with nonzero divergence\n`;
  
  return report;
}

function generateWitnessReport(witnesses) {
  let report = `WITNESS REPORT\n`;
  report += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;
  
  if (witnesses.length === 0) {
    report += `No falsifier witnesses detected.\n`;
    report += `Conservation may hold (pending closure verification).\n`;
    return report;
  }
  
  report += `Total unique witnesses: ${witnesses.length}\n\n`;
  
  for (let i = 0; i < witnesses.length; i++) {
    const w = witnesses[i];
    report += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
    report += `Witness #${i+1}: ${w.cycle_size}-cycle with leak\n`;
    report += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
    report += `Cycle nodes: ${w.cycle_nodes.join(' â†” ')}\n`;
    report += `Leak: ${w.leak_source} â†’ ${w.leak_target}\n`;
    report += `Leak flux: ${formatFlux(w.leak_flux)}\n`;
    report += `Divergence at source: ${formatFlux(w.divergence_at_source)}\n`;
    report += `Falsifies conservation: ${w.falsifies_conservation ? 'YES' : 'NO'}\n\n`;
  }
  
  const falsifies = witnesses.some(w => w.falsifies_conservation);
  report += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
  report += `VERDICT: Conservation ${falsifies ? 'FALSIFIED' : 'HOLDS'}\n`;
  report += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
  
  return report;
}

// ============================================================================
// UI FUNCTIONS
// ============================================================================

function updateStatusBadges(badges) {
  const container = document.getElementById('statusBadges');
  container.innerHTML = '';
  
  for (const [label, status] of Object.entries(badges)) {
    const badge = document.createElement('span');
    badge.className = `badge ${status}`;
    badge.textContent = label;
    container.appendChild(badge);
  }
}

function addStatus(type, message) {
  const container = document.getElementById('statusContainer');
  const div = document.createElement('div');
  div.className = `status ${type}`;
  div.textContent = message;
  container.appendChild(div);
}

function updateMetrics(mechanism, graph, witnesses) {
  document.getElementById('metricMech').textContent = mechanism.meta.name;
  document.getElementById('metricStates').textContent = graph.V.length;
  document.getElementById('metricEdges').textContent = graph.E.length;
  
  const cycles = findCycles(graph);
  document.getElementById('metricCycles').textContent = cycles.length;
  document.getElementById('metricWitnesses').textContent = witnesses.length;
  
  const falsifies = witnesses.some(w => w.falsifies_conservation);
  const verdict = falsifies ? 'FALSIFIED' : 'HOLDS';
  const verdictEl = document.getElementById('metricConservation');
  verdictEl.textContent = verdict;
  verdictEl.style.color = falsifies ? '#ff4a4a' : '#4aff4a';
}

function createDownloadLinks(outputs) {
  const links = [
    { name: 'trace.json', data: outputs.trace, label: 'ğŸ“„ Trace Bundle' },
    { name: 'graph.json', data: outputs.graph, label: 'ğŸ”— Graph Summary' },
    { name: 'divergence.json', data: outputs.divergence, label: 'ğŸ“Š Divergence Data' },
    { name: 'witnesses.json', data: outputs.witnesses, label: 'âš ï¸ Witnesses' }
  ];
  
  const container = document.getElementById('downloadLinks');
  container.innerHTML = '';
  
  for (const link of links) {
    const json_str = JSON.stringify(link.data, null, 2);
    const blob = new Blob([json_str], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${outputs.mechanism.meta.name}_${link.name}`;
    a.textContent = link.label;
    a.className = 'download-btn';
    container.appendChild(a);
  }
  
  document.getElementById('exportBtn').disabled = false;
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

let currentOutputs = null;

document.getElementById('runBtn').addEventListener('click', async () => {
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('Starting evaluation...');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  // Clear previous results
  document.getElementById('statusContainer').innerHTML = '';
  document.getElementById('divergenceReport').textContent = 'Generating...';
  document.getElementById('witnessReport').textContent = 'Analyzing...';
  
  updateStatusBadges({
    'ğŸ”„ Running': 'blue'
  });
  
  try {
    // Load mechanism
    const preset = document.getElementById('mechanismSelect').value;
    const user_steps = parseInt(document.getElementById('refineSteps').value);
    const seed = parseInt(document.getElementById('seed').value);
    
    addStatus('info', `Loading mechanism: ${preset}`);
    const mechanism = MechanismLoader.load(preset);
    console.log('Mechanism loaded:', mechanism.meta.name);
    
    // Use mechanism's exact_steps if specified, otherwise use user input
    const steps = mechanism.exact_steps || user_steps;
    if (mechanism.exact_steps) {
      console.log(`Using mechanism exact_steps: ${steps} (overriding UI value)`);
      addStatus('info', `Using exact steps for minimal falsifier: ${steps}`);
    }
    
    // Execute refinement
    addStatus('info', 'Executing refinement...');
    const executor = new RefinementExecutor(mechanism, seed);
    const trace = executor.execute(steps);
    console.log(`Trace captured: ${trace.steps.length} steps, ${trace.states.size} states`);
    
    // Build graph
    addStatus('info', 'Building refinement graph...');
    const graph = buildGraph(trace);
    
    // Compute divergence
    addStatus('info', 'Computing divergence...');
    const div_result = computeDivergence(graph);
    
    // Detect falsifier
    addStatus('info', 'Detecting witnesses...');
    const witnesses = detectFalsifier(graph, div_result);
    
    // Generate reports
    addStatus('info', 'Generating reports...');
    const div_report = generateDivergenceReport(mechanism, graph, div_result);
    const wit_report = generateWitnessReport(witnesses);
    
    // Update UI
    document.getElementById('divergenceReport').textContent = div_report;
    document.getElementById('witnessReport').textContent = wit_report;
    
    updateMetrics(mechanism, graph, witnesses);
    
    // Prepare outputs
    currentOutputs = {
      mechanism: mechanism,
      trace: {
        meta: {
          chamber: 'XXX',
          version: '1.0.0',
          instrument_stage: 'implementation',
          timestamp: new Date().toISOString(),
          seed: seed
        },
        mechanism: mechanism,
        states: Array.from(trace.states.values()),
        steps: trace.steps
      },
      graph: {
        meta: { 
          chamber: 'XXX', 
          instrument_stage: 'implementation',
          timestamp: new Date().toISOString() 
        },
        vertices: graph.V,
        edges: graph.E,
        metrics: graph.metrics
      },
      divergence: {
        meta: { 
          chamber: 'XXX', 
          carrier: INVARIANTS.carrier_group,
          instrument_stage: 'implementation'
        },
        divergence_map: Object.fromEntries(div_result.div_map),
        summary: {
          num_vertices: graph.V.length,
          nonzero_count: graph.V.filter(v => !isZeroFlux(div_result.div_map.get(v.canon_id))).length
        }
      },
      witnesses: {
        meta: { 
          chamber: 'XXX', 
          instrument_stage: 'implementation',
          timestamp: new Date().toISOString() 
        },
        witnesses: witnesses,
        summary: {
          total: witnesses.length,
          falsifies: witnesses.some(w => w.falsifies_conservation)
        }
      }
    };
    
    createDownloadLinks(currentOutputs);
    
    // Update badges
    const falsifies = witnesses.some(w => w.falsifies_conservation);
    updateStatusBadges({
      'âœ“ Mechanism Loaded': 'green',
      'âœ“ Graph Constructed': 'green',
      'âœ“ Divergence Computed': 'green',
      'âœ“ Witnesses Detected': 'green',
      [falsifies ? 'âŠ— Conservation Falsified' : 'âœ“ Conservation Holds']: falsifies ? 'red' : 'green'
    });
    
    addStatus('success', 'Evaluation complete!');
    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('Evaluation complete');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
  } catch (error) {
    console.error('Error during evaluation:', error);
    addStatus('error', `Error: ${error.message}`);
    updateStatusBadges({ 'âŒ Error': 'red' });
  }
});

// Export bundle button
document.getElementById('exportBtn').addEventListener('click', () => {
  if (!currentOutputs) {
    addStatus('error', 'No outputs available. Run evaluation first.');
    return;
  }
  
  // Create complete bundle
  const bundle = {
    meta: {
      chamber: 'XXX',
      bundle_type: 'complete_evidence',
      instrument_stage: 'implementation',
      timestamp: new Date().toISOString(),
      mechanism: currentOutputs.mechanism.meta.name
    },
    trace: currentOutputs.trace,
    graph: currentOutputs.graph,
    divergence: currentOutputs.divergence,
    witnesses: currentOutputs.witnesses
  };
  
  const json_str = JSON.stringify(bundle, null, 2);
  const blob = new Blob([json_str], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `${currentOutputs.mechanism.meta.name}_complete_bundle.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  addStatus('success', `Bundle exported: ${a.download}`);
  console.log(`âœ“ Complete bundle exported: ${a.download}`);
});

// Initialize
window.addEventListener('DOMContentLoaded', () => {
  console.log('Chamber XXX MVP loaded');
  console.log('Calibration-locked invariants:', INVARIANTS);
  
  // Test canonicalization
  const canon_test = CanonV0.test();
  console.log('Canonicalization test:', canon_test.all_pass ? 'PASS' : 'FAIL');
  
  if (!canon_test.all_pass) {
    addStatus('error', 'Canonicalization test failed!');
    document.getElementById('runBtn').disabled = true;
  }
  
  updateStatusBadges({ 'âš™ï¸ Ready': 'gray' });
});

  </script>
</body>
</html>
