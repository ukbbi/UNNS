<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Physics Protocols</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            padding: 40px 20px;
            background: rgba(15, 15, 35, 0.8);
            border-bottom: 2px solid #00ffff;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 200%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            animation: sweep 8s linear infinite;
        }
        
        @keyframes sweep {
            to { left: 100%; }
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            z-index: 1;
        }
        
        .subtitle {
            font-size: 1.2em;
            color: #aaa;
            position: relative;
            z-index: 1;
        }
        
        .nav-tabs {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            padding: 20px;
            background: rgba(26, 26, 62, 0.5);
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .tab-button {
            padding: 10px 20px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
            border-radius: 5px;
        }
        
        .tab-button:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 255, 255, 0.3);
        }
        
        .tab-button.active {
            background: rgba(255, 0, 255, 0.2);
            border-color: #ff00ff;
            color: #ff00ff;
        }
        
        .content-area {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .protocol-section {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }
        
        .protocol-section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .protocol-card {
            background: rgba(26, 26, 62, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .protocol-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ffff);
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: -1;
        }
        
        .protocol-card:hover::before {
            opacity: 0.3;
        }
        
        h2 {
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        h3 {
            color: #ff00ff;
            margin: 20px 0 15px 0;
            font-size: 1.3em;
        }
        
        .concept-box {
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid #00ffff;
            padding: 15px;
            margin: 15px 0;
        }
        
        .equation {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            overflow-x: auto;
            color: #00ff88;
        }
        
        .visualization {
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }
        
        svg {
            max-width: 100%;
            height: auto;
        }
        
        .progression-diagram {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
        }
        
        .stage-card {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            padding: 20px;
            flex: 1 1 250px;
            max-width: 300px;
            transition: all 0.3s;
        }
        
        .stage-card:hover {
            transform: scale(1.05);
            background: rgba(255, 0, 255, 0.1);
            border-color: #ff00ff;
        }
        
        .references {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
            padding: 30px;
            margin-top: 50px;
        }
        
        .ref-link {
            display: block;
            color: #00ffff;
            text-decoration: none;
            padding: 8px 0;
            transition: all 0.3s;
        }
        
        .ref-link:hover {
            color: #ff00ff;
            padding-left: 10px;
        }
        
        .flow-arrow {
            font-size: 2em;
            color: #00ffff;
            text-align: center;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            50% { opacity: 0.5; }
        }
        
        .interactive-demo {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        button {
            background: linear-gradient(45deg, #00ffff, #00cccc);
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px;
        }
        
        button:hover {
            background: linear-gradient(45deg, #ff00ff, #cc00cc);
            transform: scale(1.05);
        }
        
        .highlight {
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.2));
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>UNNS Physics Protocols</h1>
        <div class="subtitle">From Recursive Vectors to Black Holes</div>
    </div>

    <div class="nav-tabs">
        <button class="tab-button active" onclick="showSection('overview')">Overview</button>
        <button class="tab-button" onclick="showSection('foundations')">Foundations</button>
        <button class="tab-button" onclick="showSection('classical')">Classical Field Theory</button>
        <button class="tab-button" onclick="showSection('quantum')">Quantum Theory</button>
        <button class="tab-button" onclick="showSection('gravity')">Gravity & Holography</button>
        <button class="tab-button" onclick="showSection('references')">References</button>
    </div>

    <div class="content-area">
        <!-- Overview Section -->
        <section id="overview" class="protocol-section active">
            <div class="protocol-card">
                <h2>The UNNS Physics Journey</h2>
                <p>The UNNS Physics Protocols establish a comprehensive framework that bridges recursive mathematics with fundamental physics. This journey takes us from basic vector spaces through gauge theory, quantum mechanics, and ultimately to models of gravity and black holes.</p>
                
                <div class="progression-diagram">
                    <div class="stage-card">
                        <h3>Stage 1: Foundations</h3>
                        <p><span class="highlight">Vector Protocol</span> → <span class="highlight">Tensor Protocol</span></p>
                        <p>Establish linear and multilinear structures for recursive nests</p>
                    </div>
                    
                    <div class="stage-card">
                        <h3>Stage 2: Classical</h3>
                        <p><span class="highlight">Gauge Protocol</span> → <span class="highlight">Lagrangian</span> → <span class="highlight">Hamiltonian</span></p>
                        <p>Develop action principles and energy conservation</p>
                    </div>
                    
                    <div class="stage-card">
                        <h3>Stage 3: Quantum</h3>
                        <p><span class="highlight">Quantization</span> → <span class="highlight">Path Integral</span> → <span class="highlight">Gauge Path Integral</span></p>
                        <p>Introduce quantum operators and sum-over-histories</p>
                    </div>
                    
                    <div class="stage-card">
                        <h3>Stage 4: Gravity</h3>
                        <p><span class="highlight">Gauge-Gravity</span> → <span class="highlight">Holographic</span> → <span class="highlight">Black Holes</span></p>
                        <p>Emergent geometry from recursive substrates</p>
                    </div>
                </div>

                <div class="visualization">
                    <svg viewBox="0 0 800 400" id="overview-animation">
                        <!-- Will be populated by animation -->
                    </svg>
                </div>
            </div>
        </section>

        <!-- Foundations Section -->
        <section id="foundations" class="protocol-section">
            <div class="protocol-card">
                <h2>Vector & Tensor Protocols</h2>
                <h3>The UNNS Vector Protocol (UVP)</h3>
                <p>The Vector Protocol establishes the linear algebraic foundation by mapping nests into vector spaces.</p>
                
                <div class="concept-box">
                    <strong>Key Concept:</strong> Nest Vectorization<br>
                    <div class="equation">V(N) = Σ(k≥0) a_k e_k ∈ V</div>
                    Maps recursive sequences to infinite-dimensional vectors with basis {e_k}.
                </div>

                <div class="interactive-demo">
                    <h4>Vector Visualization</h4>
                    <svg viewBox="0 0 600 300" id="vector-viz">
                        <!-- Vector animation will go here -->
                    </svg>
                    <button onclick="animateVector()">Animate Vectorization</button>
                </div>

                <h3>The UNNS Tensor Protocol (UTP)</h3>
                <p>Extends vectors to tensors for multilinear recursive interactions.</p>
                
                <div class="concept-box">
                    <strong>Key Innovation:</strong> Tensor products of nests enable interaction modeling<br>
                    <div class="equation">T(N₁,...,Nᵣ) = V(N₁) ⊗ ... ⊗ V(Nᵣ)</div>
                </div>
                
                <p>The tensor protocol introduces:</p>
                <ul style="margin-left: 20px;">
                    <li>• Multilinear operator actions</li>
                    <li>• Contraction operations (trace analogs)</li>
                    <li>• Recursion curvature tensors from non-commuting operators</li>
                </ul>
            </div>
        </section>

        <!-- Classical Field Theory Section -->
        <section id="classical" class="protocol-section">
            <div class="protocol-card">
                <h2>Classical Field Theory Protocols</h2>
                
                <h3>Gauge Protocol</h3>
                <p>Treats UNNS operators as connections on a recursion mesh.</p>
                
                <div class="concept-box">
                    <strong>Connection:</strong> A : V → End(V)<br>
                    <strong>Curvature:</strong> F(v,w) = [A(v), A(w)] - A([v,w])
                </div>

                <div class="interactive-demo">
                    <h4>Gauge Field Visualization</h4>
                    <svg viewBox="0 0 600 300" id="gauge-field">
                        <!-- Gauge field animation -->
                    </svg>
                    <button onclick="animateGaugeField()">Show Field Lines</button>
                    <button onclick="showCurvature()">Show Curvature</button>
                </div>

                <h3>Lagrangian Protocol</h3>
                <p>Defines action principles for recursive dynamics.</p>
                
                <div class="equation">
                    S[A] = ∫ [½⟨F,F⟩ + V(A)] dμ
                </div>
                
                <p>Variational principle yields recursive Euler-Lagrange equations.</p>

                <h3>Hamiltonian Protocol</h3>
                <p>Introduces phase space and energy conservation.</p>
                
                <div class="concept-box">
                    <strong>Phase Space:</strong> P = {(aᵢ, pᵢ) | i ≥ 0}<br>
                    <strong>Hamilton's Equations:</strong><br>
                    <div class="equation">ȧᵢ = ∂H/∂pᵢ, ṗᵢ = -∂H/∂aᵢ</div>
                </div>
            </div>
        </section>

        <!-- Quantum Theory Section -->
        <section id="quantum" class="protocol-section">
            <div class="protocol-card">
                <h2>Quantum Protocols</h2>
                
                <h3>Quantization Protocol</h3>
                <p>Elevates nests to quantum states in Hilbert space.</p>
                
                <div class="concept-box">
                    <strong>Vacuum State:</strong> |0⟩ = Zero Nest<br>
                    <strong>Creation/Annihilation:</strong> â†ᵢ, âᵢ operators<br>
                    <strong>Commutation:</strong> [âᵢ, â†ⱼ] = δᵢⱼ
                </div>

                <div class="interactive-demo">
                    <h4>Quantum State Evolution</h4>
                    <svg viewBox="0 0 600 300" id="quantum-states">
                        <!-- Quantum visualization -->
                    </svg>
                    <button onclick="createExcitation()">Create Excitation</button>
                    <button onclick="annihilate()">Annihilate</button>
                </div>

                <h3>Path Integral Protocol</h3>
                <p>Sum-over-histories formulation for recursive trajectories.</p>
                
                <div class="equation">
                    Z = Σ_γ exp(iS[γ])
                </div>
                
                <p>Each recursive path γ contributes with phase weight from action S[γ].</p>

                <h3>Gauge Path Integral</h3>
                <p>Combines gauge theory with path integrals, introducing Wilson loops.</p>
                
                <div class="concept-box">
                    <strong>Wilson Loop:</strong> ⟨W(C)⟩ = (1/Z) ∫ Daₑ Tr(U(C)) exp(iS_G)<br>
                    Measures recursion curvature around closed paths.
                </div>
            </div>
        </section>

        <!-- Gravity & Holography Section -->
        <section id="gravity" class="protocol-section">
            <div class="protocol-card">
                <h2>Gravity & Holographic Protocols</h2>
                
                <h3>Gauge-Gravity Correspondence</h3>
                <p>Recursion coefficients on edges define discrete geometry.</p>
                
                <div class="concept-box">
                    <strong>Key Principle:</strong> Boundary recursion ⟺ Bulk geometry<br>
                    Discrete Ricci curvature emerges from gauge holonomies.
                </div>

                <div class="interactive-demo">
                    <h4>Emergent Geometry</h4>
                    <svg viewBox="0 0 600 400" id="emergent-geometry">
                        <!-- Geometry visualization -->
                    </svg>
                    <button onclick="showBoundary()">Show Boundary</button>
                    <button onclick="showBulk()">Show Bulk</button>
                    <button onclick="animateHolography()">Animate Correspondence</button>
                </div>

                <h3>Holographic Principle</h3>
                <p>All bulk information is encoded in boundary UNNS sequences.</p>
                
                <div class="equation">
                    I(Bulk) ≤ S(Boundary)
                </div>
                
                <p>This UNNS analog of AdS/CFT suggests reality emerges from boundary recursion data.</p>

                <h3>Black Hole Model</h3>
                <p>Recursion collapse generates horizons with entropic boundaries.</p>
                
                <div class="concept-box">
                    <strong>Horizon Condition:</strong> Recursion coefficients stabilize to fixed point<br>
                    <strong>Entropy Law:</strong> S = α · #{boundary nests}<br>
                    <strong>Information Paradox:</strong> Resolved via repair operators
                </div>

                <div class="interactive-demo">
                    <h4>Black Hole Formation</h4>
                    <svg viewBox="0 0 600 400" id="black-hole">
                        <!-- Black hole visualization -->
                    </svg>
                    <button onclick="collapseRecursion()">Initiate Collapse</button>
                    <button onclick="showHorizon()">Show Horizon</button>
                    <button onclick="showEntropy()">Calculate Entropy</button>
                </div>
            </div>
        </section>

        <!-- References Section -->
        <section id="references" class="protocol-section">
            <div class="references">
                <h2>References & Resources</h2>
                <p>Complete documentation for the UNNS Physics Protocols:</p>
                
                <h3>Foundation Protocols</h3>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Vector Protocol.pdf" class="ref-link">
                    📄 The UNNS Vector Protocol (UVP) - Linear structures for recursive nests
                </a>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Tensor Protoco.pdf" class="ref-link">
                    📄 The UNNS Tensor Protocol (UTP) - Multilinear extensions and curvature
                </a>
                
                <h3>Classical Field Theory</h3>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Gauge Protocol.pdf" class="ref-link">
                    📄 The UNNS Gauge Protocol (UGP) - Connections and field strengths
                </a>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Lagrangian Protocol.pdf" class="ref-link">
                    📄 The UNNS Lagrangian Protocol (ULP) - Action principles
                </a>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Hamiltonian Protocol.pdf" class="ref-link">
                    📄 The UNNS Hamiltonian Protocol (UHP) - Phase space and conservation
                </a>
                
                <h3>Quantum Theory</h3>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Quantization Protocol.pdf" class="ref-link">
                    📄 The UNNS Quantization Protocol (UQP) - Operators and Hilbert space
                </a>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Path Integral Protoco.pdf" class="ref-link">
                    📄 The UNNS Path Integral Protocol (UPIP) - Sum-over-histories
                </a>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Gauge Path Integral.pdf" class="ref-link">
                    📄 The UNNS Gauge Path Integral (UGPI) - Wilson loops and holonomy
                </a>
                
                <h3>Gravity & Holography</h3>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Gauge–Gravity Correspondence.pdf" class="ref-link">
                    📄 The UNNS Gauge-Gravity Correspondence (UGGC) - Emergent geometry
                </a>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Holographic Principle.pdf" class="ref-link">
                    📄 The UNNS Holographic Principle (UHP) - Boundary/bulk duality
                </a>
                <a href="https://ukbbi.github.io/UNNS/docs/protocols/The UNNS Black Hole Mode.pdf" class="ref-link">
                    📄 The UNNS Black Hole Model (UBHM) - Recursion collapse and horizons
                </a>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255, 0, 255, 0.3);">
                    <p style="color: #888;">These protocols establish UNNS as a comprehensive mathematical substrate capable of modeling phenomena from quantum mechanics to general relativity through the lens of recursive number theory.</p>
                </div>
            </div>
        </section>
    </div>

    <script>
        // Tab switching functionality
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.protocol-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionId).classList.add('active');
            
            // Mark corresponding tab as active
            event.target.classList.add('active');
            
            // Initialize animations for the shown section
            if (sectionId === 'overview') {
                animateOverview();
            }
        }
        
        // Overview animation
        function animateOverview() {
            const svg = document.getElementById('overview-animation');
            svg.innerHTML = `
                <defs>
                    <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#00ffff;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#ff00ff;stop-opacity:1" />
                    </linearGradient>
                </defs>
                
                <!-- Protocol nodes -->
                <g id="protocol-nodes">
                    <circle cx="100" cy="200" r="30" fill="rgba(0,255,255,0.2)" stroke="#00ffff" stroke-width="2">
                        <animate attributeName="r" values="30;35;30" dur="3s" repeatCount="indefinite"/>
                    </circle>
                    <text x="100" y="205" text-anchor="middle" fill="#00ffff" font-size="12">Vector</text>
                    
                    <circle cx="250" cy="150" r="30" fill="rgba(0,255,255,0.2)" stroke="#00ffff" stroke-width="2">
                        <animate attributeName="r" values="30;35;30" dur="3s" begin="0.2s" repeatCount="indefinite"/>
                    </circle>
                    <text x="250" y="155" text-anchor="middle" fill="#00ffff" font-size="12">Tensor</text>
                    
                    <circle cx="400" cy="100" r="30" fill="rgba(255,0,255,0.2)" stroke="#ff00ff" stroke-width="2">
                        <animate attributeName="r" values="30;35;30" dur="3s" begin="0.4s" repeatCount="indefinite"/>
                    </circle>
                    <text x="400" y="105" text-anchor="middle" fill="#ff00ff" font-size="12">Gauge</text>
                    
                    <circle cx="550" cy="150" r="30" fill="rgba(255,0,255,0.2)" stroke="#ff00ff" stroke-width="2">
                        <animate attributeName="r" values="30;35;30" dur="3s" begin="0.6s" repeatCount="indefinite"/>
                    </circle>
                    <text x="550" y="155" text-anchor="middle" fill="#ff00ff" font-size="12">Quantum</text>
                    
                    <circle cx="700" cy="200" r="30" fill="rgba(255,255,0,0.2)" stroke="#ffff00" stroke-width="2">
                        <animate attributeName="r" values="30;35;30" dur="3s" begin="0.8s" repeatCount="indefinite"/>
                    </circle>
                    <text x="700" y="205" text-anchor="middle" fill="#ffff00" font-size="12">Gravity</text>
                </g>
                
                <!-- Connecting paths -->
                <g id="connections">
                    <path d="M130 200 Q190 175, 220 150" fill="none" stroke="url(#grad1)" stroke-width="2" opacity="0.6">
                        <animate attributeName="stroke-dasharray" values="0 100;100 0" dur="2s" repeatCount="indefinite"/>
                    </path>
                    <path d="M280 150 Q340 125, 370 100" fill="none" stroke="url(#grad1)" stroke-width="2" opacity="0.6">
                        <animate attributeName="stroke-dasharray" values="0 100;100 0" dur="2s" begin="0.5s" repeatCount="indefinite"/>
                    </path>
                    <path d="M430 100 Q490 125, 520 150" fill="none" stroke="url(#grad1)" stroke-width="2" opacity="0.6">
                        <animate attributeName="stroke-dasharray" values="0 100;100 0" dur="2s" begin="1s" repeatCount="indefinite"/>
                    </path>
                    <path d="M580 150 Q640 175, 670 200" fill="none" stroke="url(#grad1)" stroke-width="2" opacity="0.6">
                        <animate attributeName="stroke-dasharray" values="0 100;100 0" dur="2s" begin="1.5s" repeatCount="indefinite"/>
                    </path>
                </g>
                
                <!-- Flow particles -->
                <g id="particles">
                    <circle r="3" fill="#00ffff">
                        <animateMotion dur="8s" repeatCount="indefinite">
                            <mpath href="#flow-path"/>
                        </animateMotion>
                    </circle>
                    <circle r="3" fill="#ff00ff">
                        <animateMotion dur="8s" begin="2s" repeatCount="indefinite">
                            <mpath href="#flow-path"/>
                        </animateMotion>
                    </circle>
                </g>
                
                <path id="flow-path" d="M100,200 Q250,100 400,100 T700,200" fill="none" stroke="none"/>
            `;
        }
        
        // Vector animation
        function animateVector() {
            const svg = document.getElementById('vector-viz');
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#00ffff" />
                    </marker>
                </defs>
                
                <!-- Coordinate axes -->
                <line x1="50" y1="250" x2="550" y2="250" stroke="#444" stroke-width="2"/>
                <line x1="50" y1="250" x2="50" y2="50" stroke="#444" stroke-width="2"/>
                
                <!-- Vector components -->
                <g id="vector-components">
                    ${[1, 0.8, 0.6, 0.4, 0.3, 0.2].map((val, i) => `
                        <line x1="${100 + i*70}" y1="250" x2="${100 + i*70}" y2="${250 - val*150}"
                              stroke="#00ffff" stroke-width="3" opacity="0"
                              marker-end="url(#arrowhead)">
                            <animate attributeName="opacity" to="1" dur="0.5s" begin="${i*0.2}s" fill="freeze"/>
                            <animate attributeName="y2" from="250" to="${250 - val*150}" dur="0.5s" begin="${i*0.2}s" fill="freeze"/>
                        </line>
                        <text x="${100 + i*70}" y="270" text-anchor="middle" fill="#00ffff" font-size="12" opacity="0">
                            e${i}
                            <animate attributeName="opacity" to="1" dur="0.5s" begin="${i*0.2 + 0.5}s" fill="freeze"/>
                        </text>
                    `).join('')}
                </g>
                
                <!-- Labels -->
                <text x="300" y="30" text-anchor="middle" fill="#00ffff" font-size="16">V(N) = Σ aₖeₖ</text>
            `;
        }
        
        // Gauge field animation
        function animateGaugeField() {
            const svg = document.getElementById('gauge-field');
            const fieldLines = [];
            
            for(let i = 0; i < 8; i++) {
                for(let j = 0; j < 5; j++) {
                    const x = 50 + i * 70;
                    const y = 50 + j * 50;
                    const angle = Math.sin(i * 0.5) * Math.cos(j * 0.5) * Math.PI;
                    const dx = Math.cos(angle) * 20;
                    const dy = Math.sin(angle) * 20;
                    
                    fieldLines.push(`
                        <line x1="${x}" y1="${y}" x2="${x + dx}" y2="${y + dy}"
                              stroke="#00ffff" stroke-width="2" opacity="0"
                              marker-end="url(#arrowhead)">
                            <animate attributeName="opacity" to="0.7" dur="0.5s" begin="${(i+j)*0.05}s" fill="freeze"/>
                        </line>
                    `);
                }
            }
            
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto">
                        <polygon points="0 0, 6 2, 0 4" fill="#00ffff" />
                    </marker>
                </defs>
                ${fieldLines.join('')}
                <text x="300" y="280" text-anchor="middle" fill="#00ffff" font-size="14">Gauge Connection Field A</text>
            `;
        }
        
        function showCurvature() {
            const svg = document.getElementById('gauge-field');
            svg.innerHTML += `
                <circle cx="300" cy="150" r="60" fill="none" stroke="#ff00ff" stroke-width="2" opacity="0">
                    <animate attributeName="opacity" to="1" dur="1s" fill="freeze"/>
                    <animate attributeName="r" from="0" to="60" dur="1s" fill="freeze"/>
                </circle>
                <text x="300" y="150" text-anchor="middle" fill="#ff00ff" font-size="14">F = [A,A]</text>
            `;
        }
        
        // Quantum state animations
        function createExcitation() {
            const svg = document.getElementById('quantum-states');
            const levels = [0, 1, 2, 3, 4].map(n => 250 - n * 40);
            
            svg.innerHTML = `
                <!-- Energy levels -->
                ${levels.map((y, n) => `
                    <line x1="100" y1="${y}" x2="500" y2="${y}" stroke="#444" stroke-width="1"/>
                    <text x="80" y="${y + 5}" text-anchor="end" fill="#00ffff" font-size="12">n=${n}</text>
                `).join('')}
                
                <!-- Excitation -->
                <circle cx="300" cy="${levels[0]}" r="8" fill="#00ffff">
                    <animate attributeName="cy" from="${levels[0]}" to="${levels[2]}" dur="0.5s" fill="freeze"/>
                    <animate attributeName="fill" values="#00ffff;#ff00ff;#00ffff" dur="0.5s"/>
                </circle>
                
                <text x="300" y="30" text-anchor="middle" fill="#ff00ff" font-size="14">â†|n⟩ = |n+1⟩</text>
            `;
        }
        
        function annihilate() {
            const svg = document.getElementById('quantum-states');
            const levels = [0, 1, 2, 3, 4].map(n => 250 - n * 40);
            
            svg.innerHTML = `
                <!-- Energy levels -->
                ${levels.map((y, n) => `
                    <line x1="100" y1="${y}" x2="500" y2="${y}" stroke="#444" stroke-width="1"/>
                    <text x="80" y="${y + 5}" text-anchor="end" fill="#00ffff" font-size="12">n=${n}</text>
                `).join('')}
                
                <!-- Annihilation -->
                <circle cx="300" cy="${levels[3]}" r="8" fill="#ff00ff">
                    <animate attributeName="cy" from="${levels[3]}" to="${levels[1]}" dur="0.5s" fill="freeze"/>
                    <animate attributeName="r" from="8" to="0" dur="0.5s" begin="0.5s" fill="freeze"/>
                </circle>
                
                <text x="300" y="30" text-anchor="middle" fill="#00ffff" font-size="14">â|n⟩ = √n|n-1⟩</text>
            `;
        }
        
        // Holography animations
        function showBoundary() {
            const svg = document.getElementById('emergent-geometry');
            svg.innerHTML = `
                <rect x="50" y="50" width="500" height="300" fill="none" stroke="#00ffff" stroke-width="3" stroke-dasharray="10,5">
                    <animate attributeName="stroke-width" values="3;5;3" dur="2s" repeatCount="indefinite"/>
                </rect>
                <text x="300" y="30" text-anchor="middle" fill="#00ffff" font-size="14">Boundary Recursion Layer</text>
            `;
        }
        
        function showBulk() {
            const svg = document.getElementById('emergent-geometry');
            const existingContent = svg.innerHTML;
            svg.innerHTML = existingContent + `
                <g opacity="0">
                    ${Array.from({length: 20}, (_, i) => {
                        const x = 100 + Math.random() * 400;
                        const y = 100 + Math.random() * 200;
                        return `<circle cx="${x}" cy="${y}" r="3" fill="#ff00ff"/>`;
                    }).join('')}
                    <animate attributeName="opacity" to="1" dur="1s" fill="freeze"/>
                </g>
                <text x="300" y="380" text-anchor="middle" fill="#ff00ff" font-size="14">Bulk Geometry</text>
            `;
        }
        
        function animateHolography() {
            const svg = document.getElementById('emergent-geometry');
            svg.innerHTML = `
                <!-- Boundary -->
                <rect x="50" y="50" width="500" height="300" fill="none" stroke="#00ffff" stroke-width="2"/>
                
                <!-- Bulk points emerging from boundary -->
                <g id="holographic-mapping">
                    ${Array.from({length: 15}, (_, i) => {
                        const angle = (i / 15) * Math.PI * 2;
                        const startX = 300 + 200 * Math.cos(angle);
                        const startY = 200 + 100 * Math.sin(angle);
                        const endX = 300 + (100 + Math.random() * 50) * Math.cos(angle);
                        const endY = 200 + (50 + Math.random() * 30) * Math.sin(angle);
                        
                        return `
                            <circle r="4" fill="#ff00ff">
                                <animate attributeName="cx" from="${startX}" to="${endX}" dur="2s" repeatCount="indefinite"/>
                                <animate attributeName="cy" from="${startY}" to="${endY}" dur="2s" repeatCount="indefinite"/>
                                <animate attributeName="opacity" values="0;1;1;0" dur="2s" repeatCount="indefinite"/>
                            </circle>
                        `;
                    }).join('')}
                </g>
                
                <text x="300" y="30" text-anchor="middle" fill="#00ffff" font-size="14">Boundary → Bulk Correspondence</text>
            `;
        }
        
        // Black hole animations
        function collapseRecursion() {
            const svg = document.getElementById('black-hole');
            svg.innerHTML = `
                <!-- Recursion layers collapsing -->
                <g id="collapse-animation">
                    ${Array.from({length: 6}, (_, i) => {
                        const r = 150 - i * 20;
                        return `
                            <circle cx="300" cy="200" r="${r}" fill="none" stroke="#00ffff" stroke-width="2" opacity="${1 - i*0.15}">
                                <animate attributeName="r" to="30" dur="${2 + i*0.2}s" fill="freeze"/>
                                <animate attributeName="opacity" to="0" dur="${2 + i*0.2}s" fill="freeze"/>
                            </circle>
                        `;
                    }).join('')}
                </g>
                
                <!-- Singularity -->
                <circle cx="300" cy="200" r="5" fill="#ff00ff" opacity="0">
                    <animate attributeName="opacity" to="1" dur="0.5s" begin="2.5s" fill="freeze"/>
                    <animate attributeName="r" values="5;10;5" dur="1s" begin="2.5s" repeatCount="indefinite"/>
                </circle>
                
                <text x="300" y="350" text-anchor="middle" fill="#00ffff" font-size="14">Recursion Collapse → Black Hole</text>
            `;
        }
        
        function showHorizon() {
            const svg = document.getElementById('black-hole');
            svg.innerHTML += `
                <circle cx="300" cy="200" r="60" fill="none" stroke="#ff00ff" stroke-width="3" stroke-dasharray="5,5" opacity="0">
                    <animate attributeName="opacity" to="1" dur="1s" fill="freeze"/>
                    <animateTransform attributeName="transform" type="rotate" from="0 300 200" to="360 300 200" dur="20s" repeatCount="indefinite"/>
                </circle>
                <text x="300" y="120" text-anchor="middle" fill="#ff00ff" font-size="12">Event Horizon</text>
            `;
        }
        
        function showEntropy() {
            const svg = document.getElementById('black-hole');
            const existingContent = svg.innerHTML;
            
            // Calculate boundary nests
            const boundaryNests = 12;
            const entropy = Math.log(boundaryNests) * 2.5;
            
            svg.innerHTML = existingContent + `
                <text x="300" y="380" text-anchor="middle" fill="#ffff00" font-size="14" opacity="0">
                    S = ${entropy.toFixed(2)} (${boundaryNests} boundary nests)
                    <animate attributeName="opacity" to="1" dur="1s" fill="freeze"/>
                </text>
            `;
        }
        
        // Initialize overview animation on load
        window.addEventListener('load', () => {
            animateOverview();
        });
    </script>
</body>
</html>