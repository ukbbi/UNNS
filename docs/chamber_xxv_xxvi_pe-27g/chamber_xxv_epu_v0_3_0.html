<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory â€” Chamber XXV: EPU v0.3.0</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Consolas', 'Monaco', monospace; 
      background: #0a0a0a; 
      color: #e0e0e0;
      line-height: 1.6;
    }
    
    .container { 
      max-width: 1600px; 
      margin: 0 auto; 
      padding: 20px; 
    }
    
    /* Header */
    header { 
      text-align: center; 
      margin-bottom: 30px; 
      padding: 30px 20px; 
      border-bottom: 2px solid #2a2a2a;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2a 100%);
    }
    
    h1 { 
      font-size: 2.2em; 
      color: #4a9eff; 
      letter-spacing: 2px;
      margin-bottom: 10px;
    }
    
    .subtitle { 
      color: #888; 
      margin-top: 10px; 
      font-size: 0.95em; 
    }
    
    .badges {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    .badge {
      background: #1a2a3a;
      color: #4a9eff;
      padding: 5px 12px;
      border-radius: 12px;
      font-size: 0.85em;
      border: 1px solid #2a4a6a;
    }
    
    /* Panels */
    .panel { 
      background: #1a1a1a; 
      border: 1px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 20px; 
      margin-bottom: 20px; 
    }
    
    .panel-title { 
      font-size: 1.2em; 
      color: #4a9eff; 
      margin-bottom: 15px; 
      padding-bottom: 10px; 
      border-bottom: 1px solid #2a2a2a;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    #guideToggle {
      background: #2a4a7a;
      color: #e0e0e0;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }
    
    #guideToggle:hover {
      background: #3a5a8a;
    }
    
    .panel-subtitle {
      font-size: 0.85em;
      color: #888;
      margin-bottom: 15px;
    }
    
    /* Controls */
    .controls { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); 
      gap: 15px; 
      margin-bottom: 20px; 
    }
    
    .control-group { 
      display: flex; 
      flex-direction: column; 
    }
    
    label { 
      font-size: 0.9em; 
      color: #aaa; 
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    input[type="number"], 
    input[type="range"], 
    select { 
      background: #0a0a0a; 
      border: 1px solid #3a3a3a; 
      color: #e0e0e0; 
      padding: 8px; 
      border-radius: 4px; 
      font-family: inherit;
      font-size: 0.9em;
    }
    
    input[type="number"]:focus,
    select:focus {
      outline: none;
      border-color: #4a9eff;
    }
    
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
    }
    
    /* Buttons */
    button { 
      background: #2a4a7a; 
      border: none; 
      color: #e0e0e0; 
      padding: 12px 24px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-family: inherit;
      font-size: 0.95em;
      margin-right: 10px;
      margin-bottom: 10px;
      transition: background 0.2s;
    }
    
    button:hover { 
      background: #3a5a8a; 
    }
    
    button:disabled { 
      background: #1a1a1a; 
      color: #555; 
      cursor: not-allowed; 
    }
    
    .button-primary { 
      background: #4a9eff; 
    }
    
    .button-primary:hover {
      background: #5aaeff;
    }
    
    .button-secondary {
      background: #4a7a4a;
    }
    
    .button-secondary:hover {
      background: #5a8a5a;
    }
    
    .button-danger {
      background: #7a4a4a;
    }
    
    .button-danger:hover {
      background: #8a5a5a;
    }
    
    .preset-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .preset-btn {
      background: #2a3a4a;
      padding: 8px 16px;
      font-size: 0.85em;
    }
    
    /* Metrics */
    .metrics { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
      gap: 12px; 
    }
    
    .metric { 
      background: #0a0a0a; 
      padding: 12px; 
      border-radius: 4px; 
      border: 1px solid #2a2a2a; 
    }
    
    .metric-label { 
      font-size: 0.8em; 
      color: #888; 
      margin-bottom: 5px; 
    }
    
    .metric-value { 
      font-size: 1.2em; 
      color: #4a9eff; 
      font-weight: bold;
      word-break: break-all;
    }
    
    .metric-value.good { color: #4aff4a; }
    .metric-value.warning { color: #ffaa4a; }
    .metric-value.error { color: #ff4a4a; }
    
    /* Status */
    .status { 
      padding: 12px; 
      border-radius: 4px; 
      margin-top: 15px; 
      font-size: 0.9em;
      display: none;
    }
    
    .status.running { 
      background: #2a4a2a; 
      color: #4aff4a;
      display: block;
    }
    
    .status.complete { 
      background: #2a3a4a; 
      color: #4a9eff;
      display: block;
    }
    
    .status.error {
      background: #4a2a2a;
      color: #ff4a4a;
      display: block;
    }
    
    /* Progress Bar */
    .progress-bar { 
      width: 100%; 
      height: 4px; 
      background: #1a1a1a; 
      border-radius: 2px; 
      overflow: hidden; 
      margin-top: 10px; 
    }
    
    .progress-fill { 
      height: 100%; 
      background: #4a9eff; 
      transition: width 0.3s;
      width: 0%;
    }
    
    /* Canvas Container */
    .canvas-container { 
      position: relative; 
      background: #000; 
      border: 1px solid #2a2a2a; 
      border-radius: 4px;
      margin-top: 15px;
      min-height: 400px;
    }
    
    canvas { 
      width: 100%; 
      height: 100%;
      display: block;
    }
    
    .canvas-label { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      background: rgba(0,0,0,0.7); 
      padding: 5px 10px; 
      border-radius: 3px; 
      font-size: 0.9em; 
      color: #4a9eff;
      border: 1px solid #2a2a2a;
    }
    
    .canvas-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .canvas-controls button {
      padding: 8px 16px;
      font-size: 0.85em;
    }
    
    .canvas-btn.active {
      background: #4a9eff;
    }
    
    /* Residuals Table */
    .residuals-table {
      width: 100%;
      margin-top: 15px;
      border-collapse: collapse;
      font-size: 0.9em;
    }
    
    .residuals-table th,
    .residuals-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #2a2a2a;
    }
    
    .residuals-table th {
      color: #4a9eff;
      font-weight: bold;
    }
    
    .residuals-table tr:hover {
      background: #0a0a0a;
    }
    
    /* Info boxes */
    .info-box {
      background: #1a2a3a;
      border-left: 3px solid #4a9eff;
      padding: 12px;
      margin: 15px 0;
      border-radius: 4px;
    }
    
    .warning-box {
      background: #2a1a1a;
      border-left: 3px solid #ff4a4a;
      padding: 12px;
      margin: 15px 0;
      border-radius: 4px;
    }
    
    /* Layout grids */
    .two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    
    @media (max-width: 1024px) {
      .two-column {
        grid-template-columns: 1fr;
      }
    }
    
    /* Scrollable content */
    .scrollable {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 10px;
    }
    
    .scrollable::-webkit-scrollbar {
      width: 8px;
    }
    
    .scrollable::-webkit-scrollbar-track {
      background: #0a0a0a;
    }
    
    .scrollable::-webkit-scrollbar-thumb {
      background: #2a2a2a;
      border-radius: 4px;
    }
    
    .scrollable::-webkit-scrollbar-thumb:hover {
      background: #3a3a3a;
    }
    
    /* Helper text */
    .helper-text {
      font-size: 0.85em;
      color: #666;
      margin-top: 5px;
    }
    
    .inline-code {
      background: #0a0a0a;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <header>
      <h1>âš›ï¸ CHAMBER XXV: EMPIRICAL PROJECTION & UNIFICATION</h1>
      <div class="subtitle">Operator XXV â€” Recursion-to-Observable Mapping Engine</div>
      <div class="badges">
        <span class="badge">Phase-E</span>
        <span class="badge">UNNS-Lab v0.1.0</span>
        <span class="badge">Empirical Diagnostic Engine</span>
        <span class="badge">Ï„-Field Compatible</span>
        <span class="badge">RK-25 Kernel</span>
      </div>
    </header>
    
    <!-- Control Panel A: Recursion Sweep -->
    <div class="panel">
      <div class="panel-title">ğŸ”„ Module A â€” Recursion Sweep Configuration</div>
      <div class="panel-subtitle">Configure Î³-dependent recursion parameters</div>
      
      <div class="controls">
        <div class="control-group">
          <label>Î³ Min</label>
          <input type="number" id="gammaMin" value="1.55" step="0.01" min="0.1" max="3.0">
        </div>
        <div class="control-group">
          <label>Î³ Max</label>
          <input type="number" id="gammaMax" value="1.68" step="0.01" min="0.1" max="3.0">
        </div>
        <div class="control-group">
          <label>Î³ Step</label>
          <input type="number" id="gammaStep" value="0.01" step="0.001" min="0.001" max="0.1">
        </div>
        <div class="control-group">
          <label>Recursion Depth</label>
          <input type="number" id="depth" value="200" step="50" min="50" max="1000">
        </div>
        <div class="control-group">
          <label>Grid Resolution</label>
          <select id="gridRes">
            <option value="32">32Ã—32 (fast)</option>
            <option value="64" selected>64Ã—64 (balanced)</option>
            <option value="128">128Ã—128 (high-res)</option>
          </select>
        </div>
        <div class="control-group">
          <label>RNG Seed</label>
          <input type="number" id="seed" value="137042" step="1">
        </div>
      </div>
      
      <button id="runSweep" class="button-primary">â–¶ Run Sweep</button>
      <button id="stopSweep" class="button-danger" disabled>â¸ Stop</button>
      <button id="resetSweep">ğŸ”„ Reset</button>
      
      <div id="statusSweep" class="status"></div>
      <div class="progress-bar"><div id="progressSweep" class="progress-fill"></div></div>
    </div>
    
    <!-- Control Panel B: Projection Parameters -->
    <div class="panel">
      <div class="panel-title">ğŸ¯ Module B â€” Projection Configuration (PE-26)</div>
      <div class="panel-subtitle">Log-normalized physical projection with domain-specific presets</div>
      
      <div class="controls">
        <div class="control-group">
          <label><strong>Projection Model</strong></label>
          <select id="projModel">
            <option value="cosmoLSS" selected>Cosmo+LSS (Î›, Hâ‚€, N_eff, Ïƒâ‚ˆ, r_drag, n_s)</option>
            <option value="precision">Precision Physics (Î±, Î¼, g_e)</option>
            <option value="unified">Unified (All 10 observables)</option>
            <option value="taufield">Ï„-Field (curvature-stability)</option>
            <option value="cosmology">Legacy: Cosmology</option>
            <option value="em">Legacy: Electromagnetic</option>
            <option value="hybrid">Legacy: Hybrid</option>
          </select>
          <div class="helper-text">Domain-specific parameter presets</div>
        </div>
      </div>
      
      <div class="preset-buttons">
        <button class="preset-btn" id="presetCosmoLSS">ğŸ“¡ Load Cosmo+LSS Preset</button>
        <button class="preset-btn" id="presetPrecision">âš¡ Load Precision Physics</button>
        <button class="preset-btn" id="presetUnified">ğŸ”€ Load Unified Preset</button>
        <button class="preset-btn" id="presetTauField">ğŸŒ€ Load Ï„-Field Preset</button>
      </div>
      
      <div style="margin-top: 20px;">
        <button id="autoCalibrate" class="button-primary" disabled>
          ğŸ¯ Auto-Calibrate (TE-26)
        </button>
        <button id="resetTheta" disabled>
          ğŸ”„ Reset Î¸ to Defaults
        </button>
      </div>
      
      <div id="statusCalibration" class="status" style="margin-top: 15px;"></div>
      
      <!-- Theta Display -->
      <div style="margin-top: 20px;">
        <strong style="color: #4a9eff;">Current Î¸ Parameters:</strong>
        <table class="residuals-table" style="margin-top: 10px; font-size: 0.85em;">
          <thead>
            <tr>
              <th>Observable</th>
              <th>kâ‚€</th>
              <th>k_R</th>
              <th>k_Ï</th>
              <th>k_S</th>
              <th>k_Î³</th>
            </tr>
          </thead>
          <tbody id="thetaDisplay">
            <tr><td colspan="6" style="text-align: center; color: #666;">Run sweep to display Î¸</td></tr>
          </tbody>
        </table>
      </div>
      
      <div class="info-box" style="margin-top: 15px;">
        <strong>PE-26 Log-Domain Model:</strong><br>
        logâ‚â‚€(O<sub>pred</sub>/O<sub>ref</sub>) = kâ‚€ + k<sub>R</sub>Â·f<sub>R</sub> + k<sub>Ï</sub>Â·f<sub>Ï</sub> + k<sub>S</sub>Â·f<sub>S</sub> + k<sub>Î³</sub>Â·f<sub>Î³</sub><br>
        <span style="color: #888; font-size: 0.9em;">Features normalized to geometric means | Physically accurate Ï‡Â² regime</span>
      </div>
    </div>
    
    <!-- Control Panel C: Dataset Selection & Fit Strategy -->
    <div class="panel">
      <div class="panel-title">ğŸ“Š Module C/D â€” Dataset Selection & Fit Configuration</div>
      <div class="panel-subtitle">Select empirical datasets and optimization strategy</div>
      
      <div style="margin-bottom: 15px;">
        <strong style="color: #4a9eff;">Active Datasets:</strong>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 10px;">
          <div class="checkbox-group">
            <input type="checkbox" id="datasetLambda" checked>
            <label for="datasetLambda">Î› (Cosmological constant)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetH0" checked>
            <label for="datasetH0">Hâ‚€ (Hubble constant)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetAlpha" checked>
            <label for="datasetAlpha">Î± (Fine-structure)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetRhovac">
            <label for="datasetRhovac">Ï_vac (Vacuum density)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetNeff" checked>
            <label for="datasetNeff">N_eff (Relativistic species)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetSigma8" checked>
            <label for="datasetSigma8">Ïƒâ‚ˆ (Matter fluctuation)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetRdrag" checked>
            <label for="datasetRdrag">r_drag (BAO sound horizon)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetMu">
            <label for="datasetMu">Î¼ = m_p / m_e</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetGe">
            <label for="datasetGe">g_e (Electron g-factor)</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="datasetNs" checked>
            <label for="datasetNs">n_s (Scalar spectral index)</label>
          </div>
        </div>
      </div>
      
      <div class="controls">
        <div class="control-group">
          <label>Fit Strategy</label>
          <select id="fitStrategy">
            <option value="grid" selected>Grid Sweep</option>
            <option value="local">Local Refinement</option>
            <option value="random">Random Sampling</option>
            <option value="hybrid">Hybrid Scan</option>
          </select>
        </div>
        <div class="control-group">
          <label>Ï‡Â² Method</label>
          <select id="chi2Method">
            <option value="standard" selected>Standard</option>
            <option value="robust">Robust</option>
            <option value="weighted">Weighted</option>
          </select>
        </div>
      </div>
      
      <div class="info-box">
        <strong>ğŸ“Œ Empirical Values (Embedded):</strong><br>
        Î› = 1.1056Ã—10â»âµÂ² mâ»Â² (Planck 2018)<br>
        Hâ‚€ = 67.4 km/s/Mpc (Planck 2018)<br>
        Î± = 7.2973525693Ã—10â»Â³ (CODATA 2018)<br>
        Ï_vac = 5.96Ã—10â»Â¹â° J/mÂ³ (derived)
      </div>
    </div>
    
    <!-- Metrics Panel -->
    <div class="panel">
      <div class="panel-title">ğŸ“ˆ Real-Time Metrics</div>
      
      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Î³â˜… (Best-fit)</div>
          <div class="metric-value" id="metricGammaStar">â€”</div>
        </div>
        <div class="metric">
          <div class="metric-label">Ï‡Â² Total</div>
          <div class="metric-value" id="metricChi2">â€”</div>
        </div>
        <div class="metric">
          <div class="metric-label">Ï‡Â²/dof</div>
          <div class="metric-value" id="metricChi2Dof">â€”</div>
        </div>
        <div class="metric">
          <div class="metric-label">Current Î³</div>
          <div class="metric-value" id="metricGamma">â€”</div>
        </div>
        <div class="metric">
          <div class="metric-label">R_r (Curvature)</div>
          <div class="metric-value" id="metricRr">â€”</div>
        </div>
        <div class="metric">
          <div class="metric-label">Ï_I (Info Density)</div>
          <div class="metric-value" id="metricRhoI">â€”</div>
        </div>
        <div class="metric">
          <div class="metric-label">Variance</div>
          <div class="metric-value" id="metricVar">â€”</div>
        </div>
        <div class="metric">
          <div class="metric-label">Stability</div>
          <div class="metric-value" id="metricStab">â€”</div>
        </div>
      </div>
    </div>
    
    <!-- Visualization Panel -->
    <div class="panel">
      <div class="panel-title">ğŸ“Š Module E â€” Visualization Layer</div>
      
      <div class="canvas-controls">
        <button class="canvas-btn active" data-view="chi2">Ï‡Â² Curve</button>
        <button class="canvas-btn" data-view="observables">Observable Curves</button>
        <button class="canvas-btn" data-view="residuals">Residuals</button>
        <button class="canvas-btn" data-view="heatmap">2D Heatmap</button>
      </div>
      
      <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
        <div class="canvas-label" id="canvasLabel">Ï‡Â² vs Î³ Curve</div>
      </div>
    </div>
    
    <!-- Residuals Table -->
    <div class="panel">
      <div class="panel-title">ğŸ“‹ Best-Fit Residuals</div>
      
      <table class="residuals-table" id="residualsTable">
        <thead>
          <tr>
            <th>Observable</th>
            <th>Predicted</th>
            <th>Observed</th>
            <th>Sigma (Ïƒ)</th>
            <th>Residual</th>
            <th>Z-score</th>
            <th>Ï‡Â² Contrib</th>
          </tr>
        </thead>
        <tbody id="residualsBody">
          <tr><td colspan="7" style="text-align: center; color: #666;">Run sweep to generate residuals</td></tr>
        </tbody>
      </table>
    </div>
    
    <!-- Export Panel -->
    <div class="panel">
      <div class="panel-title">ğŸ’¾ Module F â€” Export Engine</div>
      
      <button id="exportJSON" class="button-secondary" disabled>ğŸ“¦ Export Complete JSON</button>
      <button id="exportResiduals" disabled>ğŸ“„ Export Residuals JSON</button>
      <button id="exportCSV" disabled>ğŸ“Š Export Residuals CSV</button>
      
      <div class="info-box" style="margin-top: 15px;">
        <strong>Export Format:</strong> chamber_xxv_epu_YYYY-MM-DD.json<br>
        Contains: config, recursion sweep, projections, Ï‡Â² landscape, best-fit solution, residuals
      </div>
    </div>
    
    <!-- Laboratory Guide -->
    <div class="panel">
      <div class="panel-title">
        ğŸ“š Laboratory Guide
        <button id="guideToggle" style="margin-left: auto; padding: 6px 12px; font-size: 0.85em;">â–¼ Hide Guide</button>
      </div>
      
      <div id="guideContent" class="scrollable" style="line-height: 1.8; color: #aaa; display: block;">
        
        <!-- CHAMBER XXV GUIDE v0.3.0 START -->
<section id="chamber-xxv-guide" class="xxv-guide">
  <style>
    .xxv-guide {
      padding: 1.5rem 1.75rem;
      background: radial-gradient(circle at top left, rgba(80,120,255,0.15), transparent 55%);
      color: #e6ecff;
      font-size: 0.95rem;
      line-height: 1.6;
    }
    .xxv-guide h2,
    .xxv-guide h3 {
      margin: 1.1rem 0 0.4rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      color: #f4f5ff;
    }
    .xxv-guide h2 {
      font-size: 1.35rem;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      padding-bottom: 0.4rem;
    }
    .xxv-guide h3 {
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 1.4rem;
    }
    .xxv-guide p {
      margin: 0.25rem 0 0.7rem;
    }
    .xxv-guide ul {
      margin: 0.2rem 0 0.8rem 1.2rem;
      padding-left: 0;
    }
    .xxv-guide li {
      margin: 0.15rem 0;
    }
    .xxv-guide-strong {
      font-weight: 600;
      color: #ffffff;
    }
    .xxv-pill {
      display: inline-block;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: rgba(110,180,255,0.11);
      border: 1px solid rgba(110,180,255,0.35);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-right: 0.3rem;
    }
    .xxv-module-icon {
      width: 22px;
      height: 22px;
      flex: 0 0 auto;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #8cf8ff, #4252ff);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 0 1px rgba(140,248,255,0.4);
    }
    .xxv-module-icon svg {
      width: 16px;
      height: 16px;
    }
    .xxv-guide-metadata {
      margin-bottom: 0.8rem;
      font-size: 0.82rem;
      opacity: 0.8;
    }
    .xxv-guide-metadata span {
      margin-right: 0.8rem;
    }
    .xxv-callout {
      border-left: 3px solid rgba(154,229,255,0.8);
      padding: 0.55rem 0.85rem;
      margin: 0.4rem 0 0.9rem;
      background: linear-gradient(to right, rgba(75,125,255,0.14), transparent);
      font-size: 0.86rem;
    }
    .xxv-guide-em {
      color: #aee3ff;
      font-style: normal;
      font-weight: 500;
    }
    .xxv-guide-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr);
      gap: 0.9rem 1.5rem;
      margin-top: 0.4rem;
    }
    @media (max-width: 900px) {
      .xxv-guide-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .xxv-guide-grid-block {
      background: rgba(8,14,40,0.8);
      border-radius: 0.7rem;
      padding: 0.7rem 0.85rem;
      border: 1px solid rgba(143,187,255,0.22);
      font-size: 0.86rem;
    }
    .xxv-guide-grid-block strong {
      display: block;
      margin-bottom: 0.25rem;
      color: #ffffff;
    }
    .xxv-badge-row {
      margin: 0.4rem 0 0.9rem;
    }
    .xxv-badge {
      display: inline-block;
      padding: 0.12rem 0.55rem;
      border-radius: 999px;
      font-size: 0.78rem;
      margin-right: 0.35rem;
      border: 1px solid rgba(255,255,255,0.2);
      background: radial-gradient(circle at 0 0, rgba(255,255,255,0.15), transparent 55%);
    }
    .xxv-badge.phase {
      border-color: rgba(135,205,255,0.75);
    }
    .xxv-badge.engine {
      border-color: rgba(200,160,255,0.7);
    }
    .xxv-badge.mode {
      border-color: rgba(160,255,210,0.7);
    }
    .xxv-guide-table {
      width: 100%;
      border-collapse: collapse;
      margin: 0.2rem 0 0.8rem;
      font-size: 0.86rem;
    }
    .xxv-guide-table th,
    .xxv-guide-table td {
      padding: 0.2rem 0.4rem;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .xxv-guide-table th {
      text-align: left;
      font-weight: 600;
      color: #cfd8ff;
      background: rgba(32,46,96,0.7);
    }
    .xxv-guide-table td {
      color: #dae3ff;
    }
    .xxv-guide-kpi {
      display: inline-block;
      padding: 0.08rem 0.4rem;
      border-radius: 0.4rem;
      background: rgba(120,220,170,0.18);
      border: 1px solid rgba(120,220,170,0.6);
      font-size: 0.78rem;
      margin-left: 0.25rem;
    }
  </style>

  <h2>Chamber XXV â€” Empirical Projection &amp; Unification (v0.3.0)</h2>
  <div class="xxv-guide-metadata">
    <span><strong>Purpose:</strong> Recursion â†’ Observables (Cosmology, LSS, Precision)</span>
    <span><strong>Engine:</strong> PE-26 Projection, Î³-Sweep, Î¸-Calibration</span>
  </div>
  <div class="xxv-badge-row">
    <span class="xxv-badge phase">Phase E Lab</span>
    <span class="xxv-badge engine">PE-26 Projection Engine</span>
    <span class="xxv-badge mode">Chamber XXV Â· v0.3.0</span>
  </div>

  <p>
    Chamber XXV is the <span class="xxv-guide-strong">Empirical Projection &amp; Unification (EPU)</span> engine of the UNNS Substrate.
    It maps recursion geometry at a given <span class="xxv-guide-em">Î³</span> into a set of
    <span class="xxv-guide-em">empirical observables</span> drawn from:
  </p>
  <ul>
    <li><span class="xxv-guide-strong">Cosmology</span> â€” Î›, Hâ‚€, Ï_vac</li>
    <li><span class="xxv-guide-strong">Large-Scale Structure (LSS)</span> â€” N_eff, Ïƒâ‚ˆ, r_drag, n_s</li>
    <li><span class="xxv-guide-strong">Precision Physics</span> â€” Î±, Î¼, g_e</li>
  </ul>
  <p>
    The goal is <span class="xxv-guide-strong">not</span> to claim new physical predictions, but to test how far
    a <span class="xxv-guide-em">single recursion signature</span> can reproduce the existing empirical structure
    before micro-recursion operators (XVI, XVII, XXI) become necessary.
  </p>

  <div class="xxv-callout">
    <span class="xxv-guide-strong">Key idea:</span>
    Chamber XXV is a <span class="xxv-guide-em">macro-recursion</span> engine. It is excellent at matching cosmology &amp; LSS,
    and deliberately limited for precision-scale observables. Chamber XXVI is dedicated to the micro-recursion regime.
  </div>

  <!-- MODULE A -->
  <h3>
    <span class="xxv-module-icon">
      <!-- Module A Icon: Î³-sweep spiral -->
      <svg viewBox="0 0 24 24">
        <path d="M12 4.5a5.5 5.5 0 0 0-5.5 5.5 1 1 0 1 0 2 0 3.5 3.5 0 0 1 3.5-3.5 3 3 0 0 1 0 6h-0.6a1 1 0 1 0 0 2H12a5 5 0 0 0 0-10z"
              fill="#e9f7ff"/>
        <circle cx="12" cy="12" r="7.5" fill="none" stroke="#d0e8ff" stroke-width="1.2" stroke-dasharray="3 2"/>
      </svg>
    </span>
    <span><span class="xxv-pill">Module A</span> Recursion Sweep (Î³-Landscape)</span>
  </h3>
  <p>
    Module A scans a range of <span class="xxv-guide-em">Î³</span> values. For each Î³, it runs the internal recursion engine,
    extracts geometric features, and evaluates how well they reproduce the active datasets.
  </p>
  <p><span class="xxv-guide-strong">Inputs:</span></p>
  <ul>
    <li><span class="xxv-guide-strong">Î³ Min, Î³ Max, Î³ Step</span> â€” sweep range (for example 1.55 â†’ 1.68, Î”Î³ = 0.01).</li>
    <li><span class="xxv-guide-strong">Recursion Depth</span> â€” number of recursion iterations; higher depth gives smoother results, but slower runs.</li>
    <li><span class="xxv-guide-strong">Grid Resolution</span> â€” size of the sampling grid for recursion geometry (e.g. 64Ã—64, 128Ã—128).</li>
    <li><span class="xxv-guide-strong">RNG Seed</span> â€” fixes random components for reproducibility.</li>
  </ul>
  <p><span class="xxv-guide-strong">Outputs:</span></p>
  <ul>
    <li><span class="xxv-guide-em">Î³â˜…</span> â€” the best-fit value at which the global Ï‡Â² is minimal.</li>
    <li><span class="xxv-guide-strong">Ï‡Â²(Î³) curve</span> â€” how total misfit changes along the Î³-axis.</li>
    <li><span class="xxv-guide-strong">Recursion features</span> â€” curvature, variance, stability metrics at each Î³.</li>
  </ul>
  <div class="xxv-callout">
    A clean, bowl-shaped Ï‡Â²(Î³) curve indicates a <span class="xxv-guide-em">stable recursion</span> and a well-behaved projection.
    The selected Î³â˜… is then used in all downstream PE-26 computations.
  </div>

  <!-- MODULE B -->
  <h3>
    <span class="xxv-module-icon">
      <!-- Module B Icon: projection matrix -->
      <svg viewBox="0 0 24 24">
        <rect x="4" y="5" width="6" height="6" rx="1.2" fill="#e9f7ff"/>
        <rect x="14" y="5" width="6" height="6" rx="1.2" fill="none" stroke="#e9f7ff" stroke-width="1.1"/>
        <rect x="4" y="13" width="6" height="6" rx="1.2" fill="none" stroke="#e9f7ff" stroke-width="1.1"/>
        <path d="M10 8h4M7 11v2M17 11v2" stroke="#b9d6ff" stroke-width="1"/>
      </svg>
    </span>
    <span><span class="xxv-pill">Module B</span> Projection Configuration (PE-26)</span>
  </h3>
  <p>
    PE-26 is the <span class="xxv-guide-strong">recursion-to-observable projection model</span>.
    It takes recursion features at Î³â˜…:
  </p>
  <ul>
    <li><span class="xxv-guide-em">f_R</span> â€” curvature response,</li>
    <li><span class="xxv-guide-em">f_p</span> â€” propagation term,</li>
    <li><span class="xxv-guide-em">f_S</span> â€” structural drift,</li>
    <li><span class="xxv-guide-em">f_Î³</span> â€” Î³-derivative mode,</li>
  </ul>
  <p>
    and forms predictions using a log-domain linear mapping:
  </p>
  <p>
    <code>log10(O_pred / O_ref) = k0 + k_R f_R + k_p f_p + k_S f_S + k_Î³ f_Î³</code>
  </p>
  <p>
    Each observable has its own parameter set (Î¸-vector) in PE-26:
  </p>
  <table class="xxv-guide-table">
    <thead>
      <tr>
        <th>Regime</th>
        <th>Observables</th>
        <th>Î¸-Parameters</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Cosmology</td>
        <td>Î›, Hâ‚€, Ï_vac</td>
        <td>kâ‚€, k_R, k_p, k_S, k_Î³ for each</td>
      </tr>
      <tr>
        <td>LSS</td>
        <td>N_eff, Ïƒâ‚ˆ, r_drag, n_s</td>
        <td>kâ‚€, k_R, k_p, k_S, k_Î³ for each</td>
      </tr>
      <tr>
        <td>Precision</td>
        <td>Î±, Î¼, g_e</td>
        <td>kâ‚€, k_R, k_p, k_S, k_Î³ for each</td>
      </tr>
    </tbody>
  </table>
  <p>
    The Î¸-table can be edited manually or loaded via presets. PE-26 itself is agnostic to the origin of Î¸; it simply
    projects recursion features into the observable space.
  </p>

  <!-- MODULE C/D -->
  <h3>
    <span class="xxv-module-icon">
      <!-- Module C/D Icon: dataset selector -->
      <svg viewBox="0 0 24 24">
        <rect x="4" y="6" width="16" height="12" rx="2" fill="none" stroke="#e9f7ff" stroke-width="1.2"/>
        <path d="M8 10h3M8 14h4.5" stroke="#b9d6ff" stroke-width="1.2" stroke-linecap="round"/>
        <circle cx="16.5" cy="10" r="0.9" fill="#e9f7ff"/>
        <circle cx="16.5" cy="14" r="0.9" fill="#e9f7ff"/>
      </svg>
    </span>
    <span><span class="xxv-pill">Modules C &amp; D</span> Dataset Selection &amp; Fit Strategy</span>
  </h3>
  <p>
    Modules C and D control <span class="xxv-guide-strong">which empirical observables are active</span> and how the fit
    is evaluated.
  </p>
  <p><span class="xxv-guide-strong">Available observables:</span></p>
  <div class="xxv-guide-grid">
    <div class="xxv-guide-grid-block">
      <strong>Cosmology</strong>
      <ul>
        <li>Î› â€” cosmological constant / dark energy density</li>
        <li>Hâ‚€ â€” Hubble parameter</li>
        <li>Ï_vac â€” vacuum energy density proxy</li>
      </ul>
    </div>
    <div class="xxv-guide-grid-block">
      <strong>Large-Scale Structure (LSS)</strong>
      <ul>
        <li>N_eff â€” effective number of neutrino species</li>
        <li>Ïƒâ‚ˆ â€” clustering amplitude</li>
        <li>r_drag â€” BAO drag scale</li>
        <li>n_s â€” scalar spectral index</li>
      </ul>
    </div>
    <div class="xxv-guide-grid-block">
      <strong>Precision Physics</strong>
      <ul>
        <li>Î± â€” fine-structure constant</li>
        <li>Î¼ â€” proton-to-electron mass ratio</li>
        <li>g_e â€” electron g-factor</li>
      </ul>
    </div>
    <div class="xxv-guide-grid-block">
      <strong>Fit Strategy</strong>
      <ul>
        <li>Î³-sweep with fixed Î¸ (default)</li>
        <li>Î¸-tuning via presets</li>
        <li>Ï‡Â² total / Ï‡Â² per observable readout</li>
      </ul>
    </div>
  </div>

  <p>
    The chamber computes a standard Ï‡Â² score:
  </p>
  <p><code>Ï‡Â² = Î£ ((O_pred - O_obs) / Ïƒ)Â²</code></p>
  <p>
    You can enable/disable observables to study how different subsets pull the Î³-fit and affect the total Ï‡Â².
  </p>

  <h3>
    <span class="xxv-module-icon">
      <!-- Module E Icon: plots/visualization -->
      <svg viewBox="0 0 24 24">
        <path d="M5 17L9.5 11l3 3.5 4-6 2.5 3.5" fill="none" stroke="#e9f7ff" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M4 18.5h16" stroke="#b9d6ff" stroke-width="1.1"/>
        <circle cx="9.5" cy="11" r="1" fill="#e9f7ff"/>
        <circle cx="16.5" cy="8.5" r="1" fill="#e9f7ff"/>
      </svg>
    </span>
    <span><span class="xxv-pill">Module E</span> Ï‡Â² Landscape, Curves &amp; Residuals</span>
  </h3>
  <p>
    The visualization layer shows how well the recursion geometry at Î³â˜… matches the active datasets.
  </p>
  <p><span class="xxv-guide-strong">Components:</span></p>
  <ul>
    <li><span class="xxv-guide-strong">Ï‡Â² vs Î³ curve</span> â€” global fit landscape across the sweep range.</li>
    <li><span class="xxv-guide-strong">Observable curves</span> â€” O_pred(Î³) overlaid with reference ranges.</li>
    <li><span class="xxv-guide-strong">Residual table</span> â€” predicted, observed, residual, z-score, Ï‡Â² contribution for each observable.</li>
    <li><span class="xxv-guide-strong">Optional 2D heatmaps</span> â€” when enabled, show Ï‡Â² or residuals across parameter slices.</li>
  </ul>
  <p>
    Z-scores are the most compact indicator:
    <span class="xxv-guide-kpi">|Z| &lt; 0.1 â†’ excellent</span> Â·
    <span class="xxv-guide-kpi">0.1 &le; |Z| &lt; 1 â†’ mild tension</span> Â·
    <span class="xxv-guide-kpi">|Z| â‰¥ 1 â†’ significant deviation</span>
  </p>

  <!-- MODULE F -->
  <h3>
    <span class="xxv-module-icon">
      <!-- Module F Icon: export arrows -->
      <svg viewBox="0 0 24 24">
        <path d="M7 9.5V6.8C7 6.36 7.36 6 7.8 6h8.4c0.44 0 0.8 0.36 0.8 0.8v2.7"
              fill="none" stroke="#e9f7ff" stroke-width="1.2"/>
        <path d="M12 10.5v7M9.5 14l2.5 3 2.5-3" fill="none" stroke="#e9f7ff" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
        <rect x="5" y="5" width="14" height="14" rx="2.2" fill="none" stroke="#b9d6ff" stroke-width="1.1" stroke-dasharray="3 2"/>
      </svg>
    </span>
    <span><span class="xxv-pill">Module F</span> Export &amp; Downstream Analysis</span>
  </h3>
  <p>
    The export engine captures the full state of the chamber for further analysis or archival.
  </p>
  <p><span class="xxv-guide-strong">JSON export includes:</span></p>
  <ul>
    <li>Sweep parameters (Î³ range, depth, resolution, seed).</li>
    <li>Î³-landscape: Ï‡Â²(Î³), recursion features per Î³, best-fit Î³â˜….</li>
    <li>PE-26 Î¸-table for all 10 observables.</li>
    <li>Best-fit predictions, residuals, z-scores, Ï‡Â² contributions.</li>
    <li>Runtime and stability metrics.</li>
  </ul>
  <p><span class="xxv-guide-strong">CSV export includes:</span></p>
  <ul>
    <li>Residual table only (predicted, observed, residual, z, Ï‡Â²áµ¢) â€” suitable for spreadsheets or plotting.</li>
  </ul>

  <h3>Limitations &amp; Relationship to Chamber XXVI</h3>
  <p>
    Chamber XXV is intentionally limited to a <span class="xxv-guide-em">macro-recursion</span> view:
  </p>
  <ul>
    <li>It matches cosmological and LSS observables remarkably well using PE-26.</li>
    <li>It cannot, by design, fully capture precision observables (Î¼, g_e) that require micro-recursion, torsion kernels, and closure dynamics.</li>
  </ul>
  <p>
    These micro-recursion structures live in Operators XVI, XVII, XXI and are explored in
    <span class="xxv-guide-strong">Chamber XXVI</span>. XXV defines the
    <span class="xxv-guide-em">boundary of PE-26</span>: it shows how far a single Î³-based recursion signature can go
    before we must turn on micro-operators.
  </p>

  <h3>Typical Workflow in Chamber XXV</h3>
  <ol>
    <li>Select the <span class="xxv-guide-strong">Cosmo+LSS preset</span> and run the Î³-sweep to find Î³â˜… and Ï‡Â²_min.</li>
    <li>Inspect the Ï‡Â² curve and residual table to see how cosmology &amp; LSS are matched.</li>
    <li>Switch to the <span class="xxv-guide-strong">Unified Physics preset</span> to include Î±, Î¼, g_e and observe how the fit degrades.</li>
    <li>Optionally adjust Î¸-parameters for specific observables and re-run the sweep.</li>
    <li>Export the JSON or CSV results for documentation, comparison, or downstream analysis (e.g. Chambers XXVI+).</li>
  </ol>
  <p>
    Used this way, Chamber XXV becomes a <span class="xxv-guide-strong">diagnostic lens</span> on the UNNS Substrate:
    it reveals where recursion geometry already mirrors physical structure, and where deeper micro-recursion dynamics
    must be engaged.
  </p>
</section>


<!-- CHAMBER XXV GUIDE v0.3.0 END -->
<!-- ===================== XXV EXTENDED GUIDE: FIT STRATEGY & TE-26 ===================== -->

<hr class="guide-separator">

<h2 id="fit-strategy" class="xxv-guide-heading">
    Fit Strategy &amp; Ï‡Â² Landscape Behaviour
</h2>

<div class="xxv-diagram-row">

    <!-- Î³-sweep bowl icon -->
    <svg class="xxv-diagram-icon" viewBox="0 0 120 60" role="img" aria-label="Gamma sweep chi-squared bowl">
        <defs>
            <linearGradient id="xxv-gamma-grad" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0%" stop-color="#4fa9ff"/>
                <stop offset="100%" stop-color="#a8ffea"/>
            </linearGradient>
        </defs>
        <!-- axis -->
        <line x1="8" y1="52" x2="112" y2="52" stroke="#6c7a89" stroke-width="1"/>
        <line x1="8" y1="8"  x2="8"  y2="52" stroke="#6c7a89" stroke-width="1"/>
        <!-- Ï‡Â² bowl -->
        <path d="M10,45 Q60,5 110,45" fill="none" stroke="url(#xxv-gamma-grad)" stroke-width="2"/>
        <!-- best-fit gamma marker -->
        <circle cx="60" cy="18" r="3" fill="#a8ffea"/>
        <text x="60" y="12" text-anchor="middle" font-size="7" fill="#a8ffea">Î³â˜…</text>
        <text x="112" y="59" text-anchor="end" font-size="7" fill="#6c7a89">Î³</text>
        <text x="12" y="10" text-anchor="start" font-size="7" fill="#6c7a89">Ï‡Â²</text>
    </svg>

</div>

<p>
    The <strong>Fit Strategy</strong> controls how Chamber XXV explores the
    <em>Ï‡Â²(Î³)</em> landscape generated by the recursion engine and the PE-26
    projection model. Different strategies balance completeness vs. speed:
</p>

<ul>
    <li>
        <strong>Grid Sweep</strong> â€”
        dense, uniform sampling of Î³ across the selected range
        (e.g. 1.55â€“1.68 with step 0.01). Best for:
        <ul>
            <li>Global scans for publication-quality Ï‡Â² curves</li>
            <li>Detecting multiple local minima or plateaus</li>
            <li>Comparing different datasets or presets</li>
        </ul>
    </li>

    <li>
        <strong>Local Search</strong> â€”
        starts from a good initial guess (e.g. a known Î³â˜…) and refines nearby
        points. Best for:
        <ul>
            <li>Fast re-calibration after small preset changes</li>
            <li>Fine-tuning Î¸ after a grid sweep has found a basin</li>
        </ul>
    </li>

    <li>
        <strong>Random / Monte-Carlo</strong> â€”
        draws Î³ samples stochastically in the allowed interval. Best for:
        <ul>
            <li>Exploring noisy or irregular Ï‡Â² landscapes</li>
            <li>Stress-testing stability of projected observables</li>
        </ul>
    </li>

    <li>
        <strong>Hybrid</strong> â€”
        combines a coarse grid with local refinement around promising minima.
        This is the recommended mode for:
        <ul>
            <li>Mixed datasets (cosmology + LSS + precision physics)</li>
            <li>Pre-XXVI studies where we probe the limits of macro-recursion</li>
        </ul>
    </li>
</ul>

<p>
    In all cases, the goal is to identify a <strong>robust minimum</strong> of Ï‡Â²(Î³),
    not just a single lucky sample. Good practice:
</p>

<ul>
    <li>Confirm Î³â˜… with at least two different strategies (e.g. grid + local).</li>
    <li>Check that nearby Î³ values do not produce equally good Ï‡Â² â€” otherwise
        the solution is <em>degenerate</em> and should be reported as such.</li>
    <li>For publication, use grid or hybrid with high resolution
        (128Ã—128, depth â‰¥ 400, small Î³ steps).</li>
</ul>

<hr class="guide-separator">

<h2 id="theta-and-te26" class="xxv-guide-heading">
    Î¸-Parameters, TE-26 Auto-Calibration, and Precision Limits
</h2>

<div class="xxv-diagram-row">

    <!-- Projection manifold icon -->
    <svg class="xxv-diagram-icon" viewBox="0 0 140 60" role="img" aria-label="Projection manifold">
        <defs>
            <linearGradient id="xxv-manifold-grad" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0%" stop-color="#4fa9ff"/>
                <stop offset="100%" stop-color="#ff9efc"/>
            </linearGradient>
        </defs>
        <!-- feature axes -->
        <line x1="15" y1="50" x2="15" y2="12" stroke="#6c7a89" stroke-width="1"/>
        <line x1="15" y1="50" x2="120" y2="50" stroke="#6c7a89" stroke-width="1"/>
        <!-- curved surface (projection manifold) -->
        <path d="M15,40 C45,10 80,10 120,40"
              fill="none" stroke="url(#xxv-manifold-grad)" stroke-width="2"/>
        <path d="M15,45 C45,25 80,25 120,45"
              fill="none" stroke="url(#xxv-manifold-grad)" stroke-width="1" opacity="0.6"/>
        <!-- projection ray -->
        <circle cx="60" cy="28" r="3" fill="#a8ffea"/>
        <line x1="60" y1="28" x2="88" y2="10"
              stroke="#a8ffea" stroke-width="1.2" stroke-dasharray="3,2"/>
        <text x="60" y="22" text-anchor="middle" font-size="7" fill="#a8ffea">O<sub>pred</sub></text>
        <text x="19" y="16" font-size="7" fill="#6c7a89">f<sub>R</sub>, f<sub>Ï</sub>, f<sub>S</sub>, f<sub>Î³</sub></text>
    </svg>

</div>

<p>
    PE-26 projects recursion features into observables via the
    <strong>Î¸-parameter matrix</strong>. For each observable <em>O</em>, we use:
</p>

<p class="xxv-inline-math">
    log<sub>10</sub>(O<sub>pred</sub>/O<sub>ref</sub>) =
    k<sub>0</sub> +
    k<sub>R</sub> f<sub>R</sub> +
    k<sub>Ï</sub> f<sub>Ï</sub> +
    k<sub>S</sub> f<sub>S</sub> +
    k<sub>Î³</sub> f<sub>Î³</sub>,
</p>

<p>
    where the <strong>dimensionless features</strong> are:
</p>

<ul>
    <li><strong>f<sub>R</sub></strong> â€” normalized curvature (R<sub>r</sub>/R<sub>0</sub>)</li>
    <li><strong>f<sub>Ï</sub></strong> â€” normalized information density (p<sub>I</sub>/Ï<sub>0</sub>)  
        <em>(this replaces the older label f<sub>p</sub>)</em></li>
    <li><strong>f<sub>S</sub></strong> â€” normalized stability (S/S<sub>0</sub>)</li>
    <li><strong>f<sub>Î³</sub></strong> â€” normalized recursion parameter (Î³/Î³<sub>0</sub>)</li>
</ul>

<p>
    The vector Î¸ = (k<sub>0</sub>, k<sub>R</sub>, k<sub>Ï</sub>, k<sub>S</sub>, k<sub>Î³</sub>)
    defines how strongly each feature influences a given observable.
    <strong>TE-26 auto-calibration</strong> adjusts Î¸ to minimize Ï‡Â² over the selected datasets.
</p>

<h3 class="xxv-guide-subheading">TE-26: Two-Stage Auto-Calibration</h3>

<ol>
    <li>
        <strong>Stage 1 â€” Intercept Grid Search</strong>  
        For each observable, TE-26 sweeps k<sub>0</sub> on a coarse grid to anchor
        O<sub>pred</sub> near O<sub>ref</sub>. This stabilizes the log-ratio and
        prevents runaway residuals.
    </li>
    <li>
        <strong>Stage 2 â€” Slope Refinement</strong>  
        With k<sub>0</sub> fixed, TE-26 performs coordinate descent over
        (k<sub>R</sub>, k<sub>Ï</sub>, k<sub>S</sub>, k<sub>Î³</sub>) to reduce Ï‡Â².
        The process respects preset bounds (e.g. |k| â‰¤ 1.2, and
        |k| â‰¤ 0.02 for precision observables such as Î±).
    </li>
</ol>

<p>
    The result is a <strong>physically meaningful Î¸ matrix</strong> that shows how
    cosmological and large-scale structure observables respond to recursion
    geometry. This works very well for Î›, Hâ‚€, Ï<sub>vac</sub>, N<sub>eff</sub>,
    Ïƒâ‚ˆ, r<sub>drag</sub>, and n<sub>s</sub>.
</p>

<div class="xxv-diagram-row">

    <!-- Residual bar icon -->
    <svg class="xxv-diagram-icon" viewBox="0 0 140 60" role="img" aria-label="Residual diagnostics">
        <defs>
            <linearGradient id="xxv-resid-grad" x1="0" y1="0" x2="1" y2="0">
                <stop offset="0%" stop-color="#4fa9ff"/>
                <stop offset="50%" stop-color="#ffd35c"/>
                <stop offset="100%" stop-color="#ff6b81"/>
            </linearGradient>
        </defs>
        <!-- axis -->
        <line x1="10" y1="50" x2="130" y2="50" stroke="#6c7a89" stroke-width="1"/>
        <!-- bars -->
        <rect x="18" y="30" width="12" height="20" fill="#4cd964"/>
        <rect x="46" y="20" width="12" height="30" fill="#ffd35c"/>
        <rect x="74" y="10" width="12" height="40" fill="#ff6b81"/>
        <rect x="102" y="34" width="12" height="16" fill="#4cd964"/>
        <!-- legend stripe -->
        <rect x="20" y="8" width="90" height="4" fill="url(#xxv-resid-grad)"/>
        <text x="65" y="18" text-anchor="middle" font-size="7" fill="#9ea7b8">|Î”| : small â†’ large</text>
    </svg>

</div>

<h3 class="xxv-guide-subheading">Why Precision Constants (Î±, Î¼, g<sub>e</sub>) are Out of Reach in XXV</h3>

<p>
    Precision QED observables such as the fine-structure constant Î±, the
    proton-to-electron mass ratio Î¼, and the electron g-factor g<sub>e</sub>
    have uncertainties as small as 10â»Â¹Â²â€“10â»â¹. In Chamber XXV:
</p>

<ul>
    <li>We use only <strong>four macro-features</strong>
        (f<sub>R</sub>, f<sub>Ï</sub>, f<sub>S</sub>, f<sub>Î³</sub>).</li>
    <li>The mapping from features to observables is
        <strong>linear in log-space</strong> via Î¸.</li>
    <li>Recursion data comes from a <strong>coarse Î³-sweep</strong> without
        micro-scale torsion or local oscillations.</li>
</ul>

<p>
    This is sufficient to match <strong>macro-observables</strong> (cosmology and
    large-scale structure), but it lacks:
</p>

<ul>
    <li>Micro-curvature oscillations and torsion kernels (Operator XXI).</li>
    <li>Closure-driven flux balancing at small scales (Operator XVI).</li>
    <li>Matrix-level mode coupling between distinct recursion channels
        (Operator XVII and higher-order operators).</li>
</ul>

<p>
    In other words, Chamber XXV deliberately operates in a
    <strong>macro-recursion regime</strong>. It demonstrates that:
</p>

<ul>
    <li>The UNNS Substrate can map recursion geometry to cosmological data
        in a mathematically consistent way.</li>
    <li>There is a clear boundary where macro-recursion stops being expressive
        enough to capture precision quantum physics.</li>
</ul>

<p>
    Chamber XXVI and the PE-27/PE-27C engines extend this framework with
    <strong>micro-recursion modes</strong>, torsion sampling, and operator-level
    diagnostics, specifically to tackle Î±, Î¼, g<sub>e</sub>, and related
    precision observables beyond the capabilities of PE-26.
</p>

<!-- ===================== END XXV EXTENDED GUIDE BLOCK ===================== -->
        
        <p style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #2a2a2a; font-size: 0.85em; color: #666;">
          <strong>Version:</strong> 0.3.0 | <strong>Phase:</strong> E | <strong>Status:</strong> Production Ready | <strong>Kernel:</strong> RK-25 | <strong>Projection:</strong> PE-26 | <strong>Tuning:</strong> TE-26
        </p>
      </div>
    </div>
  </div>
  
  <script>
// ============================================
// CHAMBER XXV â€” EPU v0.3.0
// Empirical Projection & Unification
// UNNS Laboratory Phase-E
// Extended Datasets: 10 observables (EDM-31)
// ============================================

console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
console.log('â•‘  UNNS Phase E | Chamber XXV â€” EPU v0.3.0  â•‘');
console.log('â•‘  Empirical Projection & Unification      â•‘');
console.log('â•‘  PE-26 + TE-26 Auto-Calibration          â•‘');
console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

// ============================================
// MODULE A: RECURSION KERNEL (RK-25)
// ============================================

class RecursionKernelRK25 {
  constructor(config = {}) {
    this.W = config.grid_width || 64;
    this.size = this.W * this.W;
    this.depth = config.depth || 200;
    this.gamma = config.gamma || 1.618;
    this.seed = config.seed || 137042;
    this.rng = this.createSeededRNG(this.seed);
    
    // Field storage
    this.tau = new Float64Array(this.size);
    this.tau_next = new Float64Array(this.size);
    
    // Metrics
    this.step_count = 0;
    
    this.initialize();
  }
  
  initialize() {
    for (let i = 0; i < this.size; i++) {
      this.tau[i] = this.rng.random() * 2 * Math.PI;
    }
    this.step_count = 0;
  }
  
  step() {
    const W = this.W;
    
    for (let y = 0; y < W; y++) {
      for (let x = 0; x < W; x++) {
        const idx = x + y * W;
        
        // Neighbors with periodic BC
        const right = this.tau[((x + 1) % W) + y * W];
        const left = this.tau[((x - 1 + W) % W) + y * W];
        const up = this.tau[x + ((y + 1) % W) * W];
        const down = this.tau[x + ((y - 1 + W) % W) * W];
        
        const center = this.tau[idx];
        
        // Recursive coupling with gamma scaling
        const delta_x = Math.sin(right - center);
        const delta_y = Math.sin(up - center);
        
        // Î³-dependent evolution
        const coupling = 0.1 * this.gamma;
        const laplacian = (right + left + up + down - 4 * center);
        
        this.tau_next[idx] = center + coupling * (delta_x + delta_y) - 0.01 * laplacian;
      }
    }
    
    // Swap buffers
    [this.tau, this.tau_next] = [this.tau_next, this.tau];
    this.step_count++;
  }
  
  evolve(steps) {
    for (let i = 0; i < steps; i++) {
      this.step();
    }
  }
  
  computeMetrics() {
    // Compute R_r (recursive curvature approximation)
    let sum_grad_sq = 0;
    let sum_laplacian_sq = 0;
    
    for (let y = 0; y < this.W; y++) {
      for (let x = 0; x < this.W; x++) {
        const idx = x + y * this.W;
        const center = this.tau[idx];
        
        const right = this.tau[((x + 1) % this.W) + y * this.W];
        const left = this.tau[((x - 1 + this.W) % this.W) + y * this.W];
        const up = this.tau[x + ((y + 1) % this.W) * this.W];
        const down = this.tau[x + ((y - 1 + this.W) % this.W) * this.W];
        
        const grad_x = (right - left) / 2;
        const grad_y = (up - down) / 2;
        const laplacian = (right + left + up + down - 4 * center);
        
        sum_grad_sq += grad_x * grad_x + grad_y * grad_y;
        sum_laplacian_sq += laplacian * laplacian;
      }
    }
    
    const Rr = Math.sqrt(sum_laplacian_sq / this.size);
    
    // Information density (variance-based)
    const mean = this.tau.reduce((a, b) => a + b, 0) / this.size;
    let variance = 0;
    for (let i = 0; i < this.size; i++) {
      variance += (this.tau[i] - mean) ** 2;
    }
    variance /= this.size;
    
    const rhoI = variance;
    
    // Stability metric (inverse of variance rate)
    const stability = 1.0 / (1.0 + variance);
    
    return {
      Rr,
      rhoI,
      variance,
      stability,
      convergence: variance < 1.0
    };
  }
  
  createSeededRNG(seed) {
    let state = seed >>> 0;
    return {
      random() {
        state = (state * 1664525 + 1013904223) >>> 0;
        return state / 4294967296;
      }
    };
  }
}

// ============================================
// MODULE B: PROJECTION ENGINE (PE-25)
// ============================================

class ProjectionEnginePE25 {
  constructor(params = {}) {
    // Physical constants
    this.c = 299792458; // m/s
    this.G = 6.67430e-11; // mÂ³/kgÂ·sÂ²
    this.hbar = 1.054571817e-34; // JÂ·s
    this.phi = 1.618033988749895;
    
    // Projection parameters
    this.l0 = params.l0 || 1.616255e-35; // Planck length
    this.t0 = params.t0 || 5.391247e-44; // Planck time
    this.lambda0 = params.lambda0 || 1.1056e-52; // Cosmological reference
    this.alpha0 = params.alpha0 || 0.0072973525693; // Fine-structure ref
    this.chi_cal = params.chi_cal || 1.0;
    this.beta_r = params.beta_r || 2.0;
    this.zeta_stab = params.zeta_stab || 0.5;
    this.model = params.model || 'cosmology';
  }
  
  project(recursion_summary) {
    const { Rr, rhoI, variance, stability } = recursion_summary;
    
    // Dimensionless scaling factors
    const f_curv = Math.pow(Math.abs(Rr), this.beta_r);
    const f_info = rhoI * this.chi_cal;
    const f_stab = Math.pow(stability, this.zeta_stab);
    
    let Lambda_pred, H0_pred, alpha_pred, rhovac_pred;
    
    if (this.model === 'cosmology') {
      // Cosmological constant projection
      Lambda_pred = this.lambda0 * f_curv * f_stab;
      
      // Hubble constant (km/s/Mpc)
      const H0_SI = Math.sqrt(Lambda_pred * this.c * this.c / 3);
      H0_pred = H0_SI * 3.086e+19 / 1000; // Convert to km/s/Mpc
      
      // Fine-structure (weak dependence in cosmo mode)
      alpha_pred = this.alpha0 * (1 + 0.01 * f_info);
      
      // Vacuum energy density
      rhovac_pred = Lambda_pred * this.hbar * this.c / (8 * Math.PI * this.G * this.l0 * this.l0);
      
    } else if (this.model === 'em') {
      // EM-optimized projection
      alpha_pred = this.alpha0 * f_info * f_stab;
      
      // Weaker cosmological predictions in EM mode
      Lambda_pred = this.lambda0 * (1 + 0.1 * f_curv);
      H0_pred = 67.4; // Default
      rhovac_pred = 5.96e-10;
      
    } else {
      // Hybrid mode
      Lambda_pred = this.lambda0 * f_curv * Math.sqrt(f_stab);
      const H0_SI = Math.sqrt(Lambda_pred * this.c * this.c / 3);
      H0_pred = H0_SI * 3.086e+19 / 1000;
      alpha_pred = this.alpha0 * f_info * f_stab;
      rhovac_pred = Lambda_pred * this.hbar * this.c / (8 * Math.PI * this.G * this.l0 * this.l0);
    }
    
    return {
      Lambda_pred,
      H0_pred,
      alpha_pred,
      rhovac_pred
    };
  }
}

// ============================================
// MODULE B2: PROJECTION ENGINE (PE-26)
// Physically Normalized Log-Domain Model
// ============================================

class ProjectionEnginePE26 {
  constructor(params = {}) {
    this.version = 'PE-26';
    
    // Reference values for normalization
    this.refScales = params.refScales || null;
    
    // Theta parameters (per observable)
    this.theta = params.theta || this.getDefaultTheta();
  }
  
  getDefaultTheta() {
    return {
      // Existing observables
      Lambda: { k0: 0, kR: 1.0, kRho: 0, kS: 0.5, kGamma: 0 },
      H0: { k0: 0, kR: 0.5, kRho: 0, kS: 0, kGamma: 0 },
      alpha: { k0: 0, kR: 0, kRho: -0.5, kS: 0, kGamma: 0 },
      rhovac: { k0: 0, kR: 0.5, kRho: 0.5, kS: 0, kGamma: 0 },

      // New cosmology / LSS observables
      Neff: { k0: 0, kR: 0.2, kRho: 0.05, kS: 0.0, kGamma: 0.05 },
      sigma8: { k0: 0, kR: 0.10, kRho: -0.05, kS: 0.05, kGamma: 0.0 },
      r_drag: { k0: 0, kR: -0.30, kRho: 0.05, kS: 0.0, kGamma: 0.05 },

      // New precision-physics observables (tiny slopes!)
      mu_pe: { k0: 0, kR: 0.02, kRho: 0.02, kS: -0.02, kGamma: 0.0 },
      g_e: { k0: 0, kR: 0.01, kRho: -0.01, kS: 0.01, kGamma: 0.0 },

      // Primordial tilt
      n_s: { k0: 0, kR: 0.15, kRho: 0.10, kS: 0.05, kGamma: 0.05 }
    };
  }
  
  setRefScales(scales) {
    this.refScales = scales;
  }
  
  setTheta(theta) {
    this.theta = theta;
  }
  
  computeFeatures(recursion_summary, gamma) {
    if (!this.refScales) {
      throw new Error('PE-26: Reference scales not set. Call setRefScales() first.');
    }
    
    const { Rr, rhoI, stability } = recursion_summary;
    const { R0, rho0, S0, gamma0 } = this.refScales;
    
    // Avoid log(0) or log(negative)
    const safeLog = (val, ref) => {
      const ratio = Math.abs(val) / Math.abs(ref);
      return ratio > 1e-100 ? Math.log10(ratio) : -100;
    };
    
    return {
      fR: safeLog(Rr, R0),
      fRho: safeLog(rhoI, rho0),
      fS: safeLog(stability, S0),
      fGamma: safeLog(gamma, gamma0)
    };
  }
  
  project(features, datasets = EmpiricalDatasets) {
    const predictions = {};
    
    // Lambda
    if (this.theta.Lambda) {
      const t = this.theta.Lambda;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho + 
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.Lambda_pred = datasets.Lambda.value * Math.pow(10, logRatio);
    }
    
    // H0
    if (this.theta.H0) {
      const t = this.theta.H0;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho + 
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.H0_pred = datasets.H0.value * Math.pow(10, logRatio);
    }
    
    // alpha
    if (this.theta.alpha) {
      const t = this.theta.alpha;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho + 
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.alpha_pred = datasets.alpha.value * Math.pow(10, logRatio);
    }
    
    // rhovac
    if (this.theta.rhovac) {
      const t = this.theta.rhovac;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho + 
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.rhovac_pred = datasets.rhovac.value * Math.pow(10, logRatio);
    }

    // Neff
    if (this.theta.Neff) {
      const t = this.theta.Neff;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho +
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.Neff_pred = datasets.Neff.value * Math.pow(10, logRatio);
    }

    // sigma8
    if (this.theta.sigma8) {
      const t = this.theta.sigma8;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho +
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.sigma8_pred = datasets.sigma8.value * Math.pow(10, logRatio);
    }

    // r_drag
    if (this.theta.r_drag) {
      const t = this.theta.r_drag;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho +
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.r_drag_pred = datasets.r_drag.value * Math.pow(10, logRatio);
    }

    // mu_pe
    if (this.theta.mu_pe) {
      const t = this.theta.mu_pe;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho +
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.mu_pe_pred = datasets.mu_pe.value * Math.pow(10, logRatio);
    }

    // g_e
    if (this.theta.g_e) {
      const t = this.theta.g_e;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho +
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.g_e_pred = datasets.g_e.value * Math.pow(10, logRatio);
    }

    // n_s
    if (this.theta.n_s) {
      const t = this.theta.n_s;
      const logRatio = t.k0 + t.kR * features.fR + t.kRho * features.fRho +
                       t.kS * features.fS + t.kGamma * features.fGamma;
      predictions.n_s_pred = datasets.n_s.value * Math.pow(10, logRatio);
    }
    
    return predictions;
  }
}

// ============================================
// MODULE B3: TUNING ENGINE (TE-26)
// Automatic Parameter Calibration
// ============================================

class TuningEngineTE26 {
  constructor(config = {}) {
    this.maxIter = config.maxIter || 15;
    this.initialDelta = config.initialDelta || 1.0;
    this.deltaMin = config.deltaMin || 0.05;
    this.epsilon = config.epsilon || 1e-3;
    
    // Parameters to tune (can be subset)
    this.tunableParams = config.tunableParams || [
      'Lambda.kR', 'Lambda.kS',
      'H0.kR', 'H0.kRho',
      'alpha.kRho',
      'rhovac.kR', 'rhovac.kRho'
    ];
  }
  
  computeRefScales(sweepData) {
    // Geometric means for reference scales
    const n = sweepData.length;
    
    let prodRr = 1, prodRhoI = 1, prodS = 1, sumGamma = 0;
    
    for (const point of sweepData) {
      prodRr *= Math.abs(point.recursion.Rr);
      prodRhoI *= Math.abs(point.recursion.rhoI);
      prodS *= Math.abs(point.recursion.stability);
      sumGamma += point.gamma;
    }
    
    const R0 = Math.pow(prodRr, 1/n);
    const rho0 = Math.pow(prodRhoI, 1/n);
    const S0 = Math.pow(prodS, 1/n);
    const gamma0 = sumGamma / n;
    
    return { R0, rho0, S0, gamma0 };
  }
  
  async calibrate(sweepData, activeDatasets, projEngine, fitEngine, statusCallback) {
    console.log('ğŸ¯ TE-26: Starting auto-calibration...');
    
    // Stage 0: Compute reference scales and features
    const refScales = this.computeRefScales(sweepData);
    projEngine.setRefScales(refScales);
    
    console.log('  Reference scales:', refScales);
    
    // Precompute features for all sweep points
    const featuresMap = new Map();
    for (const point of sweepData) {
      const features = projEngine.computeFeatures(point.recursion, point.gamma);
      featuresMap.set(point.gamma, features);
    }
    
    // Stage 1: Calibrate intercepts
    if (statusCallback) statusCallback('Stage 1: Calibrating intercepts...');
    let theta = await this.calibrateIntercepts(
      sweepData, featuresMap, activeDatasets, projEngine, fitEngine
    );
    projEngine.setTheta(theta);
    
    console.log('  Stage 1 complete. Î¸ after intercept calibration:', theta);
    
    // Stage 2: Coordinate descent on slopes
    if (statusCallback) statusCallback('Stage 2: Optimizing slopes...');
    theta = await this.coordinateDescent(
      sweepData, featuresMap, activeDatasets, projEngine, fitEngine, theta
    );
    projEngine.setTheta(theta);
    
    console.log('  Stage 2 complete. Final Î¸:', theta);
    console.log('âœ… TE-26: Calibration complete');
    
    return { theta, refScales, featuresMap };
  }
  
  async calibrateIntercepts(sweepData, featuresMap, activeDatasets, projEngine, fitEngine) {
    const theta = JSON.parse(JSON.stringify(projEngine.theta)); // Deep copy
    
    const interceptRange = [];
    for (let k = -4; k <= 4; k += 0.5) {
      interceptRange.push(k);
    }
    
    for (const obs of activeDatasets) {
      if (!theta[obs]) continue;
      
      let bestK0 = theta[obs].k0;
      let bestChi2 = Infinity;
      
      for (const k0_candidate of interceptRange) {
        theta[obs].k0 = k0_candidate;
        
        const chi2 = this.evaluateChi2(
          sweepData, featuresMap, activeDatasets, projEngine, fitEngine, theta
        );
        
        if (chi2 < bestChi2) {
          bestChi2 = chi2;
          bestK0 = k0_candidate;
        }
      }
      
      theta[obs].k0 = bestK0;
      console.log(`    ${obs}: k0 = ${bestK0.toFixed(3)}, Ï‡Â² = ${bestChi2.toExponential(3)}`);
    }
    
    return theta;
  }
  
  async coordinateDescent(sweepData, featuresMap, activeDatasets, projEngine, fitEngine, thetaInit) {
    let theta = JSON.parse(JSON.stringify(thetaInit));
    let delta = this.initialDelta;
    
    for (let iter = 0; iter < this.maxIter; iter++) {
      let improved = false;
      
      const currentChi2 = this.evaluateChi2(
        sweepData, featuresMap, activeDatasets, projEngine, fitEngine, theta
      );
      
      console.log(`    Iter ${iter + 1}: Ï‡Â² = ${currentChi2.toExponential(3)}, Î” = ${delta.toFixed(3)}`);
      
      // Try each tunable parameter
      for (const paramPath of this.tunableParams) {
        const [obs, param] = paramPath.split('.');
        if (!theta[obs]) continue;
        
        const currentVal = theta[obs][param];
        const candidates = [currentVal - delta, currentVal, currentVal + delta];
        
        let bestVal = currentVal;
        let bestChi2Local = currentChi2;
        
        for (const candidate of candidates) {
          theta[obs][param] = candidate;
          
          const chi2 = this.evaluateChi2(
            sweepData, featuresMap, activeDatasets, projEngine, fitEngine, theta
          );
          
          if (chi2 < bestChi2Local) {
            bestChi2Local = chi2;
            bestVal = candidate;
          }
        }
        
        if (Math.abs(bestChi2Local - currentChi2) > this.epsilon * currentChi2) {
          theta[obs][param] = bestVal;
          improved = true;
        } else {
          theta[obs][param] = currentVal; // Restore
        }
      }
      
      if (!improved) {
        delta /= 2;
        if (delta < this.deltaMin) {
          console.log('    Converged: Î” < Î”_min');
          break;
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 0)); // Allow UI updates
    }
    
    return theta;
  }
  
  evaluateChi2(sweepData, featuresMap, activeDatasets, projEngine, fitEngine, theta) {
    projEngine.setTheta(theta);
    
    let chi2Total = 0;
    
    for (const point of sweepData) {
      const features = featuresMap.get(point.gamma);
      const predictions = projEngine.project(features);
      const chi2 = fitEngine.computeChi2(predictions, activeDatasets);
      chi2Total += chi2.total;
    }
    
    return chi2Total;
  }
}

// ============================================
// MODULE C: EMPIRICAL DATASET (EDM-31)
// Extended dataset with 10 observables (v0.3.0)
// ============================================

const EmpiricalDatasets = {
  // Core cosmological set
  Lambda: {
    value: 1.1056e-52, // m^-2
    sigma: 2e-54,
    weight: 1.0,
    source: 'Planck 2018',
    units: 'm^-2'
  },
  H0: {
    value: 67.4, // km/s/Mpc
    sigma: 0.5,
    weight: 1.0,
    source: 'Planck 2018',
    units: 'km/s/Mpc'
  },
  alpha: {
    value: 0.0072973525693,
    sigma: 1.1e-12,
    weight: 1.0,
    source: 'CODATA 2018',
    units: 'dimensionless'
  },
  rhovac: {
    value: 5.96e-10, // J/m^3
    sigma: 1e-11,
    weight: 0.5, // lower weight: derived quantity
    source: 'Derived',
    units: 'J/m^3'
  },

  // New extended cosmology / LSS observables
  Neff: {
    value: 2.99,
    sigma: 0.17,
    weight: 1.0,
    source: 'Planck 2018',
    units: 'dimensionless'
  },
  sigma8: {
    value: 0.811,
    sigma: 0.010,
    weight: 1.0,
    source: 'Planck 2018',
    units: 'dimensionless'
  },
  r_drag: {
    value: 147.09,
    sigma: 0.30,
    weight: 1.0,
    source: 'Planck 2018',
    units: 'Mpc'
  },

  // New precision-physics observables
  mu_pe: {
    value: 1836.15267343,
    sigma: 1e-7, // slightly inflated to avoid Ï‡Â² domination
    weight: 1.0,
    source: 'CODATA 2018',
    units: 'dimensionless'
  },
  g_e: {
    value: 2.00231930436256,
    sigma: 5e-12, // slightly inflated as well
    weight: 1.0,
    source: 'QED / CODATA 2018',
    units: 'dimensionless'
  },
  n_s: {
    value: 0.9649,
    sigma: 0.005,
    weight: 1.0,
    source: 'Planck 2018',
    units: 'dimensionless'
  }
};

// ============================================
// MODULE D: FIT ENGINE (FE-25)
// ============================================

class FitEngineFE25 {
  constructor(datasets, method = 'standard') {
    this.datasets = datasets;
    this.method = method;
  }
  
  computeChi2(predictions, activeDatasets) {
    let chi2_total = 0;
    let dof = 0;
    const per_observable = {};
    
    for (const key of activeDatasets) {
      if (this.datasets[key] && predictions[`${key}_pred`] !== undefined) {
        const obs = this.datasets[key];
        const pred = predictions[`${key}_pred`];
        
        const residual = pred - obs.value;
        const chi2_contrib = obs.weight * (residual / obs.sigma) ** 2;
        
        per_observable[key] = chi2_contrib;
        chi2_total += chi2_contrib;
        dof++;
      }
    }
    
    return {
      total: chi2_total,
      per_observable,
      dof
    };
  }
  
  computeResiduals(predictions, activeDatasets) {
    const residuals = [];
    
    for (const key of activeDatasets) {
      if (this.datasets[key] && predictions[`${key}_pred`] !== undefined) {
        const obs = this.datasets[key];
        const pred = predictions[`${key}_pred`];
        
        const residual = pred - obs.value;
        const z_score = residual / obs.sigma;
        const chi2_contribution = obs.weight * z_score ** 2;
        
        residuals.push({
          observable: key,
          predicted: pred,
          observed: obs.value,
          sigma: obs.sigma,
          residual,
          z_score,
          chi2_contribution
        });
      }
    }
    
    return residuals;
  }
}

// ============================================
// MODULE E: VISUALIZATION LAYER (VL-25)
// ============================================

class VisualizationLayerVL25 {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.setupCanvas();
    this.currentView = 'chi2';
  }
  
  setupCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    this.ctx.scale(dpr, dpr);
    this.width = rect.width;
    this.height = rect.height;
    this.clear();
  }
  
  clear() {
    this.ctx.fillStyle = '#000';
    this.ctx.fillRect(0, 0, this.width, this.height);
  }
  
  plotChi2Curve(gammaValues, chi2Values, gammaStar = null) {
    this.clear();
    
    if (gammaValues.length < 2) return;
    
    const padding = 60;
    const plotWidth = this.width - 2 * padding;
    const plotHeight = this.height - 2 * padding;
    
    const gammaMin = Math.min(...gammaValues);
    const gammaMax = Math.max(...gammaValues);
    const chi2Min = Math.min(...chi2Values);
    const chi2Max = Math.max(...chi2Values);
    
    // Draw axes
    this.ctx.strokeStyle = '#2a2a2a';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(padding, padding);
    this.ctx.lineTo(padding, this.height - padding);
    this.ctx.lineTo(this.width - padding, this.height - padding);
    this.ctx.stroke();
    
    // Draw curve
    this.ctx.strokeStyle = '#4a9eff';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    
    for (let i = 0; i < gammaValues.length; i++) {
      const x = padding + ((gammaValues[i] - gammaMin) / (gammaMax - gammaMin)) * plotWidth;
      const y = this.height - padding - ((chi2Values[i] - chi2Min) / (chi2Max - chi2Min)) * plotHeight;
      
      if (i === 0) this.ctx.moveTo(x, y);
      else this.ctx.lineTo(x, y);
    }
    this.ctx.stroke();
    
    // Mark gamma star
    if (gammaStar !== null) {
      const idx = gammaValues.findIndex(g => Math.abs(g - gammaStar) < 0.001);
      if (idx >= 0) {
        const x = padding + ((gammaValues[idx] - gammaMin) / (gammaMax - gammaMin)) * plotWidth;
        const y = this.height - padding - ((chi2Values[idx] - chi2Min) / (chi2Max - chi2Min)) * plotHeight;
        
        this.ctx.fillStyle = '#4aff4a';
        this.ctx.beginPath();
        this.ctx.arc(x, y, 5, 0, 2 * Math.PI);
        this.ctx.fill();
        
        this.ctx.fillStyle = '#4aff4a';
        this.ctx.font = '12px Consolas';
        this.ctx.fillText(`Î³â˜… = ${gammaStar.toFixed(4)}`, x + 10, y - 10);
      }
    }
    
    // Labels
    this.ctx.fillStyle = '#aaa';
    this.ctx.font = '12px Consolas';
    this.ctx.fillText('Î³', this.width / 2, this.height - 20);
    this.ctx.save();
    this.ctx.translate(20, this.height / 2);
    this.ctx.rotate(-Math.PI / 2);
    this.ctx.fillText('Ï‡Â²', 0, 0);
    this.ctx.restore();
    
    // Axis values
    this.ctx.fillStyle = '#666';
    this.ctx.font = '10px Consolas';
    this.ctx.fillText(gammaMin.toFixed(2), padding, this.height - padding + 20);
    this.ctx.fillText(gammaMax.toFixed(2), this.width - padding, this.height - padding + 20);
    this.ctx.fillText(chi2Min.toFixed(1), padding - 40, this.height - padding);
    this.ctx.fillText(chi2Max.toFixed(1), padding - 40, padding + 5);
  }
  
  plotObservables(sweepData, datasets) {
    this.clear();
    
    if (sweepData.length < 2) return;
    
    const padding = 60;
    const plotWidth = this.width - 2 * padding;
    const plotHeight = (this.height - 3 * padding) / 2;
    
    const gammaValues = sweepData.map(d => d.gamma);
    const gammaMin = Math.min(...gammaValues);
    const gammaMax = Math.max(...gammaValues);
    
    // Plot Lambda
    this.plotSingleObservable(
      sweepData.map(d => d.projection.Lambda_pred),
      datasets.Lambda.value,
      gammaValues,
      padding,
      plotHeight,
      'Î› (mâ»Â²)',
      '#4a9eff'
    );
    
    // Plot H0
    this.plotSingleObservable(
      sweepData.map(d => d.projection.H0_pred),
      datasets.H0.value,
      gammaValues,
      padding + plotHeight + padding,
      plotHeight,
      'Hâ‚€ (km/s/Mpc)',
      '#ff4a9e'
    );
  }
  
  plotSingleObservable(predValues, obsValue, gammaValues, yOffset, height, label, color) {
    const padding = 60;
    const plotWidth = this.width - 2 * padding;
    
    const gammaMin = Math.min(...gammaValues);
    const gammaMax = Math.max(...gammaValues);
    const predMin = Math.min(...predValues, obsValue);
    const predMax = Math.max(...predValues, obsValue);
    
    // Axes
    this.ctx.strokeStyle = '#2a2a2a';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(padding, yOffset);
    this.ctx.lineTo(padding, yOffset + height);
    this.ctx.lineTo(this.width - padding, yOffset + height);
    this.ctx.stroke();
    
    // Observed line
    const obsY = yOffset + height - ((obsValue - predMin) / (predMax - predMin)) * height;
    this.ctx.strokeStyle = '#4aff4a';
    this.ctx.setLineDash([5, 5]);
    this.ctx.beginPath();
    this.ctx.moveTo(padding, obsY);
    this.ctx.lineTo(this.width - padding, obsY);
    this.ctx.stroke();
    this.ctx.setLineDash([]);
    
    // Predicted curve
    this.ctx.strokeStyle = color;
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    
    for (let i = 0; i < predValues.length; i++) {
      const x = padding + ((gammaValues[i] - gammaMin) / (gammaMax - gammaMin)) * plotWidth;
      const y = yOffset + height - ((predValues[i] - predMin) / (predMax - predMin)) * height;
      
      if (i === 0) this.ctx.moveTo(x, y);
      else this.ctx.lineTo(x, y);
    }
    this.ctx.stroke();
    
    // Label
    this.ctx.fillStyle = color;
    this.ctx.font = '12px Consolas';
    this.ctx.fillText(label, padding + 10, yOffset + 20);
  }
  
  plotResiduals(residuals) {
    this.clear();
    
    if (residuals.length === 0) return;
    
    const padding = 60;
    const barWidth = (this.width - 2 * padding) / residuals.length - 10;
    const plotHeight = this.height - 2 * padding;
    
    const maxZ = Math.max(...residuals.map(r => Math.abs(r.z_score)));
    
    // Zero line
    const zeroY = this.height / 2;
    this.ctx.strokeStyle = '#2a2a2a';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(padding, zeroY);
    this.ctx.lineTo(this.width - padding, zeroY);
    this.ctx.stroke();
    
    // Bars
    residuals.forEach((r, i) => {
      const x = padding + i * (barWidth + 10);
      const barHeight = (r.z_score / maxZ) * (plotHeight / 2);
      const y = zeroY - barHeight;
      
      this.ctx.fillStyle = Math.abs(r.z_score) > 2 ? '#ff4a4a' : '#4a9eff';
      this.ctx.fillRect(x, Math.min(y, zeroY), barWidth, Math.abs(barHeight));
      
      // Label
      this.ctx.fillStyle = '#aaa';
      this.ctx.font = '10px Consolas';
      this.ctx.save();
      this.ctx.translate(x + barWidth / 2, this.height - padding + 20);
      this.ctx.rotate(-Math.PI / 4);
      this.ctx.fillText(r.observable, 0, 0);
      this.ctx.restore();
    });
    
    // Title
    this.ctx.fillStyle = '#4a9eff';
    this.ctx.font = '12px Consolas';
    this.ctx.fillText('Residuals (Z-scores)', padding, padding - 20);
  }
}

// ============================================
// MAIN APPLICATION
// ============================================

const App = {
  // State
  running: false,
  sweepData: [],
  bestFit: null,
  recursionCache: {},
  theta: null, // PE-26 theta parameters
  refScales: null, // PE-26 reference scales
  featuresMap: null, // PE-26 features cache
  
  // UI Elements
  ui: {
    runBtn: document.getElementById('runSweep'),
    stopBtn: document.getElementById('stopSweep'),
    resetBtn: document.getElementById('resetSweep'),
    statusSweep: document.getElementById('statusSweep'),
    progressSweep: document.getElementById('progressSweep'),
    
    gammaMin: document.getElementById('gammaMin'),
    gammaMax: document.getElementById('gammaMax'),
    gammaStep: document.getElementById('gammaStep'),
    depth: document.getElementById('depth'),
    gridRes: document.getElementById('gridRes'),
    seed: document.getElementById('seed'),
    
    // Projection model selector (domain presets)
    projModel: document.getElementById('projModel'),
    
    // PE-26 controls
    autoCalibrate: document.getElementById('autoCalibrate'),
    resetTheta: document.getElementById('resetTheta'),
    statusCalibration: document.getElementById('statusCalibration'),
    thetaDisplay: document.getElementById('thetaDisplay'),
    
    datasetLambda: document.getElementById('datasetLambda'),
    datasetH0: document.getElementById('datasetH0'),
    datasetAlpha: document.getElementById('datasetAlpha'),
    datasetRhovac: document.getElementById('datasetRhovac'),
    datasetNeff: document.getElementById('datasetNeff'),
    datasetSigma8: document.getElementById('datasetSigma8'),
    datasetRdrag: document.getElementById('datasetRdrag'),
    datasetMu: document.getElementById('datasetMu'),
    datasetGe: document.getElementById('datasetGe'),
    datasetNs: document.getElementById('datasetNs'),
    
    fitStrategy: document.getElementById('fitStrategy'),
    chi2Method: document.getElementById('chi2Method'),
    
    metricGammaStar: document.getElementById('metricGammaStar'),
    metricChi2: document.getElementById('metricChi2'),
    metricChi2Dof: document.getElementById('metricChi2Dof'),
    metricGamma: document.getElementById('metricGamma'),
    metricRr: document.getElementById('metricRr'),
    metricRhoI: document.getElementById('metricRhoI'),
    metricVar: document.getElementById('metricVar'),
    metricStab: document.getElementById('metricStab'),
    
    exportJSON: document.getElementById('exportJSON'),
    exportResiduals: document.getElementById('exportResiduals'),
    exportCSV: document.getElementById('exportCSV'),
    
    residualsBody: document.getElementById('residualsBody'),
    canvasLabel: document.getElementById('canvasLabel')
  },
  
  // Visualization
  viz: null,
  
  // Initialize
  init() {
    console.log('âœ… Initializing Chamber XXV...');
    
    this.viz = new VisualizationLayerVL25('mainCanvas');
    
    // Event listeners
    this.ui.runBtn.addEventListener('click', () => this.runSweep());
    this.ui.stopBtn.addEventListener('click', () => this.stopSweep());
    this.ui.resetBtn.addEventListener('click', () => this.reset());
    
    // Auto-calibration (PE-26)
    this.ui.autoCalibrate.addEventListener('click', () => this.runAutoCalibration());
    this.ui.resetTheta.addEventListener('click', () => this.resetTheta());
    
    // Presets (PE-26 domain models)
    document.getElementById('presetCosmoLSS').addEventListener('click', () => this.applyPreset('cosmoLSS'));
    document.getElementById('presetPrecision').addEventListener('click', () => this.applyPreset('precision'));
    document.getElementById('presetUnified').addEventListener('click', () => this.applyPreset('unified'));
    document.getElementById('presetTauField').addEventListener('click', () => this.applyPreset('taufield'));
    
    // Canvas view controls
    document.querySelectorAll('.canvas-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('.canvas-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        this.viz.currentView = e.target.dataset.view;
        this.updateVisualization();
      });
    });
    
    // Export buttons
    this.ui.exportJSON.addEventListener('click', () => this.exportJSON());
    this.ui.exportResiduals.addEventListener('click', () => this.exportResidualsJSON());
    this.ui.exportCSV.addEventListener('click', () => this.exportResidualsCSV());
    
    // Laboratory guide toggle
    const guideToggle = document.getElementById('guideToggle');
    const guideContent = document.getElementById('guideContent');
    if (guideToggle && guideContent) {
      guideToggle.addEventListener('click', () => {
        const isHidden = guideContent.style.display === 'none';
        guideContent.style.display = isHidden ? 'block' : 'none';
        guideToggle.textContent = isHidden ? 'â–¼ Hide Laboratory Guide' : 'â–¶ Show Laboratory Guide';
      });
    }
    
    console.log('âœ… Chamber XXV ready! (PE-26 + TE-26)');
  },
  
  // Run sweep
  async runSweep() {
    console.log('ğŸš€ Starting EPU sweep with PE-26...');
    
    this.running = true;
    this.ui.runBtn.disabled = true;
    this.ui.stopBtn.disabled = false;
    this.ui.statusSweep.textContent = 'Running sweep...';
    this.ui.statusSweep.className = 'status running';
    
    // Get config
    const config = this.getConfig();
    
    // Generate gamma range
    const gammaRange = [];
    for (let g = config.gamma_min; g <= config.gamma_max; g += config.gamma_step) {
      gammaRange.push(g);
    }
    
    console.log(`  ğŸ“Š Sweeping ${gammaRange.length} Î³ values using PE-26`);
    
    // Clear data
    this.sweepData = [];
    this.recursionCache = {};
    
    // Create PE-26 engine with domain model preset
    const projEngine = new ProjectionEnginePE26();
    this.applyModelPreset(projEngine, config.projection_model);
    this.theta = projEngine.theta;
    
    const fitEngine = new FitEngineFE25(EmpiricalDatasets, config.chi2_method);
    
    // Sweep loop - collect recursion data first
    const recursionData = [];
    for (let i = 0; i < gammaRange.length && this.running; i++) {
      const gamma = gammaRange[i];
      
      console.log(`  Î³ = ${gamma.toFixed(4)} [${i + 1}/${gammaRange.length}]`);
      
      // Run recursion
      const recursion = await this.runRecursion(gamma, config);
      recursionData.push({ gamma, recursion });
      
      this.ui.progressSweep.style.width = `${((i + 1) / gammaRange.length) * 50}%`; // First 50%
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    
    if (!this.running) {
      this.ui.runBtn.disabled = false;
      this.ui.stopBtn.disabled = true;
      return;
    }
    
    // Compute reference scales and features
    const tuner = new TuningEngineTE26();
    this.refScales = tuner.computeRefScales(recursionData);
    projEngine.setRefScales(this.refScales);
    
    this.featuresMap = new Map();
    
    console.log('  ğŸ“ Computing PE-26 features...');
    console.log('  Reference scales:', this.refScales);
    
    for (let i = 0; i < recursionData.length && this.running; i++) {
      const { gamma, recursion } = recursionData[i];
      
      const features = projEngine.computeFeatures(recursion, gamma);
      this.featuresMap.set(gamma, features);
      
      const projection = projEngine.project(features);
      const chi2 = fitEngine.computeChi2(projection, config.active_datasets);
      
      this.sweepData.push({ gamma, recursion, projection, chi2, features });
      
      // Update UI
      this.updateMetrics(gamma, recursion, chi2);
      this.ui.progressSweep.style.width = `${50 + ((i + 1) / recursionData.length) * 50}%`; // Second 50%
      
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    
    if (this.running) {
      // Find best fit
      this.findBestFit(fitEngine, config.active_datasets, projEngine);
      
      // Update visualization
      this.updateVisualization();
      
      // Update theta display
      this.updateThetaDisplay();
      this.ui.autoCalibrate.disabled = false;
      this.ui.resetTheta.disabled = false;
      
      this.ui.statusSweep.textContent = `Complete! Î³â˜… = ${this.bestFit.gamma_star.toFixed(4)}, Ï‡Â² = ${this.bestFit.chi2_total.toExponential(2)}`;
      this.ui.statusSweep.className = 'status complete';
      
      this.ui.exportJSON.disabled = false;
      this.ui.exportResiduals.disabled = false;
      this.ui.exportCSV.disabled = false;
      
      console.log(`âœ… Best fit: Î³â˜… = ${this.bestFit.gamma_star.toFixed(6)}, Ï‡Â²/dof = ${this.bestFit.chi2_dof.toExponential(3)}`);
    }
    
    this.ui.runBtn.disabled = false;
    this.ui.stopBtn.disabled = true;
    this.running = false;
  },
  
  // Run recursion for single gamma (with caching)
  async runRecursion(gamma, config) {
    const cacheKey = `${gamma.toFixed(6)}_${config.grid_width}_${config.depth}_${config.seed}`;
    
    if (this.recursionCache[cacheKey]) {
      return this.recursionCache[cacheKey];
    }
    
    const kernel = new RecursionKernelRK25({
      grid_width: config.grid_width,
      depth: config.depth,
      gamma: gamma,
      seed: config.seed
    });
    
    kernel.evolve(config.depth);
    const metrics = kernel.computeMetrics();
    
    this.recursionCache[cacheKey] = metrics;
    return metrics;
  },
  
  // Find best fit
  findBestFit(fitEngine, activeDatasets, projEngine = null) {
    let minIdx = 0;
    let minChi2 = this.sweepData[0].chi2.total;
    
    for (let i = 1; i < this.sweepData.length; i++) {
      if (this.sweepData[i].chi2.total < minChi2) {
        minChi2 = this.sweepData[i].chi2.total;
        minIdx = i;
      }
    }
    
    const best = this.sweepData[minIdx];
    const residuals = fitEngine.computeResiduals(best.projection, activeDatasets);
    
    this.bestFit = {
      gamma_star: best.gamma,
      chi2_total: best.chi2.total,
      chi2_dof: best.chi2.total / best.chi2.dof,
      recursion_summary: best.recursion,
      projection: best.projection,
      residuals
    };
    
    // Update metrics
    this.ui.metricGammaStar.textContent = this.bestFit.gamma_star.toFixed(6);
    this.ui.metricChi2.textContent = this.bestFit.chi2_total.toExponential(3);
    this.ui.metricChi2Dof.textContent = this.bestFit.chi2_dof.toExponential(3);
    
    // Update residuals table
    this.updateResidualsTable(residuals);
  },
  
  // Auto-calibration (TE-26)
  async runAutoCalibration() {
    if (!this.sweepData || this.sweepData.length === 0) {
      alert('Please run a sweep first before auto-calibrating.');
      return;
    }
    
    console.log('ğŸ¯ Starting TE-26 auto-calibration...');
    
    this.ui.autoCalibrate.disabled = true;
    this.ui.runBtn.disabled = true;
    this.ui.statusCalibration.textContent = 'Auto-calibrating projection parameters...';
    this.ui.statusCalibration.className = 'status running';
    
    const config = this.getConfig();
    
    // Create engines
    const projEngine = new ProjectionEnginePE26();
    const fitEngine = new FitEngineFE25(EmpiricalDatasets, config.chi2_method);
    const tuner = new TuningEngineTE26();
    
    // Run calibration
    const result = await tuner.calibrate(
      this.sweepData,
      config.active_datasets,
      projEngine,
      fitEngine,
      (status) => {
        this.ui.statusCalibration.textContent = status;
      }
    );
    
    // Store results
    this.theta = result.theta;
    this.refScales = result.refScales;
    this.featuresMap = result.featuresMap;
    
    // Re-compute all predictions with calibrated theta
    console.log('  ğŸ”„ Re-computing predictions with calibrated Î¸...');
    projEngine.setTheta(this.theta);
    projEngine.setRefScales(this.refScales);
    
    for (let i = 0; i < this.sweepData.length; i++) {
      const point = this.sweepData[i];
      const features = this.featuresMap.get(point.gamma);
      const projection = projEngine.project(features);
      const chi2 = fitEngine.computeChi2(projection, config.active_datasets);
      
      point.projection = projection;
      point.chi2 = chi2;
      point.features = features;
    }
    
    // Re-find best fit
    this.findBestFit(fitEngine, config.active_datasets, projEngine);
    
    // Update display
    this.updateThetaDisplay();
    this.updateVisualization();
    
    this.ui.statusCalibration.textContent = `Calibration complete! Ï‡Â² = ${this.bestFit.chi2_total.toExponential(3)}, Î³â˜… = ${this.bestFit.gamma_star.toFixed(4)}`;
    this.ui.statusCalibration.className = 'status complete';
    
    this.ui.autoCalibrate.disabled = false;
    this.ui.runBtn.disabled = false;
    
    console.log('âœ… TE-26 calibration complete');
    console.log('  Final Î¸:', this.theta);
  },
  
  // Reset theta to defaults
  resetTheta() {
    const projEngine = new ProjectionEnginePE26();
    this.theta = projEngine.getDefaultTheta();
    this.updateThetaDisplay();
    console.log('ğŸ”„ Î¸ reset to defaults');
  },
  
  // Update theta display
  updateThetaDisplay() {
    if (!this.theta) return;
    
    const tbody = this.ui.thetaDisplay;
    tbody.innerHTML = '';
    
    for (const obs of [
      'Lambda', 'H0', 'alpha', 'rhovac',
      'Neff', 'sigma8', 'r_drag',
      'mu_pe', 'g_e', 'n_s'
    ]) {
      if (!this.theta[obs]) continue;
      
      const row = document.createElement('tr');
      const t = this.theta[obs];
      
      row.innerHTML = `
        <td>${obs}</td>
        <td>${t.k0.toFixed(3)}</td>
        <td>${t.kR.toFixed(3)}</td>
        <td>${t.kRho.toFixed(3)}</td>
        <td>${t.kS.toFixed(3)}</td>
        <td>${t.kGamma.toFixed(3)}</td>
      `;
      
      tbody.appendChild(row);
    }
  },
  
  // Update visualization
  updateVisualization() {
    if (this.sweepData.length < 2) return;
    
    const gammaValues = this.sweepData.map(d => d.gamma);
    const chi2Values = this.sweepData.map(d => d.chi2.total);
    
    if (this.viz.currentView === 'chi2') {
      this.viz.plotChi2Curve(gammaValues, chi2Values, this.bestFit?.gamma_star);
      this.ui.canvasLabel.textContent = 'Ï‡Â² vs Î³ Curve';
    } else if (this.viz.currentView === 'observables') {
      this.viz.plotObservables(this.sweepData, EmpiricalDatasets);
      this.ui.canvasLabel.textContent = 'Observable Predictions vs Î³';
    } else if (this.viz.currentView === 'residuals') {
      if (this.bestFit) {
        this.viz.plotResiduals(this.bestFit.residuals);
        this.ui.canvasLabel.textContent = 'Best-Fit Residuals';
      }
    }
  },
  
  // Update metrics
  updateMetrics(gamma, recursion, chi2) {
    this.ui.metricGamma.textContent = gamma.toFixed(6);
    this.ui.metricRr.textContent = recursion.Rr.toFixed(6);
    this.ui.metricRhoI.textContent = recursion.rhoI.toFixed(6);
    this.ui.metricVar.textContent = recursion.variance.toFixed(6);
    this.ui.metricStab.textContent = recursion.stability.toFixed(6);
  },
  
  // Update residuals table
  updateResidualsTable(residuals) {
    const tbody = this.ui.residualsBody;
    tbody.innerHTML = '';
    
    residuals.forEach(r => {
      const row = document.createElement('tr');
      
      const zColor = Math.abs(r.z_score) > 2 ? '#ff4a4a' : '#4aff4a';
      
      row.innerHTML = `
        <td>${r.observable}</td>
        <td>${r.predicted.toExponential(4)}</td>
        <td>${r.observed.toExponential(4)}</td>
        <td>${r.sigma.toExponential(2)}</td>
        <td>${r.residual.toExponential(3)}</td>
        <td style="color: ${zColor}; font-weight: bold;">${r.z_score.toFixed(3)}</td>
        <td>${r.chi2_contribution.toFixed(3)}</td>
      `;
      
      tbody.appendChild(row);
    });
  },
  
  // Get config
  getConfig() {
    const activeDatasets = [];
    if (this.ui.datasetLambda.checked) activeDatasets.push('Lambda');
    if (this.ui.datasetH0.checked) activeDatasets.push('H0');
    if (this.ui.datasetAlpha.checked) activeDatasets.push('alpha');
    if (this.ui.datasetRhovac.checked) activeDatasets.push('rhovac');
    
    if (this.ui.datasetNeff.checked) activeDatasets.push('Neff');
    if (this.ui.datasetSigma8.checked) activeDatasets.push('sigma8');
    if (this.ui.datasetRdrag.checked) activeDatasets.push('r_drag');
    if (this.ui.datasetMu.checked) activeDatasets.push('mu_pe');
    if (this.ui.datasetGe.checked) activeDatasets.push('g_e');
    if (this.ui.datasetNs.checked) activeDatasets.push('n_s');
    
    return {
      gamma_min: parseFloat(this.ui.gammaMin.value),
      gamma_max: parseFloat(this.ui.gammaMax.value),
      gamma_step: parseFloat(this.ui.gammaStep.value),
      depth: parseInt(this.ui.depth.value),
      grid_width: parseInt(this.ui.gridRes.value),
      seed: parseInt(this.ui.seed.value),
      
      projection_model: this.ui.projModel.value,
      active_datasets: activeDatasets,
      fit_strategy: this.ui.fitStrategy.value,
      chi2_method: this.ui.chi2Method.value
    };
  },
  
  // Apply model preset (PE-26)
  applyPreset(mode) {
    const projEngine = new ProjectionEnginePE26();
    this.applyModelPreset(projEngine, mode);
    this.theta = projEngine.theta;
    this.updateThetaDisplay();
    this.ui.projModel.value = mode;
    console.log(`âœ… Applied ${mode} projection model preset`);
  },
  
  // Apply model preset to projection engine
  applyModelPreset(projEngine, mode) {
    // Reset all to baseline first
    const observables = [
      'Lambda', 'H0', 'alpha', 'rhovac',
      'Neff', 'sigma8', 'r_drag',
      'mu_pe', 'g_e', 'n_s'
    ];
    observables.forEach(obs => {
      if (projEngine.theta[obs]) {
        projEngine.theta[obs].k0 = 0.0;
        projEngine.theta[obs].kR = 0.0;
        projEngine.theta[obs].kRho = 0.0;
        projEngine.theta[obs].kS = 0.0;
        projEngine.theta[obs].kGamma = 0.0;
      }
    });
    
    if (mode === 'cosmoLSS') {
      // Cosmology + LSS: Î›, H0, Ï_vac, Neff, sigma8, r_drag, n_s
      projEngine.theta.Lambda.kR = 1.2;
      projEngine.theta.Lambda.kS = 0.6;
      
      projEngine.theta.H0.kR = 0.6;
      projEngine.theta.H0.kRho = 0.1;
      
      projEngine.theta.rhovac.kR = 0.6;
      projEngine.theta.rhovac.kRho = 0.5;
      
      projEngine.theta.Neff.kR = 0.25;
      projEngine.theta.Neff.kRho = 0.05;
      
      projEngine.theta.sigma8.kR = 0.12;
      projEngine.theta.sigma8.kRho = -0.05;
      
      projEngine.theta.r_drag.kR = -0.35;
      projEngine.theta.r_drag.kRho = 0.05;
      
      projEngine.theta.n_s.kR = 0.18;
      projEngine.theta.n_s.kRho = 0.10;
      
    } else if (mode === 'precision') {
      // Precision Physics: Î±, Î¼, g_e â€” ultra-small slopes
      projEngine.theta.alpha.kR = 0.0;
      projEngine.theta.alpha.kRho = -0.8;
      projEngine.theta.alpha.kS = 0.3;
      
      projEngine.theta.mu_pe.kR = 0.02;
      projEngine.theta.mu_pe.kRho = 0.02;
      projEngine.theta.mu_pe.kS = -0.02;
      
      projEngine.theta.g_e.kR = 0.01;
      projEngine.theta.g_e.kRho = -0.01;
      projEngine.theta.g_e.kS = 0.01;
      
      // Keep cosmology mild to avoid domination
      projEngine.theta.Lambda.kR = 0.5;
      projEngine.theta.H0.kR = 0.3;
      
    } else if (mode === 'unified') {
      // Unified Physics: balanced weights across all 10
      projEngine.theta.Lambda.kR = 0.9;
      projEngine.theta.Lambda.kS = 0.4;
      
      projEngine.theta.H0.kR = 0.5;
      
      projEngine.theta.alpha.kRho = -0.6;
      
      projEngine.theta.rhovac.kR = 0.5;
      projEngine.theta.rhovac.kRho = 0.4;
      
      projEngine.theta.Neff.kR = 0.22;
      projEngine.theta.sigma8.kR = 0.10;
      projEngine.theta.r_drag.kR = -0.30;
      projEngine.theta.n_s.kR = 0.16;
      
      projEngine.theta.mu_pe.kR = 0.02;
      projEngine.theta.mu_pe.kRho = 0.02;
      
      projEngine.theta.g_e.kR = 0.01;
      projEngine.theta.g_e.kRho = -0.01;
      
    } else if (mode === 'cosmology') {
      // Legacy: redirect to cosmoLSS
      this.applyModelPreset(projEngine, 'cosmoLSS');
      return;
      
    } else if (mode === 'em') {
      // Legacy: redirect to precision
      this.applyModelPreset(projEngine, 'precision');
      return;
      
    } else if (mode === 'hybrid') {
      // Legacy: redirect to unified
      this.applyModelPreset(projEngine, 'unified');
      return;
      
    } else if (mode === 'taufield') {
      // Ï„-Field: curvature-stability focus with explicit Î³ dependence
      projEngine.theta.Lambda.kR = 0.40;
      projEngine.theta.Lambda.kS = 0.20;
      projEngine.theta.Lambda.kGamma = 0.10;
      
      projEngine.theta.H0.kR = 0.25;
      projEngine.theta.H0.kRho = 0.10;
      projEngine.theta.H0.kS = 0.10;
      projEngine.theta.H0.kGamma = 0.05;
      
      projEngine.theta.alpha.kR = 0.02;
      projEngine.theta.alpha.kRho = -0.03;
      projEngine.theta.alpha.kS = 0.03;
      projEngine.theta.alpha.kGamma = 0.02;
      
      projEngine.theta.rhovac.kR = 0.45;
      projEngine.theta.rhovac.kRho = 0.15;
      projEngine.theta.rhovac.kS = 0.15;
      projEngine.theta.rhovac.kGamma = 0.10;
    }
  },
  
  // Stop sweep
  stopSweep() {
    this.running = false;
    this.ui.statusSweep.textContent = 'Stopped by user';
    this.ui.statusSweep.className = 'status error';
    console.log('â¸ï¸ Sweep stopped');
  },
  
  // Reset
  reset() {
    this.sweepData = [];
    this.bestFit = null;
    this.recursionCache = {};
    this.viz.clear();
    this.ui.progressSweep.style.width = '0%';
    this.ui.statusSweep.style.display = 'none';
    
    this.ui.metricGammaStar.textContent = 'â€”';
    this.ui.metricChi2.textContent = 'â€”';
    this.ui.metricChi2Dof.textContent = 'â€”';
    this.ui.metricGamma.textContent = 'â€”';
    this.ui.metricRr.textContent = 'â€”';
    this.ui.metricRhoI.textContent = 'â€”';
    this.ui.metricVar.textContent = 'â€”';
    this.ui.metricStab.textContent = 'â€”';
    
    this.ui.residualsBody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #666;">Run sweep to generate residuals</td></tr>';
    
    this.ui.exportJSON.disabled = true;
    this.ui.exportResiduals.disabled = true;
    this.ui.exportCSV.disabled = true;
    
    console.log('ğŸ”„ Chamber reset');
  },
  
  // Export JSON
  exportJSON() {
    const config = this.getConfig();
    
    const exportData = {
      chamber: 'XXV',
      metadata: {
        title: 'Empirical Projection & Unification Chamber',
        version: '0.2.0',
        timestamp: new Date().toISOString(),
        lab_version: '0.1.0',
        phase: 'E',
        operator: 'XXV',
        projection_model: 'PE-26'
      },
      config,
      constants: {
        c: 299792458,
        G: 6.67430e-11,
        hbar: 1.054571817e-34,
        phi: 1.618033988749895
      },
      datasets: EmpiricalDatasets,
      results: {
        sweep: this.sweepData,
        best_fit: this.bestFit
      },
      projection_pe26: {
        theta: this.theta,
        ref_scales: this.refScales,
        tuning: {
          algorithm: 'TE-26 coordinate descent',
          status: this.theta ? 'calibrated' : 'default'
        }
      },
      visualization: {
        chi2_curve: {
          gamma_values: this.sweepData.map(d => d.gamma),
          chi2_values: this.sweepData.map(d => d.chi2.total)
        }
      }
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const dateStr = new Date().toISOString().split('T')[0];
    a.download = `chamber_xxv_epu_pe26_${dateStr}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    console.log(`ğŸ’¾ JSON exported (PE-26):`, a.download);
  },
  
  // Export residuals JSON
  exportResidualsJSON() {
    if (!this.bestFit) return;
    
    const data = {
      gamma_star: this.bestFit.gamma_star,
      chi2_total: this.bestFit.chi2_total,
      chi2_dof: this.bestFit.chi2_dof,
      residuals: this.bestFit.residuals
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const dateStr = new Date().toISOString().split('T')[0];
    a.download = `xxv_residuals_${dateStr}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    console.log('ğŸ’¾ Residuals JSON exported');
  },
  
  // Export residuals CSV
  exportResidualsCSV() {
    if (!this.bestFit) return;
    
    let csv = 'observable,predicted,observed,sigma,residual,z_score,chi2_contribution\n';
    
    this.bestFit.residuals.forEach(r => {
      csv += `${r.observable},${r.predicted},${r.observed},${r.sigma},${r.residual},${r.z_score},${r.chi2_contribution}\n`;
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const dateStr = new Date().toISOString().split('T')[0];
    a.download = `xxv_residuals_${dateStr}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    
    console.log('ğŸ’¾ Residuals CSV exported');
  }
};

// Initialize on load
window.addEventListener('load', () => {
  App.init();
});

console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  </script>
</body>
</html>
