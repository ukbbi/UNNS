<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>UNNS ⟂ Classical — Projectile Calculator Showcase</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0a0e1a;--bg2:#0f1220;--ink:#e8ecff;--muted:#9aa3c7;--card:#171a2b;
    --line:#2a2f4a;--axis:#8aa0c6;--cyan:#6ae3ff;--mag:#ff6ad5;--warn:#f59e0b;
    --good:#2dd4bf;--bad:#fb7185;--purple:#a78bfa;--gold:#fbbf24;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,sans-serif;
    overflow-x:hidden}
  
  /* Animated gradient background */
  body::before{
    content:'';position:fixed;top:0;left:0;right:0;bottom:0;
    background:radial-gradient(circle at 20% 30%, rgba(106,227,255,0.08) 0%, transparent 50%),
               radial-gradient(circle at 80% 70%, rgba(255,106,213,0.08) 0%, transparent 50%);
    animation:bgShift 15s ease infinite;z-index:0;
  }
  @keyframes bgShift{
    0%,100%{opacity:1}
    50%{opacity:0.7}
  }
  
  .container{position:relative;z-index:1;max-width:1400px;margin:0 auto;padding:0 20px}
  
  /* Header */
  header{padding:30px 0;text-align:center;position:relative}
  header h1{margin:0;font-size:2.5rem;font-weight:800;
    background:linear-gradient(135deg,var(--cyan),var(--mag),var(--purple));
    -webkit-background-clip:text;-webkit-text-fill-color:transparent;
    background-clip:text;animation:titleGlow 3s ease infinite}
  @keyframes titleGlow{
    0%,100%{filter:brightness(1)}
    50%{filter:brightness(1.2)}
  }
  header p{margin:8px 0 0;color:var(--muted);font-size:1.05rem}
  
  .btn-group{display:flex;gap:12px;justify-content:center;margin:20px 0;flex-wrap:wrap}
  .help-btn{background:rgba(167,139,250,0.15);border:1px solid rgba(167,139,250,0.3);
    color:var(--purple);padding:10px 20px;border-radius:12px;cursor:pointer;
    font-weight:600;transition:all 0.3s;backdrop-filter:blur(10px)}
  .help-btn:hover{background:rgba(167,139,250,0.25);transform:translateY(-2px);
    box-shadow:0 6px 20px rgba(167,139,250,0.3)}
  
  /* Tabs */
  .tabs{display:flex;gap:8px;justify-content:center;margin:30px 0;flex-wrap:wrap}
  .tab{background:rgba(23,26,43,0.6);border:1px solid var(--line);
    color:var(--muted);padding:14px 32px;border-radius:14px;cursor:pointer;
    font-weight:600;transition:all 0.3s;backdrop-filter:blur(10px);
    position:relative;overflow:hidden}
  .tab::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;
    background:linear-gradient(90deg,transparent,rgba(106,227,255,0.2),transparent);
    transition:left 0.5s}
  .tab:hover::before{left:100%}
  .tab.active{background:linear-gradient(135deg,rgba(106,227,255,0.15),rgba(255,106,213,0.15));
    border-color:var(--cyan);color:var(--cyan);box-shadow:0 4px 20px rgba(106,227,255,0.3)}
  
  /* Card system */
  .glass-card{background:rgba(23,26,43,0.7);border:1px solid rgba(42,47,74,0.8);
    border-radius:20px;padding:24px;margin:20px 0;backdrop-filter:blur(20px);
    box-shadow:0 8px 32px rgba(0,0,0,0.3);transition:transform 0.3s}
  .glass-card:hover{transform:translateY(-4px);box-shadow:0 12px 40px rgba(0,0,0,0.4)}
  
  .card-title{font-size:1.3rem;font-weight:700;margin:0 0 20px;
    color:var(--cyan);display:flex;align-items:center;gap:10px}
  .card-title::before{content:'';width:4px;height:24px;
    background:linear-gradient(180deg,var(--cyan),var(--mag));border-radius:2px}
  
  /* Grid layouts */
  .grid-2{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:20px}
  .grid-3{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:16px}
  
  /* Form controls */
  .input-group{margin:16px 0}
  .input-row{display:flex;align-items:center;gap:12px;margin:10px 0;flex-wrap:wrap}
  label{color:var(--muted);font-size:0.95rem;min-width:160px;font-weight:500}
  input[type="number"],select{
    background:rgba(14,17,32,0.8);border:1px solid var(--line);color:var(--ink);
    border-radius:10px;padding:10px 14px;font-size:0.95rem;
    transition:all 0.3s;width:140px}
  input[type="number"]:focus,select:focus{
    outline:none;border-color:var(--cyan);
    box-shadow:0 0 0 3px rgba(106,227,255,0.1)}
  input[type="checkbox"]{
    width:20px;height:20px;cursor:pointer;accent-color:var(--cyan)}
  
  .btn{
    background:linear-gradient(135deg,#2b86ff,var(--cyan));
    color:#001a24;border:none;border-radius:12px;padding:12px 24px;
    font-weight:700;cursor:pointer;transition:all 0.3s;
    box-shadow:0 4px 15px rgba(43,134,255,0.4);position:relative;
    overflow:hidden}
  .btn::after{content:'';position:absolute;top:50%;left:50%;
    width:0;height:0;border-radius:50%;background:rgba(255,255,255,0.5);
    transform:translate(-50%,-50%);transition:width 0.6s,height 0.6s}
  .btn:hover::after{width:300px;height:300px}
  .btn:hover{transform:translateY(-2px);box-shadow:0 6px 25px rgba(43,134,255,0.6)}
  .btn:disabled{opacity:0.4;cursor:not-allowed}
  
  .btn-secondary{background:rgba(42,47,74,0.6);color:var(--ink);
    box-shadow:0 2px 10px rgba(0,0,0,0.2)}
  .btn-secondary:hover{background:rgba(42,47,74,0.8)}
  
  .btn-danger{background:linear-gradient(135deg,#ef4444,var(--bad));
    box-shadow:0 4px 15px rgba(239,68,68,0.4)}
  
  .btn-success{background:linear-gradient(135deg,#10b981,var(--good));
    box-shadow:0 4px 15px rgba(16,185,129,0.4)}
  
  /* Canvas */
  canvas{width:100%;border-radius:16px;background:rgba(14,17,32,0.9);
    box-shadow:inset 0 2px 10px rgba(0,0,0,0.5);display:block}
  
  /* Results display */
  .results{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px}
  .result-box{background:rgba(14,17,32,0.6);border:1px solid var(--line);
    border-radius:12px;padding:16px;border-left:4px solid var(--cyan)}
  .result-box.unns{border-left-color:var(--mag)}
  .result-box h3{margin:0 0 12px;font-size:1.1rem;color:var(--cyan)}
  .result-box.unns h3{color:var(--mag)}
  .result-value{font-family:ui-monospace,monospace;font-size:0.9rem;
    line-height:1.6;color:var(--ink)}
  
  /* Legend */
  .legend{display:flex;gap:20px;flex-wrap:wrap;margin:16px 0}
  .legend-item{display:flex;align-items:center;gap:8px;font-size:0.9rem;color:var(--muted)}
  .legend-dot{width:14px;height:14px;border-radius:50%;box-shadow:0 0 8px currentColor}
  .dot-classical{background:var(--cyan);color:var(--cyan)}
  .dot-unns{background:var(--mag);color:var(--mag)}
  .dot-impact{background:var(--warn);color:var(--warn)}
  .dot-optimal{background:var(--good);color:var(--good)}
  
  /* Modal */
  .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;
    background:rgba(0,0,0,0.8);z-index:1000;backdrop-filter:blur(5px);
    align-items:center;justify-content:center;padding:20px}
  .modal.active{display:flex}
  .modal-content{background:var(--card);border:1px solid var(--line);
    border-radius:20px;max-width:800px;max-height:90vh;overflow-y:auto;
    padding:32px;position:relative;box-shadow:0 20px 60px rgba(0,0,0,0.5)}
  .modal-close{position:absolute;top:16px;right:16px;background:var(--bad);
    border:none;color:white;width:32px;height:32px;border-radius:50%;
    cursor:pointer;font-size:20px;line-height:1}
  .modal h2{color:var(--cyan);margin-top:0}
  .modal p{line-height:1.7;color:var(--muted)}
  
  /* Progress indicator */
  .progress{height:4px;background:rgba(42,47,74,0.6);border-radius:2px;
    overflow:hidden;margin:12px 0}
  .progress-bar{height:100%;background:linear-gradient(90deg,var(--cyan),var(--mag));
    transition:width 0.3s;border-radius:2px}
  
  /* Status badges */
  .badge{display:inline-block;padding:4px 12px;border-radius:6px;
    font-size:0.85rem;font-weight:600}
  .badge-info{background:rgba(106,227,255,0.15);color:var(--cyan);
    border:1px solid rgba(106,227,255,0.3)}
  .badge-warn{background:rgba(245,158,11,0.15);color:var(--warn);
    border:1px solid rgba(245,158,11,0.3)}
  
  /* Responsive */
  @media(max-width:768px){
    header h1{font-size:1.8rem}
    .tabs{gap:6px}
    .tab{padding:10px 20px;font-size:0.9rem}
    .input-row{flex-direction:column;align-items:stretch}
    label{min-width:auto}
  }
  
  /* Hide inactive tab content */
  .tab-content{display:none}
  .tab-content.active{display:block}
  
  /* Fan visualization special */
  .fan-controls{background:rgba(14,17,32,0.4);padding:16px;border-radius:12px;
    border:1px solid var(--line);margin:12px 0}
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>UNNS ⟂ Classical Projectile Calculator</h1>
    <p>Comparative dynamics with substrate operators, drag models, and geometric inlaying</p>
    <div class="btn-group">
      <button class="help-btn" onclick="showAbout()">Theory & Background</button>
      <button class="help-btn" onclick="window.open('https://ukbbi.github.io/UNNS/docs/projectile_calculator/UNNS%20vs%20Classical%20Dynamics%20A%20Comparative%20Theoretical%20Framework.pdf','_blank')">Full Paper</button>
    </div>
  </header>

  <!-- Tabs -->
  <div class="tabs">
    <div class="tab active" onclick="switchTab('single')">Single Shot</div>
    <div class="tab" onclick="switchTab('compare')">Side-by-Side</div>
    <div class="tab" onclick="switchTab('optimizer')">Angle Optimizer</div>
    <div class="tab" onclick="switchTab('fan')">Fan View (Multi-Shot)</div>
  </div>

  <!-- Tab: Single Shot -->
  <div id="tab-single" class="tab-content active">
    <div class="grid-2">
      <!-- Controls -->
      <div class="glass-card">
        <h2 class="card-title">Input Parameters</h2>
        
        <div class="input-group">
          <label>Preset Scenarios</label>
          <select id="preset1" onchange="applyPreset(this.value)">
            <option value="vac">Vacuum (baseline)</option>
            <option value="earth">Earth (with drag)</option>
            <option value="mars">Mars (g=3.71 m/s²)</option>
            <option value="moon">Moon (g=1.62 m/s²)</option>
            <option value="unnsHeavy">UNNS Heavy Damping</option>
          </select>
        </div>

        <h3 style="color:var(--muted);font-size:1rem;margin:20px 0 12px;border-bottom:1px solid var(--line);padding-bottom:8px">Basic Parameters</h3>
        <div class="input-row"><label>Initial Velocity V₀ (m/s)</label><input id="v0" type="number" step="any" value="30"></div>
        <div class="input-row"><label>Launch Angle α (deg)</label><input id="ang" type="number" step="any" value="45"></div>
        <div class="input-row"><label>Initial Height y₀ (m)</label><input id="y0" type="number" step="any" value="0"></div>
        <div class="input-row"><label>Gravity g (m/s²)</label><input id="grav" type="number" step="any" value="9.80665"></div>
        
        <h3 style="color:var(--muted);font-size:1rem;margin:20px 0 12px;border-bottom:1px solid var(--line);padding-bottom:8px">Physics Model</h3>
        <div class="input-row">
          <input id="linDrag" type="checkbox">
          <label>Linear Drag k (1/s)</label>
          <input id="kLin" type="number" step="any" value="0.05" style="width:100px">
        </div>
        <div class="input-row">
          <input id="quadDrag" type="checkbox">
          <label>Quadratic Drag c (1/m)</label>
          <input id="cQuad" type="number" step="any" value="0.01" style="width:100px">
        </div>
        <div class="input-row">
          <input id="altModel" type="checkbox">
          <label style="min-width:auto">Altitude-Dependent Air Density ρ(h)</label>
        </div>
        
        <h3 style="color:var(--muted);font-size:1rem;margin:20px 0 12px;border-bottom:1px solid var(--line);padding-bottom:8px">UNNS Operators</h3>
        <div class="input-row">
          <input id="dampOn" type="checkbox" checked>
          <label>Damping Factor α</label>
          <input id="alpha" type="number" step="any" value="0.997" style="width:100px">
        </div>
        <div class="input-row">
          <input id="driftOn" type="checkbox" checked>
          <label>Entropy Drift δ</label>
          <input id="delta" type="number" step="any" value="0.001" style="width:100px">
        </div>
        <div class="input-row">
          <input id="collapseOn" type="checkbox">
          <label>Collapse Threshold ε (m/s)</label>
          <input id="eps" type="number" step="any" value="0.01" style="width:100px">
        </div>
        <div class="input-row">
          <input id="gridOn" type="checkbox">
          <label>Square Grid Snap h (m)</label>
          <input id="hGrid" type="number" step="any" value="0.5" style="width:100px">
        </div>
        <div class="input-row">
          <input id="hexOn" type="checkbox">
          <label>Hex Lattice Snap h (m)</label>
          <input id="hHex" type="number" step="any" value="0.5" style="width:100px">
        </div>

        <div style="margin-top:24px;display:flex;gap:12px;flex-wrap:wrap">
          <button class="btn" onclick="compute()">Compute</button>
          <button class="btn btn-secondary" onclick="resetParams()">Reset</button>
          <button class="btn btn-success" onclick="exportCSV()">Export CSV</button>
        </div>
      </div>

      <!-- Results -->
      <div class="glass-card">
        <h2 class="card-title">Results</h2>
        <div class="results" id="results"></div>
        <div class="legend">
          <div class="legend-item"><span class="legend-dot dot-classical"></span>Classical</div>
          <div class="legend-item"><span class="legend-dot dot-unns"></span>UNNS</div>
          <div class="legend-item"><span class="legend-dot dot-impact"></span>Impact</div>
        </div>
      </div>
    </div>

    <!-- Trajectory Plot -->
    <div class="glass-card">
      <h2 class="card-title">Trajectory Visualization</h2>
      <canvas id="cvTraj" width="1200" height="500"></canvas>
    </div>

    <!-- Energy & Divergence -->
    <div class="grid-2">
      <div class="glass-card">
        <h2 class="card-title">Energy Evolution</h2>
        <canvas id="cvEnergy" width="600" height="300"></canvas>
      </div>
      <div class="glass-card">
        <h2 class="card-title">Divergence Analysis</h2>
        <canvas id="cvDiv" width="600" height="300"></canvas>
      </div>
    </div>
  </div>

  <!-- Tab: Compare -->
  <div id="tab-compare" class="tab-content">
    <div class="glass-card">
      <h2 class="card-title">Classical vs UNNS Comparison</h2>
      <p style="color:var(--muted)">Direct side-by-side comparison with shared parameters</p>
      
      <div style="margin:20px 0">
        <button class="btn" onclick="computeCompare()">Compare Trajectories</button>
      </div>
      
      <canvas id="cvCompare" width="1200" height="500"></canvas>
      <div id="compareResults" style="margin-top:20px"></div>
    </div>
  </div>

  <!-- Tab: Optimizer -->
  <div id="tab-optimizer" class="tab-content">
    <div class="glass-card">
      <h2 class="card-title">Angle Optimizer</h2>
      <p style="color:var(--muted)">Find the optimal launch angle for maximum range</p>
      
      <div class="input-row">
        <label>Model to Optimize</label>
        <select id="optModel">
          <option value="classical">Classical Only</option>
          <option value="unns">UNNS Only</option>
          <option value="both">Both (Compare)</option>
        </select>
      </div>
      
      <div style="margin:20px 0">
        <button class="btn" onclick="optimizeAngle()">Find Optimal Angle</button>
        <span id="optStatus" style="margin-left:12px"></span>
      </div>
      
      <div class="progress" id="optProgress" style="display:none">
        <div class="progress-bar" id="optBar"></div>
      </div>
      
      <div id="optResults"></div>
      <canvas id="cvOpt" width="1200" height="500"></canvas>
    </div>
  </div>

  <!-- Tab: Fan View -->
  <div id="tab-fan" class="tab-content">
    <div class="glass-card">
      <h2 class="card-title">Fan View - Multiple Launch Angles</h2>
      
      <div class="fan-controls">
        <div class="input-row">
          <label>Start Angle (deg)</label>
          <input id="fanStart" type="number" value="15" step="5">
          <label>End Angle (deg)</label>
          <input id="fanEnd" type="number" value="75" step="5">
          <label>Step (deg)</label>
          <input id="fanStep" type="number" value="5" step="1">
        </div>
        <div class="input-row">
          <input id="fanAnimate" type="checkbox" checked>
          <label style="min-width:auto">Animate Propagation</label>
        </div>
        <button class="btn" onclick="computeFan()">Generate Fan</button>
        <button class="btn btn-secondary" onclick="stopFanAnim()">Stop</button>
      </div>
      
      <canvas id="cvFan" width="1200" height="500"></canvas>
      <div id="fanInfo"></div>
    </div>
  </div>
</div>

<!-- Modal -->
<div id="modal" class="modal" onclick="closeModal(event)">
  <div class="modal-content" onclick="event.stopPropagation()">
    <button class="modal-close" onclick="closeModal()">×</button>
    <h2>UNNS vs Classical Dynamics</h2>
    <p><strong>Classical Mechanics</strong> treats motion through continuous differential equations in smooth spacetime. For projectiles, Newton's second law yields deterministic parabolic trajectories.</p>
    
    <p><strong>UNNS (Unbounded Nested Number Sequences)</strong> generates motion through recursive operators on discrete layers. Rather than solving differential equations, UNNS evolves states via:</p>
    
    <p style="text-align:center;font-family:monospace;background:rgba(14,17,32,0.6);padding:12px;border-radius:8px">
      a<sub>n+1</sub> = f(a<sub>n</sub>, a<sub>n-1</sub>; ε<sub>n</sub>, operators)
    </p>
    
    <h3 style="color:var(--cyan)">Key UNNS Operators</h3>
    <ul style="line-height:1.8">
      <li><strong>Damping (α):</strong> Energy decay per recursive step, modeling friction without explicit forces</li>
      <li><strong>Entropy Drift (δ):</strong> Time-varying effective gravity, simulating non-stationary fields</li>
      <li><strong>Collapse Threshold (ε):</strong> Velocity quantization below threshold</li>
      <li><strong>Lattice Inlaying:</strong> Snap positions to discrete grids (square/hexagonal), enforcing geometric constraints</li>
    </ul>
    
    <h3 style="color:var(--cyan)">Theoretical Bridge</h3>
    <p><strong>Theorem (Continuum Limit):</strong> As the recursive step Δ → 0, UNNS dynamics converge to classical Newtonian motion. Thus classical mechanics emerges as the limiting case of stable recursion.</p>
    
    <p>This calculator lets you explore both regimes, observe divergence under various operators, and visualize how discrete substrate effects modify classical trajectories.</p>
    
    <p style="color:var(--muted);font-size:0.9rem;margin-top:20px">For full mathematical treatment, see: <a href="https://ukbbi.github.io/UNNS/docs/projectile_calculator/UNNS%20vs%20Classical%20Dynamics%20A%20Comparative%20Theoretical%20Framework.pdf" target="_blank" style="color:var(--cyan)">Complete Paper (PDF)</a></p>
  </div>
</div>

<script>
(function(){
  'use strict';
  
  // State
  let State = {
    v0: 30, ang: 45, y0: 0, g: 9.80665,
    linDrag: false, kLin: 0.05, quadDrag: false, cQuad: 0.01, altModel: false,
    dampOn: true, alpha: 0.997, driftOn: true, delta: 0.001,
    collapseOn: false, eps: 0.01, gridOn: false, hGrid: 0.5, hexOn: false, hHex: 0.5,
    classPath: [], unnsPath: [],
    impactC: null, impactU: null,
    energiesC: [], energiesU: [],
    divergence: [],
    fanPaths: [],
    fanAnimFrame: null
  };
  
  const $ = id => document.getElementById(id);
  
  // Tab switching
  window.switchTab = (tab) => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    event.target.classList.add('active');
    $('tab-' + tab).classList.add('active');
  };
  
  // Presets
  window.applyPreset = (preset) => {
    const presets = {
      vac: {v0:30,ang:45,y0:0,g:9.80665,linDrag:false,quadDrag:false,altModel:false,dampOn:false,alpha:1,driftOn:false,delta:0},
      earth: {v0:30,ang:45,y0:0,g:9.80665,linDrag:true,kLin:0.05,quadDrag:true,cQuad:0.01,altModel:true,dampOn:true,alpha:0.997,driftOn:true,delta:0.001},
      mars: {v0:30,ang:45,y0:0,g:3.71,linDrag:false,quadDrag:false,altModel:false},
      moon: {v0:30,ang:45,y0:0,g:1.62,linDrag:false,quadDrag:false,altModel:false},
      unnsHeavy: {v0:30,ang:45,y0:0,g:9.80665,dampOn:true,alpha:0.99,driftOn:true,delta:0.003,collapseOn:true,eps:0.01,gridOn:true,hGrid:0.5}
    };
    if(presets[preset]) applyState(presets[preset]);
  };
  
  function applyState(obj) {
    Object.assign(State, obj);
    $('v0').value = State.v0;
    $('ang').value = State.ang;
    $('y0').value = State.y0;
    $('grav').value = State.g;
    $('linDrag').checked = State.linDrag;
    $('kLin').value = State.kLin;
    $('quadDrag').checked = State.quadDrag;
    $('cQuad').value = State.cQuad;
    $('altModel').checked = State.altModel;
    $('dampOn').checked = State.dampOn;
    $('alpha').value = State.alpha;
    $('driftOn').checked = State.driftOn;
    $('delta').value = State.delta;
    $('collapseOn').checked = State.collapseOn;
    $('eps').value = State.eps;
    $('gridOn').checked = State.gridOn;
    $('hGrid').value = State.hGrid;
    $('hexOn').checked = State.hexOn;
    $('hHex').value = State.hHex;
  }
  
  function readState() {
    State.v0 = parseFloat($('v0').value) || 0;
    State.ang = parseFloat($('ang').value) || 0;
    State.y0 = parseFloat($('y0').value) || 0;
    State.g = parseFloat($('grav').value) || 9.80665;
    State.linDrag = $('linDrag').checked;
    State.kLin = parseFloat($('kLin').value) || 0;
    State.quadDrag = $('quadDrag').checked;
    State.cQuad = parseFloat($('cQuad').value) || 0;
    State.altModel = $('altModel').checked;
    State.dampOn = $('dampOn').checked;
    State.alpha = parseFloat($('alpha').value) || 1;
    State.driftOn = $('driftOn').checked;
    State.delta = parseFloat($('delta').value) || 0;
    State.collapseOn = $('collapseOn').checked;
    State.eps = parseFloat($('eps').value) || 0.01;
    State.gridOn = $('gridOn').checked;
    State.hGrid = parseFloat($('hGrid').value) || 0.5;
    State.hexOn = $('hexOn').checked;
    State.hHex = parseFloat($('hHex').value) || 0.5;
  }
  
  window.resetParams = () => {
    applyState({v0:30,ang:45,y0:0,g:9.80665,linDrag:false,quadDrag:false,altModel:false,
      dampOn:true,alpha:0.997,driftOn:true,delta:0.001,collapseOn:false,gridOn:false,hexOn:false});
    compute();
  };
  
  // Air density model
  function airDensity(h) {
    // Simplified exponential: ρ(h) = ρ₀ * exp(-h/H), H ≈ 8500m
    return Math.exp(-h / 8500);
  }
  
  // Snap functions
  function snapGrid(x, y, h) {
    return h > 0 ? [Math.round(x/h)*h, Math.round(y/h)*h] : [x, y];
  }
  
  function snapHex(x, y, h) {
    if(h <= 0) return [x, y];
    const a = [h, 0], b = [h/2, h*Math.sqrt(3)/2];
    const det = a[0]*b[1] - a[1]*b[0];
    const u = Math.round((x*b[1] - y*b[0]) / det);
    const v = Math.round((-x*a[1] + y*a[0]) / det);
    return [u*a[0] + v*b[0], u*a[1] + v*b[1]];
  }
  
  // Simulate classical
  function simulateClassical(params = State) {
    const ang = params.ang * Math.PI / 180;
    const dt = 0.01, maxSteps = 20000;
    let t = 0, x = 0, y = params.y0;
    let vx = params.v0 * Math.cos(ang);
    let vy = params.v0 * Math.sin(ang);
    const path = [[t, x, y]];
    const energies = [];
    let ymax = y, tmax = 0;
    
    for(let n = 0; n < maxSteps; n++) {
      let ax = 0, ay = -params.g;
      
      // Drag
      if(params.linDrag) {
        ax -= params.kLin * vx;
        ay -= params.kLin * vy;
      }
      if(params.quadDrag) {
        const v = Math.hypot(vx, vy);
        const drag = params.altModel ? params.cQuad * airDensity(Math.max(y, 0)) : params.cQuad;
        ax -= drag * v * vx;
        ay -= drag * v * vy;
      }
      
      vx += ax * dt;
      vy += ay * dt;
      x += vx * dt;
      y += vy * dt;
      t += dt;
      
      path.push([t, x, y]);
      const E = 0.5*(vx*vx + vy*vy) + params.g*Math.max(y, 0);
      energies.push([t, E]);
      
      if(y > ymax) { ymax = y; tmax = t; }
      if(y <= 0 && t > 0) {
        const [t1,x1,y1] = path[path.length-2];
        const [t2,x2,y2] = path[path.length-1];
        const lam = -y1 / (y2 - y1 + 1e-12);
        const xi = x1 + lam * (x2 - x1);
        return {path, energies, impact: {t: t1 + lam*(t2-t1), x: xi, ymax, tmax}};
      }
      if(Math.abs(x) > 1e6 || Math.abs(y) > 1e6) break;
    }
    return {path, energies, impact: null};
  }
  
  // Simulate UNNS
  function simulateUNNS(params = State) {
    const ang = params.ang * Math.PI / 180;
    const dt = 0.01, maxSteps = 20000;
    let t = 0, x = 0, y = params.y0;
    let vx = params.v0 * Math.cos(ang);
    let vy = params.v0 * Math.sin(ang);
    const path = [[t, x, y]];
    const energies = [];
    let ymax = y, tmax = 0;
    
    for(let n = 0; n < maxSteps; n++) {
      // UNNS operators
      if(params.dampOn) {
        vx *= params.alpha;
        vy *= params.alpha;
      }
      if(params.collapseOn) {
        if(Math.abs(vx) < params.eps) vx = 0;
        if(Math.abs(vy) < params.eps) vy = 0;
      }
      
      const gEff = params.driftOn ? params.g * (1 + params.delta * t) : params.g;
      vy -= gEff * dt;
      
      x += vx * dt;
      y += vy * dt;
      t += dt;
      
      // Lattice inlaying
      if(params.gridOn) [x, y] = snapGrid(x, y, params.hGrid);
      if(params.hexOn) [x, y] = snapHex(x, y, params.hHex);
      
      path.push([t, x, y]);
      const E = 0.5*(vx*vx + vy*vy) + params.g*Math.max(y, 0);
      energies.push([t, E]);
      
      if(y > ymax) { ymax = y; tmax = t; }
      if(y <= 0 && t > 0) {
        const [t1,x1,y1] = path[path.length-2];
        const [t2,x2,y2] = path[path.length-1];
        const lam = -y1 / (y2 - y1 + 1e-12);
        const xi = x1 + lam * (x2 - x1);
        return {path, energies, impact: {t: t1 + lam*(t2-t1), x: xi, ymax, tmax}};
      }
      if(Math.abs(x) > 1e6 || Math.abs(y) > 1e6) break;
    }
    return {path, energies, impact: null};
  }
  
  // Compute divergence
  function computeDivergence() {
    const div = [];
    const n = Math.min(State.classPath.length, State.unnsPath.length);
    for(let i = 0; i < n; i++) {
      const [tc,xc,yc] = State.classPath[i];
      const [tu,xu,yu] = State.unnsPath[i];
      div.push([Math.min(tc,tu), Math.hypot(xc-xu, yc-yu)]);
    }
    return div;
  }
  
  // Main compute
  window.compute = () => {
    readState();
    
    const C = simulateClassical();
    const U = simulateUNNS();
    
    State.classPath = C.path;
    State.impactC = C.impact;
    State.energiesC = C.energies;
    
    State.unnsPath = U.path;
    State.impactU = U.impact;
    State.energiesU = U.energies;
    
    State.divergence = computeDivergence();
    
    drawTrajectory();
    drawEnergy();
    drawDivergence();
    displayResults();
  };
  
  // Drawing functions
  function drawTrajectory() {
    const cv = $('cvTraj'), ctx = cv.getContext('2d');
    const W = cv.width, H = cv.height;
    ctx.clearRect(0, 0, W, H);
    
    const allX = [...State.classPath.map(p=>p[1]), ...State.unnsPath.map(p=>p[1]), 10];
    const allY = [...State.classPath.map(p=>p[2]), ...State.unnsPath.map(p=>p[2]), 10];
    const xMax = Math.max(...allX) * 1.1;
    const yMax = Math.max(...allY) * 1.15;
    
    const pad = {l:60, r:30, t:30, b:50};
    const X = x => pad.l + (x/xMax) * (W - pad.l - pad.r);
    const Y = y => H - pad.b - (y/yMax) * (H - pad.t - pad.b);
    
    // Axes
    ctx.strokeStyle = '#8aa0c6';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(xMax), Y(0));
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(0), Y(yMax));
    ctx.stroke();
    
    // Classical path
    ctx.strokeStyle = '#6ae3ff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    State.classPath.forEach(([t,x,y], i) => {
      if(i === 0) ctx.moveTo(X(x), Y(y));
      else ctx.lineTo(X(x), Y(y));
    });
    ctx.stroke();
    
    // UNNS path
    ctx.strokeStyle = '#ff6ad5';
    ctx.lineWidth = 3;
    ctx.beginPath();
    State.unnsPath.forEach(([t,x,y], i) => {
      if(i === 0) ctx.moveTo(X(x), Y(y));
      else ctx.lineTo(X(x), Y(y));
    });
    ctx.stroke();
    
    // Impact markers
    ctx.fillStyle = '#f59e0b';
    if(State.impactC) {
      ctx.beginPath();
      ctx.arc(X(State.impactC.x), Y(0), 6, 0, 2*Math.PI);
      ctx.fill();
    }
    if(State.impactU) {
      ctx.beginPath();
      ctx.arc(X(State.impactU.x), Y(0), 6, 0, 2*Math.PI);
      ctx.fill();
    }
    
    // Labels
    ctx.fillStyle = '#e8ecff';
    ctx.font = '14px system-ui';
    ctx.fillText('Range (m)', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('Height (m)', 0, 0);
    ctx.restore();
  }
  
  function drawEnergy() {
    const cv = $('cvEnergy'), ctx = cv.getContext('2d');
    const W = cv.width, H = cv.height;
    ctx.clearRect(0, 0, W, H);
    
    const tMax = Math.max(
      State.energiesC.length ? State.energiesC[State.energiesC.length-1][0] : 0,
      State.energiesU.length ? State.energiesU[State.energiesU.length-1][0] : 0,
      1
    );
    const eMax = Math.max(
      ...State.energiesC.map(e=>e[1]),
      ...State.energiesU.map(e=>e[1]),
      1
    );
    
    const pad = {l:50, r:20, t:30, b:40};
    const X = t => pad.l + (t/tMax) * (W - pad.l - pad.r);
    const Y = e => H - pad.b - (e/eMax) * (H - pad.t - pad.b);
    
    // Axes
    ctx.strokeStyle = '#8aa0c6';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(tMax), Y(0));
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(0), Y(eMax));
    ctx.stroke();
    
    // Classical energy
    ctx.strokeStyle = '#6ae3ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    State.energiesC.forEach(([t,e], i) => {
      if(i === 0) ctx.moveTo(X(t), Y(e));
      else ctx.lineTo(X(t), Y(e));
    });
    ctx.stroke();
    
    // UNNS energy
    ctx.strokeStyle = '#ff6ad5';
    ctx.lineWidth = 2;
    ctx.beginPath();
    State.energiesU.forEach(([t,e], i) => {
      if(i === 0) ctx.moveTo(X(t), Y(e));
      else ctx.lineTo(X(t), Y(e));
    });
    ctx.stroke();
    
    ctx.fillStyle = '#e8ecff';
    ctx.font = '13px system-ui';
    ctx.fillText('Time (s)', W/2, H - 8);
    ctx.fillText('E', 10, 20);
  }
  
  function drawDivergence() {
    const cv = $('cvDiv'), ctx = cv.getContext('2d');
    const W = cv.width, H = cv.height;
    ctx.clearRect(0, 0, W, H);
    
    if(!State.divergence.length) return;
    
    const tMax = State.divergence[State.divergence.length-1][0];
    const dMax = Math.max(...State.divergence.map(d=>d[1]), 0.01);
    
    const pad = {l:50, r:20, t:30, b:40};
    const X = t => pad.l + (t/tMax) * (W - pad.l - pad.r);
    const Y = d => H - pad.b - (d/dMax) * (H - pad.t - pad.b);
    
    ctx.strokeStyle = '#8aa0c6';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(tMax), Y(0));
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(0), Y(dMax));
    ctx.stroke();
    
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 2;
    ctx.beginPath();
    State.divergence.forEach(([t,d], i) => {
      if(i === 0) ctx.moveTo(X(t), Y(d));
      else ctx.lineTo(X(t), Y(d));
    });
    ctx.stroke();
    
    ctx.fillStyle = '#e8ecff';
    ctx.font = '13px system-ui';
    ctx.fillText('Time (s)', W/2, H - 8);
    ctx.fillText('Δ (m)', 10, 20);
  }
  
  function displayResults() {
    const html = `
      <div class="result-box">
        <h3>Classical</h3>
        <div class="result-value">
          Range: ${State.impactC ? State.impactC.x.toFixed(3) : '—'} m<br>
          Time: ${State.impactC ? State.impactC.t.toFixed(3) : '—'} s<br>
          Max Height: ${State.impactC ? State.impactC.ymax.toFixed(3) : '—'} m
        </div>
      </div>
      <div class="result-box unns">
        <h3>UNNS</h3>
        <div class="result-value">
          Range: ${State.impactU ? State.impactU.x.toFixed(3) : '—'} m<br>
          Time: ${State.impactU ? State.impactU.t.toFixed(3) : '—'} s<br>
          Max Height: ${State.impactU ? State.impactU.ymax.toFixed(3) : '—'} m
        </div>
      </div>
      <div class="result-box" style="border-left-color:#fbbf24">
        <h3 style="color:#fbbf24">Divergence</h3>
        <div class="result-value">
          ${State.divergence.length ? 
            `Max: ${Math.max(...State.divergence.map(d=>d[1])).toFixed(3)} m<br>
             Avg: ${(State.divergence.reduce((s,d)=>s+d[1],0)/State.divergence.length).toFixed(3)} m` 
            : '—'}
        </div>
      </div>
    `;
    $('results').innerHTML = html;
  }
  
  // Angle optimizer
  window.optimizeAngle = () => {
    readState();
    const model = $('optModel').value;
    $('optProgress').style.display = 'block';
    $('optStatus').innerHTML = '<span class="badge badge-info">Optimizing...</span>';
    
    setTimeout(() => {
      const angles = [];
      const rangesC = [], rangesU = [];
      
      for(let a = 5; a <= 85; a += 0.5) {
        angles.push(a);
        $('optBar').style.width = ((a-5)/80*100) + '%';
        
        if(model === 'classical' || model === 'both') {
          const paramsC = {...State, ang: a};
          const C = simulateClassical(paramsC);
          rangesC.push(C.impact ? C.impact.x : 0);
        }
        
        if(model === 'unns' || model === 'both') {
          const paramsU = {...State, ang: a};
          const U = simulateUNNS(paramsU);
          rangesU.push(U.impact ? U.impact.x : 0);
        }
      }
      
      let optC = 0, maxC = 0, optU = 0, maxU = 0;
      
      if(model === 'classical' || model === 'both') {
        optC = angles[rangesC.indexOf(Math.max(...rangesC))];
        maxC = Math.max(...rangesC);
      }
      
      if(model === 'unns' || model === 'both') {
        optU = angles[rangesU.indexOf(Math.max(...rangesU))];
        maxU = Math.max(...rangesU);
      }
      
      $('optStatus').innerHTML = '<span class="badge badge-info">Complete!</span>';
      $('optProgress').style.display = 'none';
      
      let html = '<div class="results" style="margin:20px 0">';
      
      if(model === 'classical' || model === 'both') {
        html += `
          <div class="result-box">
            <h3>Classical Optimal</h3>
            <div class="result-value">
              Angle: ${optC.toFixed(1)}°<br>
              Range: ${maxC.toFixed(3)} m
            </div>
          </div>
        `;
      }
      
      if(model === 'unns' || model === 'both') {
        html += `
          <div class="result-box unns">
            <h3>UNNS Optimal</h3>
            <div class="result-value">
              Angle: ${optU.toFixed(1)}°<br>
              Range: ${maxU.toFixed(3)} m
            </div>
          </div>
        `;
      }
      html += '</div>';
      $('optResults').innerHTML = html;
      
      // Draw optimization curve
      drawOptCurve(angles, rangesC, rangesU, model, optC, optU);
    }, 100);
  };
  
  function drawOptCurve(angles, rangesC, rangesU, model, optC, optU) {
    const cv = $('cvOpt'), ctx = cv.getContext('2d');
    const W = cv.width, H = cv.height;
    ctx.clearRect(0, 0, W, H);
    
    const maxR = Math.max(
      ...(model === 'classical' || model === 'both' ? rangesC : [0]),
      ...(model === 'unns' || model === 'both' ? rangesU : [0])
    ) * 1.1;
    const pad = {l:60, r:30, t:30, b:50};
    const X = a => pad.l + ((a-5)/80) * (W - pad.l - pad.r);
    const Y = r => H - pad.b - (r/maxR) * (H - pad.t - pad.b);
    
    // Axes
    ctx.strokeStyle = '#8aa0c6';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(X(5), Y(0));
    ctx.lineTo(X(85), Y(0));
    ctx.moveTo(X(5), Y(0));
    ctx.lineTo(X(5), Y(maxR));
    ctx.stroke();
    
    // Classical curve
    if(model === 'classical' || model === 'both') {
      ctx.strokeStyle = '#6ae3ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      angles.forEach((a, i) => {
        if(i === 0) ctx.moveTo(X(a), Y(rangesC[i]));
        else ctx.lineTo(X(a), Y(rangesC[i]));
      });
      ctx.stroke();
      
      // Classical optimal marker
      ctx.fillStyle = '#2dd4bf';
      ctx.beginPath();
      ctx.arc(X(optC), Y(Math.max(...rangesC)), 8, 0, 2*Math.PI);
      ctx.fill();
    }
    
    // UNNS curve
    if(model === 'unns' || model === 'both') {
      ctx.strokeStyle = '#ff6ad5';
      ctx.lineWidth = 3;
      ctx.beginPath();
      angles.forEach((a, i) => {
        if(i === 0) ctx.moveTo(X(a), Y(rangesU[i]));
        else ctx.lineTo(X(a), Y(rangesU[i]));
      });
      ctx.stroke();
      
      // UNNS optimal marker
      ctx.fillStyle = '#2dd4bf';
      ctx.beginPath();
      ctx.arc(X(optU), Y(Math.max(...rangesU)), 8, 0, 2*Math.PI);
      ctx.fill();
    }
    
    ctx.fillStyle = '#e8ecff';
    ctx.font = '14px system-ui';
    ctx.fillText('Launch Angle (deg)', W/2, H - 10);
    ctx.fillText('Range (m)', 10, 20);
  }
  
  // Compare mode
  window.computeCompare = () => {
    readState();
    
    const C = simulateClassical();
    const U = simulateUNNS();
    
    drawCompare(C, U);
    
    const html = `
      <div class="results">
        <div class="result-box">
          <h3>Classical Results</h3>
          <div class="result-value">
            Range: ${C.impact ? C.impact.x.toFixed(3) : '—'} m<br>
            Time: ${C.impact ? C.impact.t.toFixed(3) : '—'} s<br>
            Max Height: ${C.impact ? C.impact.ymax.toFixed(3) : '—'} m
          </div>
        </div>
        <div class="result-box unns">
          <h3>UNNS Results</h3>
          <div class="result-value">
            Range: ${U.impact ? U.impact.x.toFixed(3) : '—'} m<br>
            Time: ${U.impact ? U.impact.t.toFixed(3) : '—'} s<br>
            Max Height: ${U.impact ? U.impact.ymax.toFixed(3) : '—'} m
          </div>
        </div>
        <div class="result-box" style="border-left-color:#fbbf24">
          <h3 style="color:#fbbf24">Difference</h3>
          <div class="result-value">
            ΔRange: ${C.impact && U.impact ? (U.impact.x - C.impact.x).toFixed(3) : '—'} m<br>
            ΔTime: ${C.impact && U.impact ? (U.impact.t - C.impact.t).toFixed(3) : '—'} s<br>
            ΔHeight: ${C.impact && U.impact ? (U.impact.ymax - C.impact.ymax).toFixed(3) : '—'} m
          </div>
        </div>
      </div>
      <div class="legend">
        <div class="legend-item"><span class="legend-dot dot-classical"></span>Classical</div>
        <div class="legend-item"><span class="legend-dot dot-unns"></span>UNNS</div>
        <div class="legend-item"><span class="legend-dot dot-impact"></span>Impact points</div>
      </div>
    `;
    $('compareResults').innerHTML = html;
  };
  
  function drawCompare(C, U) {
    const cv = $('cvCompare'), ctx = cv.getContext('2d');
    const W = cv.width, H = cv.height;
    ctx.clearRect(0, 0, W, H);
    
    const allX = [...C.path.map(p=>p[1]), ...U.path.map(p=>p[1]), 10];
    const allY = [...C.path.map(p=>p[2]), ...U.path.map(p=>p[2]), 10];
    const xMax = Math.max(...allX) * 1.1;
    const yMax = Math.max(...allY) * 1.15;
    
    const pad = {l:60, r:30, t:30, b:50};
    const X = x => pad.l + (x/xMax) * (W - pad.l - pad.r);
    const Y = y => H - pad.b - (y/yMax) * (H - pad.t - pad.b);
    
    // Axes
    ctx.strokeStyle = '#8aa0c6';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(xMax), Y(0));
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(0), Y(yMax));
    ctx.stroke();
    
    // Grid for comparison
    ctx.strokeStyle = 'rgba(138,160,198,0.1)';
    ctx.lineWidth = 1;
    const gridStep = Math.pow(10, Math.floor(Math.log10(xMax/8)));
    for(let x = 0; x <= xMax; x += gridStep) {
      ctx.beginPath();
      ctx.moveTo(X(x), Y(0));
      ctx.lineTo(X(x), Y(yMax));
      ctx.stroke();
    }
    const gridStepY = Math.pow(10, Math.floor(Math.log10(yMax/6)));
    for(let y = 0; y <= yMax; y += gridStepY) {
      ctx.beginPath();
      ctx.moveTo(X(0), Y(y));
      ctx.lineTo(X(xMax), Y(y));
      ctx.stroke();
    }
    
    // Classical path
    ctx.strokeStyle = '#6ae3ff';
    ctx.lineWidth = 4;
    ctx.shadowColor = '#6ae3ff';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    C.path.forEach(([t,x,y], i) => {
      if(i === 0) ctx.moveTo(X(x), Y(y));
      else ctx.lineTo(X(x), Y(y));
    });
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // UNNS path
    ctx.strokeStyle = '#ff6ad5';
    ctx.lineWidth = 4;
    ctx.shadowColor = '#ff6ad5';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    U.path.forEach(([t,x,y], i) => {
      if(i === 0) ctx.moveTo(X(x), Y(y));
      else ctx.lineTo(X(x), Y(y));
    });
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Impact markers
    ctx.fillStyle = '#f59e0b';
    ctx.shadowColor = '#f59e0b';
    ctx.shadowBlur = 10;
    if(C.impact) {
      ctx.beginPath();
      ctx.arc(X(C.impact.x), Y(0), 8, 0, 2*Math.PI);
      ctx.fill();
      
      // Label
      ctx.fillStyle = '#6ae3ff';
      ctx.font = 'bold 12px system-ui';
      ctx.fillText('C', X(C.impact.x) - 3, Y(0) - 12);
    }
    if(U.impact) {
      ctx.beginPath();
      ctx.arc(X(U.impact.x), Y(0), 8, 0, 2*Math.PI);
      ctx.fill();
      
      // Label
      ctx.fillStyle = '#ff6ad5';
      ctx.font = 'bold 12px system-ui';
      ctx.fillText('U', X(U.impact.x) - 3, Y(0) - 12);
    }
    ctx.shadowBlur = 0;
    
    // Axis labels
    ctx.fillStyle = '#e8ecff';
    ctx.font = '14px system-ui';
    ctx.fillText('Range (m)', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('Height (m)', 0, 0);
    ctx.restore();
  }
  
  // Fan view
  window.computeFan = () => {
    readState();
    const start = parseFloat($('fanStart').value);
    const end = parseFloat($('fanEnd').value);
    const step = parseFloat($('fanStep').value);
    const animate = $('fanAnimate').checked;
    
    State.fanPaths = [];
    
    for(let a = start; a <= end; a += step) {
      const params = {...State, ang: a};
      const C = simulateClassical(params);
      const U = simulateUNNS(params);
      State.fanPaths.push({angle: a, classPath: C.path, unnsPath: U.path});
    }
    
    if(animate) {
      animateFan();
    } else {
      drawFan(null);
    }
    
    $('fanInfo').innerHTML = `<p style="color:var(--muted);margin-top:12px">Generated ${State.fanPaths.length} trajectories from ${start}° to ${end}°</p>`;
  };
  
  let fanFrame = 0;
  function animateFan() {
    const maxLen = Math.max(...State.fanPaths.map(p => p.classPath.length));
    
    function step() {
      drawFan(fanFrame);
      fanFrame += Math.ceil(maxLen / 200);
      if(fanFrame < maxLen) {
        State.fanAnimFrame = requestAnimationFrame(step);
      }
    }
    fanFrame = 0;
    step();
  }
  
  window.stopFanAnim = () => {
    if(State.fanAnimFrame) cancelAnimationFrame(State.fanAnimFrame);
    drawFan(null);
  };
  
  function drawFan(frameLimit) {
    const cv = $('cvFan'), ctx = cv.getContext('2d');
    const W = cv.width, H = cv.height;
    ctx.clearRect(0, 0, W, H);
    
    if(!State.fanPaths.length) return;
    
    const allX = [], allY = [];
    State.fanPaths.forEach(p => {
      p.classPath.forEach(pt => {allX.push(pt[1]); allY.push(pt[2]);});
      p.unnsPath.forEach(pt => {allX.push(pt[1]); allY.push(pt[2]);});
    });
    const xMax = Math.max(...allX, 10) * 1.1;
    const yMax = Math.max(...allY, 10) * 1.15;
    
    const pad = {l:60, r:30, t:30, b:50};
    const X = x => pad.l + (x/xMax) * (W - pad.l - pad.r);
    const Y = y => H - pad.b - (y/yMax) * (H - pad.t - pad.b);
    
    // Axes
    ctx.strokeStyle = '#8aa0c6';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(xMax), Y(0));
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(0), Y(yMax));
    ctx.stroke();
    
    // Draw trajectories
    State.fanPaths.forEach((traj, idx) => {
      const hue = (idx / State.fanPaths.length) * 240;
      
      // Classical
      ctx.strokeStyle = `hsl(${hue}, 70%, 60%)`;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      const cPath = frameLimit ? traj.classPath.slice(0, frameLimit) : traj.classPath;
      cPath.forEach(([t,x,y], i) => {
        if(i === 0) ctx.moveTo(X(x), Y(y));
        else ctx.lineTo(X(x), Y(y));
      });
      ctx.stroke();
      
      // UNNS
      ctx.strokeStyle = `hsl(${320 + hue/4}, 80%, 65%)`;
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4, 2]);
      ctx.beginPath();
      const uPath = frameLimit ? traj.unnsPath.slice(0, frameLimit) : traj.unnsPath;
      uPath.forEach(([t,x,y], i) => {
        if(i === 0) ctx.moveTo(X(x), Y(y));
        else ctx.lineTo(X(x), Y(y));
      });
      ctx.stroke();
      ctx.setLineDash([]);
    });
    
    ctx.globalAlpha = 1;
  }
  
  // Export CSV
  window.exportCSV = () => {
    const rows = ['t,x_classical,y_classical,x_unns,y_unns,divergence'];
    const n = Math.max(State.classPath.length, State.unnsPath.length);
    for(let i = 0; i < n; i++) {
      const [tc,xc,yc] = State.classPath[i] || [NaN,NaN,NaN];
      const [tu,xu,yu] = State.unnsPath[i] || [NaN,NaN,NaN];
      const t = isFinite(tc) ? tc : tu;
      const d = State.divergence[i] ? State.divergence[i][1] : '';
      rows.push([t,xc,yc,xu,yu,d].join(','));
    }
    const blob = new Blob([rows.join('\n')], {type: 'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'unns_projectile_' + Date.now() + '.csv';
    a.click();
  };
  
  // Modal
  window.showAbout = () => $('modal').classList.add('active');
  window.closeModal = (e) => {
    if(!e || e.target === $('modal')) {
      $('modal').classList.remove('active');
    }
  };
  
  // Initial compute
  compute();
})();
</script>
</body>
</html>