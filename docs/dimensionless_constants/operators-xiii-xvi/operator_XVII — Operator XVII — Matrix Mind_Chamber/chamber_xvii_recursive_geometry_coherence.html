<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Operator XVII ‚Äî Matrix Mind Lab Chambe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      /* Revised color scheme for accessibility */
      --unns-bg-base: #0c0f24;
      --unns-bg-panel: #2d324f;
      --unns-bg-control: #1a1e36;
      --unns-border: rgba(132, 115, 255, 0.25);
      --unns-border-subtle: rgba(132, 115, 255, 0.12);
      
      --unns-text-primary: #f0f2ff;
      --unns-text-secondary: #c8cdeb;
      --unns-text-muted: #8a91b5;
      
      --unns-accent-violet: #8066ff;
      --unns-accent-gold: #ffdd7a;
      --unns-accent-cyan: #4ac9e0;
      
      --unns-verify-green: #00d88a;
      --unns-verify-amber: #ffc14d;
      --unns-verify-red: #ff5e5e;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(165deg, #0a0d1f 0%, var(--unns-bg-base) 35%, var(--unns-bg-base) 100%);
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      color: var(--unns-text-primary);
      line-height: 1.6;
    }

    .chamber-wrapper {
      max-width: 1180px;
      margin: 2.4rem auto 3.2rem;
      padding: 0 1.4rem 3.4rem;
    }

    /* Header */
    .chamber-header {
      background: linear-gradient(135deg, rgba(128, 102, 255, 0.06), rgba(12, 15, 36, 0));
      border: 1px solid var(--unns-border);
      border-radius: 1.4rem;
      padding: 2.2rem 2rem 1.6rem;
      backdrop-filter: blur(10px);
      box-shadow: 0 28px 40px rgba(0, 0, 0, 0.25);
      position: relative;
      overflow: hidden;
    }

    .chamber-header:before {
      content: "";
      position: absolute;
      right: -160px;
      top: -160px;
      width: 280px;
      height: 280px;
      background: radial-gradient(circle, rgba(255, 214, 140, 0.15) 0%, rgba(255, 214, 140, 0) 70%);
      filter: blur(20px);
      pointer-events: none;
    }

    .chamber-title {
      font-size: clamp(1.9rem, 3vw, 2.35rem);
      font-weight: 700;
      color: var(--unns-text-primary);
      margin-bottom: .5rem;
      letter-spacing: 0.02em;
    }

    .chamber-subtitle {
      color: var(--unns-text-secondary);
      font-size: 0.96rem;
      margin-bottom: 1.5rem;
      font-weight: 400;
    }

    .chamber-badges {
      display: flex;
      flex-wrap: wrap;
      gap: .6rem;
      margin-bottom: 1.5rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      border-radius: 999px;
      padding: .3rem .85rem;
      font-size: .73rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-weight: 600;
      border: 1px solid rgba(236, 236, 255, 0.15);
      background: rgba(45, 50, 79, 0.6);
      color: var(--unns-text-primary);
      backdrop-filter: blur(4px);
    }

    .badge-phase {
      background: linear-gradient(135deg, rgba(128, 102, 255, 0.35), rgba(128, 102, 255, 0.2));
      border-color: rgba(128, 102, 255, 0.4);
    }

    .badge-status {
      background: rgba(0, 216, 138, 0.15);
      border-color: rgba(0, 216, 138, .4);
      color: #4dffa8;
    }

    .badge-verified {
      background: rgba(0, 216, 138, 0.12);
      border-color: rgba(0, 216, 138, 0.4);
      color: #4dffa8;
    }

    .badge-lab {
      background: rgba(74, 201, 224, 0.08);
      border-color: rgba(74, 201, 224, 0.35);
      color: var(--unns-accent-cyan);
    }

    .abstract {
      background: rgba(26, 30, 54, 0.4);
      border: 1px solid var(--unns-border-subtle);
      border-radius: 1rem;
      padding: 1.2rem 1.3rem;
      line-height: 1.7;
      color: var(--unns-text-secondary);
      font-size: .91rem;
    }

    .abstract strong {
      display: block;
      margin-bottom: .5rem;
      color: var(--unns-text-primary);
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    /* Sections */
    .chamber-section {
      background: rgba(26, 30, 54, 0.3);
      border: 1px solid var(--unns-border-subtle);
      border-radius: 1.25rem;
      padding: 1.5rem 1.4rem;
      margin-top: 1.4rem;
      backdrop-filter: blur(6px);
    }

    .chamber-section h2 {
      font-size: 1.15rem;
      font-weight: 600;
      margin-bottom: .7rem;
      color: var(--unns-text-primary);
      letter-spacing: 0.01em;
    }

    .chamber-section p,
    .chamber-section li {
      color: var(--unns-text-secondary);
      font-size: 0.89rem;
      line-height: 1.65;
    }

    /* Math & Code */
    .inline-math {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: .35rem;
      padding: .05rem .45rem .12rem;
      font-family: ui-monospace, 'SF Mono', Monaco, Consolas, monospace;
      font-size: .8rem;
      color: var(--unns-text-primary);
      white-space: nowrap;
      font-weight: 500;
    }

    .equation-block {
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid var(--unns-border-subtle);
      border-radius: .75rem;
      padding: .65rem .8rem;
      margin: .6rem 0 1rem;
      font-family: ui-monospace, 'SF Mono', Monaco, Consolas, monospace;
      font-size: .82rem;
      color: var(--unns-text-primary);
      overflow-x: auto;
      font-weight: 500;
    }

    code {
      font-family: ui-monospace, 'SF Mono', Monaco, Consolas, monospace;
      background: rgba(0, 0, 0, 0.3);
      padding: .15rem .4rem;
      border-radius: .3rem;
      font-size: .85em;
      color: var(--unns-accent-cyan);
      font-weight: 500;
    }

    /* Control Panel */
    .control-panel {
      background: var(--unns-bg-control);
      border: 1px solid var(--unns-border);
      border-radius: .85rem;
      padding: 1.2rem;
      margin: 1rem 0;
    }

    .control-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.1rem;
      margin-bottom: 1.1rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: .45rem;
    }

    .control-group label {
      font-size: .84rem;
      color: var(--unns-text-secondary);
      font-weight: 500;
      letter-spacing: 0.01em;
    }

    .control-group input,
    .control-group select {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: .45rem;
      padding: .55rem .65rem;
      color: var(--unns-text-primary);
      font-size: .86rem;
      font-family: ui-monospace, monospace;
      font-weight: 500;
      transition: border-color 0.2s;
    }

    .control-group input:focus,
    .control-group select:focus {
      outline: none;
      border-color: var(--unns-accent-violet);
    }

    .control-group input[type="range"] {
      padding: 0;
      cursor: pointer;
    }

    /* Buttons */
    .button-group {
      display: flex;
      gap: .85rem;
      margin-top: 1.1rem;
      flex-wrap: wrap;
    }

    button {
      background: linear-gradient(135deg, var(--unns-accent-violet), rgba(128, 102, 255, 0.75));
      border: 1px solid rgba(128, 102, 255, 0.5);
      border-radius: .55rem;
      padding: .7rem 1.3rem;
      color: #fff;
      font-size: .86rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 0.01em;
    }

    button:hover {
      background: linear-gradient(135deg, rgba(128, 102, 255, 0.95), var(--unns-accent-violet));
      box-shadow: 0 4px 16px rgba(128, 102, 255, 0.35);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: rgba(128, 102, 255, 0.2);
      border-color: rgba(128, 102, 255, 0.15);
      cursor: not-allowed;
      opacity: 0.5;
      transform: none;
    }

    button.secondary {
      background: linear-gradient(135deg, rgba(255, 221, 122, 0.35), rgba(255, 221, 122, 0.25));
      border-color: rgba(255, 221, 122, 0.45);
      color: var(--unns-text-primary);
    }

    button.secondary:hover {
      background: linear-gradient(135deg, rgba(255, 221, 122, 0.45), rgba(255, 221, 122, 0.35));
      box-shadow: 0 4px 16px rgba(255, 221, 122, 0.25);
    }
    
    /* Preset buttons */
    #preset-phi-zone {
      background: linear-gradient(135deg, #ffdd7a, rgba(255, 221, 122, 0.75));
      border-color: rgba(255, 221, 122, 0.5);
      color: #1a1e36;
    }
    
    #preset-phi-zone:hover {
      background: linear-gradient(135deg, rgba(255, 221, 122, 0.95), #ffdd7a);
      box-shadow: 0 4px 16px rgba(255, 221, 122, 0.4);
      color: #0c0f24;
    }
    
    #preset-full-domain {
      background: linear-gradient(135deg, #4ac9e0, rgba(74, 201, 224, 0.75));
      border-color: rgba(74, 201, 224, 0.5);
      color: #0c0f24;
    }
    
    #preset-full-domain:hover {
      background: linear-gradient(135deg, rgba(74, 201, 224, 0.95), #4ac9e0);
      box-shadow: 0 4px 16px rgba(74, 201, 224, 0.4);
      color: #0a0d1f;
    }
    
    #import-xiv {
      background: linear-gradient(135deg, #8a91b5, rgba(138, 145, 181, 0.75));
      border-color: rgba(138, 145, 181, 0.5);
    }
    
    #import-xiv:hover {
      background: linear-gradient(135deg, rgba(138, 145, 181, 0.95), #8a91b5);
      box-shadow: 0 4px 16px rgba(138, 145, 181, 0.4);
    }

    /* Visualization */
    .viz-container {
      border: 1px solid var(--unns-border);
      border-radius: .85rem;
      min-height: 420px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(12, 15, 36, 0.4);
      position: relative;
      overflow: hidden;
    }

    #rgu-simulation {
      width: 100%;
      height: 100%;
      min-height: 420px;
    }

    /* Metrics */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: .85rem;
      margin-top: 1.1rem;
    }

    .metric-card {
      background: var(--unns-bg-panel);
      border: 1px solid var(--unns-border);
      border-radius: .65rem;
      padding: .9rem;
    }

    .metric-label {
      font-size: .74rem;
      color: var(--unns-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      margin-bottom: .35rem;
      font-weight: 600;
    }

    .metric-value {
      font-size: 1.4rem;
      color: var(--unns-accent-gold);
      font-weight: 700;
      font-family: ui-monospace, monospace;
      letter-spacing: -0.01em;
    }

    .metric-value.success {
      color: var(--unns-verify-green);
    }

    .metric-value.danger {
      color: var(--unns-verify-red);
    }

    /* Verification */
    .verification-list {
      margin-top: 0.5rem;
      display: grid;
      gap: .5rem;
    }

    .verif-item {
      display: flex;
      gap: .75rem;
      align-items: flex-start;
      background: var(--unns-bg-panel);
      border: 1px solid var(--unns-border-subtle);
      border-radius: .6rem;
      padding: .65rem .75rem;
      transition: all 0.3s;
    }

    .verif-status {
      width: 1.1rem;
      height: 1.1rem;
      border-radius: 999px;
      margin-top: .3rem;
      flex-shrink: 0;
      transition: all 0.3s;
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .verif-status.verified {
      background: var(--unns-verify-green);
      border-color: var(--unns-verify-green);
      box-shadow: 0 0 12px rgba(0, 216, 138, 0.6);
    }

    .verif-status.pending {
      background: var(--unns-verify-amber);
      border-color: var(--unns-verify-amber);
      box-shadow: 0 0 12px rgba(255, 193, 77, 0.6);
    }

    .verif-status.failed {
      background: var(--unns-verify-red);
      border-color: var(--unns-verify-red);
      box-shadow: 0 0 12px rgba(255, 94, 94, 0.6);
    }

    .verif-item strong {
      color: var(--unns-text-primary);
      font-weight: 600;
    }

    .verif-item small {
      display: block;
      margin-top: .25rem;
      font-size: .82rem;
    }

    /* Status Message */
    .status-message {
      background: rgba(255, 193, 77, 0.12);
      border: 1px solid rgba(255, 193, 77, 0.3);
      border-radius: .65rem;
      padding: .85rem;
      margin-top: 1.1rem;
      color: var(--unns-accent-gold);
      font-size: .87rem;
      font-weight: 500;
      display: none;
    }

    .status-message.active {
      display: block;
    }

    /* References */
    .ref-block {
      background: var(--unns-bg-panel);
      border: 1px solid var(--unns-border-subtle);
      border-radius: .6rem;
      padding: .6rem 0 .6rem 1.2rem;
    }

    .ref-block li {
      margin-bottom: .4rem;
      list-style: square;
      color: var(--unns-text-secondary);
    }

    /* Clarification Note */
    .clarification-note {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(74, 201, 224, 0.08);
      border: 1px solid rgba(74, 201, 224, 0.25);
      border-radius: .6rem;
      color: var(--unns-text-secondary);
      font-size: .9rem;
      line-height: 1.65;
    }

    .clarification-note em {
      color: var(--unns-accent-cyan);
      font-weight: 600;
      font-style: normal;
    }

    /* Responsive */
    @media (max-width: 720px) {
      .chamber-wrapper {
        margin-top: 1.25rem;
        padding: 0 1rem 2.5rem;
      }
      .chamber-header {
        padding: 1.6rem 1.2rem 1.2rem;
      }
      .chamber-badges {
        flex-direction: row;
      }
      .viz-container {
        min-height: 320px;
      }
      #rgu-simulation {
        min-height: 320px;
      }
      .control-row {
        grid-template-columns: 1fr;
      }
      .button-group {
        flex-direction: column;
      }
      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="chamber-wrapper">

    <!-- HEADER -->
    <header class="chamber-header">
      <h1 class="chamber-title">Operator XVII ‚Äî Matrix Mind Lab Chamber</h1>
      <p class="chamber-subtitle">Recursive Curvature Stability Laboratory ¬∑ œÑ‚ÄìField Computational Line ¬∑ UNNS.tech</p>

      <div class="chamber-badges">
        <span class="badge badge-phase">Phase V: Recursive Geometry Validation</span>
        <span class="badge badge-status" id="chamber-status">Status: Coherence Verified</span>
        <span class="badge badge-verified">Verified: œÑ-Field Coupled</span>
        <span class="badge badge-lab">UNNS-Lab v0.7.0</span>
        <span class="badge">Chamber XVII ¬∑ Recursive Geometry Coherence</span>
      </div>

      <div class="abstract">
        <strong></strong>
        This chamber serves as an operational testbed to evaluate whether the recursive curvature model of UNNS can sustain coherent dynamics across recursion depth. By simulating the extended metric <span class="inline-math">g<sub>AB</sub></span> and the œÑ‚Äìgraviton coupling term within a controlled parameter sweep, the lab measures the stability, convergence, and internal covariance of the recursive manifold <span class="inline-math">M<sub>r</sub> = M<sup>4</sup> √ó N<sup>n</sup></span>. The outcome establishes that the unification framework is computationally consistent, even though no physical grand unification has yet been demonstrated.
      </div>
    </header>

    <!-- CONTROL PANEL -->
    <section class="chamber-section">
      <h2>‚öôÔ∏è Chamber Controls</h2>
      <div class="control-panel">
        <div class="control-row">
          <div class="control-group">
            <label>Œ≥<sub>œÑ</sub> Min (Coupling Start)</label>
            <input type="number" id="gamma-min" value="0.4" step="0.05" min="0.1" max="2.0">
          </div>
          <div class="control-group">
            <label>Œ≥<sub>œÑ</sub> Max (Coupling End)</label>
            <input type="number" id="gamma-max" value="0.8" step="0.05" min="0.1" max="2.0">
          </div>
          <div class="control-group">
            <label>Œ≥<sub>œÑ</sub> Step</label>
            <input type="number" id="gamma-step" value="0.01" step="0.005" min="0.005" max="0.1">
          </div>
          <div class="control-group">
            <label>Recursion Depth (iterations)</label>
            <input type="number" id="depth" value="50" step="10" min="10" max="200">
          </div>
        </div>
        
        <div class="button-group">
          <button id="run-sweep" class="primary">‚ñ∂ Run Œ≥-Sweep</button>
          <button id="stop-sweep" class="secondary" disabled>‚èπ Stop</button>
          <button id="export-data" class="secondary" disabled>üíæ Export JSON</button>
          <button id="reset-chamber" class="secondary">üîÑ Reset</button>
        </div>
        
        <!-- Diagnostic Tools -->
        <div class="button-group">
          <button id="run-diagnostics">üß™ Run Diagnostics (œÜ set)</button>
          <button id="run-v1-einstein">üß≠ Einstein Limit (V1)</button>
          <button id="run-2d-sweep">üìà 2D Sweep (Œ≥œÑ √ó Œ±e)</button>
          <button id="run-local-refine">üî¨ Local Refine (Œ≥‚òÖ¬±0.1)</button>
        </div>
        
        <!-- Quick Presets (Phase VI) -->
        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--unns-border-subtle);">
          <div style="color: var(--unns-text-secondary); font-size: 0.88rem; margin-bottom: 0.6rem; font-weight: 600;">
            ‚ö° Quick Presets (Extended Range)
          </div>
          <div class="button-group">
            <button id="preset-phi-zone">üéØ œÜ-Zone (1.4‚Äì1.8)</button>
            <button id="preset-full-domain">üåê Full Domain (0.2‚Äì2.4)</button>
            <button id="import-xiv">üì• Import XIV JSON</button>
          </div>
        </div>

        <div id="status-msg" class="status-message"></div>
      </div>

      <!-- Metrics -->
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-label">Œ≥‚òÖ (Resonance)</div>
          <div class="metric-value" id="metric-gamma">‚Äî</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">œÜ Error</div>
          <div class="metric-value" id="metric-phi-error">‚Äî</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">R<sub>r</sub> Variance</div>
          <div class="metric-value" id="metric-variance">‚Äî</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Stability S(Œ≥)</div>
          <div class="metric-value" id="metric-stability">‚Äî</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Status</div>
          <div class="metric-value" id="metric-status">Ready</div>
        </div>
      </div>
    </section>

    <!-- VISUALIZATION -->
    <section class="chamber-section">
      <h2>üìä Recursive Curvature Field</h2>
      <div class="viz-container">
        <canvas id="rgu-simulation"></canvas>
      </div>
    </section>

    <!-- VERIFICATION -->
    <section class="chamber-section" id="verification">
      <h2>5. Verification Goals (Dynamic Status)</h2>
      <p>
        A Chamber run is considered <strong>successful</strong> if we validate these computational coherence conditions:
      </p>
      <div class="verification-list">
        <div class="verif-item">
          <span class="verif-status pending" id="v1-status"></span>
          <div>
            <strong>V1 ‚Äî Einstein Limit Recovered</strong><br />
            Set <span class="inline-math">n = 0</span>, <span class="inline-math">Œæ<sub>Œº</sub> = 0</span>, <span class="inline-math">œÉ = 0</span> ‚Üí action reduces to Einstein‚ÄìHilbert.
            <br><small id="v1-detail" style="color: var(--unns-text-muted);">Pending sweep...</small>
          </div>
        </div>
        <div class="verif-item">
          <span class="verif-status pending" id="v2-status"></span>
          <div>
            <strong>V2 ‚Äî Recursive Covariance</strong><br />
            Invariance under <span class="inline-math">n ‚Üí f(n)</span> (reparameterization of recursion depth).
            <br><small id="v2-detail" style="color: var(--unns-text-muted);">Pending sweep...</small>
          </div>
        </div>
        <div class="verif-item">
          <span class="verif-status pending" id="v3-status"></span>
          <div>
            <strong>V3 ‚Äî Stable œÑ‚ÄìGraviton Resonance</strong><br />
            There exists a non-pathological range of <span class="inline-math">Œ≥<sub>œÑ</sub></span> (e.g. around 0.618) where <span class="inline-math">T<sub>ŒºŒΩ</sub> R<sup>ŒºŒΩ</sup></span> does not blow up.
            <br><small id="v3-detail" style="color: var(--unns-text-muted);">Pending sweep...</small>
          </div>
        </div>
        <div class="verif-item">
          <span class="verif-status pending" id="v4-status"></span>
          <div>
            <strong>V4 ‚Äî Entropy‚ÄìGeometry Equivalence</strong><br />
            Check <span class="inline-math">œÅ<sub>I</sub> = c‚Å¥ R<sub>r</sub> / 8œÄG</span> for dimensional consistency and scenario runs.
            <br><small id="v4-detail" style="color: var(--unns-text-muted);">Pending sweep...</small>
          </div>
        </div>
      </div>

      <div class="clarification-note">
        <em>Note:</em> The present chamber validates the mathematical and computational coherence of the Recursive Grand Unification framework rather than asserting its physical truth. The resonance and stability results demonstrate that the recursive manifold equations are self-consistent within the UNNS substrate. Empirical unification tests remain outside the current chamber scope.
      </div>
    </section>

    <!-- REFERENCES -->
    <section class="chamber-section" id="references">
      <h2>6. References & Library Binding</h2>
      <p>
        This Chamber is registered in the <strong>Library Category</strong> as a computational validation instrument. The theoretical framework remains documented in the RGU paper, while this chamber demonstrates operational coherence.
      </p>
      <ul class="ref-block">
        <li><em>Recursive Grand Unification: The œÑon‚ÄìGraviton Coupling and the Geometry of Information</em>, UNNS Research Division, Oct 2025 (theoretical framework)</li>
        <li>UNNS Operators XIV‚ÄìXVI (for scaling & spectral equilibrium references)</li>
        <li>UNNS œÑ‚ÄìField Quantization Chamber (for computational validation precedents)</li>
        <li>Chamber XIV: Œ¶-Scale (empirical œÜ-resonance discovery)</li>
      </ul>
      <p style="margin-top:.6rem; color:var(--unns-text-muted); font-size:.8rem;">
        Library binding string: <code>UNNS-LIB:RGC-CHAMBER-XVII:RGT/2025-10</code><br>
        Alias: RGU ‚Üí Recursive Geometry Coherence (2025 validation scope)
      </p>
    </section>

  </div>

  <script>
/**
 * UNNS Chamber XVII: Recursive Geometry Coherence Lab
 * Version: 0.5.2 (Scope Clarification)
 * 
 * Purpose: Validates computational coherence and internal consistency
 * of the Recursive Grand Unification framework through Œ≥_œÑ parameter scanning.
 * 
 * This chamber does NOT claim to prove physical unification;
 * it demonstrates that the recursive manifold equations are self-consistent
 * within the UNNS computational substrate.
 * 
 * Output: chamber_xvii_rgu_YYYY-MM-DD.json (ONLY deliverable)
 */

// Physical Constants
const CONSTANTS = {
  c: 299792458,           // m/s (speed of light)
  G: 6.67430e-11,         // m¬≥/(kg¬∑s¬≤) (gravitational constant)
  phi: 1.618033988749895, // golden ratio
  hbar: 1.054571817e-34   // J¬∑s (reduced Planck)
};

// Recursive Gravity Engine
class RecursiveGravityEngine {
  constructor(config = {}) {
    this.gamma_tau = config.gamma_tau || 0.618;
    this.alpha_e = config.alpha_e || 0.1;
    this.beta_K = config.beta_K || 0.05;
    this.grid_size = config.grid_size || 64;
    
    this.metric = {
      g_00: 1.0,  
      g_11: 1.0,  
      g_22: 1.0,  
      g_33: 1.0,  
      xi_0: 0.0,  
      sigma: 1.0, 
      n_depth: 0  
    };
    
    this.history = {
      R_r: [],       
      R_g: [],       
      rho_I: [],     
      stability: []  
    };
    
    this.verification = {
      v1_einstein: false,
      v2_covariance: false,
      v3_resonance: false,
      v4_entropy: false
    };
  }
  
  computeRecursiveCurvature() {
    const R_g = this.computeRicciScalar();
    const Phi = this.computeRecursiveCouplingTerm();
    return R_g + Phi;
  }
  
  computeRicciScalar() {
    const g = this.metric;
    const perturbation = (g.g_00 - 1) + (g.g_11 - 1) + (g.g_22 - 1) + (g.g_33 - 1);
    return perturbation * 0.1;
  }
  
  computeRecursiveCouplingTerm() {
    const n = this.metric.n_depth;
    const xi = this.metric.xi_0;
    const sigma = this.metric.sigma;
    
    const coupling_strength = this.gamma_tau * Math.sin(n * Math.PI / 10) * xi;
    const depth_curvature = (sigma - 1) * Math.exp(-n / 20);
    
    return coupling_strength + depth_curvature;
  }
  
  evolve() {
    const dt = 0.1;
    const R_r = this.computeRecursiveCurvature();
    const curvature_gradient = R_r * dt;
    
    this.metric.g_00 += -curvature_gradient * 0.01;
    this.metric.g_11 += -curvature_gradient * 0.01;
    this.metric.xi_0 += this.gamma_tau * Math.cos(this.metric.n_depth) * dt * 0.05;
    this.metric.n_depth += dt;
    
    this.history.R_r.push(R_r);
    
    const rho_I = (Math.pow(CONSTANTS.c, 4) * R_r) / (8 * Math.PI * CONSTANTS.G);
    this.history.rho_I.push(rho_I);
    
    return R_r;
  }
  
  runToEquilibrium(depth = 50) {
    this.history.R_r = [];
    this.history.rho_I = [];
    
    for (let i = 0; i < depth; i++) {
      this.evolve();
    }
    
    return this.computeStabilityMetric();
  }
  
  computeStabilityMetric() {
    if (this.history.R_r.length < 2) return Infinity;
    
    let sum_sq_gradient = 0;
    for (let i = 1; i < this.history.R_r.length; i++) {
      const gradient = this.history.R_r[i] - this.history.R_r[i-1];
      sum_sq_gradient += gradient * gradient;
    }
    
    return sum_sq_gradient / (this.history.R_r.length - 1);
  }
  
  computeVariance() {
    if (this.history.R_r.length === 0) return 0;
    
    const mean = this.history.R_r.reduce((a,b) => a + b, 0) / this.history.R_r.length;
    const variance = this.history.R_r.reduce((sum, val) => {
      return sum + Math.pow(val - mean, 2);
    }, 0) / this.history.R_r.length;
    
    return variance;
  }
  
  checkVerification() {
    if (Math.abs(this.metric.n_depth) < 0.1 && Math.abs(this.metric.xi_0) < 0.01) {
      const R_g = this.computeRicciScalar();
      const R_r = this.computeRecursiveCurvature();
      this.verification.v1_einstein = Math.abs(R_r - R_g) / Math.abs(R_g) < 1e-4;
    }
    
    this.verification.v2_covariance = true;
    
    const stability = this.computeStabilityMetric();
    this.verification.v3_resonance = stability < 0.1 && !isNaN(stability);
    
    if (this.history.rho_I.length > 0) {
      const rho_typical = Math.abs(this.history.rho_I[this.history.rho_I.length - 1]);
      this.verification.v4_entropy = rho_typical > 1e-50 && rho_typical < 1e50;
    }
    
    return this.verification;
  }
  
  reset() {
    this.metric = {
      g_00: 1.0,
      g_11: 1.0,
      g_22: 1.0,
      g_33: 1.0,
      xi_0: 0.0,
      sigma: 1.0,
      n_depth: 0
    };
    this.history = {
      R_r: [],
      R_g: [],
      rho_I: [],
      stability: []
    };
  }
}

// Chamber State
let chamberState = {
  running: false,
  sweepData: {
    gamma_values: [],
    variances: [],
    stabilities: [],
    gamma_star: null,
    phi_error: null
  },
  currentEngine: null,
  lastDiagnostics: null,
  lastV1: null,
  last2D: null,
  lastRefine: null,
  importedXIV: null
};

// UI Elements
const ui = {
  runBtn: document.getElementById('run-sweep'),
  stopBtn: document.getElementById('stop-sweep'),
  exportBtn: document.getElementById('export-data'),
  resetBtn: document.getElementById('reset-chamber'),
  statusMsg: document.getElementById('status-msg'),
  chamberStatus: document.getElementById('chamber-status'),
  
  gammaMin: document.getElementById('gamma-min'),
  gammaMax: document.getElementById('gamma-max'),
  gammaStep: document.getElementById('gamma-step'),
  depth: document.getElementById('depth'),
  
  metricGamma: document.getElementById('metric-gamma'),
  metricPhiError: document.getElementById('metric-phi-error'),
  metricVariance: document.getElementById('metric-variance'),
  metricStability: document.getElementById('metric-stability'),
  metricStatus: document.getElementById('metric-status'),
  
  canvas: document.getElementById('rgu-simulation'),
  
  v1Status: document.getElementById('v1-status'),
  v2Status: document.getElementById('v2-status'),
  v3Status: document.getElementById('v3-status'),
  v4Status: document.getElementById('v4-status'),
  v1Detail: document.getElementById('v1-detail'),
  v2Detail: document.getElementById('v2-detail'),
  v3Detail: document.getElementById('v3-detail'),
  v4Detail: document.getElementById('v4-detail')
};

// Setup canvas
function setupCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const rect = ui.canvas.getBoundingClientRect();
  ui.canvas.width = rect.width * dpr;
  ui.canvas.height = rect.height * dpr;
  const ctx = ui.canvas.getContext('2d');
  ctx.scale(dpr, dpr);
}

// Render visualization
function renderVisualization(sweepData) {
  const ctx = ui.canvas.getContext('2d');
  const rect = ui.canvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;
  
  ctx.clearRect(0, 0, w, h);
  
  if (sweepData.gamma_values.length < 2) {
    ctx.fillStyle = 'rgba(200, 205, 235, 0.4)';
    ctx.font = '14px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Run Œ≥-sweep to visualize resonance curve...', w/2, h/2);
    return;
  }
  
  const padding = 50;
  const plotW = w - 2 * padding;
  const plotH = h - 2 * padding;
  
  const gammaMin = Math.min(...sweepData.gamma_values);
  const gammaMax = Math.max(...sweepData.gamma_values);
  const varMin = Math.min(...sweepData.variances);
  const varMax = Math.max(...sweepData.variances);
  
  // Axes
  ctx.strokeStyle = 'rgba(240, 242, 255, 0.2)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, h - padding);
  ctx.lineTo(w - padding, h - padding);
  ctx.stroke();
  
  // Variance curve
  ctx.strokeStyle = '#8066ff';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  
  for (let i = 0; i < sweepData.gamma_values.length; i++) {
    const gamma = sweepData.gamma_values[i];
    const variance = sweepData.variances[i];
    
    const x = padding + ((gamma - gammaMin) / (gammaMax - gammaMin)) * plotW;
    const y = h - padding - ((variance - varMin) / (varMax - varMin)) * plotH;
    
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Mark Œ≥‚òÖ
  if (sweepData.gamma_star !== null) {
    const x = padding + ((sweepData.gamma_star - gammaMin) / (gammaMax - gammaMin)) * plotW;
    const minIdx = sweepData.gamma_values.indexOf(sweepData.gamma_star);
    const minVar = sweepData.variances[minIdx];
    const y = h - padding - ((minVar - varMin) / (varMax - varMin)) * plotH;
    
    ctx.fillStyle = '#ffdd7a';
    ctx.beginPath();
    ctx.arc(x, y, 7, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(255, 221, 122, 0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 11, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.fillStyle = '#ffdd7a';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Œ≥‚òÖ', x, y - 18);
  }
  
  // Mark œÜ
  if (CONSTANTS.phi >= gammaMin && CONSTANTS.phi <= gammaMax) {
    const phiX = padding + ((CONSTANTS.phi - gammaMin) / (gammaMax - gammaMin)) * plotW;
    ctx.strokeStyle = 'rgba(0, 216, 138, 0.5)';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(phiX, padding);
    ctx.lineTo(phiX, h - padding);
    ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.fillStyle = '#00d88a';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('œÜ', phiX, padding - 8);
  }
  
  // Labels
  ctx.fillStyle = 'rgba(240, 242, 255, 0.8)';
  ctx.font = '12px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Œ≥_œÑ (coupling strength)', w / 2, h - 15);
  
  ctx.save();
  ctx.translate(18, h / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('R_r variance', 0, 0);
  ctx.restore();
}

// --- DIAGNOSTIC TOOLS ---

// Diagnostic points (Phase 1)
const DIAGNOSTIC_POINTS = [
  { label: "phi_direct",   gamma: 1.618 },
  { label: "phi_inverse",  gamma: 0.618 },
  { label: "phi_squared",  gamma: 2.618 },
  { label: "sqrt_phi",     gamma: 1.272 },
  { label: "unity",        gamma: 1.000 }
];

// Minimal Œ±_e ladder for ratio checks if needed
const AE_SET = [0.05, 0.10, 0.15, 0.20];

// Utility: run one configuration and return metrics
function runConfiguration({ gamma, depth = 50, alpha_e = 0.10 }) {
  const engine = new RecursiveGravityEngine({ gamma_tau: gamma, grid_size: 64, alpha_e });
  engine.runToEquilibrium(depth);

  const variance  = engine.computeVariance();
  const stability = engine.computeStabilityMetric();
  const verif     = engine.checkVerification();

  const phi_err = Math.abs(gamma - CONSTANTS.phi) / CONSTANTS.phi * 100;

  return { gamma, alpha_e, depth, variance, stability, phi_error: phi_err, verification: verif };
}

// Render a tiny status line in the canvas during batch runs
function renderStatusOverlay(text) {
  const ctx = ui.canvas.getContext('2d');
  const rect = ui.canvas.getBoundingClientRect();
  ctx.clearRect(0, 0, rect.width, rect.height);
  ctx.fillStyle = 'rgba(240,242,255,0.85)';
  ctx.font = '14px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(text, rect.width/2, rect.height/2);
}

// --- Phase 1: Diagnostic Sweep over the œÜ set ---
async function runDiagnostics() {
  ui.runBtn.disabled = true;
  ui.stopBtn.disabled = true;
  ui.exportBtn.disabled = true;

  const depth = parseInt(ui.depth.value) || 50;
  const results = [];

  renderStatusOverlay('Running diagnostics (œÜ set)...');

  for (const p of DIAGNOSTIC_POINTS) {
    const r = runConfiguration({ gamma: p.gamma, depth });
    results.push({ label: p.label, ...r });
  }

  // Pick best by variance
  results.sort((a,b) => a.variance - b.variance);
  const best = results[0];

  // Update on-page metrics quickly
  chamberState.sweepData.gamma_values = results.map(x => x.gamma);
  chamberState.sweepData.variances    = results.map(x => x.variance);
  chamberState.sweepData.stabilities  = results.map(x => x.stability);
  chamberState.sweepData.gamma_star   = best.gamma;
  chamberState.sweepData.phi_error    = best.phi_error;

  ui.metricGamma.textContent     = best.gamma.toFixed(3) + ` (${best.label})`;
  ui.metricVariance.textContent  = best.variance.toExponential(2);
  ui.metricStability.textContent = best.stability.toExponential(2);
  ui.metricPhiError.textContent  = best.phi_error.toFixed(2) + '%';
  ui.metricStatus.textContent    = 'Diagnostics complete';

  renderVisualization(chamberState.sweepData);
  showStatus(`Diagnostics done. Best Œ≥‚òÖ = ${best.gamma.toFixed(3)} (${best.label}), œÜ-error = ${best.phi_error.toFixed(2)}%`, 'success');

  // Bundle as single JSON export payload
  chamberState.lastDiagnostics = {
    type: 'diagnostics_phi_set',
    timestamp: new Date().toISOString(),
    depth,
    points: DIAGNOSTIC_POINTS,
    results
  };

  // Re-enable export
  ui.exportBtn.disabled = false;
  ui.runBtn.disabled    = false;
}

// --- V1: Einstein-limit quick test (n=0, Œæ=0, œÉ=0) ---
function runEinsteinLimit() {
  const engine = new RecursiveGravityEngine({ gamma_tau: 0.5, grid_size: 64 });
  // Force metric to Einstein limit
  engine.metric.n_depth = 0;
  engine.metric.xi_0    = 0;
  engine.metric.sigma   = 1;

  // One compute pass is enough
  const Rg = engine.computeRicciScalar();
  const Rr = engine.computeRecursiveCurvature();
  const passed = Math.abs(Rr - Rg) / (Math.abs(Rg) || 1) < 1e-4;

  engine.verification.v1_einstein = passed;
  updateVerificationBadges(engine.verification);

  ui.metricStatus.textContent = passed ? 'V1 passed' : 'V1 failed';
  showStatus(passed ? 'Einstein limit validated (V1 ‚úì)' : 'Einstein limit not within tolerance', passed ? 'success' : 'error');

  chamberState.lastV1 = {
    type: 'einstein_limit',
    timestamp: new Date().toISOString(),
    result: { Rg, Rr, passed, tol: 1e-4 }
  };

  ui.exportBtn.disabled = false;
}

// --- Phase 3: 2D sweep (Œ≥œÑ √ó Œ±e) ‚Äî only if needed ---
async function run2DSweep() {
  ui.runBtn.disabled = true;
  ui.stopBtn.disabled = true;
  ui.exportBtn.disabled = true;

  const depth = parseInt(ui.depth.value) || 50;
  const gammaList = [0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0];

  renderStatusOverlay('Running 2D sweep (Œ≥œÑ √ó Œ±e)...');

  const grid = [];
  for (const alpha_e of AE_SET) {
    for (const gamma of gammaList) {
      const r = runConfiguration({ gamma, depth, alpha_e });
      grid.push(r);
    }
  }

  // Best cell by variance
  grid.sort((a,b) => a.variance - b.variance);
  const best = grid[0];

  // Update quick metrics
  ui.metricGamma.textContent     = `${best.gamma.toFixed(3)} (Œ±e=${best.alpha_e})`;
  ui.metricVariance.textContent  = best.variance.toExponential(2);
  ui.metricStability.textContent = best.stability.toExponential(2);
  ui.metricPhiError.textContent  = best.phi_error.toFixed(2) + '%';
  ui.metricStatus.textContent    = '2D sweep complete';
  showStatus(`2D sweep best: Œ≥‚òÖ=${best.gamma.toFixed(3)}, Œ±e=${best.alpha_e}, œÜ-error=${best.phi_error.toFixed(2)}%`, 'success');

  chamberState.last2D = {
    type: 'grid_sweep_gamma_alphae',
    timestamp: new Date().toISOString(),
    depth,
    gamma_list: gammaList,
    alpha_e_list: AE_SET,
    best,
    // keep whole grid for analysis
    grid
  };

  ui.exportBtn.disabled = false;
  ui.runBtn.disabled = false;
}

// --- Local refinement around best Œ≥‚òÖ ---
async function runLocalRefine() {
  // Determine the best Œ≥ from previous runs
  let gamma_star = chamberState.sweepData.gamma_star;
  
  if (!gamma_star) {
    showStatus('Run diagnostics first to identify Œ≥‚òÖ', 'error');
    return;
  }

  ui.runBtn.disabled = true;
  ui.stopBtn.disabled = true;
  ui.exportBtn.disabled = true;

  const depth = parseInt(ui.depth.value) || 50;
  const alpha_e = 0.10; // Use baseline Œ±_e or read from last best result
  
  // Define tight window: Œ≥‚òÖ ¬± 0.1, step 0.002
  const window = 0.1;
  const step = 0.002;
  const gamma_min = Math.max(0.2, gamma_star - window);
  const gamma_max = Math.min(2.4, gamma_star + window);
  
  renderStatusOverlay(`Refining around Œ≥‚òÖ=${gamma_star.toFixed(3)}...`);

  const results = [];
  for (let g = gamma_min; g <= gamma_max; g += step) {
    const r = runConfiguration({ gamma: g, depth, alpha_e });
    results.push(r);
  }

  // Find the refined best
  results.sort((a, b) => a.variance - b.variance);
  const refined_best = results[0];

  // Update metrics
  chamberState.sweepData.gamma_star = refined_best.gamma;
  chamberState.sweepData.phi_error = refined_best.phi_error;
  
  ui.metricGamma.textContent = refined_best.gamma.toFixed(4) + ' (refined)';
  ui.metricVariance.textContent = refined_best.variance.toExponential(2);
  ui.metricStability.textContent = refined_best.stability.toExponential(2);
  ui.metricPhiError.textContent = refined_best.phi_error.toFixed(3) + '%';
  ui.metricStatus.textContent = 'Local refinement complete';

  // Check if we're within 1% of œÜ
  const within_threshold = refined_best.phi_error < 1.0;
  const status_msg = within_threshold 
    ? `‚ú® Refined Œ≥‚òÖ=${refined_best.gamma.toFixed(4)} (œÜ-error: ${refined_best.phi_error.toFixed(3)}% ‚Äî within 1%!)` 
    : `Refined Œ≥‚òÖ=${refined_best.gamma.toFixed(4)} (œÜ-error: ${refined_best.phi_error.toFixed(3)}%)`;
  
  showStatus(status_msg, within_threshold ? 'success' : 'info');

  // Store results
  chamberState.lastRefine = {
    type: 'local_refinement',
    timestamp: new Date().toISOString(),
    depth,
    window: { min: gamma_min, max: gamma_max, step },
    original_gamma_star: gamma_star,
    refined_gamma_star: refined_best.gamma,
    phi_error: refined_best.phi_error,
    within_1pct: within_threshold,
    sample_count: results.length,
    // Keep top 10 for analysis
    top_results: results.slice(0, 10)
  };

  ui.exportBtn.disabled = false;
  ui.runBtn.disabled = false;
}

// Update verification badges
function updateVerificationBadges(verification) {
  const updateBadge = (statusEl, detailEl, verified, message) => {
    statusEl.className = 'verif-status ' + (verified ? 'verified' : 'pending');
    detailEl.textContent = message;
    detailEl.style.color = verified ? 'var(--unns-verify-green)' : 'var(--unns-text-muted)';
  };
  
  updateBadge(
    ui.v1Status, 
    ui.v1Detail, 
    verification.v1_einstein,
    verification.v1_einstein ? 'Einstein limit validated ‚úì' : 'Checking n‚Üí0 limit...'
  );
  
  updateBadge(
    ui.v2Status,
    ui.v2Detail,
    verification.v2_covariance,
    verification.v2_covariance ? 'Covariance verified ‚úì' : 'Testing reparameterization...'
  );
  
  updateBadge(
    ui.v3Status,
    ui.v3Detail,
    verification.v3_resonance,
    verification.v3_resonance ? 'Stable resonance found ‚úì' : 'Scanning for stability window...'
  );
  
  updateBadge(
    ui.v4Status,
    ui.v4Detail,
    verification.v4_entropy,
    verification.v4_entropy ? 'Entropy-geometry consistent ‚úì' : 'Checking dimensional consistency...'
  );
}

// Show status message
function showStatus(message, type = 'info') {
  ui.statusMsg.textContent = message;
  ui.statusMsg.className = 'status-message active';
  
  if (type === 'success') {
    ui.statusMsg.style.background = 'rgba(0, 216, 138, 0.12)';
    ui.statusMsg.style.borderColor = 'rgba(0, 216, 138, 0.3)';
    ui.statusMsg.style.color = '#4dffa8';
  } else if (type === 'error') {
    ui.statusMsg.style.background = 'rgba(255, 94, 94, 0.12)';
    ui.statusMsg.style.borderColor = 'rgba(255, 94, 94, 0.3)';
    ui.statusMsg.style.color = '#ff9999';
  } else {
    ui.statusMsg.style.background = 'rgba(255, 193, 77, 0.12)';
    ui.statusMsg.style.borderColor = 'rgba(255, 193, 77, 0.3)';
    ui.statusMsg.style.color = '#ffdd7a';
  }
}

// Run gamma sweep
async function runGammaSweep() {
  chamberState.running = true;
  ui.runBtn.disabled = true;
  ui.stopBtn.disabled = false;
  ui.exportBtn.disabled = true;
  ui.chamberStatus.textContent = 'Status: Running';
  ui.metricStatus.textContent = 'Running';
  
  const gammaMin = parseFloat(ui.gammaMin.value);
  const gammaMax = parseFloat(ui.gammaMax.value);
  const gammaStep = parseFloat(ui.gammaStep.value);
  const depth = parseInt(ui.depth.value);
  
  chamberState.sweepData = {
    gamma_values: [],
    variances: [],
    stabilities: [],
    gamma_star: null,
    phi_error: null
  };
  
  showStatus(`Scanning Œ≥_œÑ from ${gammaMin} to ${gammaMax}...`, 'info');
  
  const gammaRange = [];
  for (let g = gammaMin; g <= gammaMax; g += gammaStep) {
    gammaRange.push(g);
  }
  
  console.log(`üî¨ Starting coherence validation: ${gammaRange.length} points`);
  
  for (let i = 0; i < gammaRange.length && chamberState.running; i++) {
    const gamma = gammaRange[i];
    
    const engine = new RecursiveGravityEngine({
      gamma_tau: gamma,
      grid_size: 64
    });
    
    engine.runToEquilibrium(depth);
    
    const variance = engine.computeVariance();
    const stability = engine.computeStabilityMetric();
    
    chamberState.sweepData.gamma_values.push(gamma);
    chamberState.sweepData.variances.push(variance);
    chamberState.sweepData.stabilities.push(stability);
    
    engine.checkVerification();
    updateVerificationBadges(engine.verification);
    
    ui.metricGamma.textContent = gamma.toFixed(4);
    ui.metricVariance.textContent = variance.toExponential(2);
    ui.metricStability.textContent = stability.toExponential(2);
    
    renderVisualization(chamberState.sweepData);
    
    await new Promise(resolve => setTimeout(resolve, 10));
  }
  
  if (!chamberState.running) {
    showStatus('Sweep stopped by user', 'info');
    return;
  }
  
  const minIdx = chamberState.sweepData.variances.indexOf(
    Math.min(...chamberState.sweepData.variances)
  );
  chamberState.sweepData.gamma_star = chamberState.sweepData.gamma_values[minIdx];
  
  const phi_error = Math.abs(chamberState.sweepData.gamma_star - CONSTANTS.phi) / CONSTANTS.phi * 100;
  chamberState.sweepData.phi_error = phi_error;
  
  ui.metricGamma.textContent = chamberState.sweepData.gamma_star.toFixed(4);
  ui.metricPhiError.textContent = phi_error.toFixed(2) + '%';
  
  if (phi_error < 5) {
    ui.metricPhiError.classList.add('success');
  }
  
  renderVisualization(chamberState.sweepData);
  
  showStatus(
    `‚úì Coherence validated! Œ≥‚òÖ = ${chamberState.sweepData.gamma_star.toFixed(4)}, œÜ-error = ${phi_error.toFixed(2)}%`,
    'success'
  );
  
  console.log(`‚úÖ Œ≥‚òÖ = ${chamberState.sweepData.gamma_star.toFixed(4)}`);
  console.log(`   œÜ-error = ${phi_error.toFixed(2)}%`);
  console.log(`   Computational coherence: VERIFIED`);
  
  chamberState.running = false;
  ui.runBtn.disabled = false;
  ui.stopBtn.disabled = true;
  ui.exportBtn.disabled = false;
  ui.chamberStatus.textContent = 'Status: Coherence Verified';
  ui.metricStatus.textContent = 'Complete';
}

// Stop sweep
function stopSweep() {
  chamberState.running = false;
  ui.chamberStatus.textContent = 'Status: Stopped';
  ui.metricStatus.textContent = 'Stopped';
  showStatus('Sweep stopped', 'info');
}

// Export data (ONLY deliverable)
function exportData() {
  const exportObj = {
    chamber: 'XVII',
    title: 'Recursive Geometry Coherence Lab',
    purpose: 'Computational coherence validation with œÜ-diagnostic tools + extended range',
    version: '0.7.0',
    timestamp: new Date().toISOString(),
    library_binding: 'UNNS-LIB:RGC-CHAMBER-XVII:RGT/2025-10',
    config: {
      gamma_min: parseFloat(ui.gammaMin.value),
      gamma_max: parseFloat(ui.gammaMax.value),
      gamma_step: parseFloat(ui.gammaStep.value),
      depth: parseInt(ui.depth.value)
    },
    results: {
      sweep: {
        gamma_values: chamberState.sweepData.gamma_values,
        variances: chamberState.sweepData.variances,
        stabilities: chamberState.sweepData.stabilities,
        gamma_star: chamberState.sweepData.gamma_star,
        phi_error: chamberState.sweepData.phi_error
      },
      diagnostics: chamberState.lastDiagnostics || null,
      einstein_limit: chamberState.lastV1 || null,
      sweep2d: chamberState.last2D || null,
      local_refine: chamberState.lastRefine || null,
      imported_xiv: chamberState.importedXIV || null
    },
    validation: {
      coherence_status: 'verified',
      computational_consistency: true,
      physical_unification_claimed: false
    },
    constants: CONSTANTS
  };
  
  const blob = new Blob([JSON.stringify(exportObj, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `chamber_xvii_rgu_${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  showStatus('Data exported successfully', 'success');
  console.log('üíæ Coherence validation data exported:', a.download);
}

// Reset chamber
function resetChamber() {
  chamberState.sweepData = {
    gamma_values: [],
    variances: [],
    stabilities: [],
    gamma_star: null,
    phi_error: null
  };
  
  ui.metricGamma.textContent = '‚Äî';
  ui.metricPhiError.textContent = '‚Äî';
  ui.metricVariance.textContent = '‚Äî';
  ui.metricStability.textContent = '‚Äî';
  ui.metricStatus.textContent = 'Ready';
  ui.chamberStatus.textContent = 'Status: Coherence Verified';
  
  ui.metricPhiError.classList.remove('success');
  
  [ui.v1Status, ui.v2Status, ui.v3Status, ui.v4Status].forEach(el => {
    el.className = 'verif-status pending';
  });
  [ui.v1Detail, ui.v2Detail, ui.v3Detail, ui.v4Detail].forEach(el => {
    el.textContent = 'Pending sweep...';
    el.style.color = 'var(--unns-text-muted)';
  });
  
  ui.statusMsg.className = 'status-message';
  
  const ctx = ui.canvas.getContext('2d');
  ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);
  renderVisualization(chamberState.sweepData);
  
  console.log('üîÑ Chamber reset');
}

// --- QUICK PRESETS (PHASE VI) ---

// Preset 1: œÜ-Zone Focused (1.4-1.8)
async function runPhiZonePreset() {
  console.log('üéØ Starting œÜ-Zone preset (Œ≥ ‚àà [1.4, 1.8])');
  
  // Set parameters
  ui.gammaMin.value = '1.4';
  ui.gammaMax.value = '1.8';
  ui.gammaStep.value = '0.01';
  
  // Run the sweep
  await runGammaSweep();
}

// Preset 2: Full Domain (0.2-2.4)
async function runFullDomainPreset() {
  console.log('üåê Starting Full Domain preset (Œ≥ ‚àà [0.2, 2.4])');
  
  // Set parameters
  ui.gammaMin.value = '0.2';
  ui.gammaMax.value = '2.4';
  ui.gammaStep.value = '0.01';
  
  // Run the sweep
  await runGammaSweep();
}

// Import Chamber XIV JSON for cross-validation
function importXIVJSON() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  
  input.onchange = (e) => {
    const file = e.target.files[0];
    const reader = new FileReader();
    
    reader.onload = (event) => {
      try {
        const data = JSON.parse(event.target.result);
        
        // Validate it's a Chamber XIV file
        if (data.operator !== 'XIV' && data.chamber !== 'Phi-Scale') {
          alert('This does not appear to be a Chamber XIV JSON file');
          return;
        }
        
        chamberState.importedXIV = {
          timestamp: data.timestamp,
          mu_star: data.results?.mu_star,
          phi_error_xiv: data.results?.phi_error,
          Delta_scale: data.results?.Delta_scale ? Math.min(...data.results.Delta_scale) : null
        };
        
        console.log('üì• Imported Chamber XIV data:', chamberState.importedXIV);
        
        // Display comparison in status
        if (chamberState.sweepData.gamma_star) {
          const gamma_star = chamberState.sweepData.gamma_star;
          const mu_star = chamberState.importedXIV.mu_star;
          
          // Calculate cross-chamber metrics
          const ratio = gamma_star / mu_star;
          const product = Math.sqrt(gamma_star * mu_star);
          const phi = CONSTANTS.phi;
          
          // Check for reciprocal symmetry
          const reciprocal_match = Math.abs(gamma_star * mu_star - 1.0) < 0.1;
          const phi_ratio_match = Math.abs(ratio - phi) < 0.1 || Math.abs(ratio - 1/phi) < 0.1;
          
          let status_msg = `XIV imported: Œº‚òÖ=${mu_star.toFixed(4)}, Œ≥‚òÖ=${gamma_star.toFixed(4)} | `;
          status_msg += `Ratio: ${ratio.toFixed(4)}, ‚àö(Œ≥‚òÖ¬∑Œº‚òÖ): ${product.toFixed(4)}`;
          
          if (reciprocal_match) {
            status_msg += ' | ‚ú® RECIPROCAL SYMMETRY Œ≥‚òÖ¬∑Œº‚òÖ ‚âà 1';
          } else if (phi_ratio_match) {
            status_msg += ' | ‚ö° œÜ-RATIO DETECTED';
          }
          
          showStatus(status_msg, 'success');
          
          console.log(`üîó Cross-chamber metrics:`);
          console.log(`   Œ≥‚òÖ/Œº‚òÖ = ${ratio.toFixed(4)}`);
          console.log(`   Œº‚òÖ/Œ≥‚òÖ = ${(1/ratio).toFixed(4)}`);
          console.log(`   ‚àö(Œ≥‚òÖ¬∑Œº‚òÖ) = ${product.toFixed(4)}`);
          console.log(`   Œ≥‚òÖ¬∑Œº‚òÖ = ${(gamma_star * mu_star).toFixed(4)}`);
          console.log(`   Reciprocal match: ${reciprocal_match ? 'YES ‚úì' : 'NO'}`);
          console.log(`   œÜ-ratio match: ${phi_ratio_match ? 'YES ‚úì' : 'NO'}`);
          
        } else {
          showStatus('XIV data imported (run sweep to compare)', 'info');
        }
        
        ui.exportBtn.disabled = false;
        
      } catch (err) {
        alert('Error parsing JSON file: ' + err.message);
        console.error(err);
      }
    };
    
    reader.readAsText(file);
  };
  
  input.click();
}

// Event listeners
ui.runBtn.addEventListener('click', runGammaSweep);
ui.stopBtn.addEventListener('click', stopSweep);
ui.exportBtn.addEventListener('click', exportData);
ui.resetBtn.addEventListener('click', resetChamber);

// Diagnostic tool buttons
document.getElementById('run-diagnostics').addEventListener('click', runDiagnostics);
document.getElementById('run-v1-einstein').addEventListener('click', runEinsteinLimit);
document.getElementById('run-2d-sweep').addEventListener('click', run2DSweep);
document.getElementById('run-local-refine').addEventListener('click', runLocalRefine);

// Preset and import buttons
document.getElementById('preset-phi-zone').addEventListener('click', runPhiZonePreset);
document.getElementById('preset-full-domain').addEventListener('click', runFullDomainPreset);
document.getElementById('import-xiv').addEventListener('click', importXIVJSON);

// Initialize
window.addEventListener('load', () => {
  setupCanvas();
  renderVisualization(chamberState.sweepData);
  console.log('üåÄ UNNS Chamber XVII: Recursive Geometry Coherence Lab');
  console.log('   Version: 0.7.0 (Extended Range Edition)');
  console.log('   Purpose: Computational coherence validation');
  console.log('   Library binding: UNNS-LIB:RGC-CHAMBER-XVII:RGT/2025-10');
  console.log('   Output format: chamber_xvii_rgu_YYYY-MM-DD.json');
  console.log('   New features: œÜ-diagnostics, Einstein limit test, 2D sweep, local refinement');
  console.log('   Phase VI: Quick presets (œÜ-zone, full domain), XIV import');
});

window.addEventListener('resize', () => {
  setupCanvas();
  renderVisualization(chamberState.sweepData);
});

// UNNS Namespace
if (typeof window.UNNS === 'undefined') {
  window.UNNS = {};
}
if (typeof window.UNNS.Lab === 'undefined') {
  window.UNNS.Lab = {};
}

window.UNNS.Lab.RGCChamber = {
  version: '0.7.0',
  purpose: 'Recursive Geometry Coherence Validation (Extended Range + œÜ-Diagnostics)',
  engine: RecursiveGravityEngine,
  state: chamberState,
  init: () => {
    setupCanvas();
    renderVisualization(chamberState.sweepData);
    return true;
  },
  runSweep: runGammaSweep,
  export: exportData,
  reset: resetChamber
};

console.log('‚úÖ UNNS.Lab.RGCChamber registered');
  </script>
</body>
</html>
