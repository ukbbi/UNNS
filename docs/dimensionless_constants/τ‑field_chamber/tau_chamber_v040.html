<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Lab v0.4.0 – τ-Field Quantization Chamber</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      color: #e0e6ed;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      border: 1px solid rgba(100, 200, 255, 0.2);
    }

    header h1 {
      font-size: 2rem;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #64b5f6, #42a5f5, #1e88e5);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    header p {
      color: #90a4ae;
      font-size: 0.9rem;
    }

    .version-badge {
      display: inline-block;
      background: linear-gradient(135deg, #1e88e5, #1565c0);
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.75rem;
      margin-top: 8px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .phase-badge {
      display: inline-block;
      background: linear-gradient(135deg, #ff6b6b, #ee5a52);
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.75rem;
      margin-top: 8px;
      margin-left: 8px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (max-width: 1200px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .control-panel {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid rgba(100, 200, 255, 0.2);
      height: fit-content;
    }

    .control-section {
      margin-bottom: 24px;
    }

    .control-section h3 {
      font-size: 0.9rem;
      color: #64b5f6;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(100, 200, 255, 0.2);
    }

    .control-group {
      margin-bottom: 16px;
    }

    .control-group label {
      display: block;
      font-size: 0.85rem;
      color: #b0bec5;
      margin-bottom: 6px;
    }

    .control-group input[type="range"],
    .control-group input[type="number"],
    .control-group select {
      width: 100%;
      padding: 8px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 6px;
      color: #e0e6ed;
      font-size: 0.9rem;
    }

    .control-group input[type="range"] {
      padding: 0;
      height: 6px;
      cursor: pointer;
    }

    .value-display {
      display: inline-block;
      float: right;
      color: #64b5f6;
      font-weight: 600;
    }

    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 20px;
    }

    button {
      padding: 12px;
      background: linear-gradient(135deg, #1e88e5, #1565c0);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:hover:not(:disabled) {
      background: linear-gradient(135deg, #42a5f5, #1e88e5);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(66, 165, 245, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: rgba(100, 100, 100, 0.3);
      cursor: not-allowed;
      transform: none;
      opacity: 0.5;
    }

    .btn-export {
      background: linear-gradient(135deg, #7e57c2, #5e35b1);
    }

    .btn-export:hover:not(:disabled) {
      background: linear-gradient(135deg, #9575cd, #7e57c2);
    }

    .btn-docs {
      background: linear-gradient(135deg, #26a69a, #00897b);
    }

    .btn-docs:hover:not(:disabled) {
      background: linear-gradient(135deg, #4db6ac, #26a69a);
    }

    .btn-automation {
      background: linear-gradient(135deg, #ff6b6b, #ee5a52);
      grid-column: 1 / -1;
    }

    .btn-automation:hover:not(:disabled) {
      background: linear-gradient(135deg, #ff8787, #ff6b6b);
    }

    .btn-cancel {
      background: linear-gradient(135deg, #607d8b, #546e7a);
      grid-column: 1 / -1;
    }

    .btn-cancel:hover:not(:disabled) {
      background: linear-gradient(135deg, #78909c, #607d8b);
    }

    .viz-container {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid rgba(100, 200, 255, 0.2);
    }

    .canvas-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (max-width: 900px) {
      .canvas-grid {
        grid-template-columns: 1fr;
      }
    }

    .canvas-wrapper {
      position: relative;
    }

    .canvas-label {
      font-size: 0.85rem;
      color: #64b5f6;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .canvas-info {
      font-size: 0.7rem;
      color: #78909c;
      text-transform: none;
      font-weight: normal;
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      border: 1px solid rgba(100, 200, 255, 0.3);
      background: rgba(0, 0, 0, 0.4);
    }

    .metrics-panel {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid rgba(100, 200, 255, 0.2);
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }

    .metric-box {
      background: rgba(0, 0, 0, 0.3);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid rgba(100, 200, 255, 0.2);
    }

    .metric-label {
      font-size: 0.75rem;
      color: #90a4ae;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }

    .metric-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: #64b5f6;
      font-family: 'Courier New', monospace;
    }

    .metric-unit {
      font-size: 0.9rem;
      color: #78909c;
      margin-left: 4px;
    }

    .status-bar {
      background: rgba(255, 255, 255, 0.05);
      padding: 12px 20px;
      border-radius: 8px;
      border: 1px solid rgba(100, 200, 255, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 20px;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #4caf50;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .status-dot.computing {
      background: #ff9800;
    }

    .status-text {
      font-size: 0.85rem;
      color: #b0bec5;
    }

    .mode-pills {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .mode-pill {
      flex: 1;
      padding: 8px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 6px;
      text-align: center;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    .mode-pill.active {
      background: linear-gradient(135deg, #1e88e5, #1565c0);
      border-color: #42a5f5;
    }

    .mode-pill:hover {
      border-color: #64b5f6;
    }

    .reference-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 12px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      font-size: 0.8rem;
    }

    .reference-toggle input[type="checkbox"] {
      width: auto;
      cursor: pointer;
    }

    .reference-toggle label {
      color: #b0bec5;
      cursor: pointer;
      margin: 0;
    }

    /* Documentation Modal */
    .docs-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 1000;
      overflow-y: auto;
      padding: 20px;
    }

    .docs-modal.active {
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    .docs-content {
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      border: 2px solid rgba(100, 200, 255, 0.3);
      border-radius: 12px;
      max-width: 1000px;
      width: 100%;
      margin: 40px auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      position: relative;
    }

    .docs-header {
      padding: 20px 30px;
      border-bottom: 1px solid rgba(100, 200, 255, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .docs-header h2 {
      color: #64b5f6;
      font-size: 1.5rem;
    }

    .docs-close {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #e0e6ed;
      font-size: 1.5rem;
      width: 40px;
      height: 40px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      padding: 0;
      text-transform: none;
      letter-spacing: normal;
    }

    .docs-close:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: none;
    }

    .docs-tabs {
      display: flex;
      gap: 0;
      padding: 0 30px;
      background: rgba(0, 0, 0, 0.2);
    }

    .docs-tab {
      padding: 15px 25px;
      background: transparent;
      border: none;
      color: #90a4ae;
      cursor: pointer;
      transition: all 0.3s;
      border-bottom: 3px solid transparent;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 0.85rem;
    }

    .docs-tab.active {
      color: #64b5f6;
      border-bottom-color: #42a5f5;
    }

    .docs-tab:hover:not(.active) {
      color: #b0bec5;
      transform: none;
    }

    .docs-body {
      padding: 30px;
      max-height: 70vh;
      overflow-y: auto;
      line-height: 1.7;
    }

    .docs-section {
      display: none;
    }

    .docs-section.active {
      display: block;
    }

    .docs-body h1 {
      color: #64b5f6;
      font-size: 2rem;
      margin-bottom: 10px;
      border-bottom: 2px solid rgba(100, 200, 255, 0.3);
      padding-bottom: 10px;
    }

    .docs-body h2 {
      color: #42a5f5;
      font-size: 1.5rem;
      margin-top: 30px;
      margin-bottom: 15px;
    }

    .docs-body h3 {
      color: #64b5f6;
      font-size: 1.2rem;
      margin-top: 20px;
      margin-bottom: 10px;
    }

    .docs-body h4 {
      color: #90a4ae;
      font-size: 1rem;
      margin-top: 15px;
      margin-bottom: 8px;
    }

    .docs-body p {
      margin-bottom: 15px;
      color: #b0bec5;
    }

    .docs-body ul, .docs-body ol {
      margin-left: 20px;
      margin-bottom: 15px;
      color: #b0bec5;
    }

    .docs-body li {
      margin-bottom: 8px;
    }

    .docs-body code {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      color: #64b5f6;
      font-size: 0.9em;
    }

    .docs-body pre {
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      margin-bottom: 15px;
      border: 1px solid rgba(100, 200, 255, 0.2);
    }

    .docs-body pre code {
      background: none;
      padding: 0;
      color: #e0e6ed;
    }

    .docs-body strong {
      color: #64b5f6;
      font-weight: 600;
    }

    .docs-body em {
      color: #90a4ae;
      font-style: italic;
    }

    .docs-body table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
    }

    .docs-body th, .docs-body td {
      padding: 12px;
      text-align: left;
      border: 1px solid rgba(100, 200, 255, 0.2);
    }

    .docs-body th {
      background: rgba(100, 200, 255, 0.1);
      color: #64b5f6;
      font-weight: 600;
    }

    .docs-body td {
      color: #b0bec5;
    }

    .docs-body blockquote {
      border-left: 4px solid #42a5f5;
      padding-left: 20px;
      margin: 20px 0;
      color: #90a4ae;
      font-style: italic;
    }

    .docs-body hr {
      border: none;
      border-top: 1px solid rgba(100, 200, 255, 0.2);
      margin: 30px 0;
    }

    .badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.85em;
      font-weight: 600;
      margin-right: 8px;
    }

    .badge-success {
      background: #4caf50;
      color: white;
    }

    .badge-info {
      background: #42a5f5;
      color: white;
    }

    .badge-warning {
      background: #ff9800;
      color: white;
    }

    .badge-phase4 {
      background: #ff6b6b;
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>τ-Field Quantization Chamber</h1>
      <p>UNNS Lab – Interactive Testing Environment</p>
      <span class="version-badge">v0.4.0 DEFINITIVE RELEASE</span>
      <span class="phase-badge">+ PHASE IV AUTOMATION</span>
    </header>

    <div class="main-grid">
      <div class="control-panel">
        <div class="control-section">
          <h3>Experiment Mode</h3>
          <div class="mode-pills">
            <div class="mode-pill active" data-mode="quantized" role="button" tabindex="0" aria-label="Quantized mode">Quantized</div>
            <div class="mode-pill" data-mode="noisy" role="button" tabindex="0" aria-label="Noisy mode">Noisy</div>
          </div>
        </div>

        <div class="control-section">
          <h3>τ-Field Parameters</h3>
          
          <div class="control-group">
            <label for="q-slider">Quantization Index (q) <span class="value-display" id="q-display">0</span></label>
            <input type="range" id="q-slider" min="0" max="136" value="0" step="1" 
                   aria-label="Quantization index q" aria-valuemin="0" aria-valuemax="136" aria-valuenow="0">
          </div>

          <div class="control-group">
            <label for="Q0-input">Fundamental Scale (Q₀) <span class="value-display" id="Q0-display">137</span></label>
            <input type="number" id="Q0-input" min="2" max="1000" value="137" step="1"
                   aria-label="Fundamental scale Q0">
          </div>

          <div class="control-group">
            <label for="sigma-slider">Noise Amplitude (σ) <span class="value-display" id="sigma-display">0.00</span></label>
            <input type="range" id="sigma-slider" min="0" max="0.5" value="0" step="0.01"
                   aria-label="Noise amplitude sigma" aria-valuemin="0" aria-valuemax="0.5" aria-valuenow="0">
          </div>
        </div>

        <div class="control-section">
          <h3>Evolution Parameters</h3>
          
          <div class="control-group">
            <label for="depth-slider">Recursion Depth (n) <span class="value-display" id="depth-display">50</span></label>
            <input type="range" id="depth-slider" min="10" max="200" value="50" step="10"
                   aria-label="Recursion depth" aria-valuemin="10" aria-valuemax="200" aria-valuenow="50">
          </div>

          <div class="control-group">
            <label for="grid-select">Grid Resolution <span class="value-display" id="grid-display">64×64</span></label>
            <select id="grid-select" aria-label="Grid resolution">
              <option value="32">32×32 (Fast)</option>
              <option value="64" selected>64×64 (Standard)</option>
              <option value="128">128×128 (High-Res)</option>
            </select>
          </div>

          <div class="control-group">
            <label for="seed-input">Random Seed <span class="value-display" id="seed-display">42</span></label>
            <input type="number" id="seed-input" min="0" max="999999" value="42" step="1"
                   aria-label="Random seed for reproducibility">
          </div>
        </div>

        <div class="control-section">
          <h3>Visualization Options</h3>
          <div class="reference-toggle" role="switch" aria-checked="false">
            <input type="checkbox" id="show-alpha-reference" aria-label="Show alpha reference line">
            <label for="show-alpha-reference">Show α = 1/137 reference</label>
          </div>
        </div>

        <div class="control-section">
          <h3>Actions</h3>
          <div class="button-group">
            <button type="button" id="btn-run" aria-label="Run single experiment">▶ Run Single</button>
            <button type="button" id="btn-sweep" aria-label="Run E8 parameter sweep">🔄 Sweep (E8)</button>
            <button type="button" id="btn-noise" aria-label="Run E9 noise stability test">📊 Noise (E9)</button>
            <button type="button" id="btn-reset" aria-label="Reset all parameters to defaults">↺ Reset</button>
          </div>
          <div class="button-group" style="margin-top: 10px;">
            <button type="button" id="btn-export-json" class="btn-export" aria-label="Export data as JSON">💾 JSON</button>
            <button type="button" id="btn-export-csv" class="btn-export" aria-label="Export data as CSV">📄 CSV</button>
          </div>
          <div class="button-group" style="margin-top: 10px;">
            <button type="button" id="btn-docs" class="btn-docs" aria-label="Open documentation" style="grid-column: 1 / -1;">📚 Documentation</button>
          </div>
          
          <div class="button-group" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(100, 200, 255, 0.2);">
            <button type="button" id="btn-auto-all" class="btn-automation" aria-label="Run all protocols E8 through E11 automatically">🚀 Run All Protocols (E8–E11)</button>
            <button type="button" id="btn-auto-cancel" class="btn-cancel" aria-label="Cancel batch automation" disabled>⏹ Cancel Batch</button>
          </div>
        </div>
      </div>

      <div class="viz-container">
        <div class="canvas-grid">
          <div class="canvas-wrapper">
            <div class="canvas-label">
              <span>κ Curvature Field</span>
              <span class="canvas-info">Bilinear interpolation</span>
            </div>
            <canvas id="canvas-kappa" width="512" height="512" aria-label="Curvature field heatmap"></canvas>
          </div>

          <div class="canvas-wrapper">
            <div class="canvas-label">
              <span>H<sub>r</sub> vs τ Phase Evolution</span>
              <span class="canvas-info">H<sub>r</sub> in bits (log₂)</span>
            </div>
            <canvas id="canvas-entropy" width="512" height="512" aria-label="Harmonic entropy evolution plot"></canvas>
          </div>
        </div>

        <div class="metrics-panel">
          <div class="metrics-grid">
            <div class="metric-box">
              <div class="metric-label">τ Phase (arg τ)</div>
              <div class="metric-value" id="metric-tau-phase">0.0000</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Mean Curvature ⟨κ⟩</div>
              <div class="metric-value" id="metric-kappa">0.0000</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Harmonic Entropy H<sub>r</sub></div>
              <div class="metric-value" id="metric-hr">0.0000<span class="metric-unit">bits</span></div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Coupling β(τ)</div>
              <div class="metric-value" id="metric-beta">0.0000</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Collapse Detected</div>
              <div class="metric-value" id="metric-collapse">No</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Execution Time</div>
              <div class="metric-value" id="metric-time">—<span class="metric-unit">ms</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="status-bar">
      <div class="status-indicator">
        <div class="status-dot" id="status-dot"></div>
        <span class="status-text" id="status-text">Initializing τ-Field Engine...</span>
      </div>
    </div>
  </div>

  <div class="docs-modal" id="docs-modal">
    <div class="docs-content">
      <div class="docs-header">
        <h2>📚 Complete Documentation</h2>
        <button type="button" class="docs-close" id="docs-close" aria-label="Close documentation">×</button>
      </div>
      
      <div class="docs-tabs">
        <button type="button" class="docs-tab active" data-tab="quick-ref">Quick Reference</button>
        <button type="button" class="docs-tab" data-tab="release-notes">Release Notes</button>
        <button type="button" class="docs-tab" data-tab="phase-iv">Phase IV Automation</button>
      </div>
      
      <div class="docs-body">
        <div class="docs-section active" id="section-quick-ref">
          <h1>v0.4.0 Quick Reference</h1>
          
          <h2>🎯 5 Enhancements at a Glance</h2>
          
          <h3>1️⃣ Entropy Now in BITS (not nats)</h3>
          <p><strong>What changed:</strong></p>
          <ul>
            <li>H<sub>r</sub> metric now uses log₂ instead of natural log</li>
            <li>Range: 0-6 bits (was 0-4.16 nats)</li>
          </ul>
          
          <h3>2️⃣ Smooth κ Heatmap (bilinear interpolation)</h3>
          <p><strong>What changed:</strong></p>
          <ul>
            <li>Left canvas (κ curvature) now uses smooth interpolation</li>
            <li>No more blocky pixels at high resolution</li>
          </ul>
          
          <h3>3️⃣ α = 1/137 Reference Line</h3>
          <p><strong>What changed:</strong></p>
          <ul>
            <li><span class="badge badge-info">NEW</span> Checkbox: "Show α = 1/137 reference"</li>
            <li>Adds red dashed line on E8 sweep plots</li>
          </ul>
          
          <h3>4️⃣ Accessibility (screen readers & keyboard)</h3>
          <p><strong>What changed:</strong></p>
          <ul>
            <li>All controls now have ARIA labels</li>
            <li>Full keyboard navigation support</li>
          </ul>
          
          <h3>5️⃣ Settings Persistence (auto-save)</h3>
          <p><strong>What changed:</strong></p>
          <ul>
            <li>All parameters now save automatically</li>
            <li>Restored when you reload page</li>
          </ul>
        </div>
        
        <div class="docs-section" id="section-release-notes">
          <h1>UNNS Lab v0.4.0 – Release Notes</h1>
          <p><strong>Release Date:</strong> October 20, 2025<br>
          <strong>Status:</strong> <span class="badge badge-success">Production-Ready</span></p>
          
          <h2>🎯 Release Summary</h2>
          <p>Version 0.4.0 represents the definitive implementation of the τ-Field Quantization Chamber with all enhancements integrated.</p>
          
          <h2>🏆 Achievements</h2>
          <ul>
            <li><span class="badge badge-success">✓</span> Phase I: Theoretical Foundation</li>
            <li><span class="badge badge-success">✓</span> Phase II: Core Implementation + Tests</li>
            <li><span class="badge badge-success">✓</span> Phase III: Interactive Chamber UI</li>
            <li><span class="badge badge-success">✓</span> v0.4.0: 5 Critical Enhancements</li>
            <li><span class="badge badge-phase4">NEW</span> Phase IV: E8-E11 Automation</li>
          </ul>
        </div>
        
        <div class="docs-section" id="section-phase-iv">
          <h1>Phase IV – E8-E11 Automation</h1>
          <p><span class="badge badge-phase4">NEW</span> <strong>Automated batch processing for all experimental protocols</strong></p>
          
          <h2>🚀 What is Phase IV?</h2>
          <p>Phase IV adds <strong>one-click automation</strong> that runs all four experimental protocols (E8-E11) sequentially and exports combined results as publication-ready datasets.</p>
          
          <h3>Protocols Automated:</h3>
          <ul>
            <li><strong>E8:</strong> Quantized τ-phase sweep (q = 0 to Q₀-1)</li>
            <li><strong>E9:</strong> Noise stability test (σ = 0 to 0.5)</li>
            <li><strong>E10:</strong> α = 1/137 alignment verification</li>
            <li><strong>E11:</strong> Harmonic collapse detection</li>
          </ul>
          
          <h2>📊 How to Use</h2>
          
          <h3>Step 1: Configure Parameters</h3>
          <p>Set your desired parameters in the control panel:</p>
          <ul>
            <li><strong>Q₀:</strong> Fundamental scale (default: 137)</li>
            <li><strong>Grid Resolution:</strong> 32×32, 64×64, or 128×128</li>
            <li><strong>Recursion Depth:</strong> Number of evolution steps</li>
            <li><strong>Random Seed:</strong> For reproducibility</li>
          </ul>
          
          <h3>Step 2: Run Automation</h3>
          <ol>
            <li>Click <strong>"🚀 Run All Protocols (E8–E11)"</strong> button</li>
            <li>Watch status bar for progress updates</li>
            <li>Wait for all four protocols to complete</li>
            <li>Files automatically download when finished</li>
          </ol>
          
          <h3>Step 3: Cancel if Needed</h3>
          <p>Click <strong>"⏹ Cancel Batch"</strong> to stop automation early.</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========================================================================
    // τ-FIELD ENGINE (QA PATCHED - v0.4.0)
    // ========================================================================
    
    class SeededRNG {
      constructor(seed = 42) {
        this.state = [seed, seed ^ 0x49616E42, seed ^ 0x744F744F, seed ^ 0x20736929];
      }
      next() {
        const s0 = this.state[0];
        let s1 = this.state[1];
        const result = (s0 + s1) >>> 0;
        s1 ^= s0;
        this.state[0] = ((s0 << 23) | (s0 >>> 9)) ^ s1 ^ (s1 << 14);
        this.state[1] = (s1 << 18) | (s1 >>> 14);
        return result / 0x100000000;
      }
      normal(mean = 0, std = 1) {
        let u1 = this.next();
        let u2 = this.next();
        u1 = Math.max(u1, 1e-12);
        u2 = Math.max(u2, 1e-12);
        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        return mean + std * z;
      }
    }

    class Complex {
      constructor(real, imag) {
        this.real = real;
        this.imag = imag;
      }
      get magnitude() {
        return Math.sqrt(this.real ** 2 + this.imag ** 2);
      }
      get phase() {
        return Math.atan2(this.imag, this.real);
      }
      add(other) {
        return new Complex(this.real + other.real, this.imag + other.imag);
      }
      static fromPolar(r, theta) {
        return new Complex(r * Math.cos(theta), r * Math.sin(theta));
      }
      toJSON() {
        return {
          real: this.real,
          imag: this.imag,
          magnitude: this.magnitude,
          phase: this.phase
        };
      }
    }

    class ScalarField {
      constructor(Nx, Ny, Lx, Ly) {
        this.Nx = Nx;
        this.Ny = Ny;
        this.Lx = Lx;
        this.Ly = Ly;
        this.dx = Lx / (Nx - 1);
        this.dy = Ly / (Ny - 1);
        this.data = Array(Nx).fill(0).map(() => Array(Ny).fill(0));
      }
      x(i) { return -this.Lx / 2 + i * this.dx; }
      y(j) { return -this.Ly / 2 + j * this.dy; }
      set(i, j, value) { this.data[i][j] = value; }
      get(i, j) { return this.data[i][j]; }
      
      getBilinear(x, y) {
        const i = (x + this.Lx / 2) / this.dx;
        const j = (y + this.Ly / 2) / this.dy;
        const i0 = Math.floor(i);
        const j0 = Math.floor(j);
        const i1 = Math.min(i0 + 1, this.Nx - 1);
        const j1 = Math.min(j0 + 1, this.Ny - 1);
        if (i0 < 0 || i0 >= this.Nx || j0 < 0 || j0 >= this.Ny) return 0;
        const tx = i - i0;
        const ty = j - j0;
        const v00 = this.data[i0][j0];
        const v10 = this.data[i1][j0];
        const v01 = this.data[i0][j1];
        const v11 = this.data[i1][j1];
        const v0 = v00 * (1 - tx) + v10 * tx;
        const v1 = v01 * (1 - tx) + v11 * tx;
        return v0 * (1 - ty) + v1 * ty;
      }
      
      gradientMagnitudeSquared(i, j) {
        if (i === 0 || i === this.Nx - 1 || j === 0 || j === this.Ny - 1) return 0;
        const dPhi_dx = (this.data[i + 1][j] - this.data[i - 1][j]) / (2 * this.dx);
        const dPhi_dy = (this.data[i][j + 1] - this.data[i][j - 1]) / (2 * this.dy);
        return dPhi_dx ** 2 + dPhi_dy ** 2;
      }
      
      laplacian(i, j) {
        if (i === 0 || i === this.Nx - 1 || j === 0 || j === this.Ny - 1) return 0;
        const d2Phi_dx2 = (this.data[i + 1][j] - 2 * this.data[i][j] + this.data[i - 1][j]) / (this.dx ** 2);
        const d2Phi_dy2 = (this.data[i][j + 1] - 2 * this.data[i][j] + this.data[i][j - 1]) / (this.dy ** 2);
        return d2Phi_dx2 + d2Phi_dy2;
      }
      
      mean() {
        let sum = 0, count = 0;
        for (let i = 0; i < this.Nx; i++) {
          for (let j = 0; j < this.Ny; j++) {
            sum += this.data[i][j];
            count++;
          }
        }
        return sum / count;
      }
      
      std() {
        const mu = this.mean();
        let sum = 0, count = 0;
        for (let i = 0; i < this.Nx; i++) {
          for (let j = 0; j < this.Ny; j++) {
            sum += (this.data[i][j] - mu) ** 2;
            count++;
          }
        }
        return Math.sqrt(sum / count);
      }
    }

    class TauFieldEngine {
      constructor(config = {}) {
        this.Nx = config.Nx || 64;
        this.Ny = config.Ny || 64;
        this.Lx = config.Lx || 10.0;
        this.Ly = config.Ly || 10.0;
        this.q = config.q || 0;
        this.Q0 = config.Q0 || 137;
        this.sigma = config.sigma || 0.0;
        this.beta_0 = config.beta_0 || 0.6;
        this.alpha_tau = config.alpha_tau || 0.1;
        this.sigma_pi = config.sigma_pi || 2.0;
        this.seed = config.seed || 42;
        this.rng = new SeededRNG(this.seed);
        this.Phi = new ScalarField(this.Nx, this.Ny, this.Lx, this.Ly);
        this.kappa = new ScalarField(this.Nx, this.Ny, this.Lx, this.Ly);
        this.timeSeries = [];
      }
      
      computeTau(n, mode = 'quantized') {
        const theta_base = (2 * Math.PI * this.q) / this.Q0;
        let theta = theta_base;
        if (mode === 'noisy' && this.sigma > 0) {
          theta += this.rng.normal(0, this.sigma);
        }
        return Complex.fromPolar(1.0, theta);
      }
      
      computeBeta(tau) {
        return this.beta_0 * (1 + Math.cos(tau.phase));
      }
      
      initializeSubstrate() {
        for (let i = 0; i < this.Nx; i++) {
          for (let j = 0; j < this.Ny; j++) {
            const x = this.Phi.x(i);
            const y = this.Phi.y(j);
            const r2 = x ** 2 + y ** 2;
            const pi = Math.exp(-r2 / (2 * this.sigma_pi ** 2));
            const phi = -Math.log(pi + 1e-10);
            this.Phi.set(i, j, phi);
          }
        }
      }
      
      updatePhi(tau) {
        const tau_coupling = this.alpha_tau * (tau.magnitude ** 2);
        for (let i = 0; i < this.Nx; i++) {
          for (let j = 0; j < this.Ny; j++) {
            const phi_base = this.Phi.get(i, j);
            this.Phi.set(i, j, phi_base + tau_coupling);
          }
        }
      }
      
      computeCurvature(beta) {
        for (let i = 0; i < this.Nx; i++) {
          for (let j = 0; j < this.Ny; j++) {
            const laplacian = this.Phi.laplacian(i, j);
            const grad_sq = this.Phi.gradientMagnitudeSquared(i, j);
            const kappa_val = laplacian + beta * grad_sq;
            this.kappa.set(i, j, kappa_val);
          }
        }
      }
      
      computeHarmonicEntropy(tau_history, n_bins = 64) {
        if (tau_history.length === 0) return 0;
        const bins = Array(n_bins).fill(0);
        const bin_width = (2 * Math.PI) / n_bins;
        for (const tau of tau_history) {
          const phase = tau.phase;
          const bin_idx = Math.floor((phase + Math.PI) / bin_width);
          const clamped_idx = Math.max(0, Math.min(n_bins - 1, bin_idx));
          bins[clamped_idx]++;
        }
        const total = tau_history.length;
        const probs = bins.map(count => count / total);
        let entropy = 0;
        const LOG2 = Math.log(2);
        for (const p of probs) {
          if (p > 0) entropy -= p * Math.log(p) / LOG2;
        }
        return entropy;
      }
      
      run(params = {}) {
        const mode = params.mode || 'quantized';
        const depth = params.depth || 50;
        if (params.q !== undefined) this.q = params.q;
        if (params.Q0 !== undefined) this.Q0 = params.Q0;
        if (params.sigma !== undefined) this.sigma = params.sigma;
        if (params.seed !== undefined) {
          this.seed = params.seed;
          this.rng = new SeededRNG(this.seed);
        }
        this.timeSeries = [];
        const tau_history = [];
        this.initializeSubstrate();
        for (let n = 0; n < depth; n++) {
          const tau = this.computeTau(n, mode);
          tau_history.push(tau);
          this.updatePhi(tau);
          const beta = this.computeBeta(tau);
          this.computeCurvature(beta);
          const Hr = this.computeHarmonicEntropy(tau_history);
          const kappa_mean = this.kappa.mean();
          const kappa_std = this.kappa.std();
          this.timeSeries.push({
            step: n,
            tau: tau.toJSON(),
            metrics: { Hr, kappa_mean, kappa_std, beta }
          });
        }
        const Hr_values = this.timeSeries.map(d => d.metrics.Hr);
        const Hr_final = Hr_values[Hr_values.length - 1];
        const Hr_mean = Hr_values.reduce((a, b) => a + b, 0) / Hr_values.length;
        const Hr_variance = Hr_values.reduce((a, b) => a + (b - Hr_mean) ** 2, 0) / Hr_values.length;
        const kappa_final = this.timeSeries[this.timeSeries.length - 1].metrics.kappa_mean;
        const collapse_detected = Hr_variance > COLLAPSE_VAR_THRESHOLD;
        return {
          metadata: {
            unns_lab_version: '0.4.0',
            timestamp: new Date().toISOString(),
            seed: this.seed,
            parameters: { mode, q: this.q, Q0: this.Q0, sigma: this.sigma, depth, beta_0: this.beta_0, alpha_tau: this.alpha_tau, grid: { Nx: this.Nx, Ny: this.Ny, Lx: this.Lx, Ly: this.Ly } }
          },
          timeSeries: this.timeSeries,
          summary: { Hr_final, Hr_mean, Hr_variance, kappa_mean_final: kappa_final, collapse_detected }
        };
      }
      
      sweep(config) {
        const parameter = config.parameter;
        const range = config.range;
        const fixed = config.fixed || {};
        const results = [];
        let values;
        if (Array.isArray(range) && range.length === 2) {
          const [min, max] = range;
          const n_points = config.n_points || (max - min + 1);
          values = Array(n_points).fill(0).map((_, i) => min + i * (max - min) / (n_points - 1));
        } else {
          values = range;
        }
        for (const value of values) {
          const params = { ...fixed };
          params[parameter] = parameter === 'q' ? Math.round(value) : value;
          const result = this.run(params);
          results.push({
            [parameter]: value,
            Hr_final: result.summary.Hr_final,
            kappa_mean: result.summary.kappa_mean_final,
            collapse: result.summary.collapse_detected
          });
        }
        return results;
      }
      
      exportJSON(result, filename = 'tau_experiment.json') {
        const json_str = JSON.stringify(result, null, 2);
        const blob = new Blob([json_str], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        return json_str;
      }
      
      exportCSV(result, filename = 'tau_experiment.csv') {
        const header = 'step,q,Q0,sigma,tau_real,tau_imag,tau_phase,Hr,kappa_mean,kappa_std,beta\n';
        const rows = result.timeSeries.map(d => {
          return [
            d.step, result.metadata.parameters.q, result.metadata.parameters.Q0, result.metadata.parameters.sigma,
            d.tau.real.toFixed(6), d.tau.imag.toFixed(6), d.tau.phase.toFixed(6),
            d.metrics.Hr.toFixed(6), d.metrics.kappa_mean.toFixed(6), d.metrics.kappa_std.toFixed(6), d.metrics.beta.toFixed(6)
          ].join(',');
        }).join('\n');
        const csv_str = header + rows;
        const blob = new Blob([csv_str], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        return csv_str;
      }
    }

    // ========================================================================
    // PHASE IV AUTOMATION
    // ========================================================================
    
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    class ProtocolRunner {
      constructor(opts = {}) {
        this.opts = Object.assign({
          grid: 64,
          seed: 42,
          depth: 100,
          Q0: 137,
          qMax: 50,
          sigmaMax: 0.5,
          sigmaSteps: 20,
          pauseMs: 50
        }, opts);
        this._cancel = false;
        this.artifacts = { E8: null, E9: null, E10: null, E11: null };
      }

      cancel() { this._cancel = true; }

      _engine(runIndex = 0) {
        return new TauFieldEngine({
          Nx: this.opts.grid,
          Ny: this.opts.grid,
          seed: (this.opts.seed + runIndex) >>> 0
        });
      }

      async E8_quantizedSweep() {
        const Q0 = this.opts.Q0;
        const qLast = Math.min(Q0 - 1, this.opts.qMax);
        const results = [];
        for (let q = 0; q <= qLast; q++) {
          if (this._cancel) break;
          const engine = this._engine(q);
          const res = engine.run({ mode: 'quantized', q, Q0, sigma: 0, depth: this.opts.depth });
          results.push({
            q,
            Hr_final: res.summary.Hr_final,
            kappa_mean: res.summary.kappa_mean_final,
            collapse: res.summary.collapse_detected
          });
          await sleep(this.opts.pauseMs);
        }
        this.artifacts.E8 = { meta: { Q0, depth: this.opts.depth }, results };
        return this.artifacts.E8;
      }

      async E9_noiseStability(q = 0) {
        const results = [];
        for (let i = 0; i < this.opts.sigmaSteps; i++) {
          if (this._cancel) break;
          const sigma = i * (this.opts.sigmaMax / (this.opts.sigmaSteps - 1));
          const engine = this._engine(i);
          const res = engine.run({ mode: 'noisy', q, Q0: this.opts.Q0, sigma, depth: this.opts.depth });
          results.push({
            sigma,
            Hr_final: res.summary.Hr_final,
            var: res.summary.Hr_variance
          });
          await sleep(this.opts.pauseMs);
        }
        this.artifacts.E9 = { meta: { q, Q0: this.opts.Q0, depth: this.opts.depth }, results };
        return this.artifacts.E9;
      }

      async E10_alphaAlignment() {
        const engine = this._engine();
        const res = engine.run({ mode: 'quantized', q: 1, Q0: 137, sigma: 0, depth: this.opts.depth });
        const phase = res.timeSeries[res.timeSeries.length - 1].tau.phase;
        const expected = 2 * Math.PI / 137;
        const delta = Math.abs(phase - expected);
        this.artifacts.E10 = {
          meta: { depth: this.opts.depth },
          result: { phase, expected, delta }
        };
        return this.artifacts.E10;
      }

      async E11_collapseDetection() {
        const engine = this._engine();
        const clean = engine.run({ mode: 'quantized', q: 0, Q0: this.opts.Q0, sigma: 0, depth: this.opts.depth });
        const noisy = engine.run({ mode: 'noisy', q: 0, Q0: this.opts.Q0, sigma: this.opts.sigmaMax, depth: this.opts.depth });
        const verdict = noisy.summary.Hr_variance > clean.summary.Hr_variance;
        this.artifacts.E11 = {
          meta: { Q0: this.opts.Q0, depth: this.opts.depth },
          result: {
            Hr_var_clean: clean.summary.Hr_variance,
            Hr_var_noisy: noisy.summary.Hr_variance,
            collapse: verdict
          }
        };
        return this.artifacts.E11;
      }

      toJSON() {
        return JSON.stringify({
          version: '0.4.0',
          ts: new Date().toISOString(),
          options: this.opts,
          artifacts: this.artifacts
        }, null, 2);
      }

      toCSV() {
        const lines = [];
        if (this.artifacts.E8) {
          lines.push('# E8 q,Hr_final,kappa_mean,collapse');
          lines.push('q,Hr_final,kappa_mean,collapse');
          this.artifacts.E8.results.forEach(r => lines.push([r.q, r.Hr_final, r.kappa_mean, r.collapse ? 1 : 0].join(',')));
          lines.push('');
        }
        if (this.artifacts.E9) {
          lines.push('# E9 sigma,Hr_final,var');
          lines.push('sigma,Hr_final,var');
          this.artifacts.E9.results.forEach(r => lines.push([r.sigma, r.Hr_final, r.var].join(',')));
          lines.push('');
        }
        if (this.artifacts.E10) {
          lines.push('# E10 phase,expected,delta');
          lines.push('phase,expected,delta');
          const r = this.artifacts.E10.result;
          lines.push([r.phase, r.expected, r.delta].join(','));
          lines.push('');
        }
        if (this.artifacts.E11) {
          lines.push('# E11 Hr_var_clean,Hr_var_noisy,collapse');
          lines.push('Hr_var_clean,Hr_var_noisy,collapse');
          const r = this.artifacts.E11.result;
          lines.push([r.Hr_var_clean, r.Hr_var_noisy, r.collapse ? 1 : 0].join(','));
          lines.push('');
        }
        return lines.join('\n');
      }
    }

    window.TauPhaseIV = { ProtocolRunner };

    // ========================================================================
    // UI CONTROLLER
    // ========================================================================
    
    let engine = null;
    let currentResult = null;
    let isComputing = false;
    let protocolRunner = null;
    
    const canvasKappa = document.getElementById('canvas-kappa');
    const ctxKappa = canvasKappa.getContext('2d');
    const canvasEntropy = document.getElementById('canvas-entropy');
    const ctxEntropy = canvasEntropy.getContext('2d');
    
    const STORAGE_KEY = 'unns_tau_chamber_settings';
    const COLLAPSE_VAR_THRESHOLD = 0.5;
    
    function setupCanvas(canvas, ctx) {
      const DPR = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || canvas.width;
      const cssH = canvas.clientHeight || canvas.height;
      canvas.width = Math.round(cssW * DPR);
      canvas.height = Math.round(cssH * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }

    function resizeCanvases() {
      setupCanvas(canvasKappa, ctxKappa);
      setupCanvas(canvasEntropy, ctxEntropy);
      renderEmpty();
    }
    
    function safeSetItem(k, v) {
      try { 
        localStorage.setItem(k, v); 
      } catch (e) { 
        console.warn('Storage full/blocked', e); 
      }
    }
    
    function saveSettings() {
      const settings = {
        mode: document.querySelector('.mode-pill.active').dataset.mode,
        q: parseInt(document.getElementById('q-slider').value),
        Q0: parseInt(document.getElementById('Q0-input').value),
        sigma: parseFloat(document.getElementById('sigma-slider').value),
        depth: parseInt(document.getElementById('depth-slider').value),
        gridSize: parseInt(document.getElementById('grid-select').value),
        seed: parseInt(document.getElementById('seed-input').value),
        showAlphaReference: document.getElementById('show-alpha-reference').checked
      };
      safeSetItem(STORAGE_KEY, JSON.stringify(settings));
    }
    
    function loadSettings() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) return false;
        const settings = JSON.parse(saved);
        document.querySelectorAll('.mode-pill').forEach(p => p.classList.remove('active'));
        document.querySelector(`.mode-pill[data-mode="${settings.mode}"]`).classList.add('active');
        document.getElementById('q-slider').value = settings.q;
        document.getElementById('Q0-input').value = settings.Q0;
        document.getElementById('sigma-slider').value = settings.sigma;
        document.getElementById('depth-slider').value = settings.depth;
        document.getElementById('grid-select').value = settings.gridSize;
        document.getElementById('seed-input').value = settings.seed;
        const refToggle = document.getElementById('show-alpha-reference');
        refToggle.checked = settings.showAlphaReference;
        refToggle.parentElement.setAttribute('aria-checked', settings.showAlphaReference ? 'true' : 'false');
        document.getElementById('q-display').textContent = settings.q;
        document.getElementById('Q0-display').textContent = settings.Q0;
        document.getElementById('sigma-display').textContent = settings.sigma.toFixed(2);
        document.getElementById('depth-display').textContent = settings.depth;
        document.getElementById('grid-display').textContent = `${settings.gridSize}×${settings.gridSize}`;
        document.getElementById('seed-display').textContent = settings.seed;
        return true;
      } catch (e) {
        console.warn('Could not load settings:', e);
        return false;
      }
    }
    
    function init() {
      const loaded = loadSettings();
      const gridSize = parseInt(document.getElementById('grid-select').value);
      engine = new TauFieldEngine({ Nx: gridSize, Ny: gridSize, seed: parseInt(document.getElementById('seed-input').value) });
      updateStatus(loaded ? 'Ready – Settings restored + Phase IV enabled' : 'Ready – τ-Field Engine + Phase IV automation', false);
      bindControls();
      resizeCanvases();
      window.addEventListener('resize', resizeCanvases);
    }
    
    function bindControls() {
      document.querySelectorAll('.mode-pill').forEach(pill => {
        pill.addEventListener('click', () => {
          document.querySelectorAll('.mode-pill').forEach(p => p.classList.remove('active'));
          pill.classList.add('active');
          saveSettings();
        });
        pill.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' || e.key === ' ') pill.click();
        });
      });
      
      const sliders = [
        { id: 'q-slider', display: 'q-display' },
        { id: 'sigma-slider', display: 'sigma-display', format: v => v.toFixed(2) },
        { id: 'depth-slider', display: 'depth-display' }
      ];
      sliders.forEach(({ id, display, format }) => {
        const slider = document.getElementById(id);
        const displayEl = document.getElementById(display);
        slider.addEventListener('input', () => {
          const value = parseFloat(slider.value);
          displayEl.textContent = format ? format(value) : value;
          slider.setAttribute('aria-valuenow', value);
          saveSettings();
        });
      });
      
      document.getElementById('Q0-input').addEventListener('input', (e) => {
        document.getElementById('Q0-display').textContent = e.target.value;
        document.getElementById('q-slider').max = parseInt(e.target.value) - 1;
        saveSettings();
      });
      
      document.getElementById('grid-select').addEventListener('change', (e) => {
        const value = parseInt(e.target.value);
        document.getElementById('grid-display').textContent = `${value}×${value}`;
        saveSettings();
      });
      
      document.getElementById('seed-input').addEventListener('input', (e) => {
        document.getElementById('seed-display').textContent = e.target.value;
        saveSettings();
      });
      
      const refToggle = document.getElementById('show-alpha-reference');
      refToggle.addEventListener('change', () => {
        refToggle.parentElement.setAttribute('aria-checked', refToggle.checked ? 'true' : 'false');
        saveSettings();
      });
      
      document.getElementById('btn-run').addEventListener('click', runSingle);
      document.getElementById('btn-sweep').addEventListener('click', runSweep);
      document.getElementById('btn-noise').addEventListener('click', runNoise);
      document.getElementById('btn-reset').addEventListener('click', resetControls);
      document.getElementById('btn-export-json').addEventListener('click', () => exportData('json'));
      document.getElementById('btn-export-csv').addEventListener('click', () => exportData('csv'));
      document.getElementById('btn-docs').addEventListener('click', openDocs);
      
      document.getElementById('btn-auto-all').addEventListener('click', runAutomation);
      document.getElementById('btn-auto-cancel').addEventListener('click', cancelAutomation);
      
      document.getElementById('docs-close').addEventListener('click', closeDocs);
      document.getElementById('docs-modal').addEventListener('click', (e) => {
        if (e.target.id === 'docs-modal') closeDocs();
      });
      document.querySelectorAll('.docs-tab').forEach(tab => {
        tab.addEventListener('click', () => switchDocsTab(tab.dataset.tab));
      });
    }
    
    function openDocs() {
      document.getElementById('docs-modal').classList.add('active');
      document.body.style.overflow = 'hidden';
    }
    
    function closeDocs() {
      document.getElementById('docs-modal').classList.remove('active');
      document.body.style.overflow = '';
    }
    
    function switchDocsTab(tabName) {
      document.querySelectorAll('.docs-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.docs-section').forEach(s => s.classList.remove('active'));
      document.querySelector(`.docs-tab[data-tab="${tabName}"]`).classList.add('active');
      document.getElementById(`section-${tabName}`).classList.add('active');
    }
    
    async function runAutomation() {
      if (isComputing) return;
      
      setComputing(true);
      document.getElementById('btn-auto-all').disabled = true;
      document.getElementById('btn-auto-cancel').disabled = false;
      
      const Q0 = parseInt(document.getElementById('Q0-input').value);
      const grid = parseInt(document.getElementById('grid-select').value);
      const depth = parseInt(document.getElementById('depth-slider').value);
      const seed = parseInt(document.getElementById('seed-input').value);
      
      protocolRunner = new ProtocolRunner({ Q0, grid, depth, seed });
      
      try {
        updateStatus('E8: Quantized sweep running…', true);
        await protocolRunner.E8_quantizedSweep();
        if (protocolRunner._cancel) throw new Error('Cancelled');
        
        updateStatus('E9: Noise stability running…', true);
        await protocolRunner.E9_noiseStability(0);
        if (protocolRunner._cancel) throw new Error('Cancelled');
        
        updateStatus('E10: α alignment check…', true);
        await protocolRunner.E10_alphaAlignment();
        if (protocolRunner._cancel) throw new Error('Cancelled');
        
        updateStatus('E11: Collapse detection…', true);
        await protocolRunner.E11_collapseDetection();
        if (protocolRunner._cancel) throw new Error('Cancelled');
        
        const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const json = protocolRunner.toJSON();
        const csv = protocolRunner.toCSV();
        
        downloadBlob(json, `tau_phaseIV_artifacts_${ts}.json`, 'application/json');
        downloadBlob(csv, `tau_phaseIV_artifacts_${ts}.csv`, 'text/csv');
        
        updateStatus('✅ E8–E11 complete – artifacts exported', false);
      } catch (err) {
        if (err.message === 'Cancelled') {
          updateStatus('⏹ Batch cancelled by user', false);
        } else {
          updateStatus(`❌ Error: ${err.message}`, false);
          console.error('Automation error:', err);
        }
      } finally {
        setComputing(false);
        document.getElementById('btn-auto-all').disabled = false;
        document.getElementById('btn-auto-cancel').disabled = true;
        protocolRunner = null;
      }
    }
    
    function cancelAutomation() {
      if (protocolRunner) {
        protocolRunner.cancel();
        updateStatus('⏹ Cancelling batch…', false);
      }
    }
    
    function downloadBlob(text, name, type) {
      const blob = new Blob([text], { type: type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function runSingle() {
      if (isComputing) return;
      setComputing(true);
      updateStatus('Computing single run...', true);

      setTimeout(() => {
        try {
          const mode = document.querySelector('.mode-pill.active').dataset.mode;
          const q = parseInt(document.getElementById('q-slider').value);
          const Q0 = parseInt(document.getElementById('Q0-input').value);
          const sigma = parseFloat(document.getElementById('sigma-slider').value);
          const depth = parseInt(document.getElementById('depth-slider').value);
          const gridSize = parseInt(document.getElementById('grid-select').value);
          const seed = parseInt(document.getElementById('seed-input').value);
          
          engine = new TauFieldEngine({ Nx: gridSize, Ny: gridSize, seed: seed });
          const startTime = performance.now();
          currentResult = engine.run({ mode, q, Q0, sigma, depth });
          const elapsed = performance.now() - startTime;
          
          updateMetrics(currentResult, elapsed);
          renderKappaHeatmap(engine.kappa);
          renderEntropyTimeSeries(currentResult.timeSeries);
          
          updateStatus(`Run complete (${elapsed.toFixed(0)} ms)`, false);
        } catch (error) {
          console.error("Error during single run:", error);
          updateStatus('Error: Computation failed. Check console.', false);
        } finally {
          setComputing(false);
        }
      }, 10);
    }

    function runSweep() {
      if (isComputing) return;
      setComputing(true);
      updateStatus('Running E8 sweep...', true);

      setTimeout(() => {
        try {
          const Q0 = parseInt(document.getElementById('Q0-input').value);
          const depth = parseInt(document.getElementById('depth-slider').value);
          const gridSize = parseInt(document.getElementById('grid-select').value);
          const seed = parseInt(document.getElementById('seed-input').value);
          
          engine = new TauFieldEngine({ Nx: gridSize, Ny: gridSize, seed: seed });
          const startTime = performance.now();
          const results = engine.sweep({
            parameter: 'q',
            range: [0, Math.min(Q0 - 1, 50)],
            fixed: { Q0, sigma: 0, depth, mode: 'quantized' }
          });
          const elapsed = performance.now() - startTime;
          
          renderSweepResults(results, 'q', Q0);
          updateStatus(`E8 sweep complete – ${results.length} runs (${elapsed.toFixed(0)} ms)`, false);
        } catch (error) {
          console.error("Error during E8 sweep:", error);
          updateStatus('Error: Sweep failed. Check console.', false);
        } finally {
          setComputing(false);
        }
      }, 10);
    }

    function runNoise() {
      if (isComputing) return;
      setComputing(true);
      updateStatus('Running E9 noise stability test...', true);

      setTimeout(() => {
        try {
          const q = parseInt(document.getElementById('q-slider').value);
          const Q0 = parseInt(document.getElementById('Q0-input').value);
          const depth = parseInt(document.getElementById('depth-slider').value);
          const gridSize = parseInt(document.getElementById('grid-select').value);
          const seed = parseInt(document.getElementById('seed-input').value);
          
          engine = new TauFieldEngine({ Nx: gridSize, Ny: gridSize, seed: seed });
          const startTime = performance.now();
          const results = engine.sweep({
            parameter: 'sigma',
            range: [0, 0.5],
            n_points: 20,
            fixed: { q, Q0, depth, mode: 'noisy' }
          });
          const elapsed = performance.now() - startTime;
          
          renderSweepResults(results, 'sigma', Q0);
          updateStatus(`E9 noise test complete – ${results.length} runs (${elapsed.toFixed(0)} ms)`, false);
        } catch (error) {
          console.error("Error during E9 noise test:", error);
          updateStatus('Error: Noise test failed. Check console.', false);
        } finally {
          setComputing(false);
        }
      }, 10);
    }
    
    function renderKappaHeatmap(kappaField) {
      const width = canvasKappa.width;
      const height = canvasKappa.height;
      const imageData = ctxKappa.createImageData(width, height);
      let minKappa = Infinity, maxKappa = -Infinity;
      for (let i = 0; i < kappaField.Nx; i++) {
        for (let j = 0; j < kappaField.Ny; j++) {
          const val = kappaField.get(i, j);
          minKappa = Math.min(minKappa, val);
          maxKappa = Math.max(maxKappa, val);
        }
      }
      for (let px = 0; px < width; px++) {
        for (let py = 0; py < height; py++) {
          const x = (px / width) * kappaField.Lx - kappaField.Lx / 2;
          const y = (py / height) * kappaField.Ly - kappaField.Ly / 2;
          const kappa = kappaField.getBilinear(x, y);
          const normalized = (kappa - minKappa) / (maxKappa - minKappa + 1e-10);
          let r, g, b;
          if (normalized < 0.5) {
            const t = normalized * 2;
            r = Math.floor(t * 100);
            g = Math.floor(100 + t * 155);
            b = Math.floor(255 - t * 155);
          } else {
            const t = (normalized - 0.5) * 2;
            r = Math.floor(100 + t * 155);
            g = Math.floor(255 - t * 155);
            b = 100;
          }
          const idx = (py * width + px) * 4;
          imageData.data[idx] = r;
          imageData.data[idx + 1] = g;
          imageData.data[idx + 2] = b;
          imageData.data[idx + 3] = 255;
        }
      }
      ctxKappa.putImageData(imageData, 0, 0);
    }
    
    function renderEntropyTimeSeries(timeSeries) {
      const width = canvasEntropy.width;
      const height = canvasEntropy.height;
      const padding = 60;
      ctxEntropy.clearRect(0, 0, width, height);
      if (timeSeries.length === 0) return;
      
      const Hr_values = timeSeries.map(d => d.metrics.Hr);
      const tau_phases = timeSeries.map(d => d.tau.phase);
      const maxHr = Math.max(...Hr_values);
      const minPhase = Math.min(...tau_phases);
      const maxPhase = Math.max(...tau_phases);
      
      ctxEntropy.strokeStyle = '#64b5f6';
      ctxEntropy.lineWidth = 2;
      ctxEntropy.beginPath();
      ctxEntropy.moveTo(padding, padding);
      ctxEntropy.lineTo(padding, height - padding);
      ctxEntropy.lineTo(width - padding, height - padding);
      ctxEntropy.stroke();
      
      ctxEntropy.fillStyle = '#90a4ae';
      ctxEntropy.font = '12px monospace';
      ctxEntropy.fillText('H_r (bits)', 10, padding - 10);
      ctxEntropy.fillText('τ phase', width - padding + 10, height - padding + 20);
      
      ctxEntropy.strokeStyle = '#42a5f5';
      ctxEntropy.lineWidth = 2;
      ctxEntropy.beginPath();
      for (let i = 0; i < timeSeries.length; i++) {
        const x = padding + ((tau_phases[i] - minPhase) / (maxPhase - minPhase + 1e-10)) * (width - 2 * padding);
        const y = height - padding - (Hr_values[i] / (maxHr + 1e-10)) * (height - 2 * padding);
        if (i === 0) ctxEntropy.moveTo(x, y);
        else ctxEntropy.lineTo(x, y);
      }
      ctxEntropy.stroke();
      
      ctxEntropy.fillStyle = '#64b5f6';
      for (let i = 0; i < timeSeries.length; i++) {
        const x = padding + ((tau_phases[i] - minPhase) / (maxPhase - minPhase + 1e-10)) * (width - 2 * padding);
        const y = height - padding - (Hr_values[i] / (maxHr + 1e-10)) * (height - 2 * padding);
        ctxEntropy.beginPath();
        ctxEntropy.arc(x, y, 3, 0, 2 * Math.PI);
        ctxEntropy.fill();
      }
    }
    
    function renderSweepResults(results, paramName, Q0) {
      const width = canvasEntropy.width;
      const height = canvasEntropy.height;
      const padding = 60;
      ctxEntropy.clearRect(0, 0, width, height);
      if (results.length === 0) return;
      
      const param_values = results.map(r => r[paramName]);
      const Hr_values = results.map(r => r.Hr_final);
      const minParam = Math.min(...param_values);
      const maxParam = Math.max(...param_values);
      const maxHr = Math.max(...Hr_values);
      
      ctxEntropy.strokeStyle = '#64b5f6';
      ctxEntropy.lineWidth = 2;
      ctxEntropy.beginPath();
      ctxEntropy.moveTo(padding, padding);
      ctxEntropy.lineTo(padding, height - padding);
      ctxEntropy.lineTo(width - padding, height - padding);
      ctxEntropy.stroke();
      
      ctxEntropy.fillStyle = '#90a4ae';
      ctxEntropy.font = '12px monospace';
      ctxEntropy.fillText('H_r (bits)', 10, padding - 10);
      ctxEntropy.fillText(paramName, width - padding - 20, height - padding + 20);
      
      const showReference = document.getElementById('show-alpha-reference').checked;
      if (showReference && paramName === 'q' && Q0 === 137) {
        const alpha_q = 1;
        if (alpha_q >= minParam && alpha_q <= maxParam) {
          const x_ref = padding + ((alpha_q - minParam) / (maxParam - minParam + 1e-10)) * (width - 2 * padding);
          ctxEntropy.strokeStyle = '#ff6b6b';
          ctxEntropy.lineWidth = 2;
          ctxEntropy.setLineDash([5, 5]);
          ctxEntropy.beginPath();
          ctxEntropy.moveTo(x_ref, padding);
          ctxEntropy.lineTo(x_ref, height - padding);
          ctxEntropy.stroke();
          ctxEntropy.setLineDash([]);
          ctxEntropy.fillStyle = '#ff6b6b';
          ctxEntropy.font = '10px monospace';
          const labelX = Math.min(Math.max(x_ref + 5, padding + 5), width - padding - 60);
          ctxEntropy.fillText('α = 1/137', labelX, padding + 15);
        }
      }
      
      ctxEntropy.strokeStyle = '#42a5f5';
      ctxEntropy.lineWidth = 2;
      ctxEntropy.beginPath();
      for (let i = 0; i < results.length; i++) {
        const x = padding + ((param_values[i] - minParam) / (maxParam - minParam + 1e-10)) * (width - 2 * padding);
        const y = height - padding - (Hr_values[i] / (maxHr + 1e-10)) * (height - 2 * padding);
        if (i === 0) ctxEntropy.moveTo(x, y);
        else ctxEntropy.lineTo(x, y);
      }
      ctxEntropy.stroke();
      
      ctxEntropy.fillStyle = '#64b5f6';
      for (let i = 0; i < results.length; i++) {
        const x = padding + ((param_values[i] - minParam) / (maxParam - minParam + 1e-10)) * (width - 2 * padding);
        const y = height - padding - (Hr_values[i] / (maxHr + 1e-10)) * (height - 2 * padding);
        ctxEntropy.beginPath();
        ctxEntropy.arc(x, y, 4, 0, 2 * Math.PI);
        ctxEntropy.fill();
      }
    }
    
    function renderEmpty() {
      ctxKappa.fillStyle = '#1a1f3a';
      ctxKappa.fillRect(0, 0, canvasKappa.width, canvasKappa.height);
      ctxEntropy.fillStyle = '#1a1f3a';
      ctxEntropy.fillRect(0, 0, canvasEntropy.width, canvasEntropy.height);
      ctxKappa.fillStyle = '#64b5f6';
      ctxKappa.font = '16px sans-serif';
      ctxKappa.textAlign = 'center';
      ctxKappa.fillText('Run experiment to visualize κ field', canvasKappa.width / 2, canvasKappa.height / 2);
      ctxEntropy.fillStyle = '#64b5f6';
      ctxEntropy.font = '16px sans-serif';
      ctxEntropy.textAlign = 'center';
      ctxEntropy.fillText('Run experiment to visualize H_r evolution', canvasEntropy.width / 2, canvasEntropy.height / 2);
    }
    
    function updateMetrics(result, elapsed) {
      const final = result.timeSeries[result.timeSeries.length - 1];
      document.getElementById('metric-tau-phase').textContent = final.tau.phase.toFixed(4);
      document.getElementById('metric-kappa').textContent = final.metrics.kappa_mean.toFixed(4);
      document.getElementById('metric-hr').innerHTML = final.metrics.Hr.toFixed(4) + '<span class="metric-unit">bits</span>';
      document.getElementById('metric-beta').textContent = final.metrics.beta.toFixed(4);
      document.getElementById('metric-collapse').textContent = result.summary.collapse_detected ? 'Yes' : 'No';
      document.getElementById('metric-time').innerHTML = `${elapsed.toFixed(0)}<span class="metric-unit">ms</span>`;
    }
    
    function setComputing(computing) {
      isComputing = computing;
      ['btn-run', 'btn-sweep', 'btn-noise', 'btn-reset', 'btn-export-json', 'btn-export-csv', 'btn-docs'].forEach(id => {
        document.getElementById(id).disabled = computing;
      });
      const statusDot = document.getElementById('status-dot');
      if (computing) statusDot.classList.add('computing');
      else statusDot.classList.remove('computing');
    }
    
    function updateStatus(text, computing) {
      document.getElementById('status-text').textContent = text;
      const statusBar = document.querySelector('.status-bar');
      if (computing) statusBar.classList.add('computing');
      else statusBar.classList.remove('computing');
    }
    
    function resetControls() {
      if (isComputing) return;
      localStorage.removeItem(STORAGE_KEY);

      document.getElementById('q-slider').value = 0;
      document.getElementById('Q0-input').value = 137;
      document.getElementById('sigma-slider').value = 0;
      document.getElementById('depth-slider').value = 50;
      document.getElementById('grid-select').value = 64;
      document.getElementById('seed-input').value = 42;
      document.getElementById('show-alpha-reference').checked = false;
      document.getElementById('show-alpha-reference').parentElement.setAttribute('aria-checked', 'false');
      
      document.getElementById('q-display').textContent = '0';
      document.getElementById('Q0-display').textContent = '137';
      document.getElementById('sigma-display').textContent = '0.00';
      document.getElementById('depth-display').textContent = '50';
      document.getElementById('grid-display').textContent = `64×64`;
      document.getElementById('seed-display').textContent = '42';
      
      document.querySelectorAll('.mode-pill').forEach(p => p.classList.remove('active'));
      document.querySelector('.mode-pill[data-mode="quantized"]').classList.add('active');

      currentResult = null;
      renderEmpty();
      updateStatus('Controls reset to defaults', false);
    }
    
    function exportData(format) {
      if (isComputing) return;
      if (!currentResult) {
        alert('No data to export. Run a single experiment first.');
        return;
      }
      try {
        const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const filename = `tau_experiment_${ts}.${format}`;
        if (format === 'json') {
          engine.exportJSON(currentResult, filename);
        } else if (format === 'csv') {
          engine.exportCSV(currentResult, filename);
        }
        updateStatus(`Exported to ${filename}`, false);
      } catch (error) {
        console.error("Export failed:", error);
        updateStatus('Error: Export failed. Check console.', false);
      }
    }
    
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>