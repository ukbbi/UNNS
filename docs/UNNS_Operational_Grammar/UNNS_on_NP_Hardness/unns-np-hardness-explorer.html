<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS NP-Hardness Collapse Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff88;
            overflow-x: hidden;
            position: relative;
        }

        /* Background Animation */
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(138, 43, 226, 0.1));
            border-bottom: 2px solid #00ff88;
            position: relative;
            overflow: hidden;
        }

        .title {
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            margin-bottom: 10px;
            animation: pulse 2s infinite;
        }

        .subtitle {
            font-size: 1.2em;
            color: #8a2be2;
            font-style: italic;
        }

        .glyphic-symbols {
            font-size: 1.5em;
            margin: 10px 0;
            letter-spacing: 10px;
            color: #ff00ff;
            animation: rotate 10s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Layout */
        .container {
            display: flex;
            min-height: calc(100vh - 150px);
        }

        /* Operator Sidebar */
        .operator-sidebar {
            width: 200px;
            background: rgba(138, 43, 226, 0.1);
            border-right: 2px solid #8a2be2;
            padding: 20px;
        }

        .operator {
            padding: 10px;
            margin: 10px 0;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .operator:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateX(5px);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .operator.active {
            background: rgba(0, 255, 136, 0.3);
            border-color: #ff00ff;
        }

        .operator-symbol {
            display: block;
            font-size: 1.3em;
            color: #ff00ff;
            margin-bottom: 5px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* Module Sections */
        .module {
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
        }

        .module-header {
            font-size: 1.5em;
            color: #ff00ff;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        /* Problem Selector */
        .problem-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .problem-btn {
            flex: 1;
            padding: 10px;
            background: rgba(138, 43, 226, 0.2);
            border: 2px solid #8a2be2;
            color: #00ff88;
            cursor: pointer;
            transition: all 0.3s;
        }

        .problem-btn:hover {
            background: rgba(138, 43, 226, 0.4);
            transform: translateY(-2px);
        }

        .problem-btn.active {
            background: rgba(138, 43, 226, 0.6);
            border-color: #ff00ff;
        }

        /* Visualization Areas */
        .visualization {
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 20px;
            margin: 15px 0;
            min-height: 200px;
            position: relative;
        }

        .canvas-container {
            width: 100%;
            height: 300px;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        /* Metrics Display */
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .metric {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
        }

        .metric-value {
            font-size: 2em;
            color: #ff00ff;
            margin: 10px 0;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .metric-label {
            font-size: 0.9em;
            color: #00ff88;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            background: rgba(0, 255, 136, 0.4);
            transform: scale(1.05);
        }

        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            background: transparent;
            outline: none;
        }

        /* Collapse Animation */
        .collapse-animation {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff00ff;
            border-radius: 50%;
            pointer-events: none;
            animation: collapse 1s ease-out forwards;
        }

        @keyframes collapse {
            to {
                transform: scale(0);
                opacity: 0;
            }
        }

        /* Reference Popup */
        .reference-popup {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff88;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 1000;
        }

        .reference-link {
            display: block;
            color: #00ff88;
            margin: 5px 0;
            text-decoration: none;
            font-size: 0.9em;
        }

        .reference-link:hover {
            color: #ff00ff;
            text-decoration: underline;
        }

        /* Philosophy Quote */
        .philosophy-quote {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #8a2be2;
            font-size: 1.1em;
            border-top: 1px solid #8a2be2;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <canvas id="background-canvas"></canvas>

    <div class="header">
        <div class="glyphic-symbols">â—ˆ â—‰ â—Š â—ˆ â—‰ â—Š</div>
        <div class="title">UNNS NP-Hardness Collapse Explorer</div>
        <div class="subtitle">Substrate-Relative Complexity Through Recursive Grammar</div>
    </div>

    <div class="container">
        <div class="operator-sidebar">
            <div class="operator active" data-operator="inlet">
                <span class="operator-symbol">@inlet</span>
                Inletting
            </div>
            <div class="operator" data-operator="inlay">
                <span class="operator-symbol">@inlay</span>
                Inlaying
            </div>
            <div class="operator" data-operator="repair">
                <span class="operator-symbol">@repair</span>
                Repair
            </div>
            <div class="operator" data-operator="trans-sentify">
                <span class="operator-symbol">@trans</span>
                Trans-Sentify
            </div>
            <div class="operator" data-operator="branch">
                <span class="operator-symbol">@branch</span>
                Branching
            </div>
            <div class="operator" data-operator="merge">
                <span class="operator-symbol">@merge</span>
                Merging
            </div>
            <div class="operator" data-operator="shadow">
                <span class="operator-symbol">@shadow</span>
                Shadowing
            </div>
            <div class="operator" data-operator="collapse">
                <span class="operator-symbol">@collapse</span>
                Collapse
            </div>
        </div>

        <div class="main-content">
            <!-- Problem Selector -->
            <div class="problem-selector">
                <button class="problem-btn active" data-problem="sat">SAT</button>
                <button class="problem-btn" data-problem="hamiltonian">Hamiltonian Cycle</button>
                <button class="problem-btn" data-problem="tsp">TSP</button>
            </div>

            <!-- Recursive Embedding Engine -->
            <div class="module">
                <div class="module-header">ðŸ”· Recursive Embedding Engine</div>
                <div class="visualization">
                    <div class="canvas-container">
                        <canvas id="embedding-canvas"></canvas>
                    </div>
                </div>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Recursive Depth</div>
                        <div class="metric-value" id="recursive-depth">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Lattice Width</div>
                        <div class="metric-value" id="lattice-width">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Nesting Level</div>
                        <div class="metric-value" id="nesting-level">0</div>
                    </div>
                </div>
            </div>

            <!-- Repair & Normalization Simulator -->
            <div class="module">
                <div class="module-header">ðŸ”¶ Repair & Normalization Simulator</div>
                <div class="visualization">
                    <div class="canvas-container">
                        <canvas id="collapse-canvas"></canvas>
                    </div>
                </div>
                <div class="controls">
                    <button class="btn" id="apply-repair">Apply Repair</button>
                    <button class="btn" id="normalize">Normalize</button>
                    <div class="slider-container">
                        <label>Collapse Rate:</label>
                        <input type="range" id="collapse-rate" min="0" max="100" value="50">
                        <span id="collapse-value">50%</span>
                    </div>
                </div>
            </div>

            <!-- Substrate Complexity Tracker -->
            <div class="module">
                <div class="module-header">ðŸ“Š Substrate Complexity Tracker</div>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Classical Complexity</div>
                        <div class="metric-value" id="classical-complexity">2^n</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">UNNS Complexity</div>
                        <div class="metric-value" id="unns-complexity">n^k</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Attractor Count</div>
                        <div class="metric-value" id="attractor-count">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Collapse Ratio</div>
                        <div class="metric-value" id="collapse-ratio">0.00</div>
                    </div>
                </div>
            </div>

            <!-- Worked Problem Scrolls -->
            <div class="module">
                <div class="module-header">ðŸ“œ Worked Problem Analysis</div>
                <div class="visualization" id="problem-analysis">
                    <!-- Dynamic content based on selected problem -->
                </div>
            </div>

            <div class="philosophy-quote">
                "Complexity is not a property of problems. It is a property of the substrate."
            </div>
        </div>
    </div>

    <!-- Reference Popup -->
    <div class="reference-popup">
        <strong>ðŸ“š Reference Papers</strong>
        <a href="https://ukbbi.github.io/UNNS/docs/UNNS_Operational_Grammar/UNNS_on_NP_Hardness/A%20UNNS%20Note%20on%20NP-Hardness.pdf" 
           class="reference-link" target="_blank">
            UNNS Note on NP-Hardness
        </a>
        <a href="https://ukbbi.github.io/UNNS/docs/UNNS_Operational_Grammar/UNNS_on_NP_Hardness/NP-Hardness%20in%20the%20UNNS%20Substrate.pdf" 
           class="reference-link" target="_blank">
            NP-Hardness in UNNS Substrate
        </a>
    </div>

    <script>
        // State Management
        const state = {
            currentProblem: 'sat',
            currentOperator: 'inlet',
            recursiveDepth: 0,
            latticeWidth: 0,
            nestingLevel: 0,
            attractorCount: 0,
            collapseRatio: 0,
            animationFrame: 0,
            particles: [],
            branches: [],
            attractors: []
        };

        // Problem Configurations
        const problems = {
            sat: {
                name: 'Boolean SAT',
                clauses: 8,
                variables: 4,
                classicalComplexity: '2^n',
                unnsComplexity: 'n^2',
                description: 'CNF clauses form recursive nests. Normalization identifies equivalent assignments.'
            },
            hamiltonian: {
                name: 'Hamiltonian Cycle',
                nodes: 10,
                edges: 15,
                classicalComplexity: 'n!',
                unnsComplexity: 'n^3',
                description: 'Recursive embedding of edges. Isomorphic substructures collapse into polynomial attractors.'
            },
            tsp: {
                name: 'Traveling Salesman',
                cities: 12,
                routes: 479001600,
                classicalComplexity: '(n-1)!/2',
                unnsComplexity: 'n^2.5',
                description: 'City permutations as recursive cycles. Symmetric tours collapse under normalization.'
            }
        };

        // Canvas Setup
        const bgCanvas = document.getElementById('background-canvas');
        const bgCtx = bgCanvas.getContext('2d');
        const embeddingCanvas = document.getElementById('embedding-canvas');
        const embeddingCtx = embeddingCanvas.getContext('2d');
        const collapseCanvas = document.getElementById('collapse-canvas');
        const collapseCtx = collapseCanvas.getContext('2d');

        function resizeCanvases() {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
            
            embeddingCanvas.width = embeddingCanvas.offsetWidth;
            embeddingCanvas.height = embeddingCanvas.offsetHeight;
            
            collapseCanvas.width = collapseCanvas.offsetWidth;
            collapseCanvas.height = collapseCanvas.offsetHeight;
        }

        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        // Background Animation
        function animateBackground() {
            bgCtx.fillStyle = 'rgba(10, 10, 10, 0.05)';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            // Draw recursive lattice lines
            bgCtx.strokeStyle = 'rgba(0, 255, 136, 0.1)';
            bgCtx.lineWidth = 1;
            
            const time = Date.now() * 0.0001;
            for (let i = 0; i < 10; i++) {
                bgCtx.beginPath();
                const y = (bgCanvas.height / 10) * i + Math.sin(time + i) * 20;
                bgCtx.moveTo(0, y);
                
                for (let x = 0; x < bgCanvas.width; x += 10) {
                    const offsetY = Math.sin(x * 0.01 + time + i) * 10;
                    bgCtx.lineTo(x, y + offsetY);
                }
                bgCtx.stroke();
            }

            requestAnimationFrame(animateBackground);
        }

        // Embedding Visualization
        function drawEmbedding() {
            embeddingCtx.fillStyle = 'rgba(15, 15, 15, 0.1)';
            embeddingCtx.fillRect(0, 0, embeddingCanvas.width, embeddingCanvas.height);

            const centerX = embeddingCanvas.width / 2;
            const centerY = embeddingCanvas.height / 2;
            const time = Date.now() * 0.001;

            // Draw recursive nests based on current problem
            if (state.currentProblem === 'sat') {
                drawSATNests(centerX, centerY, time);
            } else if (state.currentProblem === 'hamiltonian') {
                drawHamiltonianGraph(centerX, centerY, time);
            } else if (state.currentProblem === 'tsp') {
                drawTSPCities(centerX, centerY, time);
            }

            // Update metrics with animation
            state.recursiveDepth = Math.floor(5 + Math.sin(time) * 2);
            state.latticeWidth = Math.floor(8 + Math.cos(time * 0.8) * 3);
            state.nestingLevel = Math.floor(3 + Math.sin(time * 1.2) * 1);
            
            document.getElementById('recursive-depth').textContent = state.recursiveDepth;
            document.getElementById('lattice-width').textContent = state.latticeWidth;
            document.getElementById('nesting-level').textContent = state.nestingLevel;
        }

        function drawSATNests(cx, cy, time) {
            const clauses = problems.sat.clauses;
            
            for (let i = 0; i < clauses; i++) {
                const angle = (i / clauses) * Math.PI * 2;
                const radius = 80 + Math.sin(time + i) * 20;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                
                // Draw nested rectangles for clauses
                for (let j = 0; j < 3; j++) {
                    embeddingCtx.strokeStyle = `rgba(0, 255, 136, ${0.8 - j * 0.2})`;
                    embeddingCtx.strokeRect(x - 20 + j * 5, y - 20 + j * 5, 40 - j * 10, 40 - j * 10);
                }
                
                // Draw connections
                if (i > 0) {
                    const prevAngle = ((i - 1) / clauses) * Math.PI * 2;
                    const prevX = cx + Math.cos(prevAngle) * radius;
                    const prevY = cy + Math.sin(prevAngle) * radius;
                    
                    embeddingCtx.strokeStyle = 'rgba(138, 43, 226, 0.3)';
                    embeddingCtx.beginPath();
                    embeddingCtx.moveTo(prevX, prevY);
                    embeddingCtx.quadraticCurveTo(cx, cy, x, y);
                    embeddingCtx.stroke();
                }
            }
        }

        function drawHamiltonianGraph(cx, cy, time) {
            const nodes = problems.hamiltonian.nodes;
            const nodePositions = [];
            
            // Draw nodes
            for (let i = 0; i < nodes; i++) {
                const angle = (i / nodes) * Math.PI * 2;
                const radius = 100;
                const x = cx + Math.cos(angle + time * 0.1) * radius;
                const y = cy + Math.sin(angle + time * 0.1) * radius;
                
                nodePositions.push({ x, y });
                
                // Pulsing nodes
                const pulseRadius = 5 + Math.sin(time * 2 + i) * 2;
                embeddingCtx.fillStyle = 'rgba(255, 0, 255, 0.8)';
                embeddingCtx.beginPath();
                embeddingCtx.arc(x, y, pulseRadius, 0, Math.PI * 2);
                embeddingCtx.fill();
            }
            
            // Draw edges with recursive embedding visualization
            embeddingCtx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
            for (let i = 0; i < nodes; i++) {
                for (let j = i + 1; j < nodes; j++) {
                    if (Math.random() < 0.3) {
                        embeddingCtx.beginPath();
                        embeddingCtx.moveTo(nodePositions[i].x, nodePositions[i].y);
                        embeddingCtx.lineTo(nodePositions[j].x, nodePositions[j].y);
                        embeddingCtx.stroke();
                    }
                }
            }
        }

        function drawTSPCities(cx, cy, time) {
            const cities = problems.tsp.cities;
            const cityPositions = [];
            
            // Generate city positions
            for (let i = 0; i < cities; i++) {
                const angle = (i / cities) * Math.PI * 2;
                const radius = 90 + Math.sin(i * 1.5) * 30;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                
                cityPositions.push({ x, y });
                
                // Draw city
                embeddingCtx.fillStyle = 'rgba(0, 255, 136, 0.8)';
                embeddingCtx.fillRect(x - 4, y - 4, 8, 8);
            }
            
            // Draw current tour with animation
            embeddingCtx.strokeStyle = 'rgba(255, 0, 255, 0.6)';
            embeddingCtx.beginPath();
            for (let i = 0; i <= cities; i++) {
                const idx = i % cities;
                const city = cityPositions[idx];
                if (i === 0) {
                    embeddingCtx.moveTo(city.x, city.y);
                } else {
                    embeddingCtx.lineTo(city.x, city.y);
                }
            }
            embeddingCtx.stroke();
        }

        // Collapse Visualization
        function drawCollapseAnimation() {
            collapseCtx.fillStyle = 'rgba(15, 15, 15, 0.05)';
            collapseCtx.fillRect(0, 0, collapseCanvas.width, collapseCanvas.height);

            const time = Date.now() * 0.001;
            const centerX = collapseCanvas.width / 2;
            const centerY = collapseCanvas.height / 2;

            // Draw exponential branching
            collapseCtx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const startRadius = 30;
                const endRadius = 120;
                
                collapseCtx.beginPath();
                collapseCtx.moveTo(
                    centerX + Math.cos(angle) * startRadius,
                    centerY + Math.sin(angle) * startRadius
                );
                
                // Branch out exponentially
                for (let j = 1; j <= 3; j++) {
                    const branchAngle = angle + (Math.random() - 0.5) * 0.5;
                    const branchRadius = startRadius + (endRadius - startRadius) * (j / 3);
                    collapseCtx.lineTo(
                        centerX + Math.cos(branchAngle) * branchRadius,
                        centerY + Math.sin(branchAngle) * branchRadius
                    );
                }
                collapseCtx.stroke();
            }

            // Draw attractors (collapsed states)
            const attractorCount = Math.floor(3 + Math.sin(time * 0.5) * 2);
            state.attractorCount = attractorCount;
            
            for (let i = 0; i < attractorCount; i++) {
                const angle = (i / attractorCount) * Math.PI * 2;
                const radius = 60;
                const x = centerX + Math.cos(angle + time * 0.2) * radius;
                const y = centerY + Math.sin(angle + time * 0.2) * radius;
                
                // Pulsing attractor
                const pulseSize = 15 + Math.sin(time * 3 + i) * 5;
                collapseCtx.fillStyle = 'rgba(0, 255, 136, 0.6)';
                collapseCtx.beginPath();
                collapseCtx.arc(x, y, pulseSize, 0, Math.PI * 2);
                collapseCtx.fill();
                
                // Inner core
                collapseCtx.fillStyle = 'rgba(255, 0, 255, 0.8)';
                collapseCtx.beginPath();
                collapseCtx.arc(x, y, pulseSize * 0.3, 0, Math.PI * 2);
                collapseCtx.fill();
            }

            // Update complexity metrics
            document.getElementById('attractor-count').textContent = attractorCount;
            const ratio = (attractorCount / 20).toFixed(2);
            document.getElementById('collapse-ratio').textContent = ratio;
        }

        // Animation Loop
        function animate() {
            state.animationFrame++;
            drawEmbedding();
            drawCollapseAnimation();
            requestAnimationFrame(animate);
        }

        // Event Handlers
        document.querySelectorAll('.problem-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.problem-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.currentProblem = btn.dataset.problem;
                updateProblemAnalysis();
                updateComplexityMetrics();
            });
        });

        document.querySelectorAll('.operator').forEach(op => {
            op.addEventListener('click', (e) => {
                document.querySelectorAll('.operator').forEach(o => o.classList.remove('active'));
                op.classList.add('active');
                state.currentOperator = op.dataset.operator;
                applyOperator();
            });
        });

        document.getElementById('apply-repair').addEventListener('click', () => {
            applyRepair();
        });

        document.getElementById('normalize').addEventListener('click', () => {
            normalize();
        });

        document.getElementById('collapse-rate').addEventListener('input', (e) => {
            document.getElementById('collapse-value').textContent = e.target.value + '%';
        });

        // Functions
        function updateProblemAnalysis() {
            const problem = problems[state.currentProblem];
            const analysisDiv = document.getElementById('problem-analysis');
            
            analysisDiv.innerHTML = `
                <h3>${problem.name}</h3>
                <p style="color: #00ff88; margin: 10px 0;">${problem.description}</p>
                <div style="display: flex; gap: 20px; margin-top: 15px;">
                    <div>
                        <strong>Classical Approach:</strong><br>
                        <span style="color: #ff0000;">Exponential search space</span><br>
                        <span style="color: #ff0000;">Complexity: ${problem.classicalComplexity}</span>
                    </div>
                    <div>
                        <strong>UNNS Approach:</strong><br>
                        <span style="color: #00ff88;">Recursive embedding</span><br>
                        <span style="color: #00ff88;">Collapsed complexity: ${problem.unnsComplexity}</span>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: rgba(138, 43, 226, 0.1); border-left: 3px solid #8a2be2;">
                    <strong>Key Insight:</strong> Equivalence classes under Repair/Normalization reduce the effective state space from exponential to polynomial.
                </div>
            `;
        }

        function updateComplexityMetrics() {
            const problem = problems[state.currentProblem];
            document.getElementById('classical-complexity').textContent = problem.classicalComplexity;
            document.getElementById('unns-complexity').textContent = problem.unnsComplexity;
        }

        function applyOperator() {
            // Visual feedback for operator application
            const operator = state.currentOperator;
            console.log(`Applying ${operator} operator...`);
            
            // Add visual effects based on operator
            switch(operator) {
                case 'inlet':
                    state.recursiveDepth++;
                    break;
                case 'inlay':
                    state.latticeWidth++;
                    break;
                case 'repair':
                    state.attractorCount = Math.max(1, state.attractorCount - 1);
                    break;
                case 'collapse':
                    state.attractorCount = Math.min(3, state.attractorCount);
                    break;
            }
        }

        function applyRepair() {
            // Animate repair process
            console.log('Applying repair normalization...');
            state.attractorCount = Math.max(2, state.attractorCount - 2);
        }

        function normalize() {
            // Animate normalization
            console.log('Normalizing substrate...');
            state.attractorCount = 3;
        }

        // Initialize
        updateProblemAnalysis();
        updateComplexityMetrics();
        animateBackground();
        animate();
    </script>
</body>
</html>