<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS Simulation Showcase</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.2em;
            background: linear-gradient(45deg, #00d4ff, #7b2cbf, #ff006e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            font-weight: 700;
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .tab-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .tab-btn {
            padding: 12px 30px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: #a0a0a0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.9em;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
            border-color: #00d4ff;
            color: white;
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.04);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            height: fit-content;
            max-height: 85vh;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #00d4ff;
            font-weight: 600;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .control-group input[type="number"], .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 0.9em;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #ff006e;
            font-weight: bold;
            font-size: 0.85em;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 10px 18px;
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-size: 0.8em;
            letter-spacing: 0.5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        button.secondary {
            background: linear-gradient(135deg, #ff006e, #d62828);
        }

        button.secondary:hover {
            box-shadow: 0 5px 20px rgba(255, 0, 110, 0.4);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 12px;
        }

        .preset-buttons button {
            background: rgba(255, 255, 255, 0.08);
            font-size: 0.75em;
            padding: 8px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.04);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .info-card .label {
            color: #a0a0a0;
            font-size: 0.75em;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-card .value {
            color: #00d4ff;
            font-size: 1.3em;
            font-weight: bold;
        }

        .mode-indicator {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(0, 212, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid #00d4ff;
            font-weight: 600;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: pulse 2s ease-in-out infinite;
            z-index: 10;
        }

        .mode-indicator.reverse {
            background: rgba(255, 0, 110, 0.2);
            border-color: #ff006e;
        }

        .legend-window {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 180px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            padding: 12px;
            z-index: 15;
            cursor: move;
            user-select: none;
        }

        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.3);
        }

        .legend-title {
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-toggle {
            background: none;
            border: none;
            color: #00d4ff;
            font-size: 14px;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
        }

        .legend-toggle:hover {
            color: #ff006e;
        }

        .legend-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .legend-content.collapsed {
            display: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-line {
            width: 25px;
            height: 3px;
            border-radius: 2px;
        }

        .legend-line.state {
            background: #00d4ff;
            box-shadow: 0 0 5px rgba(0, 212, 255, 0.5);
        }

        .legend-line.energy {
            background: #ff006e;
            height: 2px;
            box-shadow: 0 0 5px rgba(255, 0, 110, 0.5);
        }

        .legend-line.stability {
            background: linear-gradient(90deg, #ffd700, #00d4ff);
            height: 6px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, #00d4ff, transparent);
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.8);
        }

        .legend-label {
            color: #cccccc;
            font-size: 10px;
            flex: 1;
        }

        .legend-note {
            color: #999999;
            font-size: 8px;
            margin-left: 33px;
            margin-top: -6px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .guide-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 55px;
            height: 55px;
            background: linear-gradient(135deg, #7b2cbf, #ff006e);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 5px 25px rgba(123, 44, 191, 0.5);
            transition: all 0.3s ease;
            z-index: 1000;
            font-size: 1.4em;
            color: white;
        }

        .guide-button:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 35px rgba(123, 44, 191, 0.7);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 35px;
            border-radius: 20px;
            max-width: 850px;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid rgba(0, 212, 255, 0.3);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }

        .modal-content h2 {
            color: #00d4ff;
            margin-bottom: 18px;
            font-size: 1.7em;
        }

        .modal-content h3 {
            color: #ff006e;
            margin-top: 22px;
            margin-bottom: 12px;
            font-size: 1.2em;
        }

        .modal-content p, .modal-content li {
            line-height: 1.7;
            margin-bottom: 12px;
            color: #c0c0c0;
        }

        .modal-content ul {
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .modal-content a {
            color: #00d4ff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .modal-content a:hover {
            color: #ff006e;
            text-decoration: underline;
        }

        .close-modal {
            float: right;
            font-size: 1.8em;
            cursor: pointer;
            color: #ff006e;
            line-height: 1;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            transform: rotate(90deg);
            color: #00d4ff;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            color: #00d4ff;
            margin: 12px 0;
            border-left: 3px solid #7b2cbf;
            font-size: 0.9em;
        }

        .glue-diagram {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .glue-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(0, 212, 255, 0.3);
            text-align: center;
        }

        .glue-box.twist {
            border-color: rgba(255, 0, 110, 0.3);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
            border-radius: 4px;
        }

        h3.section-title {
            color: #00d4ff;
            margin-bottom: 15px;
            margin-top: 20px;
            font-size: 0.95em;
            border-bottom: 1px solid rgba(0, 212, 255, 0.3);
            padding-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>⟂ UNNS Simulation Showcase</h1>
            <p class="subtitle">Temporal Recursion Engine • Klein Surface Mapper</p>
        </header>

        <div class="tab-nav">
            <div class="tab-btn active" onclick="switchTab('tre')">TRE — Temporal Recursion</div>
            <div class="tab-btn" onclick="switchTab('ksm')">KSM — Klein Surface</div>
        </div>

        <!-- TRE TAB -->
        <div id="tre-tab" class="tab-content active">
            <div class="main-grid">
                <div class="controls-panel">
                    <h3 class="section-title">Recursion Parameters</h3>
                    
                    <div class="control-group">
                        <label>Damping (α) <span class="value-display" id="alphaVal">0.95</span></label>
                        <input type="range" id="alpha" min="0.5" max="1.0" step="0.01" value="0.95">
                    </div>

                    <div class="control-group">
                        <label>Coupling (β) <span class="value-display" id="betaVal">0.5</span></label>
                        <input type="range" id="beta" min="0.1" max="2.0" step="0.1" value="0.5">
                    </div>

                    <div class="control-group">
                        <label>Drift (δ) <span class="value-display" id="deltaVal">0.01</span></label>
                        <input type="range" id="delta" min="0" max="0.1" step="0.001" value="0.01">
                    </div>

                    <div class="control-group">
                        <label>Noise (σ) <span class="value-display" id="noiseVal">0.05</span></label>
                        <input type="range" id="noise" min="0" max="0.2" step="0.01" value="0.05">
                    </div>

                    <div class="control-group">
                        <label>Steps</label>
                        <input type="number" id="steps" min="100" max="2000" value="500">
                    </div>

                    <div class="control-group">
                        <label>Initial a₀</label>
                        <input type="number" id="a0" step="0.1" value="1.0">
                    </div>

                    <div class="control-group">
                        <label>Initial a₁</label>
                        <input type="number" id="a1" step="0.1" value="0.5">
                    </div>

                    <h3 class="section-title">Timeline Scrubber</h3>
                    <div class="control-group">
                        <label>Depth Position <span class="value-display" id="scrubberVal">0</span></label>
                        <input type="range" id="timeScrubber" min="0" max="500" value="0" disabled>
                    </div>

                    <div class="button-group">
                        <button id="forwardBtn">▶ Forward</button>
                        <button id="reverseBtn" class="secondary">◀ Reverse</button>
                        <button id="resetBtn">⟳ Reset</button>
                        <button id="pauseBtn">⏸ Pause</button>
                        <button onclick="exportTREData()">💾 Export</button>
                        <button onclick="toggleHeatmap()">🔥 Heatmap</button>
                    </div>

                    <h3 class="section-title">Presets</h3>
                    <div class="preset-buttons">
                        <button onclick="loadTREPreset('stable')">Stable Attractor</button>
                        <button onclick="loadTREPreset('chaotic')">Chaotic Regime</button>
                        <button onclick="loadTREPreset('periodic')">Periodic Orbit</button>
                        <button onclick="loadTREPreset('klein')">Klein Resonance</button>
                    </div>
                </div>

                <div class="canvas-container">
                    <div class="mode-indicator" id="modeIndicator">Forward Recursion</div>
                    <div class="legend-window" id="treLegend">
                        <div class="legend-header">
                            <div class="legend-title">Legend</div>
                            <button class="legend-toggle" onclick="toggleTRELegend()">−</button>
                        </div>
                        <div class="legend-content" id="treLegendContent">
                            <div class="legend-item">
                                <div class="legend-line state"></div>
                                <div class="legend-label">State a_n</div>
                            </div>
                            <div class="legend-item">
                                <div class="legend-line energy"></div>
                                <div class="legend-label">Energy E_n</div>
                            </div>
                            <div class="legend-item">
                                <div class="legend-line stability"></div>
                                <div class="legend-label">Stability</div>
                            </div>
                            <div class="legend-note">(bright = stable)</div>
                            <div class="legend-item">
                                <div class="legend-dot" id="legendDot"></div>
                                <div class="legend-label">Current</div>
                            </div>
                        </div>
                    </div>
                    <canvas id="treCanvas"></canvas>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-card">
                    <div class="label">Depth (n)</div>
                    <div class="value" id="depthDisplay">0</div>
                </div>
                <div class="info-card">
                    <div class="label">Energy (E)</div>
                    <div class="value" id="energyDisplay">0.00</div>
                </div>
                <div class="info-card">
                    <div class="label">Stability</div>
                    <div class="value" id="stabilityDisplay">0.00</div>
                </div>
                <div class="info-card">
                    <div class="label">State a_n</div>
                    <div class="value" id="stateDisplay">0.00</div>
                </div>
            </div>
        </div>

        <!-- KSM TAB -->
        <div id="ksm-tab" class="tab-content">
            <div class="main-grid">
                <div class="controls-panel">
                    <h3 class="section-title">Klein Parameters</h3>
                    
                    <div class="control-group">
                        <label>Rotation Speed</label>
                        <input type="range" id="ksmRotSpeed" min="0" max="0.05" step="0.001" value="0.01">
                    </div>

                    <div class="control-group">
                        <label>Flow Density</label>
                        <input type="range" id="ksmFlowDensity" min="10" max="100" step="5" value="40">
                    </div>

                    <div class="control-group">
                        <label>Twist Factor</label>
                        <input type="range" id="ksmTwist" min="0" max="2" step="0.1" value="1">
                    </div>

                    <div class="button-group">
                        <button onclick="resetKSMView()">Reset View</button>
                        <button id="ksmFlowBtn" onclick="toggleKSMFlow()">Pause Flow</button>
                    </div>

                    <h3 class="section-title">Gluing Diagram</h3>
                    <div class="glue-diagram">
                        <div class="glue-box">
                            <strong style="color: #00d4ff;">[A] Cycle</strong>
                            <p style="font-size: 0.85em; margin-top: 8px;">Vertical: (θ, 0) ~ (θ, 1)</p>
                            <p style="font-size: 0.75em; color: #a0a0a0;">Orientation preserving</p>
                        </div>
                        <div class="glue-box twist">
                            <strong style="color: #ff006e;">[B] Cycle</strong>
                            <p style="font-size: 0.85em; margin-top: 8px;">Horizontal: (0, y) ~ (1, 1-y)</p>
                            <p style="font-size: 0.75em; color: #a0a0a0;">Orientation reversing (twist)</p>
                        </div>
                    </div>

                    <h3 class="section-title">Operator Mapping</h3>
                    <div style="font-size: 0.8em; line-height: 1.6; color: #c0c0c0;">
                        <p><strong style="color: #00d4ff;">Inletting:</strong> A-loop influx</p>
                        <p><strong style="color: #ff006e;">Inlaying:</strong> B-loop inversion</p>
                        <p><strong style="color: #7b2cbf;">Repair/Normalize:</strong> Seam coherence</p>
                        <p><strong style="color: #00d4ff;">Trans-Sentifying:</strong> Neck traversal</p>
                    </div>
                </div>

                <div class="canvas-container">
                    <div class="mode-indicator">Klein Bottle</div>
                    <div id="ksmContainer" style="width: 100%; height: 500px;"></div>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-card">
                    <div class="label">Topology</div>
                    <div class="value" style="font-size: 1em;">Non-Orientable</div>
                </div>
                <div class="info-card">
                    <div class="label">Stiefel-Whitney</div>
                    <div class="value">w₁ ≠ 0</div>
                </div>
                <div class="info-card">
                    <div class="label">Euler Char.</div>
                    <div class="value">χ = 0</div>
                </div>
                <div class="info-card">
                    <div class="label">Cycles</div>
                    <div class="value">[A] ⊕ [B]</div>
                </div>
            </div>
        </div>
    </div>

    <div class="guide-button" id="guideBtn">?</div>

    <div class="modal" id="guideModal">
        <div class="modal-content">
            <span class="close-modal" id="closeModal">&times;</span>
            <h2>UNNS Simulation Showcase — Guide</h2>
            
            <h3>What is UNNS?</h3>
            <p>The Unbounded Nested Number Sequences (UNNS) framework is a mathematical substrate where continuous differential equations are replaced with discrete recursive operations. Time is measured as recursion depth (n ∈ ℕ) rather than a continuous parameter (t ∈ ℝ).</p>

            <h3>System Architecture</h3>
            <p>The UNNS Simulation Showcase v1.0 integrates two complementary modules:</p>
            <ul>
                <li><strong>TRE (Temporal Recursion Engine):</strong> Simulates forward and reverse UNNS recursion with real-time stability analysis</li>
                <li><strong>KSM (Klein Surface Mapper):</strong> Embeds recursion trajectories onto a dynamic non-orientable manifold</li>
                <li><strong>Coupling Architecture:</strong> Numeric recursion and geometric deformation as dual projections of the same process</li>
            </ul>

            <h3>1. TRE — Temporal Recursion Engine</h3>
            <h4>Recursion Equation</h4>
            <div class="equation">
                Forward: a_{n+1} = α·a_n + β·tanh(a_{n-1}) + δ·n + σ·ε_n<br>
                Reverse: a_{n-1} = atanh((a_{n+1} - α·a_n - δ·n) / β)
            </div>
            <p>Where α is damping/persistence, β is coupling coefficient, δ is drift (time-dependent forcing), and σε_n is stochastic perturbation.</p>

            <h4>Core Features</h4>
            <ul>
                <li><strong>Forward Recursion:</strong> Expands the temporal cone through iterative operator application</li>
                <li><strong>Reverse Recursion:</strong> Requires local invertibility condition |(a_{n+1} - αa_n - δn)/β| < 1</li>
                <li><strong>Stability Analysis:</strong> Jacobian magnitude J_n = √((∂F/∂a_n)² + (∂F/∂a_{n-1})²)</li>
                <li><strong>Energy Tracking:</strong> E_n = ½a_n² visualizes dissipation vs conservation</li>
                <li><strong>Parameter Space Heatmap:</strong> 2D visualization of Jacobian across (α, β) space</li>
            </ul>

            <h4>Reversibility Domain</h4>
            <p>The inverse operator F⁻¹ exists only when the transformation is locally invertible. When this condition fails, it represents entropy increase and information loss—the forward recursion becomes irreversible.</p>

            <h3>TRE Controls</h3>
            <ul>
                <li><strong>Damping (α):</strong> Controls energy loss per step. α = 1 preserves energy; α < 1 causes decay.</li>
                <li><strong>Coupling (β):</strong> Nonlinear feedback strength via tanh. Higher β creates richer dynamics.</li>
                <li><strong>Drift (δ):</strong> Linear time-dependent forcing term.</li>
                <li><strong>Noise (σ):</strong> Stochastic perturbations; high noise breaks reversibility.</li>
            </ul>

            <h3>TRE Presets</h3>
            <ul>
                <li><strong>Stable Attractor:</strong> Strong damping (α = 0.85), converges to fixed point.</li>
                <li><strong>Chaotic Regime:</strong> High coupling (β = 1.5), sensitive dependence on initial conditions.</li>
                <li><strong>Periodic Orbit:</strong> Minimal damping (α = 1.0), resonant parameters creating cycles.</li>
                <li><strong>Klein Resonance:</strong> Parameters tuned for two-step parity-locked oscillation (α = 0.99, opposite-sign initial conditions).</li>
            </ul>

            <h3>2. KSM — Klein Surface Mapper</h3>
            <h4>Topological Structure</h4>
            <p>The Klein bottle is a non-orientable manifold with the identification:</p>
            <div class="equation">
                (θ, 0) ~ (θ, 1)  [A-cycle: periodic]<br>
                (0, y) ~ (1, 1-y)  [B-cycle: twisted]
            </div>
            <p>This yields w₁ ≠ 0 (first Stiefel-Whitney class nonzero), indicating global non-orientability.</p>

            <h4>Parametric Embedding</h4>
            <p>The surface is parametrized by (u,v) ∈ [0,2π]²:</p>
            <div class="equation">
                x = (r + a·cos v)·cos u<br>
                y = (r + a·cos v)·sin u<br>
                z = a·sin v·cos(u/2)
            </div>
            <p>Where r = 2 (major radius), a = 1 (minor radius). The factor cos(u/2) creates the characteristic twist.</p>

            <h4>Flow Field Dynamics</h4>
            <p>Particles advect along the surface with velocity u̇ = ωᵤ, where ωᵤ varies with TRE energy, simulating transport along the A-cycle (orientation-preserving direction).</p>

            <h3>TRE → KSM Coupling</h3>
            <p>The coupling architecture demonstrates how numeric recursion can drive geometric deformation:</p>
            <div class="equation">
                scale = 1 + 0.15·sin(n × 0.05)<br>
                hue = f(E_n / E_max)<br>
                emissive = g(E_n, depth)
            </div>
            <ul>
                <li><strong>Scale breathing:</strong> Surface expands/contracts with recursion depth</li>
                <li><strong>Color modulation:</strong> Shifts from cyan (low energy) to magenta (high energy)</li>
                <li><strong>Emissive intensity:</strong> Glows brighter during high-energy states</li>
                <li><strong>Rotation speed:</strong> ω = 0.003 + 0.002·E_norm accelerates with energy</li>
            </ul>

            <h3>Theoretical Correspondences</h3>
            <ul>
                <li><strong>Temporal recursion ↔ surface flow:</strong> Each depth increment = infinitesimal displacement</li>
                <li><strong>Invertibility ↔ orientability:</strong> Non-invertible recursion maps to non-orientable phase space</li>
                <li><strong>Energy decay ↔ metric contraction:</strong> Damping compresses surface volume</li>
                <li><strong>Stability cone ↔ recursion cone:</strong> Jacobian visualized as causal spread angle</li>
            </ul>

            <h3>Interactive Features</h3>
            <ul>
                <li><strong>Timeline Scrubber:</strong> Manual depth navigation for detailed exploration</li>
                <li><strong>Heatmap Toggle:</strong> Switch between trajectory view and parameter space analysis</li>
                <li><strong>Global Pause (Spacebar):</strong> Synchronized pause across TRE and KSM modules</li>
                <li><strong>Data Export:</strong> JSON export for reproducibility and external analysis</li>
                <li><strong>Draggable Legend:</strong> Collapsible, movable color guide</li>
            </ul>

            <h3>Foundational Papers & Technical Documentation</h3>
            <ul>
                <li><a href="https://ukbbi.github.io/UNNS/docs/chronotopos/temporal_recursion/On the Possibility of Temporal Recursion in the UNNS Substrate.pdf" target="_blank">On the Possibility of Temporal Recursion in the UNNS Substrate</a></li>
                <li><a href="https://ukbbi.github.io/UNNS/docs/chronotopos/temporal_recursion/Temporal Recursion in the UNNS Substrate and Its Klein Surface Realization.pdf" target="_blank">Temporal Recursion and Klein Surface Realization</a></li>
                <li><a href="https://ukbbi.github.io/UNNS/docs/chronotopos/temporal_recursion/UNNS and the Klein Surface.pdf" target="_blank">UNNS and the Klein Surface: Non-Orientable Recursion</a></li>
                <li><a href="https://ukbbi.github.io/UNNS/docs/chronotopos/temporal_recursion/Technical Appendix_UNNS Simulation Showcase .pdf" target="_blank">Technical Appendix: UNNS Simulation Showcase v1.0</a></li>
            </ul>

            <h3>Implementation Summary</h3>
            <p><strong>Technologies:</strong> JavaScript (ES6), Canvas 2D API, WebGL (Three.js r128)</p>
            <p><strong>Architecture:</strong> Event-driven modular design with TRE→KSM coupling pipeline</p>
            <p><strong>Performance:</strong> requestAnimationFrame synchronization at ~60 FPS</p>
            <p><strong>Data Model:</strong> JSON-serializable state for reproducibility</p>

            <h3>Core Principles</h3>
            <ul>
                <li><strong>Recursion depth as time:</strong> n ∈ ℕ replaces continuous t ∈ ℝ</li>
                <li><strong>Operator invertibility:</strong> F⁻¹ exists only when mapping is bijective and information preserved</li>
                <li><strong>Non-orientability:</strong> Global time arrow obstructed by topology when w₁ ≠ 0</li>
                <li><strong>Local vs. Global:</strong> Temporal recursion can exist locally while being globally constrained by topology</li>
            </ul>
        </div>
    </div>

    <script>
        // ==================== TAB SWITCHING ====================
        function switchTab(tab) {
            const tabs = ['tre', 'ksm'];
            tabs.forEach(t => {
                document.getElementById(`${t}-tab`).classList.toggle('active', t === tab);
                const btn = document.querySelector(`.tab-btn[onclick="switchTab('${t}')"]`);
                btn.classList.toggle('active', t === tab);
            });
            
            if (tab === 'ksm' && !window.ksmInitialized) {
                initKSM();
            }
        }

        // ==================== TRE MODULE ====================
        const treCanvas = document.getElementById('treCanvas');
        const treCtx = treCanvas.getContext('2d');
        treCanvas.width = treCanvas.offsetWidth;
        treCanvas.height = treCanvas.offsetHeight;

        let treSequence = [];
        let treEnergies = [];
        let treStabilities = [];
        let treCurrentStep = 0;
        let treIsForward = true;
        let treIsPaused = false;
        let treAnimationId = null;
        let treHeatmapMode = false;

        let treParams = {
            alpha: 0.95,
            beta: 0.5,
            delta: 0.01,
            noise: 0.05,
            steps: 500,
            a0: 1.0,
            a1: 0.5
        };

        function updateTREDisplays() {
            document.getElementById('alphaVal').textContent = treParams.alpha.toFixed(2);
            document.getElementById('betaVal').textContent = treParams.beta.toFixed(2);
            document.getElementById('deltaVal').textContent = treParams.delta.toFixed(3);
            document.getElementById('noiseVal').textContent = treParams.noise.toFixed(2);
        }

        document.getElementById('alpha').addEventListener('input', (e) => {
            treParams.alpha = parseFloat(e.target.value);
            updateTREDisplays();
        });

        document.getElementById('beta').addEventListener('input', (e) => {
            treParams.beta = parseFloat(e.target.value);
            updateTREDisplays();
        });

        document.getElementById('delta').addEventListener('input', (e) => {
            treParams.delta = parseFloat(e.target.value);
            updateTREDisplays();
        });

        document.getElementById('noise').addEventListener('input', (e) => {
            treParams.noise = parseFloat(e.target.value);
            updateTREDisplays();
        });

        document.getElementById('steps').addEventListener('input', (e) => {
            treParams.steps = parseInt(e.target.value);
        });

        document.getElementById('a0').addEventListener('input', (e) => {
            treParams.a0 = parseFloat(e.target.value);
        });

        document.getElementById('a1').addEventListener('input', (e) => {
            treParams.a1 = parseFloat(e.target.value);
        });

        // Timeline scrubber
        const timeScrubber = document.getElementById('timeScrubber');
        timeScrubber.addEventListener('input', (e) => {
            if (treSequence.length === 0) return;
            treCurrentStep = parseInt(e.target.value);
            document.getElementById('scrubberVal').textContent = treCurrentStep;
            treDraw();
        });

        function treForwardStep(an, an1, n) {
            const noise = (Math.random() - 0.5) * 2 * treParams.noise;
            return treParams.alpha * an + treParams.beta * Math.tanh(an1) + treParams.delta * n + noise;
        }

        function treReverseStep(an1, an, n) {
            try {
                const arg = (an1 - treParams.alpha * an - treParams.delta * n) / treParams.beta;
                // Clamp to prevent NaN from atanh domain overflow
                const clamped = Math.max(-0.999999, Math.min(0.999999, arg));
                return Math.atanh(clamped);
            } catch {
                return null;
            }
        }

        function treCalcEnergy(a) {
            return 0.5 * a * a;
        }

        function treCalcStability(an, an1) {
            const dF_dan = treParams.alpha;
            const dF_dan1 = treParams.beta * (1 - Math.tanh(an1) ** 2);
            return Math.sqrt(dF_dan ** 2 + dF_dan1 ** 2);
        }

        function treInitSequence() {
            treSequence = [treParams.a0, treParams.a1];
            treEnergies = [treCalcEnergy(treParams.a0), treCalcEnergy(treParams.a1)];
            treStabilities = [treCalcStability(treParams.a1, treParams.a0)];
            treCurrentStep = 1;
        }

        function treGenerateForward() {
            treInitSequence();
            for (let n = 2; n < treParams.steps; n++) {
                const an = treForwardStep(treSequence[n-1], treSequence[n-2], n);
                treSequence.push(an);
                treEnergies.push(treCalcEnergy(an));
                treStabilities.push(treCalcStability(an, treSequence[n-1]));
            }
            
            // Enable and configure timeline scrubber
            timeScrubber.max = treSequence.length - 1;
            timeScrubber.value = 0;
            timeScrubber.disabled = false;
        }

        function treDraw() {
            const w = treCanvas.width;
            const h = treCanvas.height;
            
            treCtx.fillStyle = 'rgba(13, 17, 23, 0.15)';
            treCtx.fillRect(0, 0, w, h);

            if (treSequence.length === 0) return;

            // Check if we should draw heatmap or regular view
            if (treHeatmapMode) {
                drawJacobianHeatmap();
                return;
            }

            treCtx.strokeStyle = 'rgba(0, 212, 255, 0.6)';
            treCtx.lineWidth = 2;
            treCtx.beginPath();

            const maxN = Math.min(treCurrentStep, treSequence.length - 1);
            const margin = 60;
            const plotW = w - 2 * margin;
            const plotH = h - 2 * margin;

            const maxVal = Math.max(...treSequence.slice(0, maxN + 1).map(Math.abs));
            const scale = plotH / (2.5 * maxVal);

            for (let i = 0; i <= maxN; i++) {
                const x = margin + (i / treParams.steps) * plotW;
                const y = h / 2 - treSequence[i] * scale;

                if (i === 0) {
                    treCtx.moveTo(x, y);
                } else {
                    treCtx.lineTo(x, y);
                }

                const stability = treStabilities[i] || 0;
                const hue = 200 - Math.min(stability * 100, 150);
                const brightness = Math.min(stability * 80, 100);
                treCtx.fillStyle = `hsla(${hue}, 100%, ${brightness}%, 0.3)`;
                treCtx.fillRect(x - 1, y - 1, 3, 3);
            }

            treCtx.stroke();

            const currX = margin + (treCurrentStep / treParams.steps) * plotW;
            const currY = h / 2 - treSequence[treCurrentStep] * scale;
            
            const gradient = treCtx.createRadialGradient(currX, currY, 0, currX, currY, 15);
            gradient.addColorStop(0, treIsForward ? 'rgba(0, 212, 255, 1)' : 'rgba(255, 0, 110, 1)');
            gradient.addColorStop(1, 'rgba(0, 212, 255, 0)');
            treCtx.fillStyle = gradient;
            treCtx.beginPath();
            treCtx.arc(currX, currY, 15, 0, Math.PI * 2);
            treCtx.fill();

            treCtx.strokeStyle = 'rgba(255, 0, 110, 0.5)';
            treCtx.lineWidth = 1.5;
            treCtx.beginPath();
            const maxEnergy = Math.max(...treEnergies);
            const eScale = (plotH * 0.3) / maxEnergy;

            for (let i = 0; i <= maxN; i++) {
                const x = margin + (i / treParams.steps) * plotW;
                const y = h - margin - treEnergies[i] * eScale;
                if (i === 0) treCtx.moveTo(x, y);
                else treCtx.lineTo(x, y);
            }
            treCtx.stroke();

            treCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            treCtx.lineWidth = 1;
            treCtx.beginPath();
            treCtx.moveTo(margin, h / 2);
            treCtx.lineTo(w - margin, h / 2);
            treCtx.stroke();

            treCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            treCtx.font = '11px monospace';
            treCtx.fillText('n →', w - margin + 10, h / 2);
            treCtx.fillText('a_n', margin - 30, h / 2);
            treCtx.fillText('E_n', w - margin - 20, h - margin + 20);

            document.getElementById('depthDisplay').textContent = treCurrentStep;
            document.getElementById('energyDisplay').textContent = treEnergies[treCurrentStep]?.toFixed(3) || '0.00';
            document.getElementById('stabilityDisplay').textContent = treStabilities[treCurrentStep]?.toFixed(3) || '0.00';
            document.getElementById('stateDisplay').textContent = treSequence[treCurrentStep]?.toFixed(3) || '0.00';
            
            // TRE → KSM coupling: update Klein surface based on TRE state
            updateKSMFromTRE();
        }

        function drawJacobianHeatmap() {
            const w = treCanvas.width;
            const h = treCanvas.height;
            const margin = 60;
            
            treCtx.fillStyle = 'rgba(13, 17, 23, 1)';
            treCtx.fillRect(0, 0, w, h);
            
            const plotW = w - 2 * margin;
            const plotH = h - 2 * margin;
            
            // Draw heatmap
            for (let i = 0; i < plotW; i++) {
                for (let j = 0; j < plotH; j++) {
                    const alpha = 0.5 + 0.5 * i / plotW;
                    const beta = 0.1 + 1.9 * j / plotH;
                    
                    // Compute Jacobian magnitude for test point
                    const testA = 1.0;
                    const dF_dan = alpha;
                    const dF_dan1 = beta * (1 - Math.tanh(testA) ** 2);
                    const jacobian = Math.sqrt(dF_dan ** 2 + dF_dan1 ** 2);
                    
                    const hue = 200 - Math.min(jacobian * 100, 150);
                    const brightness = Math.min(jacobian * 60, 80);
                    treCtx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                    treCtx.fillRect(margin + i, h - margin - j, 1, 1);
                }
            }
            
            // Draw current parameter point
            const currX = margin + (treParams.alpha - 0.5) / 0.5 * plotW;
            const currY = h - margin - (treParams.beta - 0.1) / 1.9 * plotH;
            
            treCtx.strokeStyle = '#ff006e';
            treCtx.lineWidth = 3;
            treCtx.beginPath();
            treCtx.arc(currX, currY, 8, 0, Math.PI * 2);
            treCtx.stroke();
            
            // Labels
            treCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            treCtx.font = 'bold 14px monospace';
            treCtx.fillText('Parameter Space: Jacobian Magnitude', margin, margin - 20);
            
            treCtx.font = '11px monospace';
            treCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            treCtx.fillText('α (damping) →', w - margin - 100, h - margin + 25);
            
            treCtx.save();
            treCtx.translate(margin - 40, h / 2);
            treCtx.rotate(-Math.PI / 2);
            treCtx.fillText('β (coupling) →', 0, 0);
            treCtx.restore();
            
            // Legend
            treCtx.font = '10px monospace';
            treCtx.fillText('Bright = High Stability', margin + 10, margin + 20);
            treCtx.fillText('Dark = Divergence Zone', margin + 10, margin + 35);
        }

        function updateKSMFromTRE() {
            if (!window.ksmInitialized || !ksmKlein || treSequence.length === 0) return;
            
            // Dynamic scaling based on recursion depth
            const depthFactor = Math.sin(treCurrentStep * 0.05);
            const scale = 1 + 0.15 * depthFactor;
            ksmKlein.scale.set(scale, scale, scale);
            
            // Color modulation based on energy (normalized)
            const energy = treEnergies[treCurrentStep] || 0;
            const maxEnergy = Math.max(...treEnergies) || 1;
            const eNorm = Math.min(1, Math.abs(energy) / maxEnergy);
            const hue = 0.55 - 0.35 * eNorm;
            ksmKlein.material.color.setHSL(hue, 1, 0.45 + 0.1 * eNorm);
            
            // Emissive glow pulsing with energy
            const emissiveIntensity = 0.15 + 0.15 * eNorm + 0.05 * Math.abs(depthFactor);
            ksmKlein.material.emissive = new THREE.Color().setHSL(hue + 0.1, 1, emissiveIntensity);
            ksmKlein.material.emissiveIntensity = 0.3 + 0.2 * eNorm;
            
            // Dynamic rotation speed based on energy
            ksmRotSpeed = 0.003 + 0.002 * eNorm;
        }

        function exportTREData() {
            const data = {
                metadata: {
                    timestamp: new Date().toISOString(),
                    module: 'TRE',
                    version: '1.0'
                },
                parameters: treParams,
                sequence: treSequence,
                energies: treEnergies,
                stabilities: treStabilities,
                currentStep: treCurrentStep,
                mode: treIsForward ? 'forward' : 'reverse'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `TRE_simulation_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function toggleHeatmap() {
            treHeatmapMode = !treHeatmapMode;
            const btn = event.target;
            btn.textContent = treHeatmapMode ? '📊 Trajectory' : '🔥 Heatmap';
            treDraw();
        }

        function treAnimate() {
            if (treIsPaused) return;

            if (treIsForward) {
                if (treCurrentStep < treSequence.length - 1) {
                    treCurrentStep++;
                }
            } else {
                if (treCurrentStep > 0) {
                    treCurrentStep--;
                }
            }

            // Update scrubber position
            timeScrubber.value = treCurrentStep;
            document.getElementById('scrubberVal').textContent = treCurrentStep;

            treDraw();

            if ((treIsForward && treCurrentStep < treSequence.length - 1) || 
                (!treIsForward && treCurrentStep > 0)) {
                treAnimationId = requestAnimationFrame(treAnimate);
            }
        }

        document.getElementById('forwardBtn').addEventListener('click', () => {
            treIsForward = true;
            treIsPaused = false;
            document.getElementById('modeIndicator').textContent = 'Forward Recursion';
            document.getElementById('modeIndicator').classList.remove('reverse');
            treGenerateForward();
            treCurrentStep = 0;
            if (treAnimationId) cancelAnimationFrame(treAnimationId);
            treAnimate();
        });

        document.getElementById('reverseBtn').addEventListener('click', () => {
            if (treSequence.length < 3) {
                alert('Generate forward sequence first!');
                return;
            }
            treIsForward = false;
            treIsPaused = false;
            document.getElementById('modeIndicator').textContent = 'Reverse Recursion';
            document.getElementById('modeIndicator').classList.add('reverse');
            treCurrentStep = treSequence.length - 1;
            if (treAnimationId) cancelAnimationFrame(treAnimationId);
            treAnimate();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (treAnimationId) cancelAnimationFrame(treAnimationId);
            treSequence = [];
            treEnergies = [];
            treStabilities = [];
            treCurrentStep = 0;
            treCtx.fillStyle = 'rgba(13, 17, 23, 1)';
            treCtx.fillRect(0, 0, treCanvas.width, treCanvas.height);
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            treIsPaused = !treIsPaused;
            document.getElementById('pauseBtn').textContent = treIsPaused ? '▶ Resume' : '⏸ Pause';
            if (!treIsPaused) treAnimate();
        });

        function loadTREPreset(preset) {
            if (treAnimationId) cancelAnimationFrame(treAnimationId);
            
            switch(preset) {
                case 'stable':
                    treParams = {alpha: 0.85, beta: 0.3, delta: 0.005, noise: 0.02, steps: 500, a0: 1.0, a1: 0.5};
                    break;
                case 'chaotic':
                    treParams = {alpha: 0.98, beta: 1.5, delta: 0.02, noise: 0.1, steps: 500, a0: 0.5, a1: 0.8};
                    break;
                case 'periodic':
                    treParams = {alpha: 1.0, beta: 0.5, delta: 0.0, noise: 0.0, steps: 500, a0: 1.0, a1: -1.0};
                    break;
                case 'klein':
                    treParams = {alpha: 0.99, beta: 1.0, delta: 0.0, noise: 0.01, steps: 500, a0: 0.7, a1: -0.7};
                    break;
            }
            
            document.getElementById('alpha').value = treParams.alpha;
            document.getElementById('beta').value = treParams.beta;
            document.getElementById('delta').value = treParams.delta;
            document.getElementById('noise').value = treParams.noise;
            document.getElementById('steps').value = treParams.steps;
            document.getElementById('a0').value = treParams.a0;
            document.getElementById('a1').value = treParams.a1;
            updateTREDisplays();
            
            treGenerateForward();
            treCurrentStep = 0;
            treIsForward = true;
            treIsPaused = false;
            treAnimate();
        }

        // ==================== TRE LEGEND FUNCTIONS ====================
        function toggleTRELegend() {
            const content = document.getElementById('treLegendContent');
            const btn = event.target;
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                btn.textContent = '−';
            } else {
                content.classList.add('collapsed');
                btn.textContent = '+';
            }
        }

        // Make legend draggable
        (function() {
            const legend = document.getElementById('treLegend');
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            legend.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                if (e.target.classList.contains('legend-toggle')) return;
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;

                if (e.target === legend || e.target.classList.contains('legend-header') || e.target.classList.contains('legend-title')) {
                    isDragging = true;
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    xOffset = currentX;
                    yOffset = currentY;

                    setTranslate(currentX, currentY, legend);
                }
            }

            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
            }

            function setTranslate(xPos, yPos, el) {
                el.style.transform = `translate(${xPos}px, ${yPos}px)`;
            }
        })();

        // ==================== KSM MODULE ====================
        let ksmScene, ksmCamera, ksmRenderer, ksmKlein;
        let ksmRotSpeed = 0.01;
        let ksmFlowParticles = [];
        let ksmAnimating = false;
        let ksmAnimationId = null;

        function initKSM() {
            if (window.ksmInitialized) return;
            
            const container = document.getElementById('ksmContainer');
            
            ksmScene = new THREE.Scene();
            ksmScene.background = new THREE.Color(0x0d1117);
            
            ksmCamera = new THREE.PerspectiveCamera(60, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            ksmCamera.position.set(0, 0, 8);
            
            ksmRenderer = new THREE.WebGLRenderer({ antialias: true });
            ksmRenderer.setSize(container.offsetWidth, container.offsetHeight);
            container.appendChild(ksmRenderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            ksmScene.add(ambientLight);
            
            const pointLight1 = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight1.position.set(5, 5, 5);
            ksmScene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff006e, 0.8, 100);
            pointLight2.position.set(-5, -5, 5);
            ksmScene.add(pointLight2);
            
            createKleinBottle();
            createFlowParticles();
            
            window.ksmInitialized = true;
            ksmAnimating = true;
            ksmAnimate();
        }

        // KSM resize handler
        window.addEventListener('resize', () => {
            if (ksmRenderer && ksmCamera) {
                const container = document.getElementById('ksmContainer');
                ksmRenderer.setSize(container.offsetWidth, container.offsetHeight);
                ksmCamera.aspect = container.offsetWidth / container.offsetHeight;
                ksmCamera.updateProjectionMatrix();
            }
        });

        function createKleinBottle() {
            const geometry = new THREE.ParametricGeometry((u, v, target) => {
                u *= Math.PI * 2;
                v *= Math.PI * 2;
                
                const r = 2;
                const a = 1;
                
                const x = (r + a * Math.cos(v)) * Math.cos(u);
                const y = (r + a * Math.cos(v)) * Math.sin(u);
                const z = a * Math.sin(v) * Math.cos(u / 2);
                
                target.set(x, y, z);
            }, 64, 64);
            
            const material = new THREE.MeshPhongMaterial({
                color: 0x00d4ff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                wireframe: false
            });
            
            ksmKlein = new THREE.Mesh(geometry, material);
            ksmScene.add(ksmKlein);
            
            const wireframeGeo = new THREE.WireframeGeometry(geometry);
            const wireframeMat = new THREE.LineBasicMaterial({ color: 0x7b2cbf, opacity: 0.4, transparent: true });
            const wireframe = new THREE.LineSegments(wireframeGeo, wireframeMat);
            ksmKlein.add(wireframe);
        }

        function createFlowParticles() {
            const particleGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < 40; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const r = 2;
                const a = 1;
                
                const x = (r + a * Math.cos(v)) * Math.cos(u);
                const y = (r + a * Math.cos(v)) * Math.sin(u);
                const z = a * Math.sin(v) * Math.cos(u / 2);
                
                positions.push(x, y, z);
                
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.3 + 0.5, 1, 0.5);
                colors.push(color.r, color.g, color.b);
                
                ksmFlowParticles.push({ u, v, speed: 0.01 + Math.random() * 0.02 });
            }
            
            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const particleMat = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const particles = new THREE.Points(particleGeo, particleMat);
            ksmScene.add(particles);
            
            window.ksmParticles = particles;
        }

        function ksmAnimate() {
            if (!ksmAnimating) return;
            
            ksmAnimationId = requestAnimationFrame(ksmAnimate);
            
            if (ksmKlein) {
                ksmKlein.rotation.y += ksmRotSpeed;
                ksmKlein.rotation.x += ksmRotSpeed * 0.3;
            }
            
            if (window.ksmParticles && ksmFlowParticles.length > 0) {
                const positions = window.ksmParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < ksmFlowParticles.length; i++) {
                    ksmFlowParticles[i].u += ksmFlowParticles[i].speed;
                    
                    const u = ksmFlowParticles[i].u;
                    const v = ksmFlowParticles[i].v;
                    const r = 2;
                    const a = 1;
                    
                    positions[i * 3] = (r + a * Math.cos(v)) * Math.cos(u);
                    positions[i * 3 + 1] = (r + a * Math.cos(v)) * Math.sin(u);
                    positions[i * 3 + 2] = a * Math.sin(v) * Math.cos(u / 2);
                }
                
                window.ksmParticles.geometry.attributes.position.needsUpdate = true;
            }
            
            ksmRenderer.render(ksmScene, ksmCamera);
        }

        function resetKSMView() {
            if (ksmCamera) {
                ksmCamera.position.set(0, 0, 8);
                ksmCamera.lookAt(0, 0, 0);
            }
            if (ksmKlein) {
                ksmKlein.rotation.set(0, 0, 0);
            }
        }

        function toggleKSMFlow() {
            ksmAnimating = !ksmAnimating;
            
            const btn = event.target;
            
            if (ksmAnimating) {
                btn.textContent = 'Pause Flow';
                ksmAnimate();
            } else {
                btn.textContent = 'Resume Flow';
                if (ksmAnimationId) {
                    cancelAnimationFrame(ksmAnimationId);
                    ksmAnimationId = null;
                }
            }
        }

        document.getElementById('ksmRotSpeed').addEventListener('input', (e) => {
            ksmRotSpeed = parseFloat(e.target.value);
        });

        // ==================== MODAL ====================
        document.getElementById('guideBtn').addEventListener('click', () => {
            document.getElementById('guideModal').classList.add('active');
        });

        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('guideModal').classList.remove('active');
        });

        // ==================== GLOBAL PAUSE SYSTEM ====================
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                toggleGlobalPause();
            }
        });

        function toggleGlobalPause() {
            treIsPaused = !treIsPaused;
            
            const pauseBtn = document.getElementById('pauseBtn');
            pauseBtn.textContent = treIsPaused ? '▶ Resume' : '⏸ Pause';
            
            // Sync KSM animation state
            if (window.ksmInitialized) {
                ksmAnimating = !treIsPaused;
                if (!treIsPaused && ksmAnimating) {
                    ksmAnimate();
                } else if (ksmAnimationId) {
                    cancelAnimationFrame(ksmAnimationId);
                    ksmAnimationId = null;
                }
            }
            
            // Resume TRE if not paused
            if (!treIsPaused && treSequence.length > 0) {
                treAnimate();
            }
        }

        // ==================== INIT ====================
        updateTREDisplays();
        treInitSequence();
        treDraw();
    </script>
</body>
</html>