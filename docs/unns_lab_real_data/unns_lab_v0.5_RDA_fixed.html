<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory v0.5 ‚Äî Real Data Assimilation Layer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Consolas', 'Monaco', monospace; 
      background: #0a0a0a; 
      color: #e0e0e0; 
      line-height: 1.6;
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    
    /* Header */
    header { 
      text-align: center; 
      margin-bottom: 30px; 
      padding: 30px; 
      border-bottom: 2px solid #2a2a2a;
      background: linear-gradient(135deg, #1a1a2a 0%, #1a2a1a 100%);
      border-radius: 8px;
    }
    h1 { 
      font-size: 2.2em; 
      color: #4a9eff; 
      letter-spacing: 2px; 
      margin-bottom: 10px;
    }
    .subtitle { 
      color: #888; 
      font-size: 1em; 
      margin-top: 10px;
    }
    .version-badge {
      display: inline-block;
      background: #2a4a7a;
      padding: 5px 15px;
      border-radius: 15px;
      font-size: 0.85em;
      margin-top: 10px;
      color: #4a9eff;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      border-bottom: 2px solid #2a2a2a;
      flex-wrap: wrap;
    }
    .tab {
      padding: 12px 24px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      color: #888;
      transition: all 0.3s;
    }
    .tab:hover { background: #2a2a2a; color: #aaa; }
    .tab.active { 
      background: #2a4a7a; 
      color: #4a9eff; 
      border-color: #4a9eff;
    }
    
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Panels */
    .panel { 
      background: #1a1a1a; 
      border: 1px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 20px; 
      margin-bottom: 20px; 
    }
    .panel-title { 
      font-size: 1.3em; 
      color: #4a9eff; 
      margin-bottom: 15px; 
      padding-bottom: 10px; 
      border-bottom: 1px solid #2a2a2a; 
    }
    
    /* Controls */
    .controls { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
      gap: 15px; 
      margin-bottom: 20px; 
    }
    .control-group { display: flex; flex-direction: column; }
    label { 
      font-size: 0.9em; 
      color: #aaa; 
      margin-bottom: 5px; 
    }
    input[type="number"], 
    input[type="range"], 
    input[type="file"],
    select, 
    textarea { 
      background: #0a0a0a; 
      border: 1px solid #3a3a3a; 
      color: #e0e0e0; 
      padding: 8px; 
      border-radius: 4px; 
      font-family: inherit; 
      width: 100%;
    }
    textarea {
      min-height: 120px;
      font-size: 0.85em;
      resize: vertical;
    }
    button { 
      background: #2a4a7a; 
      border: none; 
      color: #e0e0e0; 
      padding: 12px 24px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-family: inherit; 
      margin-right: 10px;
      margin-bottom: 10px;
      transition: all 0.3s;
    }
    button:hover { background: #3a5a8a; }
    button:disabled { 
      background: #1a1a1a; 
      color: #555; 
      cursor: not-allowed; 
    }
    .button-primary { background: #4a9eff; }
    .button-primary:hover { background: #5aaaff; }
    .button-success { background: #4aff4a; color: #0a0a0a; }
    .button-success:hover { background: #5aff5a; }
    .button-warning { background: #ffa54a; color: #0a0a0a; }
    .button-warning:hover { background: #ffb55a; }
    
    /* Visualization */
    .visualization { 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 20px; 
      margin-top: 20px; 
    }
    .canvas-container { 
      position: relative; 
      background: #000; 
      border: 1px solid #2a2a2a; 
      border-radius: 4px;
      aspect-ratio: 1;
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      display: block;
    }
    .canvas-label { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      background: rgba(0,0,0,0.8); 
      padding: 5px 10px; 
      border-radius: 3px; 
      font-size: 0.9em; 
      color: #4a9eff; 
    }
    
    /* Metrics */
    .metrics { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
      gap: 10px; 
      margin-top: 15px; 
    }
    .metric { 
      background: #0a0a0a; 
      padding: 12px; 
      border-radius: 4px; 
      border: 1px solid #2a2a2a; 
    }
    .metric-label { 
      font-size: 0.8em; 
      color: #888; 
      margin-bottom: 5px; 
    }
    .metric-value { 
      font-size: 1.3em; 
      color: #4a9eff; 
      font-weight: bold; 
    }
    .metric-value.success { color: #4aff4a; }
    .metric-value.warning { color: #ffa54a; }
    .metric-value.error { color: #ff4a4a; }
    
    /* Status */
    .status { 
      padding: 12px; 
      border-radius: 4px; 
      margin-top: 15px; 
      font-size: 0.95em; 
    }
    .status.running { background: #2a4a2a; color: #4aff4a; }
    .status.complete { background: #2a3a4a; color: #4a9eff; }
    .status.error { background: #4a2a2a; color: #ff4a4a; }
    .status.warning { background: #4a3a2a; color: #ffa54a; }
    
    /* Progress */
    .progress-bar { 
      width: 100%; 
      height: 4px; 
      background: #1a1a1a; 
      border-radius: 2px; 
      overflow: hidden; 
      margin-top: 10px; 
    }
    .progress-fill { 
      height: 100%; 
      background: #4a9eff; 
      transition: width 0.3s; 
    }
    
    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      font-size: 0.9em;
      background: #0a0a0a;
    }
    th {
      background: #2a2a2a;
      color: #4a9eff;
      padding: 10px 8px;
      text-align: left;
      border-bottom: 2px solid #4a9eff;
    }
    td {
      padding: 8px;
      border-bottom: 1px solid #1a1a1a;
    }
    tr:hover {
      background: #1a1a1a;
    }
    
    /* Spectrum Display */
    .spectrum-canvas {
      width: 100%;
      height: 300px;
      background: #000;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      margin: 15px 0;
    }
    
    /* Guide Sections */
    .guide-section {
      margin: 25px 0;
      padding: 20px;
      background: #0f0f0f;
      border-left: 4px solid #4a9eff;
      border-radius: 4px;
    }
    .guide-section h3 {
      color: #4a9eff;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    .guide-section h4 {
      color: #4a9eff;
      margin: 15px 0 10px;
      font-size: 1.05em;
    }
    .guide-section p, .guide-section ul, .guide-section ol {
      margin: 10px 0;
      color: #bbb;
    }
    .guide-section ul, .guide-section ol {
      margin-left: 25px;
    }
    .guide-section li {
      margin: 8px 0;
    }
    .guide-section code {
      background: #1a1a1a;
      padding: 2px 6px;
      border-radius: 3px;
      color: #4aff4a;
      font-family: 'Courier New', monospace;
    }
    .guide-section pre {
      background: #0a0a0a;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 10px 0;
      border: 1px solid #2a2a2a;
      color: #e0e0e0;
    }
    
    /* Certification Badge */
    .cert-badge {
      display: inline-block;
      padding: 8px 16px;
      background: linear-gradient(135deg, #2a4a2a, #2a2a4a);
      border: 2px solid #4aff4a;
      border-radius: 20px;
      color: #4aff4a;
      font-weight: bold;
      margin: 10px 10px 10px 0;
    }
    
    /* Alert boxes */
    .alert {
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      border-left: 4px solid;
    }
    .alert-info {
      background: #1a2a3a;
      border-color: #4a9eff;
      color: #aaccff;
    }
    .alert-success {
      background: #1a3a2a;
      border-color: #4aff4a;
      color: #aaffaa;
    }
    .alert-warning {
      background: #3a2a1a;
      border-color: #ffa54a;
      color: #ffccaa;
    }
    .alert-error {
      background: #3a1a1a;
      border-color: #ff4a4a;
      color: #ffaaaa;
    }
    
    /* Scrollable containers */
    .scrollable {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 10px;
      background: #0a0a0a;
    }
    
    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #4a9eff;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚öõÔ∏è UNNS Laboratory v0.5</h1>
      <div class="subtitle">Real Data Assimilation Layer ‚Äî œÑ-MSC Framework</div>
      <div class="version-badge">Phase B Extended ¬∑ v0.5.1 ¬∑ Dataset Pack Integrated ¬∑ 2025</div>
    </header>
    
    <div class="tabs">
      <div class="tab active" data-tab="simulator">üî¨ œÑ-MSC Simulator</div>
      <div class="tab" data-tab="data-loader">üìä Real Data Loader</div>
      <div class="tab" data-tab="comparison">üîç Comparison Engine</div>
      <div class="tab" data-tab="guide">üìñ Laboratory Guide</div>
    </div>
    
    <!-- TAB 1: œÑ-MSC SIMULATOR -->
    <div id="tab-simulator" class="tab-content active">
      <div class="panel">
        <div class="panel-title">œÑ-Field Multi-Scale Curvature Simulator</div>
        <div class="controls">
          <div class="control-group">
            <label>Grid Size</label>
            <select id="simGridSize">
              <option value="64">64√ó64 (fast)</option>
              <option value="128" selected>128√ó128 (balanced)</option>
              <option value="192">192√ó192 (high-res)</option>
            </select>
          </div>
          <div class="control-group">
            <label>Iterations</label>
            <input type="number" id="simIterations" value="500" min="100" max="2000" step="100">
          </div>
          <div class="control-group">
            <label>Œª (coupling) <span id="simLambdaValue">0.108</span></label>
            <input type="range" id="simLambda" min="0.05" max="0.20" step="0.001" value="0.108">
          </div>
          <div class="control-group">
            <label>œÉ (noise)</label>
            <input type="number" id="simSigma" value="0.02" min="0" max="0.1" step="0.01">
          </div>
          <div class="control-group">
            <label>Detection Threshold</label>
            <select id="simThreshold">
              <option value="auto" selected>Auto (95th percentile)</option>
              <option value="0.3">Fixed: 0.3</option>
              <option value="0.5">Fixed: 0.5</option>
              <option value="0.7">Fixed: 0.7</option>
            </select>
          </div>
          <div class="control-group">
            <label>Render Throttle</label>
            <select id="simRenderThrottle">
              <option value="10">Every 10 steps</option>
              <option value="25" selected>Every 25 steps</option>
              <option value="50">Every 50 steps</option>
              <option value="100">Every 100 steps</option>
            </select>
          </div>
        </div>
        
        <button id="btnRunSim" class="button-primary">‚ñ∂ Run Simulation</button>
        <button id="btnStopSim" disabled>‚è∏ Stop</button>
        <button id="btnExportSynth" disabled class="button-success">üíæ Export Synthetic Data</button>
        
        <div id="simStatus" class="status" style="display: none;"></div>
        <div class="progress-bar"><div id="simProgress" class="progress-fill" style="width: 0%;"></div></div>
      </div>
      
      <div class="panel">
        <div class="panel-title">Visualization</div>
        <div class="visualization">
          <div class="canvas-container">
            <canvas id="canvasTauField"></canvas>
            <div class="canvas-label">œÑ-Field (Phase)</div>
          </div>
          <div class="canvas-container">
            <canvas id="canvasCurvature"></canvas>
            <div class="canvas-label">‚àá¬≤œÑ (Curvature)</div>
          </div>
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-title">Synthetic Spectrum</div>
        <canvas id="canvasSynthSpectrum" class="spectrum-canvas"></canvas>
        <div class="metrics">
          <div class="metric">
            <div class="metric-label">Lines Detected</div>
            <div class="metric-value" id="metricLinesDetected">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">Freq Range (MHz)</div>
            <div class="metric-value" id="metricFreqRange">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">Mean Curvature</div>
            <div class="metric-value" id="metricMeanCurv">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">œÑ-Micro Range</div>
            <div class="metric-value" id="metricTauMicro">‚Äî</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- TAB 2: REAL DATA LOADER -->
    <div id="tab-data-loader" class="tab-content">
      <div class="panel">
        <div class="panel-title">Import Experimental Data</div>
        
        <div class="alert alert-info">
          <strong>üìå Supported Format:</strong> JSON or CSV with fields: 
          <code>frequency</code> (MHz), <code>uncertainty</code> (MHz), 
          <code>A_parallel</code>, <code>A_perp</code>, <code>bw_correction</code>, 
          <code>transition</code> (optional)
        </div>
        
        <div class="panel-title" style="margin-top: 20px; font-size: 1.1em;">üì¶ Load Preset Dataset</div>
        <div class="controls">
          <div class="control-group">
            <label>Select Dataset</label>
            <select id="datasetSelector">
              <option value="">-- Select Preset Dataset --</option>
            </select>
          </div>
        </div>
        <button id="loadDatasetBtn" class="button-primary">üìÇ Load Selected Dataset</button>
        <div id="datasetInfo" style="margin-top: 10px; font-size: 0.9em; color: #4aff4a;"></div>
        
        <div class="panel-title" style="margin-top: 30px; font-size: 1.1em;">üìÅ Upload Custom File</div>
        <div class="controls">
          <div class="control-group">
            <label>Upload File</label>
            <input type="file" id="fileRealData" accept=".json,.csv">
          </div>
        </div>
        
        <div style="margin: 20px 0;">
          <button id="btnLoadExample" class="button-primary">üìÇ Load Example RaF Data</button>
          <button id="btnClearData" class="button-warning" disabled>üóëÔ∏è Clear Data</button>
        </div>
        
        <div class="panel-title" style="margin-top: 30px;">Manual Entry (JSON)</div>
        <textarea id="textRealDataJSON" placeholder='[
  {"frequency": 1234.56, "uncertainty": 0.05, "A_parallel": 45.2, "A_perp": 22.1, "bw_correction": 0.15, "transition": "F=3‚ÜíF=4"},
  ...
]'></textarea>
        <button id="btnParseJSON" class="button-primary">‚úì Parse & Load</button>
        
        <div id="dataStatus" class="status" style="display: none;"></div>
      </div>
      
      <div class="panel" id="panelRealDataViz" style="display: none;">
        <div class="panel-title">Experimental Spectrum</div>
        <canvas id="canvasRealSpectrum" class="spectrum-canvas"></canvas>
        
        <div class="metrics">
          <div class="metric">
            <div class="metric-label">Lines Loaded</div>
            <div class="metric-value" id="metricRealLines">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">Freq Range (MHz)</div>
            <div class="metric-value" id="metricRealFreqRange">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">Mean BW Correction</div>
            <div class="metric-value" id="metricRealBW">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">Mean Uncertainty (MHz)</div>
            <div class="metric-value" id="metricRealUncert">‚Äî</div>
          </div>
        </div>
        
        <div class="scrollable" style="margin-top: 20px;">
          <table id="tableRealData">
            <thead>
              <tr>
                <th>#</th>
                <th>Frequency (MHz)</th>
                <th>Uncertainty</th>
                <th>A‚à•</th>
                <th>A‚ä•</th>
                <th>BW Correction</th>
                <th>Transition</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- TAB 3: COMPARISON ENGINE -->
    <div id="tab-comparison" class="tab-content">
      <div class="panel">
        <div class="panel-title">Comparison Configuration</div>
        
        <div class="alert alert-warning">
          <strong>‚ö†Ô∏è Prerequisites:</strong> Run œÑ-MSC simulation AND load real data before comparison.
        </div>
        
        <div class="controls">
          <div class="control-group">
            <label>Matching Threshold (MHz)</label>
            <input type="number" id="compThreshold" value="50" min="1" max="500" step="1">
          </div>
          <div class="control-group">
            <label>Weight: Frequency</label>
            <input type="number" id="weightFreq" value="0.5" min="0" max="1" step="0.1">
          </div>
          <div class="control-group">
            <label>Weight: Curvature</label>
            <input type="number" id="weightCurv" value="0.3" min="0" max="1" step="0.1">
          </div>
          <div class="control-group">
            <label>Weight: BW Correction</label>
            <input type="number" id="weightBW" value="0.2" min="0" max="1" step="0.1">
          </div>
          <div class="control-group">
            <label>Frequency Scaling</label>
            <select id="compScaling">
              <option value="percentile" selected>Percentile-based (Robust)</option>
              <option value="minmax">Min-Max (Linear)</option>
            </select>
          </div>
        </div>
        
        <button id="btnRunComparison" class="button-primary">üîç Run Comparison</button>
        <button id="btnExportComparison" disabled class="button-success">üíæ Export Results</button>
        
        <div id="compStatus" class="status" style="display: none;"></div>
      </div>
      
      <div class="panel" id="panelCompResults" style="display: none;">
        <div class="panel-title">Comparison Results</div>
        
        <div class="metrics">
          <div class="metric">
            <div class="metric-label">Match Rate</div>
            <div class="metric-value" id="metricMatchRate">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">RMSE (MHz)</div>
            <div class="metric-value" id="metricRMSE">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">Correlation (R¬≤)</div>
            <div class="metric-value" id="metricCorrelation">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">BW Alignment</div>
            <div class="metric-value" id="metricBWAlign">‚Äî</div>
          </div>
          <div class="metric">
            <div class="metric-label">œá¬≤/dof</div>
            <div class="metric-value" id="metricChiSq">‚Äî</div>
          </div>
        </div>
        
        <div class="panel-title" style="margin-top: 30px;">Aligned Spectra</div>
        <canvas id="canvasAlignedSpectra" class="spectrum-canvas"></canvas>
        
        <div class="panel-title" style="margin-top: 30px;">Residuals</div>
        <canvas id="canvasResiduals" class="spectrum-canvas"></canvas>
        
        <div class="panel-title" style="margin-top: 30px;">Matched Pairs</div>
        <div class="scrollable">
          <table id="tableMatchedPairs">
            <thead>
              <tr>
                <th>#</th>
                <th>Real Freq (MHz)</th>
                <th>Synth Freq (MHz)</th>
                <th>Œîf (MHz)</th>
                <th>Score</th>
                <th>Curv Match</th>
                <th>BW Match</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        
        <div class="panel-title" style="margin-top: 30px;">Validation Status</div>
        <div id="validationBadges"></div>
      </div>
    </div>
    
    <!-- TAB 4: GUIDE -->
    <div id="tab-guide" class="tab-content">
      <div class="panel">
        <div class="panel-title">üìö Laboratory Guide ‚Äî Real Data Assimilation</div>
        
        <div class="guide-section">
          <h3>üéØ Purpose & Motivation</h3>
          <p>
            The <strong>Real Data Assimilation Layer</strong> extends the UNNS œÑ-field framework 
            to test whether <em>recursive curvature dynamics</em> can reproduce experimentally 
            observed spectral patterns. Specifically, we compare synthetic lines extracted from 
            œÑ-MSC simulations against real hyperfine structure measurements from 
            <strong>radium monofluoride (RaF)</strong> experiments.
          </p>
          <p>
            <strong>Key Question:</strong> Can the œÑ-microstructure metric 
            (<code>curvature √ó œÑ-phase</code>) capture nuclear magnetization distribution 
            effects (Bohr-Weisskopf corrections) observed in heavy radioactive molecules?
          </p>
        </div>
        
        <div class="guide-section">
          <h3>üî¨ Theoretical Framework</h3>
          
          <h4>œÑ-Field Multi-Scale Curvature (œÑ-MSC)</h4>
          <p>The œÑ-field evolves according to:</p>
          <pre>œÑ<sub>n+1</sub>(x) = œÑ<sub>n</sub>(x) + Œª sin(œÑ<sub>n</sub>(x+Œ¥x) - œÑ<sub>n</sub>(x)) + œÉŒæ</pre>
          <p>where:</p>
          <ul>
            <li><strong>Œª:</strong> Coupling strength (typically ~0.108)</li>
            <li><strong>œÉ:</strong> Stochastic noise amplitude</li>
            <li><strong>Œ¥x:</strong> Spatial discretization</li>
          </ul>
          
          <h4>Spectral Line Extraction</h4>
          <p>Synthetic lines are identified as <strong>local maxima</strong> in the curvature field ‚àá¬≤œÑ:</p>
          <pre>‚àá¬≤œÑ = (œÑ<sub>i+1,j</sub> + œÑ<sub>i-1,j</sub> + œÑ<sub>i,j+1</sub> + œÑ<sub>i,j-1</sub> - 4œÑ<sub>i,j</sub>) / (Œ¥x)¬≤</pre>
          <p>Each detected line is characterized by:</p>
          <ul>
            <li><strong>Frequency:</strong> Derived from local œÑ-phase <code>f ~ œÑ(x,y)</code></li>
            <li><strong>Intensity:</strong> Curvature magnitude <code>|‚àá¬≤œÑ|</code></li>
            <li><strong>œÑ-Microstructure:</strong> <code>Œº_œÑ = |‚àá¬≤œÑ| √ó |œÑ|</code></li>
          </ul>
          
          <h4>Matching Algorithm</h4>
          <p>The comparison engine uses a <strong>weighted scoring system</strong>:</p>
          <pre>Score(real, synth) = w_f ¬∑ S_freq + w_c ¬∑ S_curv + w_BW ¬∑ S_BW</pre>
          <p>where:</p>
          <ul>
            <li><strong>S_freq:</strong> Frequency proximity <code>1 - |Œîf|/threshold</code></li>
            <li><strong>S_curv:</strong> Curvature similarity (placeholder: 0.5 if no real curvature)</li>
            <li><strong>S_BW:</strong> BW correction alignment <code>1 - |Œº_œÑ - BW_real|/max(BW)</code></li>
          </ul>
          <p>
            <strong>Note:</strong> Greedy matching is used in v0.5. Dynamic programming (DP) 
            for optimal global matching is planned for v0.6.
          </p>
        </div>
        
        <div class="guide-section">
          <h3>üìä Experimental Data Format</h3>
          <p>Real data should be provided as JSON or CSV with the following fields:</p>
          <table style="margin: 10px 0;">
            <tr>
              <th>Field</th>
              <th>Type</th>
              <th>Description</th>
              <th>Required</th>
            </tr>
            <tr>
              <td><code>frequency</code></td>
              <td>float</td>
              <td>Transition frequency (MHz)</td>
              <td>‚úì</td>
            </tr>
            <tr>
              <td><code>uncertainty</code></td>
              <td>float</td>
              <td>Experimental uncertainty (MHz)</td>
              <td>‚úì</td>
            </tr>
            <tr>
              <td><code>A_parallel</code></td>
              <td>float</td>
              <td>Hyperfine constant A‚à• (MHz)</td>
              <td>‚óã</td>
            </tr>
            <tr>
              <td><code>A_perp</code></td>
              <td>float</td>
              <td>Hyperfine constant A‚ä• (MHz)</td>
              <td>‚óã</td>
            </tr>
            <tr>
              <td><code>bw_correction</code></td>
              <td>float</td>
              <td>Bohr-Weisskopf correction (dimensionless)</td>
              <td>‚úì</td>
            </tr>
            <tr>
              <td><code>transition</code></td>
              <td>string</td>
              <td>Transition label (e.g., "F=3‚Üí4")</td>
              <td>‚óã</td>
            </tr>
          </table>
          
          <h4>Example JSON Structure</h4>
          <pre>[
  {
    "frequency": 1234.567,
    "uncertainty": 0.025,
    "A_parallel": 45.23,
    "A_perp": 22.15,
    "bw_correction": 0.152,
    "transition": "F=3‚ÜíF=4"
  },
  {
    "frequency": 1456.789,
    "uncertainty": 0.030,
    "A_parallel": 46.12,
    "A_perp": 23.05,
    "bw_correction": 0.165,
    "transition": "F=4‚ÜíF=5"
  }
]</pre>
        </div>
        
        <div class="guide-section">
          <h3>üîç Validation Criteria (C_RDA)</h3>
          <table style="margin: 10px 0;">
            <tr>
              <th>Criterion</th>
              <th>Target</th>
              <th>Status</th>
            </tr>
            <tr>
              <td><strong>C_RDA1:</strong> Match Rate</td>
              <td>‚â•60% within Œîf threshold</td>
              <td>Auto-checked</td>
            </tr>
            <tr>
              <td><strong>C_RDA2:</strong> RMSE</td>
              <td>&lt; 2√ó mean experimental uncertainty</td>
              <td>Auto-checked</td>
            </tr>
            <tr>
              <td><strong>C_RDA3:</strong> BW Correlation</td>
              <td>R¬≤ ‚â• 0.85</td>
              <td>Auto-checked</td>
            </tr>
            <tr>
              <td><strong>C_RDA4:</strong> Residuals</td>
              <td>œá¬≤/dof &lt; 1.5 (normal distribution)</td>
              <td>Auto-checked</td>
            </tr>
          </table>
        </div>
        
        <div class="guide-section">
          <h3>‚öôÔ∏è Recommended Workflow</h3>
          <ol>
            <li>
              <strong>Generate Synthetic Spectrum:</strong>
              <ul>
                <li>Navigate to <strong>œÑ-MSC Simulator</strong> tab</li>
                <li>Use 128√ó128 grid, 500 iterations for balanced performance</li>
                <li>Keep Œª ‚âà 0.108, œÉ = 0.02</li>
                <li>Use <strong>Auto threshold</strong> (95th percentile) for robust line detection</li>
                <li>Click <strong>Run Simulation</strong></li>
                <li>Export synthetic data if needed for records</li>
              </ul>
            </li>
            <li>
              <strong>Load Experimental Data:</strong>
              <ul>
                <li>Navigate to <strong>Real Data Loader</strong> tab</li>
                <li><strong>Option A ‚Äî Preset Datasets:</strong> Select from dropdown (RaF, OH, AlH, etc.) and click "Load Selected Dataset"</li>
                <li><strong>Option B ‚Äî Custom Upload:</strong> Upload JSON/CSV file or load example data</li>
                <li>Verify data in the displayed table</li>
                <li>Check experimental spectrum visualization</li>
              </ul>
            </li>
            <li>
              <strong>Run Comparison:</strong>
              <ul>
                <li>Navigate to <strong>Comparison Engine</strong> tab</li>
                <li>Set matching threshold (50 MHz typical for RaF)</li>
                <li>Use <strong>Percentile-based scaling</strong> for robust normalization</li>
                <li>Adjust weights if needed (default: freq=0.5, curv=0.3, BW=0.2)</li>
                <li>Click <strong>Run Comparison</strong></li>
              </ul>
            </li>
            <li>
              <strong>Analyze Results:</strong>
              <ul>
                <li>Check validation badges for C_RDA criteria</li>
                <li>Examine aligned spectra overlay</li>
                <li>Review residuals distribution (should be centered at zero)</li>
                <li>Inspect matched pairs table for individual line comparisons</li>
                <li>Export comparison results for further analysis</li>
              </ul>
            </li>
          </ol>
        </div>
        
        <div class="guide-section">
          <h3>üì¶ Preset Dataset Pack</h3>
          <p>
            The Lab includes a curated collection of experimental datasets from precision 
            spectroscopy measurements. These datasets are pre-formatted for immediate use 
            and cover a range of molecular systems:
          </p>
          
          <h4>Available Datasets</h4>
          <table style="margin: 10px 0;">
            <tr>
              <th>Molecule</th>
              <th>Isotope</th>
              <th>Transitions</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>RaF</td>
              <td><sup>225</sup>Ra</td>
              <td>~80</td>
              <td>Radium monofluoride hyperfine structure (MIT)</td>
            </tr>
            <tr>
              <td>OH</td>
              <td><sup>17</sup>O</td>
              <td>~40</td>
              <td>Hydroxyl radical hyperfine splitting</td>
            </tr>
            <tr>
              <td>AlH</td>
              <td><sup>27</sup>Al</td>
              <td>~50</td>
              <td>Aluminum hydride rotational structure</td>
            </tr>
            <tr>
              <td>ThO</td>
              <td><sup>232</sup>Th</td>
              <td>~60</td>
              <td>Thorium monoxide (ACME collaboration)</td>
            </tr>
            <tr>
              <td>YbF</td>
              <td><sup>174</sup>Yb</td>
              <td>~45</td>
              <td>Ytterbium fluoride hyperfine structure</td>
            </tr>
            <tr>
              <td>BaF</td>
              <td><sup>137</sup>Ba</td>
              <td>~55</td>
              <td>Barium fluoride molecular beam spectroscopy</td>
            </tr>
            <tr>
              <td>CaH</td>
              <td><sup>40</sup>Ca</td>
              <td>~35</td>
              <td>Calcium hydride astrophysical lines</td>
            </tr>
            <tr>
              <td>SrF</td>
              <td><sup>88</sup>Sr</td>
              <td>~48</td>
              <td>Strontium fluoride optical cycling</td>
            </tr>
            <tr>
              <td>YbOH</td>
              <td><sup>174</sup>Yb</td>
              <td>~42</td>
              <td>Ytterbium hydroxide polyatomic structure</td>
            </tr>
            <tr>
              <td>CaOH</td>
              <td><sup>40</sup>Ca</td>
              <td>~38</td>
              <td>Calcium hydroxide laser cooling candidate</td>
            </tr>
          </table>
          
          <h4>Dataset Features</h4>
          <ul>
            <li><strong>Frequency (MHz):</strong> Transition frequency with sub-MHz precision</li>
            <li><strong>Uncertainty (MHz):</strong> Experimental measurement uncertainty</li>
            <li><strong>Hyperfine Constants:</strong> A‚à• and A‚ä• when available</li>
            <li><strong>BW Corrections:</strong> Bohr-Weisskopf nuclear effects</li>
            <li><strong>Metadata:</strong> Isotope info, quantum numbers, experimental conditions</li>
          </ul>
          
          <h4>Usage Tips</h4>
          <ul>
            <li><strong>RaF (<sup>225</sup>Ra):</strong> Best for testing BW correction matching due to large nuclear effects</li>
            <li><strong>OH (<sup>17</sup>O):</strong> Clean hyperfine structure, good for validation</li>
            <li><strong>ThO (<sup>232</sup>Th):</strong> Complex actinide system, challenging test case</li>
            <li><strong>YbOH, CaOH:</strong> Polyatomic molecules, tests multi-scale structure</li>
          </ul>
          
          <div class="alert alert-info" style="margin-top: 15px;">
            <strong>üí° Tip:</strong> Start with RaF or OH datasets for initial validation, 
            then progress to more complex systems like ThO or polyatomic molecules.
          </div>
        </div>
        
        <div class="guide-section">
          <h3>üéõÔ∏è Parameter Tuning Guide</h3>
          
          <h4>œÑ-MSC Simulator Parameters</h4>
          <ul>
            <li><strong>Grid Size:</strong> 128√ó128 recommended; 192√ó192 for high-res (slower)</li>
            <li><strong>Iterations:</strong> 500‚Äì1000 for equilibration; more doesn't always help</li>
            <li><strong>Œª (coupling):</strong> 0.105‚Äì0.115 range; 0.108 is golden-ratio-derived default</li>
            <li><strong>œÉ (noise):</strong> 0.01‚Äì0.03 typical; too high destroys structure</li>
            <li><strong>Threshold:</strong> Auto (95th percentile) adapts to field dynamics; use fixed only if you know the scale</li>
            <li><strong>Render Throttle:</strong> Higher values (50‚Äì100) speed up large grids</li>
          </ul>
          
          <h4>Comparison Engine Parameters</h4>
          <ul>
            <li><strong>Matching Threshold:</strong> Should be ~2-3√ó experimental uncertainty; 50 MHz for RaF</li>
            <li><strong>Frequency Scaling:</strong> Percentile-based is more robust to outliers</li>
            <li><strong>Weight: Frequency:</strong> Most important (0.4‚Äì0.6); direct observable</li>
            <li><strong>Weight: Curvature:</strong> Secondary (0.2‚Äì0.3); structural similarity</li>
            <li><strong>Weight: BW Correction:</strong> Tertiary (0.1‚Äì0.3); nuclear effect proxy</li>
          </ul>
        </div>
        
        <div class="guide-section">
          <h3>‚ö†Ô∏è Known Limitations & Future Work</h3>
          
          <h4 style="color: #ffa54a;">Current v0.5 Limitations</h4>
          <ul>
            <li><strong>Curvature Matching:</strong> Real data doesn't include curvature; defaults to 0.5 score</li>
            <li><strong>œÑ-Microstructure Calibration:</strong> Arbitrary 0.1√ó scaling; needs empirical tuning</li>
            <li><strong>Greedy Matching:</strong> May not find global optimum; DP planned for v0.6</li>
            <li><strong>No Intensity Calibration:</strong> Synthetic intensities not matched to real cross-sections</li>
          </ul>
          
          <h4>Planned Enhancements (v0.6‚Äìv0.7)</h4>
          <ul>
            <li>Dynamic programming for optimal global matching</li>
            <li>Curvature proxy estimation for real lines using local synthetic neighbors</li>
            <li>Intensity calibration using relative line strengths</li>
            <li>Multi-seed ensemble averaging for uncertainty quantification</li>
            <li>Automated hyperparameter optimization (grid search on weights)</li>
            <li>Support for multiple isotopes/molecules</li>
          </ul>
        </div>
        
        <div class="guide-section">
          <h3>üìñ References & Context</h3>
          <ul>
            <li><strong>UNNS Framework:</strong> Unified Neural Network Substrate for recursive field dynamics</li>
            <li><strong>Phase B:</strong> Operators XIII-XVI (Chamber XIV: œÜ-Scale)</li>
            <li><strong>œÑ-MSC:</strong> Multi-Scale Curvature analysis of recursive œÑ-fields</li>
            <li><strong>RaF Experiments:</strong> MIT precision spectroscopy of radium monofluoride hyperfine structure</li>
            <li><strong>Bohr-Weisskopf Effect:</strong> Nuclear magnetization distribution correction to hyperfine splitting</li>
          </ul>
          
          <div style="margin-top: 20px; padding: 15px; background: #1a2a1a; border-left: 4px solid #4aff4a; border-radius: 4px;">
            <strong style="color: #4aff4a;">‚úì Version Information</strong>
            <p style="margin: 5px 0; color: #aaa;">
              <strong>Version:</strong> 0.5.1 | 
              <strong>Build:</strong> Step 5 Complete (Dataset Pack Integrated) |
              <strong>Engine:</strong> TauFieldEngineN | 
              <strong>Status:</strong> Production Ready | 
              <strong>Phase:</strong> B Extended
            </p>
            <p style="margin: 10px 0 5px; color: #aaa; font-size: 0.9em;">
              <strong>Changelog v0.5.1:</strong>
            </p>
            <ul style="margin: 0 0 0 20px; color: #aaa; font-size: 0.9em;">
              <li>‚úÖ Integrated 10-dataset preset pack</li>
              <li>‚úÖ Dropdown selector for instant dataset loading</li>
              <li>‚úÖ Auto-conversion to internal format</li>
              <li>‚úÖ Comprehensive dataset documentation</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
// ============================================================================
// UNNS Laboratory v0.5.1 ‚Äî Real Data Assimilation Layer (Dataset Pack)
// ============================================================================
console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
console.log('  UNNS Laboratory v0.5.1 ‚Äî RDA Layer');
console.log('  Dataset Pack Integrated (Step 5)');
console.log('  œÑ-Field Multi-Scale Curvature Framework');
console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');

// ============================================================================
// GLOBAL STATE
// ============================================================================
const state = {
  synthetic: {
    tau_field: null,
    curvature_field: null,
    spectral_lines: [],
    config: null,
    grid_size: 128
  },
  real: {
    lines: [],
    config: null
  },
  comparison: {
    matched_pairs: [],
    unmatched_real: [],
    unmatched_synth: [],
    metrics: {},
    config: null
  },
  ui: {
    active_tab: 'simulator',
    sim_running: false
  }
};

// ============================================================================
// œÑ-FIELD ENGINE (Simplified for v0.5)
// ============================================================================
class TauFieldEngine {
  constructor(config = {}) {
    this.W = config.grid_size || 128;
    this.size = this.W * this.W;
    this.lambda = config.lambda || 0.108;
    this.sigma = config.sigma || 0.02;
    this.seed = config.seed || 137042;
    
    this.tau = new Float64Array(this.size);
    this.tau_next = new Float64Array(this.size);
    this.curvature = new Float64Array(this.size);
    
    this.rng = this.createSeededRNG(this.seed);
    this.step_count = 0;
    
    this.initialize();
  }
  
  createSeededRNG(seed) {
    let state = seed >>> 0;
    return {
      random() {
        state = (state * 1664525 + 1013904223) >>> 0;
        return state / 4294967296;
      },
      gaussian() {
        let u1 = this.random();
        let u2 = this.random();
        if (u1 < 1e-10) u1 = 1e-10;
        return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      }
    };
  }
  
  initialize() {
    for (let i = 0; i < this.size; i++) {
      this.tau[i] = this.rng.random() * 2 * Math.PI;
    }
  }
  
  step() {
    for (let y = 0; y < this.W; y++) {
      for (let x = 0; x < this.W; x++) {
        const idx = x + y * this.W;
        const right_idx = ((x + 1) % this.W) + y * this.W;
        
        const delta_phi = this.tau[right_idx] - this.tau[idx];
        const noise = this.sigma > 0 ? this.sigma * this.rng.gaussian() : 0;
        
        this.tau_next[idx] = this.tau[idx] + this.lambda * Math.sin(delta_phi) + noise;
      }
    }
    
    // Swap buffers
    [this.tau, this.tau_next] = [this.tau_next, this.tau];
    this.step_count++;
  }
  
  computeCurvature() {
    for (let y = 0; y < this.W; y++) {
      for (let x = 0; x < this.W; x++) {
        const idx = x + y * this.W;
        const center = this.tau[idx];
        
        const right = this.tau[((x + 1) % this.W) + y * this.W];
        const left = this.tau[((x - 1 + this.W) % this.W) + y * this.W];
        const up = this.tau[x + ((y + 1) % this.W) * this.W];
        const down = this.tau[x + ((y - 1 + this.W) % this.W) * this.W];
        
        this.curvature[idx] = (right + left + up + down - 4 * center);
      }
    }
  }
  
  // Extract spectral lines from curvature field
  extractSpectralLines(threshold_mode = 'auto') {
    this.computeCurvature();
    
    // Determine threshold
    let threshold;
    if (threshold_mode === 'auto') {
      // Use 95th percentile
      const sorted = Array.from(this.curvature).map(Math.abs).sort((a, b) => a - b);
      const idx_95 = Math.floor(sorted.length * 0.95);
      threshold = sorted[idx_95];
      console.log(`  Auto threshold (95th percentile): ${threshold.toFixed(4)}`);
    } else {
      threshold = parseFloat(threshold_mode);
    }
    
    const lines = [];
    
    // Find local maxima in |curvature|
    for (let y = 1; y < this.W - 1; y++) {
      for (let x = 1; x < this.W - 1; x++) {
        const idx = x + y * this.W;
        const curv = Math.abs(this.curvature[idx]);
        
        if (curv < threshold) continue;
        
        // Check if local maximum
        const neighbors = [
          Math.abs(this.curvature[(x-1) + y * this.W]),
          Math.abs(this.curvature[(x+1) + y * this.W]),
          Math.abs(this.curvature[x + (y-1) * this.W]),
          Math.abs(this.curvature[x + (y+1) * this.W])
        ];
        
        const is_max = neighbors.every(n => curv >= n);
        
        if (is_max) {
          const tau_local = this.tau[idx];
          const tau_micro = curv * Math.abs(tau_local);
          
          lines.push({
            x: x,
            y: y,
            frequency: tau_local,  // Raw œÑ-phase as frequency proxy
            curvature: curv,
            tau_micro: tau_micro,
            intensity: curv  // Use curvature as intensity
          });
        }
      }
    }
    
    console.log(`  Detected ${lines.length} spectral lines`);
    return lines;
  }
}

// ============================================================================
// VISUALIZATION UTILITIES
// ============================================================================
function setupCanvas(canvasId) {
  const canvas = document.getElementById(canvasId);
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { canvas, ctx, width: rect.width, height: rect.height };
}

function renderField(field, W, canvasId, colormap = 'phase') {
  const { ctx, width, height } = setupCanvas(canvasId);
  ctx.clearRect(0, 0, width, height);
  
  const cellSize = Math.min(width, height) / W;
  const min_val = Math.min(...field);
  const max_val = Math.max(...field);
  const range = max_val - min_val || 1;
  
  for (let y = 0; y < W; y++) {
    for (let x = 0; x < W; x++) {
      const idx = x + y * W;
      const val = field[idx];
      const normalized = (val - min_val) / range;
      
      let color;
      if (colormap === 'phase') {
        const hue = normalized * 240;
        color = `hsl(${hue}, 70%, 50%)`;
      } else if (colormap === 'curvature') {
        const abs_norm = Math.abs(val) / Math.max(Math.abs(min_val), Math.abs(max_val));
        if (val > 0) {
          color = `rgb(${255 * abs_norm}, 0, 0)`;  // Positive = red
        } else {
          color = `rgb(0, 0, ${255 * abs_norm})`;  // Negative = blue
        }
      }
      
      ctx.fillStyle = color;
      ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
    }
  }
}

function renderSpectrum(lines, canvasId, options = {}) {
  const { ctx, width, height } = setupCanvas(canvasId);
  ctx.clearRect(0, 0, width, height);
  
  if (lines.length === 0) return;
  
  const padding = 40;
  const plot_w = width - 2 * padding;
  const plot_h = height - 2 * padding;
  
  // Frequency range
  const freqs = lines.map(l => options.use_normalized ? (l.frequency_normalized || l.frequency) : l.frequency);
  const freq_min = Math.min(...freqs);
  const freq_max = Math.max(...freqs);
  const freq_range = freq_max - freq_min || 1;
  
  // Intensity range
  const intensities = lines.map(l => l.intensity || l.curvature || 1);
  const int_max = Math.max(...intensities);
  
  // Draw axes
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, height - padding);
  ctx.lineTo(width - padding, height - padding);
  ctx.stroke();
  
  // Labels
  ctx.fillStyle = '#888';
  ctx.font = '12px Consolas';
  ctx.fillText('Frequency (MHz)', width / 2 - 40, height - 5);
  ctx.save();
  ctx.translate(10, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Intensity', 0, 0);
  ctx.restore();
  
  // Draw lines
  lines.forEach((line, i) => {
    const freq = freqs[i];
    const intensity = intensities[i];
    
    const x = padding + ((freq - freq_min) / freq_range) * plot_w;
    const line_height = (intensity / int_max) * plot_h;
    const y_base = height - padding;
    
    ctx.strokeStyle = options.color || '#4a9eff';
    ctx.lineWidth = options.lineWidth || 2;
    ctx.beginPath();
    ctx.moveTo(x, y_base);
    ctx.lineTo(x, y_base - line_height);
    ctx.stroke();
    
    // Mark if matched/unmatched
    if (options.mark_status && line.matched !== undefined) {
      ctx.fillStyle = line.matched ? '#4aff4a' : '#ff4a4a';
      ctx.beginPath();
      ctx.arc(x, y_base - line_height, 3, 0, 2 * Math.PI);
      ctx.fill();
    }
  });
  
  // Frequency axis labels
  ctx.fillStyle = '#888';
  ctx.font = '10px Consolas';
  const num_ticks = 5;
  for (let i = 0; i <= num_ticks; i++) {
    const freq = freq_min + (i / num_ticks) * freq_range;
    const x = padding + (i / num_ticks) * plot_w;
    ctx.fillText(freq.toFixed(1), x - 15, height - padding + 15);
  }
}

function renderAlignedSpectra(realLines, synthLines, canvasId) {
  const { ctx, width, height } = setupCanvas(canvasId);
  ctx.clearRect(0, 0, width, height);
  
  if (realLines.length === 0 || synthLines.length === 0) return;
  
  const padding = 40;
  const plot_w = width - 2 * padding;
  const plot_h = height - 2 * padding;
  
  // Get frequency range from real data
  const realFreqs = realLines.map(l => l.frequency);
  const freq_min = Math.min(...realFreqs);
  const freq_max = Math.max(...realFreqs);
  const freq_range = freq_max - freq_min || 1;
  
  // Get max intensity (normalized)
  const realInt = realLines.map(l => 1); // Uniform for real data
  const synthInt = synthLines.map(l => l.intensity || 1);
  const int_max = Math.max(...realInt, ...synthInt);
  
  // Draw axes
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, height - padding);
  ctx.lineTo(width - padding, height - padding);
  ctx.stroke();
  
  // Labels
  ctx.fillStyle = '#888';
  ctx.font = '12px Consolas';
  ctx.fillText('Frequency (MHz)', width / 2 - 40, height - 5);
  
  // Legend
  ctx.fillStyle = '#4a9eff';
  ctx.fillRect(width - padding - 120, padding + 10, 15, 3);
  ctx.fillStyle = '#888';
  ctx.fillText('Real', width - padding - 100, padding + 15);
  
  ctx.fillStyle = '#ff4a9e';
  ctx.fillRect(width - padding - 120, padding + 30, 15, 3);
  ctx.fillStyle = '#888';
  ctx.fillText('Synthetic', width - padding - 100, padding + 35);
  
  // Draw real lines (blue)
  realLines.forEach(line => {
    const x = padding + ((line.frequency - freq_min) / freq_range) * plot_w;
    const line_height = plot_h * 0.8;
    const y_base = height - padding;
    
    ctx.strokeStyle = '#4a9eff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y_base);
    ctx.lineTo(x, y_base - line_height);
    ctx.stroke();
    
    // Error bars
    if (line.uncertainty) {
      const dx = (line.uncertainty / freq_range) * plot_w;
      ctx.strokeStyle = '#4a9eff80';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x - dx, y_base - line_height / 2);
      ctx.lineTo(x + dx, y_base - line_height / 2);
      ctx.stroke();
    }
  });
  
  // Draw synthetic lines (pink)
  synthLines.forEach(line => {
    // ‚úÖ CRITICAL FIX: Use frequency_normalized if available
    const freq = line.frequency_normalized ?? line.frequency;
    const x = padding + ((freq - freq_min) / freq_range) * plot_w;
    const intensity = line.intensity || 1;
    const line_height = (intensity / int_max) * plot_h * 0.6;
    const y_base = height - padding;
    
    ctx.strokeStyle = '#ff4a9e';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y_base);
    ctx.lineTo(x, y_base - line_height);
    ctx.stroke();
  });
}

function renderResiduals(matchedPairs, canvasId) {
  const { ctx, width, height } = setupCanvas(canvasId);
  ctx.clearRect(0, 0, width, height);
  
  if (matchedPairs.length === 0) return;
  
  const padding = 40;
  const plot_w = width - 2 * padding;
  const plot_h = height - 2 * padding;
  
  const residuals = matchedPairs.map(p => p.real.frequency - p.synth.frequency_normalized);
  const res_max = Math.max(...residuals.map(Math.abs));
  
  // Draw axes
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding, height / 2);
  ctx.lineTo(width - padding, height / 2);
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, height - padding);
  ctx.stroke();
  
  // Zero line
  ctx.strokeStyle = '#4aff4a';
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(padding, height / 2);
  ctx.lineTo(width - padding, height / 2);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Labels
  ctx.fillStyle = '#888';
  ctx.font = '12px Consolas';
  ctx.fillText('Pair Index', width / 2 - 30, height - 5);
  ctx.save();
  ctx.translate(10, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Residual (MHz)', 0, 0);
  ctx.restore();
  
  // Plot residuals
  residuals.forEach((res, i) => {
    const x = padding + (i / (residuals.length - 1)) * plot_w;
    const y = height / 2 - (res / res_max) * (plot_h / 2) * 0.8;
    
    ctx.fillStyle = Math.abs(res) < 10 ? '#4aff4a' : '#ffa54a';
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, 2 * Math.PI);
    ctx.fill();
  });
}

// ============================================================================
// TAB MANAGEMENT
// ============================================================================
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    const targetTab = tab.dataset.tab;
    
    // Update tab buttons
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
    document.getElementById(`tab-${targetTab}`).classList.add('active');
    
    state.ui.active_tab = targetTab;
  });
});

// ============================================================================
// TAB 1: œÑ-MSC SIMULATOR
// ============================================================================
let engine = null;
let sim_interval = null;

document.getElementById('simLambda').addEventListener('input', (e) => {
  document.getElementById('simLambdaValue').textContent = parseFloat(e.target.value).toFixed(3);
});

document.getElementById('btnRunSim').addEventListener('click', async () => {
  console.log('üöÄ Starting œÑ-MSC simulation');
  
  const config = {
    grid_size: parseInt(document.getElementById('simGridSize').value),
    lambda: parseFloat(document.getElementById('simLambda').value),
    sigma: parseFloat(document.getElementById('simSigma').value),
    iterations: parseInt(document.getElementById('simIterations').value),
    threshold: document.getElementById('simThreshold').value,
    render_throttle: parseInt(document.getElementById('simRenderThrottle').value)
  };
  
  state.synthetic.config = config;
  state.synthetic.grid_size = config.grid_size;
  
  engine = new TauFieldEngine({
    grid_size: config.grid_size,
    lambda: config.lambda,
    sigma: config.sigma
  });
  
  state.ui.sim_running = true;
  document.getElementById('btnRunSim').disabled = true;
  document.getElementById('btnStopSim').disabled = false;
  document.getElementById('btnExportSynth').disabled = true;
  
  const statusEl = document.getElementById('simStatus');
  statusEl.textContent = 'Running simulation...';
  statusEl.className = 'status running';
  statusEl.style.display = 'block';
  
  for (let i = 0; i < config.iterations && state.ui.sim_running; i++) {
    engine.step();
    
    // Throttled rendering
    if (i % config.render_throttle === 0) {
      renderField(engine.tau, config.grid_size, 'canvasTauField', 'phase');
      engine.computeCurvature();
      renderField(engine.curvature, config.grid_size, 'canvasCurvature', 'curvature');
    }
    
    // Progress
    const progress = ((i + 1) / config.iterations) * 100;
    document.getElementById('simProgress').style.width = `${progress}%`;
    
    // Yield to browser
    if (i % 10 === 0) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
  
  if (state.ui.sim_running) {
    // Extract spectral lines
    console.log('üìä Extracting spectral lines...');
    const lines = engine.extractSpectralLines(config.threshold);
    state.synthetic.spectral_lines = lines;
    state.synthetic.tau_field = new Float64Array(engine.tau);
    state.synthetic.curvature_field = new Float64Array(engine.curvature);
    
    // Render final state
    renderField(engine.tau, config.grid_size, 'canvasTauField', 'phase');
    renderField(engine.curvature, config.grid_size, 'canvasCurvature', 'curvature');
    
    // Render spectrum
    renderSpectrum(lines, 'canvasSynthSpectrum', { color: '#ff4a9e' });
    
    // Update metrics
    if (lines.length > 0) {
      const freqs = lines.map(l => l.frequency);
      const curvs = lines.map(l => l.curvature);
      const micros = lines.map(l => l.tau_micro);
      
      document.getElementById('metricLinesDetected').textContent = lines.length;
      document.getElementById('metricFreqRange').textContent = 
        `${Math.min(...freqs).toFixed(2)} ‚Äì ${Math.max(...freqs).toFixed(2)}`;
      document.getElementById('metricMeanCurv').textContent = 
        (curvs.reduce((a,b) => a+b, 0) / curvs.length).toFixed(4);
      document.getElementById('metricTauMicro').textContent = 
        `${Math.min(...micros).toFixed(3)} ‚Äì ${Math.max(...micros).toFixed(3)}`;
    }
    
    statusEl.textContent = `Complete! ${lines.length} lines detected.`;
    statusEl.className = 'status complete';
    document.getElementById('btnExportSynth').disabled = false;
    
    console.log(`‚úÖ Simulation complete: ${lines.length} lines`);
  }
  
  document.getElementById('btnRunSim').disabled = false;
  document.getElementById('btnStopSim').disabled = true;
  state.ui.sim_running = false;
});

document.getElementById('btnStopSim').addEventListener('click', () => {
  state.ui.sim_running = false;
  document.getElementById('simStatus').textContent = 'Stopped by user';
  document.getElementById('simStatus').className = 'status warning';
  console.log('‚è∏Ô∏è Simulation stopped');
});

document.getElementById('btnExportSynth').addEventListener('click', () => {
  const exportData = {
    version: '0.5.1',
    type: 'synthetic_spectrum',
    timestamp: new Date().toISOString(),
    config: state.synthetic.config,
    lines: state.synthetic.spectral_lines.map(l => ({
      frequency: l.frequency,
      curvature: l.curvature,
      tau_micro: l.tau_micro,
      intensity: l.intensity,
      position: { x: l.x, y: l.y }
    })),
    statistics: {
      total_lines: state.synthetic.spectral_lines.length,
      freq_range: [
        Math.min(...state.synthetic.spectral_lines.map(l => l.frequency)),
        Math.max(...state.synthetic.spectral_lines.map(l => l.frequency))
      ]
    }
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `UNNS_v05_synth_${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  console.log('üíæ Synthetic data exported');
});

// ============================================================================
// TAB 2: REAL DATA LOADER - DATASET PACK INTEGRATION
// ============================================================================

// Dataset loading functions
async function loadDatasetIndex() {
  try {
    const response = await fetch('./datasets/index.json');
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    const data = await response.json();
    return data;
  } catch (err) {
    console.error('Failed to load dataset index:', err);
    return null;
  }
}

async function loadDatasetFile(path) {
  try {
    const response = await fetch(path);
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    const data = await response.json();
    return data;
  } catch (err) {
    console.error('Failed to load dataset file:', err);
    return null;
  }
}

function convertDatasetToRealFormat(dataset) {
  // Convert v0.5 dataset format to internal real data format
  const lines = [];
  
  dataset.transitions.forEach(trans => {
    lines.push({
      frequency: trans.frequency_MHz,
      uncertainty: trans.uncertainty_MHz,
      A_parallel: trans.hyperfine?.A_parallel_MHz || 0,
      A_perp: trans.hyperfine?.A_perp_MHz || 0,
      bw_correction: trans.bw_correction || 0,
      transition: trans.label || '',
      // Store full transition data for reference
      _raw: trans
    });
  });
  
  return lines;
}

// Initialize dataset selector on page load
async function initDatasetSelector() {
  const index = await loadDatasetIndex();
  if (!index) {
    console.warn('Dataset index not available - preset datasets disabled');
    document.getElementById('loadDatasetBtn').disabled = true;
    document.getElementById('datasetInfo').textContent = '‚ö†Ô∏è Dataset pack not found';
    document.getElementById('datasetInfo').style.color = '#ffa54a';
    return;
  }
  
  const selector = document.getElementById('datasetSelector');
  
  index.datasets.forEach(ds => {
    const option = document.createElement('option');
    option.value = ds.file;
    option.textContent = `${ds.name} (${ds.molecule})`;
    option.dataset.description = ds.description;
    selector.appendChild(option);
  });
  
  console.log(`‚úÖ Loaded ${index.datasets.length} preset datasets`);
}

// Handle dataset selection
document.getElementById('loadDatasetBtn').addEventListener('click', async () => {
  const selector = document.getElementById('datasetSelector');
  const filename = selector.value;
  
  if (!filename) {
    alert('Please select a dataset from the dropdown');
    return;
  }
  
  document.getElementById('datasetInfo').textContent = '‚è≥ Loading dataset...';
  document.getElementById('datasetInfo').style.color = '#4a9eff';
  
  const dataset = await loadDatasetFile(`./datasets/${filename}`);
  
  if (!dataset) {
    document.getElementById('datasetInfo').textContent = '‚ùå Failed to load dataset';
    document.getElementById('datasetInfo').style.color = '#ff4a4a';
    return;
  }
  
  // Convert and load
  const realLines = convertDatasetToRealFormat(dataset);
  loadRealData(realLines);
  
  // Update info display
  const selectedOption = selector.options[selector.selectedIndex];
  document.getElementById('datasetInfo').textContent = 
    `‚úì Loaded: ${selectedOption.textContent} (${realLines.length} transitions)`;
  document.getElementById('datasetInfo').style.color = '#4aff4a';
  
  console.log(`üì¶ Loaded dataset: ${dataset.metadata.molecule} (${realLines.length} transitions)`);
});

// Initialize on page load
initDatasetSelector();

// ============================================================================
// TAB 2: REAL DATA LOADER - MANUAL/FILE UPLOAD
// ============================================================================

// Load example RaF data
document.getElementById('btnLoadExample').addEventListener('click', () => {
  const exampleData = [
    {
      frequency: 1234.567,
      uncertainty: 0.025,
      A_parallel: 45.23,
      A_perp: 22.15,
      bw_correction: 0.152,
      transition: "F=3‚ÜíF=4"
    },
    {
      frequency: 1456.789,
      uncertainty: 0.030,
      A_parallel: 46.12,
      A_perp: 23.05,
      bw_correction: 0.165,
      transition: "F=4‚ÜíF=5"
    },
    {
      frequency: 1678.234,
      uncertainty: 0.028,
      A_parallel: 44.87,
      A_perp: 21.98,
      bw_correction: 0.148,
      transition: "F=2‚ÜíF=3"
    },
    {
      frequency: 1890.456,
      uncertainty: 0.032,
      A_parallel: 46.45,
      A_perp: 23.21,
      bw_correction: 0.171,
      transition: "F=5‚ÜíF=6"
    },
    {
      frequency: 2012.345,
      uncertainty: 0.026,
      A_parallel: 45.67,
      A_perp: 22.45,
      bw_correction: 0.158,
      transition: "F=3‚ÜíF=4"
    },
    {
      frequency: 2234.567,
      uncertainty: 0.029,
      A_parallel: 46.23,
      A_perp: 23.12,
      bw_correction: 0.163,
      transition: "F=4‚ÜíF=5"
    }
  ];
  
  loadRealData(exampleData);
  console.log('üìÇ Example RaF data loaded');
});

// File upload
document.getElementById('fileRealData').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (evt) => {
    try {
      const text = evt.target.result;
      let data;
      
      if (file.name.endsWith('.json')) {
        data = JSON.parse(text);
      } else if (file.name.endsWith('.csv')) {
        data = parseCSV(text);
      } else {
        throw new Error('Unsupported file format');
      }
      
      loadRealData(data);
      console.log(`üìÇ Loaded ${data.length} lines from ${file.name}`);
    } catch (err) {
      alert(`Error loading file: ${err.message}`);
      console.error(err);
    }
  };
  reader.readAsText(file);
});

// Manual JSON entry
document.getElementById('btnParseJSON').addEventListener('click', () => {
  try {
    const text = document.getElementById('textRealDataJSON').value;
    const data = JSON.parse(text);
    loadRealData(data);
    console.log(`üìÇ Parsed ${data.length} lines from manual entry`);
  } catch (err) {
    alert(`JSON parse error: ${err.message}`);
    console.error(err);
  }
});

// Clear data
document.getElementById('btnClearData').addEventListener('click', () => {
  state.real.lines = [];
  state.real.config = null;
  document.getElementById('panelRealDataViz').style.display = 'none';
  document.getElementById('btnClearData').disabled = true;
  document.getElementById('dataStatus').style.display = 'none';
  console.log('üóëÔ∏è Real data cleared');
});

function parseCSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  
  return lines.slice(1).map(line => {
    const values = line.split(',');
    const obj = {};
    headers.forEach((h, i) => {
      const val = values[i]?.trim();
      obj[h] = isNaN(val) ? val : parseFloat(val);
    });
    return obj;
  });
}

function loadRealData(data) {
  // Validate
  const required = ['frequency', 'uncertainty', 'bw_correction'];
  const valid = data.every(d => required.every(f => d[f] !== undefined));
  
  if (!valid) {
    alert('Invalid data format: missing required fields');
    return;
  }
  
  state.real.lines = data;
  state.real.config = {
    source: 'user_upload',
    timestamp: new Date().toISOString(),
    num_lines: data.length
  };
  
  // Update UI
  document.getElementById('panelRealDataViz').style.display = 'block';
  document.getElementById('btnClearData').disabled = false;
  
  const statusEl = document.getElementById('dataStatus');
  statusEl.textContent = `‚úì Loaded ${data.length} spectral lines`;
  statusEl.className = 'status complete';
  statusEl.style.display = 'block';
  
  // Render table
  const tbody = document.querySelector('#tableRealData tbody');
  tbody.innerHTML = '';
  data.forEach((line, i) => {
    const row = tbody.insertRow();
    row.insertCell(0).textContent = i + 1;
    row.insertCell(1).textContent = line.frequency.toFixed(3);
    row.insertCell(2).textContent = line.uncertainty?.toFixed(4) || '‚Äî';
    row.insertCell(3).textContent = line.A_parallel?.toFixed(2) || '‚Äî';
    row.insertCell(4).textContent = line.A_perp?.toFixed(2) || '‚Äî';
    row.insertCell(5).textContent = line.bw_correction?.toFixed(4) || '‚Äî';
    row.insertCell(6).textContent = line.transition || '‚Äî';
  });
  
  // Render spectrum
  renderSpectrum(data, 'canvasRealSpectrum', { color: '#4a9eff', use_normalized: false });
  
  // Update metrics
  const freqs = data.map(l => l.frequency);
  const bws = data.map(l => l.bw_correction || 0);
  const uncerts = data.map(l => l.uncertainty || 0);
  
  document.getElementById('metricRealLines').textContent = data.length;
  document.getElementById('metricRealFreqRange').textContent = 
    `${Math.min(...freqs).toFixed(1)} ‚Äì ${Math.max(...freqs).toFixed(1)}`;
  document.getElementById('metricRealBW').textContent = 
    (bws.reduce((a,b) => a+b, 0) / bws.length).toFixed(4);
  document.getElementById('metricRealUncert').textContent = 
    (uncerts.reduce((a,b) => a+b, 0) / uncerts.length).toFixed(4);
}

// ============================================================================
// TAB 3: COMPARISON ENGINE
// ============================================================================

document.getElementById('btnRunComparison').addEventListener('click', () => {
  console.log('üîç Running comparison');
  
  // Check prerequisites
  if (state.synthetic.spectral_lines.length === 0) {
    alert('Please run œÑ-MSC simulation first');
    return;
  }
  if (state.real.lines.length === 0) {
    alert('Please load real data first');
    return;
  }
  
  const config = {
    threshold_mhz: parseFloat(document.getElementById('compThreshold').value),
    weights: {
      frequency: parseFloat(document.getElementById('weightFreq').value),
      curvature: parseFloat(document.getElementById('weightCurv').value),
      bw: parseFloat(document.getElementById('weightBW').value)
    },
    scaling_mode: document.getElementById('compScaling').value
  };
  
  state.comparison.config = config;
  
  const statusEl = document.getElementById('compStatus');
  statusEl.textContent = 'Computing matches...';
  statusEl.className = 'status running';
  statusEl.style.display = 'block';
  
  // Normalize synthetic frequencies to real frequency range
  normalizeFrequencies(config.scaling_mode);
  
  // Run matching
  const { matched, unmatched_real, unmatched_synth } = matchSpectra(config);
  
  state.comparison.matched_pairs = matched;
  state.comparison.unmatched_real = unmatched_real;
  state.comparison.unmatched_synth = unmatched_synth;
  
  // Compute metrics
  const metrics = computeMetrics(matched);
  state.comparison.metrics = metrics;
  
  // Update UI
  document.getElementById('panelCompResults').style.display = 'block';
  document.getElementById('btnExportComparison').disabled = false;
  
  statusEl.textContent = `‚úì Matched ${matched.length} pairs`;
  statusEl.className = 'status complete';
  
  // Render results
  displayComparisonResults(matched, metrics);
  
  console.log(`‚úÖ Comparison complete: ${matched.length} matches`);
});

function normalizeFrequencies(mode) {
  const synthLines = state.synthetic.spectral_lines;
  const realLines = state.real.lines;
  
  const synthFreqs = synthLines.map(l => l.frequency);
  const realFreqs = realLines.map(l => l.frequency);
  
  if (mode === 'percentile') {
    // ‚úÖ ROBUST: Percentile-based scaling
    const getSortedPercentile = (arr, p) => {
      const sorted = [...arr].sort((a, b) => a - b);
      const idx = Math.floor(sorted.length * p);
      return sorted[idx];
    };
    
    const synth_p5 = getSortedPercentile(synthFreqs, 0.05);
    const synth_p95 = getSortedPercentile(synthFreqs, 0.95);
    const real_p5 = getSortedPercentile(realFreqs, 0.05);
    const real_p95 = getSortedPercentile(realFreqs, 0.95);
    
    const scale = (real_p95 - real_p5) / (synth_p95 - synth_p5);
    const offset = real_p5 - synth_p5 * scale;
    
    synthLines.forEach(line => {
      line.frequency_normalized = line.frequency * scale + offset;
    });
    
    console.log(`  Percentile scaling: scale=${scale.toFixed(4)}, offset=${offset.toFixed(2)}`);
  } else {
    // Min-max linear scaling
    const synthMin = Math.min(...synthFreqs);
    const synthMax = Math.max(...synthFreqs);
    const realMin = Math.min(...realFreqs);
    const realMax = Math.max(...realFreqs);
    
    const scale = (realMax - realMin) / (synthMax - synthMin);
    const offset = realMin - synthMin * scale;
    
    synthLines.forEach(line => {
      line.frequency_normalized = line.frequency * scale + offset;
    });
    
    console.log(`  Min-max scaling: scale=${scale.toFixed(4)}, offset=${offset.toFixed(2)}`);
  }
}

function matchSpectra(config) {
  const realLines = state.real.lines;
  const synthLines = state.synthetic.spectral_lines;
  const threshold = config.threshold_mhz;
  const weights = config.weights;
  
  // Normalize weights
  const w_sum = weights.frequency + weights.curvature + weights.bw;
  const w_freq = weights.frequency / w_sum;
  const w_curv = weights.curvature / w_sum;
  const w_bw = weights.bw / w_sum;
  
  // Get normalization factors
  const bw_max = Math.max(...realLines.map(l => Math.abs(l.bw_correction || 0)));
  const micro_scale = 0.1; // Arbitrary calibration factor (to be tuned)
  
  // Build cost matrix
  const costs = [];
  for (let i = 0; i < realLines.length; i++) {
    const real = realLines[i];
    const row = [];
    
    for (let j = 0; j < synthLines.length; j++) {
      const synth = synthLines[j];
      const freq_diff = Math.abs(real.frequency - synth.frequency_normalized);
      
      if (freq_diff > threshold) {
        row.push(null); // No match possible
        continue;
      }
      
      // Frequency score
      const s_freq = 1 - (freq_diff / threshold);
      
      // Curvature score (placeholder: real data doesn't have curvature)
      const s_curv = 0.5; // Neutral score
      
      // BW correction similarity
      const tau_micro_scaled = synth.tau_micro * micro_scale;
      const bw_diff = Math.abs(real.bw_correction - tau_micro_scaled);
      const s_bw = 1 - Math.min(bw_diff / bw_max, 1);
      
      // Combined score
      const score = w_freq * s_freq + w_curv * s_curv + w_bw * s_bw;
      
      row.push({
        score: score,
        freq_score: s_freq,
        curv_score: s_curv,
        bw_score: s_bw,
        freq_diff: freq_diff
      });
    }
    
    costs.push(row);
  }
  
  // Greedy matching (higher scores first)
  const matched = [];
  const used_real = new Set();
  const used_synth = new Set();
  
  // Flatten and sort by score
  const candidates = [];
  for (let i = 0; i < realLines.length; i++) {
    for (let j = 0; j < synthLines.length; j++) {
      if (costs[i][j] !== null) {
        candidates.push({ i, j, ...costs[i][j] });
      }
    }
  }
  candidates.sort((a, b) => b.score - a.score);
  
  // Greedy assignment
  for (const cand of candidates) {
    if (!used_real.has(cand.i) && !used_synth.has(cand.j)) {
      matched.push({
        real: realLines[cand.i],
        synth: synthLines[cand.j],
        score: cand.score,
        freq_score: cand.freq_score,
        curv_score: cand.curv_score,
        bw_score: cand.bw_score,
        freq_diff: cand.freq_diff
      });
      used_real.add(cand.i);
      used_synth.add(cand.j);
    }
  }
  
  const unmatched_real = realLines.filter((_, i) => !used_real.has(i));
  const unmatched_synth = synthLines.filter((_, i) => !used_synth.has(i));
  
  console.log(`  Matched: ${matched.length}, Unmatched real: ${unmatched_real.length}, Unmatched synth: ${unmatched_synth.length}`);
  
  return { matched, unmatched_real, unmatched_synth };
}

function computeMetrics(matchedPairs) {
  if (matchedPairs.length === 0) {
    return { match_rate: 0, rmse: 0, correlation: 0, bw_alignment: 0, chi_sq_dof: 0 };
  }
  
  const n_real = state.real.lines.length;
  const match_rate = matchedPairs.length / n_real;
  
  // RMSE
  const residuals = matchedPairs.map(p => p.real.frequency - p.synth.frequency_normalized);
  const rmse = Math.sqrt(residuals.reduce((a, b) => a + b * b, 0) / residuals.length);
  
  // Correlation
  const realFreqs = matchedPairs.map(p => p.real.frequency);
  const synthFreqs = matchedPairs.map(p => p.synth.frequency_normalized);
  const correlation = computeCorrelation(realFreqs, synthFreqs);
  
  // BW alignment (correlation between real BW and synth tau_micro)
  const realBW = matchedPairs.map(p => p.real.bw_correction);
  const synthMicro = matchedPairs.map(p => p.synth.tau_micro * 0.1);
  const bw_alignment = computeCorrelation(realBW, synthMicro);
  
  // œá¬≤/dof
  const uncertainties = matchedPairs.map(p => p.real.uncertainty || 1);
  const chi_sq = residuals.reduce((sum, res, i) => {
    return sum + (res * res) / (uncertainties[i] * uncertainties[i]);
  }, 0);
  const dof = Math.max(1, matchedPairs.length - 1);
  const chi_sq_dof = chi_sq / dof;
  
  return { match_rate, rmse, correlation, bw_alignment, chi_sq_dof };
}

function computeCorrelation(x, y) {
  const n = x.length;
  const mean_x = x.reduce((a, b) => a + b, 0) / n;
  const mean_y = y.reduce((a, b) => a + b, 0) / n;
  
  let num = 0, denom_x = 0, denom_y = 0;
  for (let i = 0; i < n; i++) {
    const dx = x[i] - mean_x;
    const dy = y[i] - mean_y;
    num += dx * dy;
    denom_x += dx * dx;
    denom_y += dy * dy;
  }
  
  return num / Math.sqrt(denom_x * denom_y);
}

function displayComparisonResults(matchedPairs, metrics) {
  // Metrics
  document.getElementById('metricMatchRate').textContent = 
    `${(metrics.match_rate * 100).toFixed(1)}%`;
  document.getElementById('metricMatchRate').className = 
    metrics.match_rate >= 0.6 ? 'metric-value success' : 'metric-value warning';
  
  document.getElementById('metricRMSE').textContent = metrics.rmse.toFixed(3);
  const mean_uncert = state.real.lines.reduce((a, b) => a + b.uncertainty, 0) / state.real.lines.length;
  document.getElementById('metricRMSE').className = 
    metrics.rmse < 2 * mean_uncert ? 'metric-value success' : 'metric-value warning';
  
  document.getElementById('metricCorrelation').textContent = 
    `${(metrics.correlation * metrics.correlation).toFixed(3)}`;
  document.getElementById('metricCorrelation').className = 
    metrics.correlation * metrics.correlation >= 0.85 ? 'metric-value success' : 'metric-value warning';
  
  document.getElementById('metricBWAlign').textContent = 
    `${(metrics.bw_alignment * metrics.bw_alignment).toFixed(3)}`;
  document.getElementById('metricBWAlign').className = 
    metrics.bw_alignment * metrics.bw_alignment >= 0.85 ? 'metric-value success' : 'metric-value warning';
  
  document.getElementById('metricChiSq').textContent = metrics.chi_sq_dof.toFixed(3);
  document.getElementById('metricChiSq').className = 
    metrics.chi_sq_dof < 1.5 ? 'metric-value success' : 'metric-value warning';
  
  // Aligned spectra
  const realForPlot = [...state.real.lines];
  const synthForPlot = [...state.synthetic.spectral_lines];
  renderAlignedSpectra(realForPlot, synthForPlot, 'canvasAlignedSpectra');
  
  // Residuals
  renderResiduals(matchedPairs, 'canvasResiduals');
  
  // Matched pairs table
  const tbody = document.querySelector('#tableMatchedPairs tbody');
  tbody.innerHTML = '';
  matchedPairs.forEach((pair, i) => {
    const row = tbody.insertRow();
    row.insertCell(0).textContent = i + 1;
    row.insertCell(1).textContent = pair.real.frequency.toFixed(3);
    row.insertCell(2).textContent = pair.synth.frequency_normalized.toFixed(3);
    row.insertCell(3).textContent = pair.freq_diff.toFixed(3);
    row.insertCell(4).textContent = pair.score.toFixed(3);
    row.insertCell(5).textContent = pair.curv_score.toFixed(3);
    row.insertCell(6).textContent = pair.bw_score.toFixed(3);
  });
  
  // Validation badges
  const badgesDiv = document.getElementById('validationBadges');
  badgesDiv.innerHTML = '';
  
  const criteria = [
    { label: 'C_RDA1: Match Rate', pass: metrics.match_rate >= 0.6 },
    { label: 'C_RDA2: RMSE', pass: metrics.rmse < 2 * mean_uncert },
    { label: 'C_RDA3: BW Correlation', pass: metrics.bw_alignment * metrics.bw_alignment >= 0.85 },
    { label: 'C_RDA4: œá¬≤/dof', pass: metrics.chi_sq_dof < 1.5 }
  ];
  
  criteria.forEach(c => {
    const badge = document.createElement('span');
    badge.className = 'cert-badge';
    badge.textContent = `${c.pass ? '‚úì' : '‚úó'} ${c.label}`;
    badge.style.borderColor = c.pass ? '#4aff4a' : '#ffa54a';
    badge.style.color = c.pass ? '#4aff4a' : '#ffa54a';
    badgesDiv.appendChild(badge);
  });
}

document.getElementById('btnExportComparison').addEventListener('click', () => {
  const exportData = {
    version: '0.5.1',
    type: 'comparison_results',
    timestamp: new Date().toISOString(),
    config: state.comparison.config,
    matched_pairs: state.comparison.matched_pairs.map(p => ({
      real: {
        frequency: p.real.frequency,
        uncertainty: p.real.uncertainty,
        bw_correction: p.real.bw_correction,
        transition: p.real.transition
      },
      synth: {
        frequency: p.synth.frequency,
        frequency_normalized: p.synth.frequency_normalized,
        curvature: p.synth.curvature,
        tau_micro: p.synth.tau_micro
      },
      scores: {
        total: p.score,
        frequency: p.freq_score,
        curvature: p.curv_score,
        bw: p.bw_score
      },
      freq_diff: p.freq_diff
    })),
    unmatched_real: state.comparison.unmatched_real.map(l => ({
      frequency: l.frequency,
      transition: l.transition
    })),
    unmatched_synth: state.comparison.unmatched_synth.map(l => ({
      frequency: l.frequency,
      frequency_normalized: l.frequency_normalized
    })),
    metrics: state.comparison.metrics,
    validation: {
      C_RDA1_match_rate: state.comparison.metrics.match_rate >= 0.6,
      C_RDA2_rmse: state.comparison.metrics.rmse < 2 * (state.real.lines.reduce((a,b) => a + b.uncertainty, 0) / state.real.lines.length),
      C_RDA3_bw_correlation: state.comparison.metrics.bw_alignment * state.comparison.metrics.bw_alignment >= 0.85,
      C_RDA4_chi_sq_dof: state.comparison.metrics.chi_sq_dof < 1.5
    }
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `UNNS_v05_comparison_${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  console.log('üíæ Comparison results exported');
});

// ============================================================================
// INITIALIZATION
// ============================================================================
console.log('‚úÖ UNNS Lab v0.5.1 ready!');
console.log('üì¶ Dataset pack integrated - 10 presets available');
console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  </script>
</body>
</html>
