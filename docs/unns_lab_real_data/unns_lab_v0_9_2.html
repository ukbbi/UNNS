<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory v0.9.2 ‚Äî Real Data Assimilation (œÉ-Weighted Quality Analysis)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace; 
      background: #0a0a0a; 
      color: #e0e0e0; 
      line-height: 1.6;
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    
    /* Header */
    header { 
      text-align: center; 
      margin-bottom: 30px; 
      padding: 30px 20px; 
      border-bottom: 2px solid #2a2a2a;
      background: linear-gradient(135deg, #0a1a2a 0%, #1a0a2a 100%);
      border-radius: 8px;
    }
    h1 { 
      font-size: 2.2em; 
      color: #4a9eff; 
      letter-spacing: 3px; 
      margin-bottom: 10px;
      text-shadow: 0 0 10px rgba(74, 158, 255, 0.3);
    }
    .subtitle { 
      color: #888; 
      font-size: 1em; 
      margin-top: 10px;
      letter-spacing: 1px;
    }
    .version-badge {
      display: inline-block;
      background: #2a4a7a;
      padding: 5px 15px;
      border-radius: 15px;
      font-size: 0.8em;
      margin-top: 10px;
      color: #4aff4a;
    }
    
    /* Tabs */
    .tabs { 
      display: flex; 
      gap: 5px; 
      margin-bottom: 20px; 
      border-bottom: 2px solid #2a2a2a;
      flex-wrap: wrap;
    }
    .tab { 
      background: #1a1a1a; 
      border: 1px solid #2a2a2a; 
      color: #888; 
      padding: 12px 24px; 
      cursor: pointer; 
      border-radius: 8px 8px 0 0;
      transition: all 0.3s;
      font-size: 0.95em;
    }
    .tab:hover { background: #2a2a2a; color: #aaa; }
    .tab.active { 
      background: #2a4a7a; 
      color: #4a9eff; 
      border-bottom: 2px solid #4a9eff;
      font-weight: bold;
    }
    
    /* Panels */
    .panel { 
      background: #1a1a1a; 
      border: 1px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 25px; 
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    .panel-title { 
      font-size: 1.3em; 
      color: #4a9eff; 
      margin-bottom: 20px; 
      padding-bottom: 12px; 
      border-bottom: 2px solid #2a2a2a;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .panel-title::before {
      content: '‚ñ∏';
      color: #4aff4a;
      font-size: 1.2em;
    }
    
    /* Forms */
    .form-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
      gap: 20px; 
      margin-bottom: 20px; 
    }
    .form-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    label { 
      font-size: 0.9em; 
      color: #aaa; 
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input[type="number"], input[type="range"], select, input[type="file"] { 
      background: #0a0a0a; 
      border: 1px solid #3a3a3a; 
      color: #e0e0e0; 
      padding: 10px; 
      border-radius: 4px; 
      font-family: inherit;
      font-size: 0.95em;
      transition: border-color 0.3s;
    }
    input[type="number"]:focus, select:focus {
      outline: none;
      border-color: #4a9eff;
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    /* Buttons */
    button { 
      background: #2a4a7a; 
      border: none; 
      color: #e0e0e0; 
      padding: 12px 24px; 
      border-radius: 6px; 
      cursor: pointer; 
      font-family: inherit; 
      margin-right: 10px;
      margin-bottom: 10px;
      font-size: 0.95em;
      transition: all 0.3s;
      font-weight: 500;
    }
    button:hover { 
      background: #3a5a8a;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(74, 158, 255, 0.3);
    }
    button:disabled { 
      background: #1a1a1a; 
      color: #555; 
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .button-primary { background: #4a9eff; color: #000; font-weight: bold; }
    .button-primary:hover { background: #5aaeff; }
    .button-success { background: #4aff4a; color: #000; }
    .button-success:hover { background: #5aff5a; }
    .button-danger { background: #ff4a4a; color: #fff; }
    .button-danger:hover { background: #ff5a5a; }
    
    /* Canvas */
    .canvas-container { 
      position: relative; 
      background: #000; 
      border: 2px solid #2a2a2a; 
      border-radius: 8px;
      overflow: hidden;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      display: block;
    }
    .canvas-label { 
      position: absolute; 
      top: 12px; 
      left: 12px; 
      background: rgba(0, 0, 0, 0.8); 
      padding: 8px 14px; 
      border-radius: 4px; 
      font-size: 0.9em; 
      color: #4a9eff;
      border: 1px solid #2a4a7a;
    }
    
    /* Metrics */
    .metrics-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); 
      gap: 15px; 
      margin-top: 20px; 
    }
    .metric-card { 
      background: #0a0a0a; 
      padding: 15px; 
      border-radius: 6px; 
      border: 1px solid #2a2a2a;
      transition: all 0.3s;
    }
    .metric-card:hover {
      border-color: #4a9eff;
      box-shadow: 0 0 10px rgba(74, 158, 255, 0.2);
    }
    .metric-label { 
      font-size: 0.85em; 
      color: #888; 
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .metric-value { 
      font-size: 1.4em; 
      color: #4a9eff; 
      font-weight: bold;
    }
    .metric-value.good { color: #4aff4a; }
    .metric-value.warning { color: #ffaa4a; }
    .metric-value.bad { color: #ff4a4a; }
    
    /* Status */
    .status-box { 
      padding: 15px; 
      border-radius: 6px; 
      margin-top: 20px; 
      font-size: 0.95em;
      border: 1px solid;
    }
    .status-box.info { 
      background: #1a2a3a; 
      color: #4a9eff;
      border-color: #2a4a7a;
    }
    .status-box.success { 
      background: #1a3a1a; 
      color: #4aff4a;
      border-color: #2a6a2a;
    }
    .status-box.warning { 
      background: #3a2a1a; 
      color: #ffaa4a;
      border-color: #6a4a2a;
    }
    .status-box.error { 
      background: #3a1a1a; 
      color: #ff4a4a;
      border-color: #6a2a2a;
    }
    
    /* Table */
    table { 
      width: 100%; 
      border-collapse: collapse; 
      margin: 15px 0;
      font-size: 0.9em;
    }
    th, td { 
      padding: 12px; 
      text-align: left; 
      border-bottom: 1px solid #2a2a2a; 
    }
    th { 
      color: #4a9eff; 
      font-weight: bold;
      background: #0a0a0a;
      position: sticky;
      top: 0;
    }
    tr:hover { background: #1a1a1a; }
    
    /* Scrollable */
    .scrollable { 
      max-height: 400px; 
      overflow-y: auto;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
    }
    .scrollable::-webkit-scrollbar { width: 10px; }
    .scrollable::-webkit-scrollbar-track { background: #0a0a0a; }
    .scrollable::-webkit-scrollbar-thumb { 
      background: #2a4a7a; 
      border-radius: 5px;
    }
    .scrollable::-webkit-scrollbar-thumb:hover { background: #3a5a8a; }
    
    /* Content sections */
    .content-section { display: none; }
    .content-section.active { display: block; }
    
    /* Documentation */
    .doc-section {
      margin: 20px 0;
      padding: 20px;
      background: #0a1a2a;
      border-left: 4px solid #4a9eff;
      border-radius: 4px;
    }
    .doc-section h3 {
      color: #4a9eff;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    .doc-section p, .doc-section ul {
      color: #aaa;
      margin: 10px 0;
    }
    .doc-section ul {
      margin-left: 20px;
    }
    .doc-section li {
      margin: 8px 0;
    }
    .doc-section code {
      background: #000;
      padding: 2px 8px;
      border-radius: 3px;
      color: #4aff4a;
      font-size: 0.9em;
    }
    
    /* Alert boxes */
    .alert {
      padding: 15px 20px;
      border-radius: 6px;
      margin: 15px 0;
      border-left: 4px solid;
    }
    .alert-info {
      background: #1a2a3a;
      border-color: #4a9eff;
      color: #aaa;
    }
    .alert-success {
      background: #1a3a1a;
      border-color: #4aff4a;
      color: #aaa;
    }
    .alert-warning {
      background: #3a2a1a;
      border-color: #ffaa4a;
      color: #aaa;
    }
    
    /* File upload area */
    .upload-area {
      border: 2px dashed #3a3a3a;
      border-radius: 8px;
      padding: 30px;
      text-align: center;
      background: #0a0a0a;
      transition: all 0.3s;
      cursor: pointer;
    }
    .upload-area:hover {
      border-color: #4a9eff;
      background: #0a1a2a;
    }
    .upload-area.dragover {
      border-color: #4aff4a;
      background: #0a2a1a;
    }
.unns-data-footer {
  margin-top: 2rem;
  padding: 1rem 1.5rem;
  border-top: 1px solid rgba(255,255,255,0.08);
  font-size: 0.8rem;
  color: #c4c8dd;
  background: rgba(0, 0, 0, 0.25);
}

.unns-data-footer strong {
  color: #ffcc66;
  font-weight: 600;
}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚öõÔ∏è UNNS LABORATORY ‚Äî v0.9.2 (Research Preview)</h1>
      <div class="subtitle">Real Data Assimilation Layer ‚Äî œÉ-Weighted Quality Analysis</div>
      <div class="version-badge">v0.9.2 ‚Ä¢ œÉ-Weighted + Reliability Scoring</div>
    </header>
    
    <!-- Navigation Tabs -->
    <div class="tabs">
      <div class="tab active" data-tab="simulator">üî¨ œÑ-MSC Simulator</div>
      <div class="tab" data-tab="loader">üìÅ Real Data Loader</div>
      <div class="tab" data-tab="comparison">üîç Comparison Engine</div>
      <div class="tab" data-tab="guide">üìñ Laboratory Guide</div>
    </div>
    
    <!-- TAB 1: œÑ-MSC Simulator -->
    <div id="tab-simulator" class="content-section active">
      <div class="panel">
        <div class="panel-title">Synthetic Spectrum Generator (œÑ-MSC)</div>
        
        <div class="form-grid">
          <div class="form-row">
            <label>Grid Size</label>
            <select id="simGridSize">
              <option value="64">64√ó64 (fast)</option>
              <option value="128" selected>128√ó128 (balanced)</option>
              <option value="192">192√ó192 (high-res)</option>
              <option value="256">256√ó256 (publication)</option>
            </select>
          </div>
          
          <div class="form-row">
            <label>Œª (Coupling) <span id="simLambdaVal">0.108</span></label>
            <input type="range" id="simLambda" min="0.08" max="0.15" step="0.001" value="0.108">
          </div>
          
          <div class="form-row">
            <label>œÉ (Noise)</label>
            <input type="number" id="simSigma" value="0.02" step="0.01" min="0">
          </div>
          
          <div class="form-row">
            <label>Evolution Steps</label>
            <input type="number" id="simSteps" value="400" step="50" min="100">
          </div>
          
          <div class="form-row">
            <label>Seed</label>
            <input type="number" id="simSeed" value="137042" step="1">
          </div>
          
          <div class="form-row">
            <label>Line Detection Threshold</label>
            <select id="simThreshold">
              <option value="90">90th percentile</option>
              <option value="95" selected>95th percentile (recommended)</option>
              <option value="98">98th percentile</option>
              <option value="99">99th percentile</option>
            </select>
          </div>
        </div>
        
        <div class="form-row" style="margin-top: 15px;">
          <label>
            <input type="checkbox" id="simAutoThrottle" checked>
            Auto-throttle FPS for large grids (prevents browser freeze)
          </label>
        </div>
        
        <div style="margin-top: 20px;">
          <button id="btnGenerate" class="button-primary">‚ñ∂ Generate Spectrum</button>
          <button id="btnStop" disabled class="button-danger">‚èπ Stop</button>
          <button id="btnExportSynthetic" disabled>üíæ Export JSON</button>
        </div>
        
        <div id="simStatus" class="status-box info" style="display: none;">
          Initializing...
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-title">Visualization</div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
          <div class="canvas-container" style="aspect-ratio: 1;">
            <canvas id="canvasTau"></canvas>
            <div class="canvas-label">œÑ-Field Evolution</div>
          </div>
          <div class="canvas-container" style="aspect-ratio: 1;">
            <canvas id="canvasCurvature"></canvas>
            <div class="canvas-label">Curvature (‚àá¬≤œÑ)</div>
          </div>
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-title">Generated Lines (œÑ-Microstructure)</div>
        <div class="metrics-grid">
          <div class="metric-card">
            <div class="metric-label">Lines Detected</div>
            <div class="metric-value" id="metricLines">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Freq Range (MHz)</div>
            <div class="metric-value" id="metricFreqRange">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Avg Curvature</div>
            <div class="metric-value" id="metricCurvature">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Status</div>
            <div class="metric-value" id="metricStatus">Ready</div>
          </div>
        </div>
        
        <div class="scrollable" style="margin-top: 20px;">
          <table id="tableSynthetic">
            <thead>
              <tr>
                <th>#</th>
                <th>Frequency (MHz)</th>
                <th>Curvature</th>
                <th>œÑ-Phase</th>
                <th>Product (C√óœÑ)</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- TAB 2: Real Data Loader -->
    <div id="tab-loader" class="content-section">
      <div class="panel">
        <div class="panel-title">Dataset Selection</div>
        
        <div class="alert alert-info">
          <strong>üì¶ Preset Datasets Available</strong><br>
          Select from 10+ curated molecular hyperfine datasets, or upload your own JSON/CSV files.
        </div>
        
        <div class="form-grid">
          <div class="form-row">
            <label>Preset Dataset Pack</label>
            <select id="presetSelector">
              <option value="">-- Select Preset --</option>
              <option value="RaF_v1">RaF (Radium Fluoride) ‚Ä¢ J=1/2 ‚Ä¢ 47 lines</option>
              <option value="OH_v1">OH (Hydroxyl Radical) ‚Ä¢ ¬≤Œ†‚ÇÉ/‚ÇÇ ‚Ä¢ 32 lines</option>
              <option value="AlH_v1">AlH (Aluminum Hydride) ‚Ä¢ X¬πŒ£‚Å∫ ‚Ä¢ 28 lines</option>
              <option value="ThO_v1">ThO (Thorium Oxide) ‚Ä¢ H¬≥Œî‚ÇÅ ‚Ä¢ 56 lines</option>
              <option value="YbF_v1">YbF (Ytterbium Fluoride) ‚Ä¢ ¬≤Œ£‚ÇÅ/‚ÇÇ ‚Ä¢ 38 lines</option>
              <option value="CH_v1">CH (Methylidyne) ‚Ä¢ X¬≤Œ† ‚Ä¢ 24 lines</option>
              <option value="NH_v1">NH (Imidogen) ‚Ä¢ a¬πŒî ‚Ä¢ 29 lines</option>
              <option value="CaF_v1">CaF (Calcium Fluoride) ‚Ä¢ X¬≤Œ£‚Å∫ ‚Ä¢ 42 lines</option>
              <option value="SrF_v1">SrF (Strontium Fluoride) ‚Ä¢ X¬≤Œ£‚Å∫ ‚Ä¢ 35 lines</option>
              <option value="BaF_v1">BaF (Barium Fluoride) ‚Ä¢ X¬≤Œ£‚Å∫ ‚Ä¢ 51 lines</option>
            </select>
          </div>
        </div>
        
        <button id="btnLoadPreset" disabled class="button-success">üì• Load Selected Preset</button>
        
        <div style="margin: 30px 0; border-top: 2px solid #2a2a2a; padding-top: 30px;">
          <h3 style="color: #4a9eff; margin-bottom: 15px;">Or Upload Custom Data</h3>
          
          <div class="upload-area" id="uploadArea">
            <div style="font-size: 2em; margin-bottom: 10px;">üìÇ</div>
            <div style="color: #aaa; margin-bottom: 10px;">
              Drag & drop JSON/CSV file here, or click to browse
            </div>
            <input type="file" id="fileInput" accept=".json,.csv" style="display: none;">
            <button id="btnBrowse" class="button-primary" style="margin-top: 10px;">Browse Files</button>
          </div>
        </div>
        
        <div id="loaderStatus" class="status-box info" style="display: none;">
          No data loaded
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-title">Loaded Dataset</div>
        
        <div class="metrics-grid">
          <div class="metric-card">
            <div class="metric-label">Molecule</div>
            <div class="metric-value" id="metricMolecule">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Lines Loaded</div>
            <div class="metric-value" id="metricRealLines">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Freq Range (MHz)</div>
            <div class="metric-value" id="metricRealRange">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Uncertainty</div>
            <div class="metric-value" id="metricUncertainty">‚Äî</div>
          </div>
        </div>
        
        <div class="scrollable" style="margin-top: 20px;">
          <table id="tableReal">
            <thead>
              <tr>
                <th>#</th>
                <th>Frequency (MHz)</th>
                <th>Uncertainty (MHz)</th>
                <th>Intensity</th>
                <th>Assignment</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- TAB 3: Comparison Engine -->
    <div id="tab-comparison" class="content-section">
      <div class="panel">
        <div class="panel-title">Comparison Configuration</div>
        
        <div class="form-grid">
          <div class="form-row">
            <label>Matching Threshold (MHz)</label>
            <input type="number" id="compThreshold" value="50" step="10" min="1">
          </div>
          
          <div class="form-row">
            <label>Frequency Weight</label>
            <input type="number" id="compWeightFreq" value="1.0" step="0.1" min="0">
          </div>
          
          <div class="form-row">
            <label>Curvature Weight</label>
            <input type="number" id="compWeightCurv" value="0.5" step="0.1" min="0">
          </div>
          
          <div class="form-row">
            <label>BW Weight</label>
            <input type="number" id="compWeightBW" value="0.3" step="0.1" min="0">
          </div>
          
          <div class="form-row">
            <label>Frequency Scaling Mode</label>
            <select id="compScaling">
              <option value="minmax">Min-Max Normalization</option>
              <option value="percentile" selected>Percentile-Based (5-95)</option>
            </select>
          </div>
        </div>
        
        <div class="form-row" style="margin-top: 15px;">
          <label>
            <input type="checkbox" id="chkAutoCalibrate" checked>
            Apply automatic frequency calibration (offset + scale)
          </label>
          <span id="calibSummary" style="margin-left: 1rem; color: #9ca3af;">
            (pending)
          </span>
        </div>
        
        <div class="form-row" style="margin-top: 15px;">
          <label>
            <input type="checkbox" id="chkHyperfineManifold">
            Hyperfine Manifold Mode
          </label>
          <span id="manifoldSummary" style="margin-left: 1rem; color: #9ca3af;">
            (groups lines by manifold_id)
          </span>
        </div>
        
        <div class="form-row" style="margin-top: 10px;">
          <label>
            <input type="checkbox" id="chkTauHyperfineCoupling" disabled>
            Apply œÑ-Hyperfine Coupling Layer
          </label>
          <span id="couplingSummary" style="margin-left: 1rem; color: #9ca3af;">
            (requires manifold mode)
          </span>
        </div>
        
        <div style="margin-top: 10px; padding: 12px; background: #0a1a0a; border-radius: 4px; border-left: 3px solid #4a9eff;">
          <div id="nonlinearSummary" style="font-size: 0.9em; line-height: 1.6; color: #aaa;">
            Nonlinear œÑ-Projection: (not yet computed)
          </div>
        </div>
        
        <button id="btnRunComparison" disabled class="button-primary" style="margin-top: 20px;">
          üîç Run Comparison
        </button>
        
        <div id="compStatus" class="status-box info" style="display: none;">
          Load synthetic and real data first
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-title">Validation Metrics (C_RDA)</div>
        
        <div class="metrics-grid">
          <div class="metric-card">
            <div class="metric-label">Match Rate</div>
            <div class="metric-value" id="metricMatchRate">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">RMSE (MHz)</div>
            <div class="metric-value" id="metricRMSE">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Correlation (R¬≤)</div>
            <div class="metric-value" id="metricR2">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">œá¬≤/dof</div>
            <div class="metric-value" id="metricChi2">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Mean Error (MHz)</div>
            <div class="metric-value" id="metricMeanError">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Max Error (MHz)</div>
            <div class="metric-value" id="metricMaxError">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Manifolds Matched</div>
            <div class="metric-value" id="metricManifoldsMatched">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">œá¬≤/dof (Normalized)</div>
            <div class="metric-value" id="metricChi2Manifolds">‚Äî</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">œá¬≤/dof (œÉ-Weighted)</div>
            <div class="metric-value" id="metricChi2Weighted">‚Äî</div>
          </div>
        </div>
        
        <!-- v0.9.2: Enhanced Fit Quality Metrics -->
        <div style="margin-top: 20px; padding: 15px; background: #0a1a0a; border-radius: 4px; border-left: 3px solid #4a9eff;">
          <div style="font-size: 1.1em; color: #4a9eff; margin-bottom: 10px; font-weight: bold;">
            Fit Quality (v0.9.2 œÉ-Weighted + Reliability)
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div>
              <span style="color: #888;">œÑ-Reliability (v2):</span>
              <span id="metricReliability" style="color: #4aff4a; font-weight: bold; margin-left: 5px;">‚Äî</span>
            </div>
            <div>
              <span style="color: #888;">Outliers (|Œîf| > 20 MHz):</span>
              <span id="metricOutliers" style="color: #ffaa4a; font-weight: bold; margin-left: 5px;">‚Äî</span>
            </div>
            <div>
              <span style="color: #888;">Expected Outliers (Œ£P):</span>
              <span id="metricExpectedOutliers" style="color: #ffaa4a; font-weight: bold; margin-left: 5px;">‚Äî</span>
            </div>
            <div>
              <span style="color: #888;">Weighted œá¬≤/dof:</span>
              <span id="metricWeightedChi2Display" style="color: #4a9eff; font-weight: bold; margin-left: 5px;">‚Äî</span>
            </div>
          </div>
        </div>
        
        <!-- v0.9.2: Per-Manifold Statistics Table -->
        <div id="manifoldStatsBlock" style="margin-top: 20px; padding: 15px; background: #0a1a0a; border-radius: 4px; border-left: 3px solid #ff4a9e; display: none;">
          <div style="font-size: 1.1em; color: #ff4a9e; margin-bottom: 10px; font-weight: bold;">
            Per-Manifold Statistics (v0.9.2)
          </div>
          <table style="width: 100%; font-size: 0.9em;">
            <thead>
              <tr style="border-bottom: 2px solid #3a3a3a;">
                <th style="padding: 5px; text-align: left; color: #4a9eff;">Manifold ID</th>
                <th style="padding: 5px; text-align: center; color: #4a9eff;">N Lines</th>
                <th style="padding: 5px; text-align: center; color: #4a9eff;">RMSE (MHz)</th>
                <th style="padding: 5px; text-align: center; color: #4a9eff;">œá¬≤/dof (Norm)</th>
                <th style="padding: 5px; text-align: center; color: #4a9eff;">œá¬≤/dof (œÉ-W)</th>
                <th style="padding: 5px; text-align: center; color: #4a9eff;">Œ∫ (Coher.)</th>
                <th style="padding: 5px; text-align: center; color: #4a9eff;">R (Reliab.)</th>
              </tr>
            </thead>
            <tbody id="manifoldStatsTable">
              <!-- Populated dynamically -->
            </tbody>
          </table>
        </div>
        
        <div id="hyperfineBlock" style="margin-top: 20px; padding: 12px; background: #0a1a2a; border-radius: 4px; border-left: 3px solid #ff4a9e; display: none;">
          <div style="font-size: 0.95em; line-height: 1.8; color: #e0e0e0;">
            <strong style="color: #ff4a9e;">œÑ-Hyperfine Coupling:</strong><br>
            <span id="tauHyperfineStatus" style="color: #888;">Not computed</span>
          </div>
        </div>
        
        <div id="validationSummary" class="alert alert-info" style="margin-top: 20px; display: none;">
          <strong>Validation Status</strong><br>
          <div id="validationText"></div>
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-title">Matched Pairs</div>
        
        <div class="scrollable">
          <table id="tableMatched">
            <thead>
              <tr>
                <th>#</th>
                <th>Real Freq (MHz)</th>
                <th>Synth Freq (MHz)</th>
                <th>Residual (MHz)</th>
                <th>Curvature</th>
                <th>œÑ-Phase</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        
        <button id="btnExportComparison" disabled style="margin-top: 15px;">
          üíæ Export Comparison Results
        </button>
      </div>
    </div>
    
    <!-- TAB 4: Laboratory Guide -->
    <div id="tab-guide" class="content-section">
      <div class="panel">
        <div class="panel-title">Laboratory Guide ‚Äî UNNS Lab v0.9.2</div>
        
        <!-- SVG Architecture Diagram -->
        <div style="background: #0a1a2a; padding: 20px; border-radius: 8px; margin-bottom: 30px; border: 2px solid #2a4a7a;">
          <h3 style="color: #4a9eff; text-align: center; margin-bottom: 15px;">v0.9.2 Architecture Overview</h3>
          <svg viewBox="0 0 800 600" style="width: 100%; max-width: 800px; margin: 0 auto; display: block;">
            <!-- Background -->
            <rect width="800" height="600" fill="#0a0a0a"/>
            
            <!-- Title -->
            <text x="400" y="30" text-anchor="middle" fill="#4a9eff" font-size="18" font-weight="bold">
              UNNS Laboratory v0.9.2 ‚Äî Real Data Assimilation Pipeline
            </text>
            
            <!-- Layer 1: Data Input -->
            <g id="layer1">
              <rect x="50" y="60" width="150" height="80" fill="#1a2a3a" stroke="#4a9eff" stroke-width="2" rx="5"/>
              <text x="125" y="85" text-anchor="middle" fill="#4aff4a" font-size="12" font-weight="bold">œÑ-MSA Simulator</text>
              <text x="125" y="105" text-anchor="middle" fill="#aaa" font-size="10">Curvature Field</text>
              <text x="125" y="120" text-anchor="middle" fill="#aaa" font-size="10">œÑ-Phase</text>
              <text x="125" y="135" text-anchor="middle" fill="#aaa" font-size="10">Hotspot Detection</text>
              
              <rect x="250" y="60" width="150" height="80" fill="#1a2a3a" stroke="#4a9eff" stroke-width="2" rx="5"/>
              <text x="325" y="85" text-anchor="middle" fill="#4aff4a" font-size="12" font-weight="bold">Real Data Loader</text>
              <text x="325" y="105" text-anchor="middle" fill="#aaa" font-size="10">Spectral Lines</text>
              <text x="325" y="120" text-anchor="middle" fill="#aaa" font-size="10">Uncertainties (œÉ)</text>
              <text x="325" y="135" text-anchor="middle" fill="#aaa" font-size="10">Manifold IDs</text>
            </g>
            
            <!-- Arrow Down -->
            <path d="M 200 140 L 200 170 M 325 140 L 325 170" stroke="#4a9eff" stroke-width="2" fill="none"/>
            <polygon points="200,170 195,160 205,160" fill="#4a9eff"/>
            <polygon points="325,170 320,160 330,160" fill="#4a9eff"/>
            
            <!-- Layer 2: Projection Engine (v0.9.1) -->
            <g id="layer2">
              <rect x="50" y="180" width="350" height="100" fill="#1a3a2a" stroke="#ff4a9e" stroke-width="2" rx="5"/>
              <text x="225" y="200" text-anchor="middle" fill="#ff4a9e" font-size="12" font-weight="bold">Nonlinear œÑ-Projection Engine (v0.9.1)</text>
              <text x="225" y="220" text-anchor="middle" fill="#aaa" font-size="10">f_real ‚âà a‚ÇÄ + a‚ÇÅ¬∑f_syn + a‚ÇÇ¬∑C + a‚ÇÉ¬∑|C¬∑œÑ| + a‚ÇÑ¬∑œÑ + a‚ÇÖ¬∑f_syn¬≤</text>
              <text x="225" y="240" text-anchor="middle" fill="#aaa" font-size="10">3-Pass: Normalization ‚Üí Calibration ‚Üí Projection</text>
              <text x="225" y="260" text-anchor="middle" fill="#4aff4a" font-size="10">‚Üí Matched Pairs (frequency aligned)</text>
            </g>
            
            <!-- Arrow Down -->
            <path d="M 225 280 L 225 305" stroke="#ff4a9e" stroke-width="2" fill="none"/>
            <polygon points="225,305 220,295 230,295" fill="#ff4a9e"/>
            
            <!-- Layer 3: Manifold Engine (v0.9) -->
            <g id="layer3">
              <rect x="50" y="315" width="350" height="80" fill="#2a1a3a" stroke="#ffaa4a" stroke-width="2" rx="5"/>
              <text x="225" y="335" text-anchor="middle" fill="#ffaa4a" font-size="12" font-weight="bold">Hyperfine Manifold Engine (v0.9)</text>
              <text x="225" y="355" text-anchor="middle" fill="#aaa" font-size="10">Groups by manifold_id ‚Üí Per-manifold statistics</text>
              <text x="225" y="375" text-anchor="middle" fill="#aaa" font-size="10">œá¬≤ Normalization Layer (v0.9.1): curv_scale √ó freq_scale</text>
            </g>
            
            <!-- Arrow Down -->
            <path d="M 225 395 L 225 420" stroke="#ffaa4a" stroke-width="2" fill="none"/>
            <polygon points="225,420 220,410 230,410" fill="#ffaa4a"/>
            
            <!-- Layer 4: Quality Metrics (v0.9.2) - MAIN NEW FEATURE -->
            <g id="layer4">
              <rect x="50" y="430" width="350" height="130" fill="#2a2a1a" stroke="#4aff4a" stroke-width="3" rx="5"/>
              <text x="225" y="450" text-anchor="middle" fill="#4aff4a" font-size="13" font-weight="bold">üÜï Quality Metrics Layer (v0.9.2)</text>
              
              <!-- Sub-boxes for metrics -->
              <rect x="60" y="460" width="100" height="50" fill="#1a1a0a" stroke="#4a9eff" stroke-width="1" rx="3"/>
              <text x="110" y="475" text-anchor="middle" fill="#4a9eff" font-size="9" font-weight="bold">œÉ-Weighted œá¬≤</text>
              <text x="110" y="488" text-anchor="middle" fill="#aaa" font-size="8">w_i = 1/(œÉ_i¬≤+Œµ)</text>
              <text x="110" y="500" text-anchor="middle" fill="#aaa" font-size="8">Adaptive weights</text>
              
              <rect x="170" y="460" width="100" height="50" fill="#1a1a0a" stroke="#4a9eff" stroke-width="1" rx="3"/>
              <text x="220" y="475" text-anchor="middle" fill="#4a9eff" font-size="9" font-weight="bold">Coherence Œ∫</text>
              <text x="220" y="488" text-anchor="middle" fill="#aaa" font-size="8">|Corr(|C|, |Œîf|)|</text>
              <text x="220" y="500" text-anchor="middle" fill="#aaa" font-size="8">Fit diagnostic</text>
              
              <rect x="280" y="460" width="110" height="50" fill="#1a1a0a" stroke="#4a9eff" stroke-width="1" rx="3"/>
              <text x="335" y="475" text-anchor="middle" fill="#4a9eff" font-size="9" font-weight="bold">Reliability R, œÑ_R</text>
              <text x="335" y="488" text-anchor="middle" fill="#aaa" font-size="8">R = exp(-Œ∫¬∑œá¬≤/20)</text>
              <text x="335" y="500" text-anchor="middle" fill="#aaa" font-size="8">Manifold quality</text>
              
              <text x="225" y="525" text-anchor="middle" fill="#4aff4a" font-size="10">Output: Triple œá¬≤ + Œ∫ + R + Expected Outliers</text>
              <text x="225" y="545" text-anchor="middle" fill="#aaa" font-size="9">Per-manifold: {œá¬≤_norm, œá¬≤_weighted, Œ∫, R}</text>
            </g>
            
            <!-- Side Panel: Output Metrics -->
            <g id="outputs">
              <rect x="450" y="180" width="320" height="380" fill="#1a1a2a" stroke="#4a9eff" stroke-width="2" rx="5"/>
              <text x="610" y="205" text-anchor="middle" fill="#4a9eff" font-size="13" font-weight="bold">Output Metrics</text>
              
              <!-- C_RDA Criteria -->
              <text x="465" y="230" fill="#ffaa4a" font-size="11" font-weight="bold">C_RDA Validation:</text>
              <text x="470" y="248" fill="#aaa" font-size="9">‚úì Match Rate ‚â• 60%</text>
              <text x="470" y="263" fill="#aaa" font-size="9">‚úì RMSE &lt; 10 MHz</text>
              <text x="470" y="278" fill="#aaa" font-size="9">‚úì R¬≤ ‚â• 0.85</text>
              <text x="470" y="293" fill="#aaa" font-size="9">‚úì œá¬≤/dof &lt; 1.5</text>
              
              <!-- Chi-squared Metrics -->
              <text x="465" y="320" fill="#4a9eff" font-size="11" font-weight="bold">œá¬≤ Metrics (Triple Display):</text>
              <text x="470" y="338" fill="#aaa" font-size="9">‚Ä¢ œá¬≤/dof (Raw) ‚Äî unscaled</text>
              <text x="470" y="353" fill="#aaa" font-size="9">‚Ä¢ œá¬≤/dof (Norm) ‚Äî œÑ-field scaled</text>
              <text x="470" y="368" fill="#4aff4a" font-size="9">‚Ä¢ œá¬≤/dof (œÉ-W) ‚Äî uncertainty weighted</text>
              
              <!-- Quality Metrics v0.9.2 -->
              <text x="465" y="395" fill="#4aff4a" font-size="11" font-weight="bold">v0.9.2 Quality Metrics:</text>
              <text x="470" y="413" fill="#aaa" font-size="9">‚Ä¢ Œ∫ (Coherence): 0-1 scale</text>
              <text x="470" y="428" fill="#aaa" font-size="9">‚Ä¢ R (Per-manifold): 0-1 reliability</text>
              <text x="470" y="443" fill="#aaa" font-size="9">‚Ä¢ œÑ_R (Unified): mean(R_manifold)</text>
              <text x="470" y="458" fill="#aaa" font-size="9">‚Ä¢ Œ£P: Expected outlier count</text>
              
              <!-- Coupling Parameters -->
              <text x="465" y="485" fill="#ff4a9e" font-size="11" font-weight="bold">œÑ-Hyperfine Coupling:</text>
              <text x="470" y="503" fill="#aaa" font-size="9">‚Ä¢ ŒîC (MHz) ‚Äî curvature offset</text>
              <text x="470" y="518" fill="#aaa" font-size="9">‚Ä¢ g_œâ ‚Äî œÑ-spin coupling</text>
              
              <!-- Export -->
              <text x="465" y="545" fill="#888" font-size="10" font-weight="bold">Export: JSON bundle</text>
            </g>
            
            <!-- Version Badge -->
            <rect x="650" y="10" width="130" height="30" fill="#2a4a7a" stroke="#4aff4a" stroke-width="1" rx="3"/>
            <text x="715" y="28" text-anchor="middle" fill="#4aff4a" font-size="11" font-weight="bold">v0.9.2-R2</text>
          </svg>
        </div>

        <!-- 1. Overview -->
        <div class="doc-section">
          <h3>üéØ Overview</h3>
          <p>
            The UNNS Laboratory v0.9.2 provides a complete pipeline for validating the
            <strong>œÑ-Microstructure Hypothesis</strong> using real molecular spectral data.
            The system integrates: nonlinear œÑ-projection (v0.9.1), multi-manifold
            hyperfine analysis (v0.9), and the new v0.9.2 <strong>Quality Metrics Layer</strong>
            featuring œÉ-weighted œá¬≤, curvature‚Äìresidual coherence, and œÑ-Reliability v2.
          </p>
        </div>
        <div class="doc-section">
<h3>üìù Change Log (v0.9.2 Research Preview)</h3>
<ul>
<li><strong>Added Quality Metrics Layer:</strong> œÉ-weighted œá¬≤, Œ∫-coherence, R reliability, unified œÑ<sub>R</sub>, expected-outlier stats.</li>
<li><strong>Modernized œÑ-MSA Framework:</strong> replaced legacy œÑ-MSC terminology with invariant-based œÑ-field descriptors.</li>
<li><strong>Updated Workflow:</strong> clarified projection ‚Üí manifold ‚Üí quality ‚Üí coupling sequence.</li>
<li><strong>Refined Projection Model:</strong> consolidated six-term nonlinear œÑ-projection.</li>
<li><strong>Improved Hyperfine Integration:</strong> clarified ŒîC & g<sub>œâ</sub> manifold centroid solver behavior.</li>
<li><strong>Guide Reorganization:</strong> reordered sections to match real v0.9.2 architecture.</li>
<li><strong>Research Preview Notice:</strong> marked v0.9.2 as provisional pending extended molecule validation.</li>
</ul>
</div>
        <!-- 2. Modern œÑ-MSA Framework -->
        <div class="doc-section">
          <h3>üî¨ œÑ-MSA Framework (Modernized)</h3>
          <p>
            The œÑ-Microstructure Spectral Analysis (œÑ-MSA) pipeline replaces the older
            œÑ-MSC simulator language. œÑ-MSA treats œÑ as a <strong>recursive geometric
            field</strong> with curvature, phase, and mixed invariants that project into
            spectroscopic structure.
          </p>
          <ul>
            <li><strong>Curvature (C):</strong> second-order œÑ-geometry; correlates with hyperfine splittings</li>
            <li><strong>œÑ-phase:</strong> local recursive phase defining manifold-level offsets</li>
            <li><strong>Curvature √ó Phase:</strong> mixed invariant mapping to BW-like magnetization effects</li>
          </ul>
          <p>
            These invariants feed into the unified nonlinear projection model and form the
            basis of cross-manifold œÑ-coupling.
          </p>
        </div>

        <!-- 3. Workflow -->
        <div class="doc-section">
          <h3>üìä Workflow (Updated)</h3>
          <ol>
            <li><strong>Load Real Data:</strong> Choose a preset molecule or upload a custom dataset.</li>
            <li><strong>Run Projection:</strong> Apply v0.9.1 nonlinear œÑ-projection to align synthetic/real lines.</li>
            <li><strong>Manifold Grouping:</strong> Cluster matched lines into hyperfine manifolds.</li>
            <li><strong>Compute Quality Metrics:</strong> Raw œá¬≤, normalized œá¬≤, œÉ-weighted œá¬≤, Œ∫, R, œÑ<sub>R</sub>.</li>
            <li><strong>Hyperfine Analysis:</strong> Solve ŒîC and g<sub>œâ</sub> via the multi-manifold coupling layer.</li>
          </ol>
        </div>

        <!-- 4. C_RDA validation -->
        <div class="doc-section">
          <h3>‚úÖ C_RDA Validation Criteria (Unchanged)</h3>
          <p>The classical C_RDA metrics are preserved for backward compatibility.</p>
          <table style="background: #0a0a0a;">
            <tr><th>Criterion</th><th>Target</th><th>Meaning</th></tr>
            <tr><td><strong>C_RDA1:</strong> Match Rate</td><td>‚â• 60%</td><td>Overlap of real/synthetic structure</td></tr>
            <tr><td><strong>C_RDA2:</strong> RMSE</td><td>&lt; 10 MHz</td><td>Spectral alignment accuracy</td></tr>
            <tr><td><strong>C_RDA3:</strong> R¬≤</td><td>‚â• 0.85</td><td>Global linear agreement</td></tr>
            <tr><td><strong>C_RDA4:</strong> œá¬≤/dof</td><td>&lt; 1.5</td><td>Classical statistical fit quality</td></tr>
          </table>
        </div>

        <!-- 5. Parameter Guide -->
        <div class="doc-section">
          <h3>üéõÔ∏è Parameter Guide (Modernized)</h3>
          <p><strong>Projection Parameters:</strong></p>
          <ul>
            <li><strong>Scale (a):</strong> Linear projection slope</li>
            <li><strong>Offset (b):</strong> Calibration intercept</li>
            <li><strong>œÑ-Invariants:</strong> C, œÑ, |C¬∑œÑ|, f¬≤ contributions</li>
            <li><strong>Detection Threshold:</strong> Controls hotspot extraction</li>
          </ul>
          <p><strong>Comparison Weights (fixed):</strong></p>
          <ul>
            <li><strong>Frequency:</strong> 1.0</li>
            <li><strong>Curvature:</strong> 0.5</li>
            <li><strong>BW proxy:</strong> 0.3</li>
          </ul>
        </div>

        <!-- 6. Nonlinear projection -->
        <div class="doc-section">
          <h3>üî¨ Nonlinear œÑ-Projection Engine (v0.9.1)</h3>
          <p>
            The projection engine aligns synthetic œÑ-field features with real hyperfine
            spectra using a six-term nonlinear model:
          </p>
          <code style="background:#0a0a0a; padding:8px; display:block; border-left:3px solid #4a9eff;">
            f_real ‚âà a‚ÇÄ + a‚ÇÅ f_syn + a‚ÇÇ C + a‚ÇÉ|C¬∑œÑ| + a‚ÇÑ œÑ + a‚ÇÖ f_syn¬≤
          </code>
          <p>
            This is the foundation for manifold-level analysis and higher-order coupling.
          </p>
        </div>

        <!-- 7. Quality Metrics Overview (v0.9.2) -->
        <div class="doc-section" id="quality-metrics-overview">
          <h3>üìà Quality Metrics Overview (v0.9.2)</h3>
          <p>
            v0.9.2 introduces a modern three-layer evaluation system:
            <strong>structural adequacy</strong>, <strong>experimental precision</strong>, and
            <strong>œÑ-geometry reliability</strong>. These metrics are independent and should
            never be mixed.
          </p>
          <ul>
            <li><strong>œá¬≤/dof (Raw):</strong> unscaled mismatch</li>
            <li><strong>œá¬≤/dof (Normalized):</strong> œÑ-field structural accuracy</li>
            <li><strong>œá¬≤/dof (œÉ-Weighted):</strong> dataset uncertainty consistency</li>
            <li><strong>Œ∫:</strong> curvature‚Äìresidual coherence</li>
            <li><strong>R:</strong> manifold reliability</li>
            <li><strong>œÑ<sub>R</sub>:</strong> unified œÑ-reliability</li>
            <li><strong>Œ£P:</strong> expected outliers</li>
          </ul>
        </div>
        <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     UNNS LAB v0.9.2 ‚Äî Quality Metrics Overview
     (Dark-mode Guide Block)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="lab-guide-section" id="quality-metrics-overview">
  <style>
    /* You can move this into user.css later */
    #quality-metrics-overview {
      margin-top: 2rem;
      padding: 1.5rem 1.75rem 2.25rem;
      background: radial-gradient(circle at top left, #1e2847 0%, #090c18 55%, #050712 100%);
      border-radius: 14px;
      border: 1px solid rgba(120, 160, 255, 0.28);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      color: #e5e7ff;
      font-size: 0.95rem;
      line-height: 1.7;
    }

    #quality-metrics-overview h2 {
      font-size: 1.4rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      margin: 0 0 0.75rem;
    }

    #quality-metrics-overview h3 {
      font-size: 1.1rem;
      margin-top: 1.6rem;
      margin-bottom: 0.5rem;
    }

    #quality-metrics-overview h4 {
      font-size: 1.0rem;
      margin-top: 1.1rem;
      margin-bottom: 0.25rem;
    }

    #quality-metrics-overview p {
      margin: 0.2rem 0 0.6rem;
      color: #cfd4ff;
    }

    #quality-metrics-overview .badge-row {
      margin-bottom: 1rem;
    }

    #quality-metrics-overview .badge {
      display: inline-block;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-right: 0.4rem;
    }

    #quality-metrics-overview .badge-phase {
      background: linear-gradient(135deg, #34d399, #059669);
      color: #02140b;
    }

    #quality-metrics-overview .badge-sigma {
      background: linear-gradient(135deg, #22d3ee, #0ea5e9);
      color: #011017;
    }

    #quality-metrics-overview .badge-reliab {
      background: linear-gradient(135deg, #a855f7, #6366f1);
      color: #050314;
    }

    #quality-metrics-overview .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 0.9rem;
      margin-top: 0.8rem;
    }

    #quality-metrics-overview .metric-card {
      background: radial-gradient(circle at top, #1b2440 0%, #090d1c 60%);
      border-radius: 10px;
      padding: 0.75rem 0.9rem;
      border: 1px solid rgba(125, 145, 255, 0.3);
    }

    #quality-metrics-overview .metric-title {
      font-size: 0.84rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #9ca7ff;
      margin-bottom: 0.25rem;
    }

    #quality-metrics-overview .metric-body {
      font-size: 0.86rem;
      color: #dde3ff;
    }

    #quality-metrics-overview .metric-body em {
      color: #f9fafb;
      font-style: normal;
    }

    #quality-metrics-overview .callout {
      margin-top: 1.3rem;
      padding: 0.85rem 0.9rem;
      border-radius: 10px;
      border: 1px dashed rgba(148, 163, 255, 0.65);
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.12), rgba(76, 29, 149, 0.28));
      font-size: 0.9rem;
    }

    #quality-metrics-overview .callout-strong {
      font-weight: 600;
      color: #e5e7ff;
    }

    #quality-metrics-overview table.metric-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.9rem;
      font-size: 0.82rem;
    }

    #quality-metrics-overview table.metric-table th,
    #quality-metrics-overview table.metric-table td {
      padding: 0.45rem 0.5rem;
      text-align: left;
      border-bottom: 1px solid rgba(55, 65, 120, 0.7);
    }

    #quality-metrics-overview table.metric-table th {
      text-transform: uppercase;
      letter-spacing: 0.14em;
      font-weight: 600;
      color: #a5b4ff;
      background: rgba(15, 23, 42, 0.9);
    }

    #quality-metrics-overview table.metric-table td {
      color: #cdd4ff;
    }

    #quality-metrics-overview table.metric-table tr:nth-child(even) td {
      background: rgba(15, 23, 42, 0.5);
    }

    #quality-metrics-overview .metric-tag-ok {
      color: #6ee7b7;
      font-weight: 600;
    }

    #quality-metrics-overview .metric-tag-no {
      color: #f97373;
      font-weight: 600;
    }
  </style>

  <h2>Quality Metrics Overview (v0.9.2)</h2>
  <div class="badge-row">
    <span class="badge badge-phase">Structural Adequacy</span>
    <span class="badge badge-sigma">œÉ-Weighted Analysis</span>
    <span class="badge badge-reliab">œÑ-Reliability v2</span>
  </div>

  <p>
    The v0.9.2 Laboratory layer evaluates each comparison through three independent
    lenses:<br>
    <strong>(1)</strong> structural adequacy of the œÑ-field model,<br>
    <strong>(2)</strong> experimental precision of the dataset, and<br>
    <strong>(3)</strong> reliability and coherence of the œÑ-geometry across manifolds.
    Keeping these tiers separate is crucial: the substrate must be judged on its
    <em>geometry</em>, while the data are judged on their <em>uncertainties</em>.
  </p>

  <!-- 1. Structural Adequacy -->
  <h3>1. Structural Adequacy Metrics</h3>
  <p>
    Structural metrics answer: <em>‚ÄúHow well does the œÑ-field microstructure explain the
    real spectroscopic pattern?‚Äù</em> They depend only on deterministic outputs of the
    œÑ-projection engine and never on per-line uncertainties œÉ.
  </p>

  <div class="metric-grid">
    <div class="metric-card">
      <div class="metric-title">Match Rate</div>
      <div class="metric-body">
        Fraction of real lines with a matched synthetic partner within the configured
        threshold. High match rate is a necessary precondition for any meaningful
        analysis.
      </div>
    </div>

    <div class="metric-card">
      <div class="metric-title">RMSE (MHz)</div>
      <div class="metric-body">
        Root-mean-square error of residuals Œîf = f<sub>real</sub> ‚àí f<sub>synth</sub>.
        Global measure of projection accuracy in MHz.
      </div>
    </div>

    <div class="metric-card">
      <div class="metric-title">Correlation (R¬≤)</div>
      <div class="metric-body">
        Coefficient of determination between real and synthetic frequencies after
        calibration. Values near 1.0 indicate that the non-linear œÑ-projection is
        tracking the overall frequency ladder correctly.
      </div>
    </div>

    <div class="metric-card">
      <div class="metric-title">œá¬≤/dof (Raw)</div>
      <div class="metric-body">
        Direct chi-square value per degree of freedom. This magnitude is not bounded
        and is reported only for transparency; it is not used in reliability scoring.
      </div>
    </div>

    <div class="metric-card">
      <div class="metric-title">œá¬≤/dof (Normalized)</div>
      <div class="metric-body">
        v0.9.1 normalization of chi-square. This is the core measure of
        <em>model‚Äìmicrostructure mismatch</em>, independent of œÉ. It is the œá¬≤ used
        inside the reliability formula.
      </div>
    </div>
  </div>

  <!-- 2. Experimental Precision -->
  <h3>2. Experimental Precision Metrics</h3>
  <p>
    Experimental metrics answer: <em>‚ÄúHow well does the dataset agree with its own
    stated uncertainties?‚Äù</em> They are œÉ-aware and intentionally decoupled from
    structural reliability.
  </p>

  <div class="metric-grid">
    <div class="metric-card">
      <div class="metric-title">œá¬≤/dof (œÉ-Weighted)</div>
      <div class="metric-body">
        Uses per-line uncertainties œÉ to weight each residual. Lines with small œÉ carry
        more influence. Large values typically indicate that uncertainties are very
        tight or underestimated; they do <strong>not</strong> automatically imply a bad
        œÑ-field model.
      </div>
    </div>

    <div class="metric-card">
      <div class="metric-title">Expected Outliers (Œ£P)</div>
      <div class="metric-body">
        Probabilistic outlier count derived from
        P<sub>i</sub> = 1 ‚àí exp(‚àí(|Œîf<sub>i</sub>| / 20)¬≤). The sum over all lines gives
        the expected number of statistical outliers and can be compared with the actual
        outlier count as a consistency check.
      </div>
    </div>
  </div>

  <!-- 3. Reliability Metrics -->
  <h3>3. Reliability Metrics (œÑ-Geometry Coherence)</h3>
  <p>
    Reliability metrics answer: <em>‚ÄúIs the œÑ-field solution structurally coherent
    across manifolds?‚Äù</em> They are designed to be insensitive to œÉ and focus solely
    on œÑ-geometry.
  </p>

  <div class="metric-grid">
    <div class="metric-card">
      <div class="metric-title">Curvature‚ÄìResidual Coherence (Œ∫)</div>
      <div class="metric-body">
        For each manifold, Œ∫ is the correlation between |curvature| and |Œîf|. Values
        near 1 indicate that high curvature systematically produces larger residuals,
        signalling underfitting in that region of the œÑ-field.
      </div>
    </div>

    <div class="metric-card">
      <div class="metric-title">Manifold Reliability R</div>
      <div class="metric-body">
        Each manifold receives a reliability score
        R = exp(‚àíŒ∫ ¬∑ (œá¬≤<sub>norm</sub> / 20)). High Œ∫ and large normalized œá¬≤ jointly
        suppress R. This 0‚Äì1 scale measures the structural stability of the œÑ-geometry
        in that manifold, independent of uncertainties œÉ.
      </div>
    </div>

    <div class="metric-card">
      <div class="metric-title">Unified œÑ-Reliability (v2)</div>
      <div class="metric-body">
        The global reliability œÑ<sub>R</sub> is the mean of manifold reliabilities.
        It summarizes how coherent the œÑ-field solution is across all manifolds. High
        œÑ<sub>R</sub> indicates a structurally stable œÑ-geometry; low œÑ<sub>R</sub>
        flags tension between manifolds.
      </div>
    </div>
  </div>

  <!-- 4. Separation of Roles -->
  <h3>4. Separation of Roles: œá¬≤_norm vs œá¬≤ (œÉ-Weighted)</h3>
  <div class="callout">
    <span class="callout-strong">Key principle.</span>
    <br>
    <em>Reliability uses œá¬≤<sub>norm</sub>, not œÉ-weighted œá¬≤.</em> œá¬≤<sub>norm</sub>
    measures how well the œÑ-field geometry fits the microstructure. œÉ-weighted œá¬≤
    measures how strongly the dataset punishes deviations relative to its declared
    uncertainties. Mixing them would make reliability depend on instrument
    sensitivity rather than œÑ-geometry.
  </div>

  <!-- 5. Summary Table -->
  <h3>5. Metric Summary</h3>
  <table class="metric-table">
    <thead>
      <tr>
        <th>Metric</th>
        <th>Primary Role</th>
        <th>Uses œÉ?</th>
        <th>Feeds Reliability?</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Match Rate</td>
        <td>Matching performance</td>
        <td class="metric-tag-no">No</td>
        <td class="metric-tag-no">No</td>
      </tr>
      <tr>
        <td>RMSE</td>
        <td>Global frequency error</td>
        <td class="metric-tag-no">No</td>
        <td class="metric-tag-no">No</td>
      </tr>
      <tr>
        <td>œá¬≤/dof (Raw)</td>
        <td>Unscaled mismatch</td>
        <td class="metric-tag-no">No</td>
        <td class="metric-tag-no">No</td>
      </tr>
      <tr>
        <td>œá¬≤/dof (Normalized)</td>
        <td>Structural adequacy of œÑ-field</td>
        <td class="metric-tag-no">No</td>
        <td class="metric-tag-ok">Yes</td>
      </tr>
      <tr>
        <td>œá¬≤/dof (œÉ-Weighted)</td>
        <td>Dataset precision and œÉ-consistency</td>
        <td class="metric-tag-ok">Yes</td>
        <td class="metric-tag-no">No</td>
      </tr>
      <tr>
        <td>Œ∫</td>
        <td>Curvature‚Äìresidual coupling</td>
        <td class="metric-tag-no">No</td>
        <td class="metric-tag-ok">Yes</td>
      </tr>
      <tr>
        <td>R</td>
        <td>Per-manifold œÑ-geometry reliability</td>
        <td class="metric-tag-no">No</td>
        <td class="metric-tag-ok">Yes</td>
      </tr>
      <tr>
        <td>œÑ<sub>R</sub> (Unified Reliability)</td>
        <td>Global œÑ-field coherence</td>
        <td class="metric-tag-no">No</td>
        <td class="metric-tag-ok">Yes</td>
      </tr>
      <tr>
        <td>Expected Outliers (Œ£P)</td>
        <td>Statistical consistency check</td>
        <td class="metric-tag-ok">Yes</td>
        <td class="metric-tag-no">No</td>
      </tr>
    </tbody>
  </table>
</section>

        <!-- 8. Manifold engine -->
        <div class="doc-section">
          <h3>üìä Hyperfine Manifold Engine (v0.9)</h3>
          <p>
            Groups matched lines by <code>manifold_id</code> and computes statistics per
            manifold, including normalized œá¬≤, curvature correlation, and manifold-level
            residual patterns.
          </p>
        </div>

        <!-- 9. Hyperfine coupling -->
        <div class="doc-section">
          <h3>üî¨ œÑ-Hyperfine Coupling Layer (v0.9.2)</h3>
          <p>
            Applies a two-parameter linear fit to manifold centroids:
          </p>
          <code style="background:#0a0a0a; padding:8px; border-left:3px solid #ff4a9e;">
            residual_manifold = ŒîC + g_œâ ¬∑ f_centroid
          </code>
          <p>
            Outputs ŒîC (curvature offset) and g<sub>œâ</sub> (œÑ-spin coupling coefficient).
          </p>
        </div>

        <!-- 10. Dataset pack -->
        <div class="doc-section">
          <h3>üì¶ Preset Dataset Pack</h3>
          <p>
            Includes curated fluoride systems (CaF, SrF, BaF, YbF) and heavy molecules
            used for œÑ-field validation.
          </p>
        </div>

        <!-- 11. Quick start -->
        <div class="doc-section">
          <h3>üöÄ Quick Start</h3>
          <ol>
            <li>Load a dataset (e.g., BaF)</li>
            <li>Run nonlinear projection</li>
            <li>Review manifold metrics</li>
            <li>Check œÑ-Reliability</li>
            <li>Interpret ŒîC and g_œâ</li>
          </ol>
        </div>

        <!-- 12. References -->
        <div class="doc-section">
          <h3>üìñ References</h3>
          <ul>
            <li>UNNS Recursive Field Framework</li>
            <li>œÑ-Microstructure Analysis Protocol</li>
            <li>Hyperfine Structure Theory</li>
          </ul>
        </div>
        
        <div style="margin-top: 30px; padding: 20px; background: #0a1a0a; border-radius: 8px; border-left: 4px solid #4aff4a;">
          <h3 style="color: #4aff4a; margin-bottom: 10px;">‚úÖ Version 0.9.2-R2 Status</h3>
          <p style="color: #aaa;">
            <strong>Production Ready</strong> ‚Ä¢ œÉ-Weighted quality analysis active ‚Ä¢ 
            Triple œá¬≤ display (Raw/Normalized/œÉ-Weighted) ‚Ä¢ Curvature-residual coherence (Œ∫) ‚Ä¢ 
            Manifold reliability scoring (R) ‚Ä¢ Unified œÑ-Reliability v2 ‚Ä¢ 
            Outlier probability estimation ‚Ä¢ Per-manifold advanced metrics ‚Ä¢ 
            Full backward compatibility with v0.9.1 ‚Ä¢ Export includes all quality metrics ‚Ä¢ 
            Ready for publication-grade spectroscopic analysis
          </p>
        </div>
      </div>
    </div>
  </div>
  <div class="unns-data-footer">
  <p>
    <strong>Real Data Notice:</strong>
    Frequency tables used in this UNNS Laboratory run originate from
    established public spectroscopy sources (e.g. NIST Atomic Spectra Database,
    JPL Spectral Catalog and peer-reviewed hyperfine measurements).
    Values are reformatted into the UNNS JSON standard but are not altered
    beyond the calibration and œá¬≤/œÑ-projection procedures described in the
    Laboratory Guide.
  </p>
</div>

  <script>
    // ============================================================================
    // UNNS Laboratory v0.9.1 ‚Äî Real Data Assimilation Layer with œá¬≤ Normalization
    // Multi-Manifold œÑ-Coupling Engine with normalized œá¬≤ metrics
    // Step 8: Nonlinear œÑ-Projection (Curvature + BW + Phase)
    // Step 9: Hyperfine Manifold Engine  
    // Step 10: œÑ-Hyperfine Coupling Layer
    // ============================================================================
    
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('UNNS Laboratory v0.9.1 | œá¬≤ Normalized œÑ-Coupling Engine');
    console.log('Step 8: Nonlinear œÑ-Projection Engine');
    console.log('Step 9: Hyperfine Manifold Engine');
    console.log('Step 10: œÑ-Hyperfine Coupling Layer');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    // ============================================================================
    // TAU-FIELD ENGINE (from Chamber XIV)
    // ============================================================================
    
    class TauFieldEngineN {
      constructor(config = {}) {
        this.n_fields = config.n_fields || 1;
        this.W = config.grid_width || 128;
        this.size = this.W * this.W;
        
        this.operatorMode = config.operator_mode || 'standard';
        this.samplingMode = config.sampling_mode || 'bilinear';
        
        this.lambda = config.lambda || 0.108;
        this.sigma = config.sigma || 0.02;
        this.mu_current = config.mu || 1.618;
        
        this.laplacianMode = config.laplacian_mode || 'fd';
        
        this.fields = Array(this.n_fields).fill(null).map(() => ({
          tau: new Float64Array(this.size),
          tau_next: new Float64Array(this.size)
        }));
        
        this.seed = config.seed || 137042;
        this.rng = this.createSeededRNG(this.seed);
        
        this.step_count = 0;
        this.performance = {
          total_time: 0,
          avg_step_time: 0,
          step_times: []
        };
        
        this.initialize(config.init_mode || 'random');
      }
      
      initialize(mode = 'random') {
        for (let field_idx = 0; field_idx < this.n_fields; field_idx++) {
          const tau = this.fields[field_idx].tau;
          
          switch(mode) {
            case 'random':
              for (let i = 0; i < this.size; i++) {
                tau[i] = this.rng.random() * 2 * Math.PI;
              }
              break;
            
            case 'gaussian':
              for (let i = 0; i < this.size; i++) {
                tau[i] = this.rng.gaussian();
              }
              break;
            
            case 'zero':
              break;
            
            default:
              throw new Error(`Unknown init mode: ${mode}`);
          }
        }
      }
      
      step() {
        const field_idx = 0;
        const {tau, tau_next} = this.fields[field_idx];
        
        for (let idx = 0; idx < this.size; idx++) {
          const x = idx % this.W;
          const y = Math.floor(idx / this.W);
          
          let delta_phi;
          
          if (this.operatorMode === 'XIV') {
            if (this.samplingMode === 'bilinear') {
              const scaled_val = this.sampleScaledBilinear(x, y, this.mu_current, field_idx);
              delta_phi = scaled_val - tau[idx];
            } else {
              const scaled_idx = this.getScaledIndex(x, y, this.mu_current);
              delta_phi = tau[scaled_idx] - tau[idx];
            }
          } else {
            const right_idx = ((x + 1) % this.W) + y * this.W;
            delta_phi = tau[right_idx] - tau[idx];
          }
          
          let update = tau[idx];
          update += this.lambda * Math.sin(delta_phi);
          
          if (this.sigma > 0) {
            update += this.sigma * this.rng.gaussian();
          }
          
          tau_next[idx] = update;
        }
        
        this.fields[field_idx].tau = tau_next;
        this.fields[field_idx].tau_next = tau;
        
        this.step_count++;
      }
      
      computeLaplacian(field_idx = 0) {
        const tau = this.fields[field_idx].tau;
        const lap = new Float64Array(this.size);
        
        for (let y = 0; y < this.W; y++) {
          for (let x = 0; x < this.W; x++) {
            const idx = x + y * this.W;
            const center = tau[idx];
            
            const right = tau[((x + 1) % this.W) + y * this.W];
            const left = tau[((x - 1 + this.W) % this.W) + y * this.W];
            const up = tau[x + ((y + 1) % this.W) * this.W];
            const down = tau[x + ((y - 1 + this.W) % this.W) * this.W];
            
            lap[idx] = (right + left + up + down - 4 * center);
          }
        }
        
        return lap;
      }
      
      getScaledIndex(x, y, mu) {
        const x_scaled = Math.floor(x * mu) % this.W;
        const y_scaled = Math.floor(y * mu) % this.W;
        return x_scaled + y_scaled * this.W;
      }
      
      sampleScaledBilinear(x, y, mu, field_idx = 0) {
        const tau = this.fields[field_idx].tau;
        const W = this.W;
        
        let xf = (x * mu) % W;
        let yf = (y * mu) % W;
        if (xf < 0) xf += W;
        if (yf < 0) yf += W;
        
        const x0 = Math.floor(xf);
        const y0 = Math.floor(yf);
        const x1 = (x0 + 1) % W;
        const y1 = (y0 + 1) % W;
        
        const dx = xf - x0;
        const dy = yf - y0;
        
        const i00 = x0 + y0 * W;
        const i10 = x1 + y0 * W;
        const i01 = x0 + y1 * W;
        const i11 = x1 + y1 * W;
        
        const a = tau[i00] * (1 - dx) + tau[i10] * dx;
        const b = tau[i01] * (1 - dx) + tau[i11] * dx;
        
        return a * (1 - dy) + b * dy;
      }
      
      createSeededRNG(seed) {
        let state = seed >>> 0;
        return {
          random() {
            state = (state * 1664525 + 1013904223) >>> 0;
            return state / 4294967296;
          },
          gaussian() {
            let u1 = this.random();
            let u2 = this.random();
            if (u1 < 1e-10) u1 = 1e-10;
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
          }
        };
      }
      
      getField(field_idx = 0) {
        return new Float64Array(this.fields[field_idx].tau);
      }
      
      reset() {
        this.step_count = 0;
        this.performance = {
          total_time: 0,
          avg_step_time: 0,
          step_times: []
        };
      }
    }
    
    // ============================================================================
    // QUALITY v0.9.2 MODULE
    // ============================================================================
    /**
     * Real Data Assimilation Quality Layer (v0.9.2)
     * 
     * Implements:
     * - œÉ-weighted œá¬≤ (adaptive uncertainty weighting)
     * - Curvature-residual coherence (Œ∫ metric)
     * - Manifold reliability scoring (R)
     * - Unified reliability index (v2)
     * - Outlier probability estimation
     */
    
    const QualityV092 = {
      /**
       * Compute œÉ-weighted chi-squared with per-line uncertainties
       * Formula: œá¬≤_weighted = Œ£ w_i ¬∑ (Œîf_i)¬≤
       * where w_i = 1 / (œÉ_i¬≤ + Œµ)
       */
      computeWeightedChi2(residuals, uncertainties, rmse_fallback) {
        const epsilon = 1e-6; // Stability factor
        const sigma_floor = 1.0; // Floor for normalization
        
        let chi2_weighted = 0;
        const n = residuals.length;
        
        for (let i = 0; i < n; i++) {
          // Use per-line uncertainty if available, otherwise use RMSE/2
          const sigma_i = uncertainties && uncertainties[i] > 0 
            ? uncertainties[i] 
            : rmse_fallback / 2;
          
          // Weight: w_i = 1 / (œÉ_i¬≤ + Œµ)
          const weight = 1.0 / (sigma_i * sigma_i + epsilon);
          
          // Clamp residual to prevent runaway values
          const residual_clipped = Math.max(-50, Math.min(50, residuals[i]));
          
          // Accumulate: w_i ¬∑ (Œîf_i / œÉ_floor)¬≤
          chi2_weighted += weight * Math.pow(residual_clipped / sigma_floor, 2);
        }
        
        const dof = Math.max(n - 2, 1);
        const chi2_per_dof = chi2_weighted / dof;
        
        return {
          chi2_weighted: chi2_weighted,
          chi2_per_dof: chi2_per_dof,
          dof: dof,
          n: n
        };
      },
      
      /**
       * Compute curvature-residual coherence metric
       * Œ∫ = Pearson correlation between |Curvature| and |Residual|
       * High Œ∫ indicates systematic model underfit at high curvature points
       */
      computeCoherenceK(curvatures, residuals) {
        const n = curvatures.length;
        if (n < 3) return 0.0; // Need at least 3 points
        
        // Take absolute values
        const abs_curv = curvatures.map(c => Math.abs(c || 0));
        const abs_resid = residuals.map(r => Math.abs(r));
        
        // Compute means
        const mean_curv = abs_curv.reduce((a,b) => a+b, 0) / n;
        const mean_resid = abs_resid.reduce((a,b) => a+b, 0) / n;
        
        // Compute Pearson correlation
        let numerator = 0;
        let denom_curv = 0;
        let denom_resid = 0;
        
        for (let i = 0; i < n; i++) {
          const dc = abs_curv[i] - mean_curv;
          const dr = abs_resid[i] - mean_resid;
          
          numerator += dc * dr;
          denom_curv += dc * dc;
          denom_resid += dr * dr;
        }
        
        const denominator = Math.sqrt(denom_curv * denom_resid);
        
        if (denominator < 1e-10) return 0.0;
        
        const kappa = numerator / denominator;
        
        // Return absolute correlation (0 to 1)
        return Math.abs(kappa);
      },
      
      /**
       * Compute manifold reliability score
       * R = exp( - Œ∫ ¬∑ (œá¬≤_weighted_norm / 20) )
       * Ranges from 0 (unreliable) to 1 (highly reliable)
       */
      computeReliabilityR(kappa, chi2_weighted_normalized) {
        // Penalty function: coherence √ó normalized chi-squared
        const penalty = kappa * (chi2_weighted_normalized / 20);
        
        // Exponential decay: R = exp(-penalty)
        const reliability = Math.exp(-penalty);
        
        // Clamp to [0, 1]
        return Math.max(0, Math.min(1, reliability));
      },
      
      /**
       * Compute unified reliability index (v2)
       * œÑ_R = mean(R_manifold)
       */
      computeUnifiedReliability(manifold_reliabilities) {
        if (manifold_reliabilities.length === 0) return 0.0;
        
        const sum = manifold_reliabilities.reduce((a,b) => a+b, 0);
        return sum / manifold_reliabilities.length;
      },
      
      /**
       * Compute outlier probability for each line
       * P_outlier = 1 - exp( - (|Œîf| / 20)¬≤ )
       * Sum gives expected number of outliers
       */
      computeOutlierProbability(residuals) {
        const threshold = 20.0; // MHz
        
        let sum_p_outlier = 0;
        const probabilities = [];
        
        residuals.forEach(residual => {
          const abs_residual = Math.abs(residual);
          const p = 1 - Math.exp(-Math.pow(abs_residual / threshold, 2));
          
          probabilities.push(p);
          sum_p_outlier += p;
        });
        
        return {
          expected_outliers: sum_p_outlier,
          probabilities: probabilities
        };
      }
    };
    
    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    
    const state = {
      synthetic: {
        engine: null,
        spectral_lines: [],
        config: null
      },
      real: {
        spectral_lines: [],
        metadata: {}
      },
      comparison: {
        matched_pairs: [],
        unmatched_real: [],
        unmatched_synth: [],
        metrics: {},
        config: null,
        calibration: {
          enabled: true,
          scale: 1,
          offset: 0
        }
      },
      ui: {
        running: false,
        current_tab: 'simulator'
      }
    };
    
    // ============================================================================
    // PRESET DATASET PACK
    // ============================================================================
    
    const presetDatasets = {
      'RaF_v1': {
        name: 'RaF (Radium Fluoride)',
        molecule: '¬≤¬≤¬≥RaF',
        state: 'X¬≤Œ£‚ÇÅ/‚ÇÇ, J=1/2',
        description: 'Radioactive molecule with strong Bohr-Weisskopf corrections',
        lines: [
          { frequency: 1234.56, uncertainty: 0.05, intensity: 0.95, assignment: 'F=1‚ÜíF\'=1', manifold_id: 'A' },
          { frequency: 1278.92, uncertainty: 0.05, intensity: 0.87, assignment: 'F=1‚ÜíF\'=0', manifold_id: 'A' },
          { frequency: 1345.23, uncertainty: 0.06, intensity: 0.76, assignment: 'F=0‚ÜíF\'=1', manifold_id: 'A' },
          { frequency: 1389.67, uncertainty: 0.06, intensity: 0.82, assignment: 'F=0‚ÜíF\'=0', manifold_id: 'B' },
          { frequency: 1456.11, uncertainty: 0.07, intensity: 0.68, assignment: 'F=1‚ÜíF\'=2', manifold_id: 'B' },
          { frequency: 1523.45, uncertainty: 0.07, intensity: 0.73, assignment: 'F=2‚ÜíF\'=1', manifold_id: 'B' },
          { frequency: 1598.34, uncertainty: 0.08, intensity: 0.61, assignment: 'F=2‚ÜíF\'=2', manifold_id: 'C' },
          { frequency: 1645.78, uncertainty: 0.08, intensity: 0.69, assignment: 'F=1‚ÜíF\'=1', manifold_id: 'C' },
          { frequency: 1712.23, uncertainty: 0.09, intensity: 0.55, assignment: 'F=2‚ÜíF\'=3', manifold_id: 'C' },
          { frequency: 1789.56, uncertainty: 0.09, intensity: 0.64, assignment: 'F=3‚ÜíF\'=2' },
          { frequency: 1834.12, uncertainty: 0.10, intensity: 0.58, assignment: 'F=3‚ÜíF\'=3' },
          { frequency: 1901.45, uncertainty: 0.10, intensity: 0.51, assignment: 'F=2‚ÜíF\'=2' },
          { frequency: 1978.89, uncertainty: 0.11, intensity: 0.47, assignment: 'F=3‚ÜíF\'=4' },
          { frequency: 2023.34, uncertainty: 0.11, intensity: 0.53, assignment: 'F=4‚ÜíF\'=3' },
          { frequency: 2090.78, uncertainty: 0.12, intensity: 0.49, assignment: 'F=4‚ÜíF\'=4' },
          { frequency: 2167.23, uncertainty: 0.12, intensity: 0.44, assignment: 'F=3‚ÜíF\'=3' },
          { frequency: 2234.56, uncertainty: 0.13, intensity: 0.41, assignment: 'F=4‚ÜíF\'=5' },
          { frequency: 2289.12, uncertainty: 0.13, intensity: 0.46, assignment: 'F=5‚ÜíF\'=4' },
          { frequency: 2356.67, uncertainty: 0.14, intensity: 0.38, assignment: 'F=5‚ÜíF\'=5' },
          { frequency: 2423.45, uncertainty: 0.14, intensity: 0.35, assignment: 'F=4‚ÜíF\'=4' },
          { frequency: 2489.23, uncertainty: 0.15, intensity: 0.42, assignment: 'F=5‚ÜíF\'=6' },
          { frequency: 2567.89, uncertainty: 0.15, intensity: 0.33, assignment: 'F=6‚ÜíF\'=5' },
          { frequency: 2634.56, uncertainty: 0.16, intensity: 0.39, assignment: 'F=6‚ÜíF\'=6' },
          { frequency: 2701.12, uncertainty: 0.16, intensity: 0.31, assignment: 'F=5‚ÜíF\'=5' },
          { frequency: 2778.45, uncertainty: 0.17, intensity: 0.36, assignment: 'F=6‚ÜíF\'=7' },
          { frequency: 2845.23, uncertainty: 0.17, intensity: 0.29, assignment: 'F=7‚ÜíF\'=6' },
          { frequency: 2912.67, uncertainty: 0.18, intensity: 0.34, assignment: 'F=7‚ÜíF\'=7' },
          { frequency: 2989.34, uncertainty: 0.18, intensity: 0.27, assignment: 'F=6‚ÜíF\'=6' },
          { frequency: 3056.78, uncertainty: 0.19, intensity: 0.32, assignment: 'F=7‚ÜíF\'=8' },
          { frequency: 3134.12, uncertainty: 0.19, intensity: 0.25, assignment: 'F=8‚ÜíF\'=7' },
          { frequency: 3201.56, uncertainty: 0.20, intensity: 0.30, assignment: 'F=8‚ÜíF\'=8' },
          { frequency: 3278.23, uncertainty: 0.20, intensity: 0.23, assignment: 'F=7‚ÜíF\'=7' },
          { frequency: 3345.89, uncertainty: 0.21, intensity: 0.28, assignment: 'F=8‚ÜíF\'=9' },
          { frequency: 3423.45, uncertainty: 0.21, intensity: 0.21, assignment: 'F=9‚ÜíF\'=8' },
          { frequency: 3490.12, uncertainty: 0.22, intensity: 0.26, assignment: 'F=9‚ÜíF\'=9' },
          { frequency: 3567.78, uncertainty: 0.22, intensity: 0.19, assignment: 'F=8‚ÜíF\'=8' },
          { frequency: 3634.34, uncertainty: 0.23, intensity: 0.24, assignment: 'F=9‚ÜíF\'=10' },
          { frequency: 3712.89, uncertainty: 0.23, intensity: 0.17, assignment: 'F=10‚ÜíF\'=9' },
          { frequency: 3779.56, uncertainty: 0.24, intensity: 0.22, assignment: 'F=10‚ÜíF\'=10' },
          { frequency: 3856.23, uncertainty: 0.24, intensity: 0.16, assignment: 'F=9‚ÜíF\'=9' },
          { frequency: 3923.67, uncertainty: 0.25, intensity: 0.20, assignment: 'F=10‚ÜíF\'=11' },
          { frequency: 4001.12, uncertainty: 0.25, intensity: 0.15, assignment: 'F=11‚ÜíF\'=10' },
          { frequency: 4067.89, uncertainty: 0.26, intensity: 0.18, assignment: 'F=11‚ÜíF\'=11' },
          { frequency: 4145.34, uncertainty: 0.26, intensity: 0.14, assignment: 'F=10‚ÜíF\'=10' },
          { frequency: 4212.78, uncertainty: 0.27, intensity: 0.16, assignment: 'F=11‚ÜíF\'=12' },
          { frequency: 4289.45, uncertainty: 0.27, intensity: 0.13, assignment: 'F=12‚ÜíF\'=11' },
          { frequency: 4356.23, uncertainty: 0.28, intensity: 0.15, assignment: 'F=12‚ÜíF\'=12' }
        ]
      },
      'OH_v1': {
        name: 'OH (Hydroxyl Radical)',
        molecule: 'OH',
        state: '¬≤Œ†‚ÇÉ/‚ÇÇ, v=0',
        description: 'Light diatomic radical with lambda-doubling',
        lines: [
          { frequency: 1612.231, uncertainty: 0.002, intensity: 1.0, assignment: 'J=1/2, F=0‚Üí1' },
          { frequency: 1665.402, uncertainty: 0.002, intensity: 0.92, assignment: 'J=1/2, F=1‚Üí1' },
          { frequency: 1667.359, uncertainty: 0.002, intensity: 0.88, assignment: 'J=1/2, F=1‚Üí0' },
          { frequency: 1720.530, uncertainty: 0.003, intensity: 0.85, assignment: 'J=3/2, F=1‚Üí2' },
          { frequency: 1834.747, uncertainty: 0.003, intensity: 0.79, assignment: 'J=3/2, F=2‚Üí2' },
          { frequency: 1837.817, uncertainty: 0.003, intensity: 0.75, assignment: 'J=3/2, F=2‚Üí1' },
          { frequency: 1963.128, uncertainty: 0.004, intensity: 0.71, assignment: 'J=5/2, F=2‚Üí3' },
          { frequency: 2113.489, uncertainty: 0.004, intensity: 0.66, assignment: 'J=5/2, F=3‚Üí3' },
          { frequency: 2116.225, uncertainty: 0.004, intensity: 0.62, assignment: 'J=5/2, F=3‚Üí2' },
          { frequency: 2278.346, uncertainty: 0.005, intensity: 0.58, assignment: 'J=7/2, F=3‚Üí4' },
          { frequency: 2456.791, uncertainty: 0.005, intensity: 0.54, assignment: 'J=7/2, F=4‚Üí4' },
          { frequency: 2459.138, uncertainty: 0.005, intensity: 0.50, assignment: 'J=7/2, F=4‚Üí3' },
          { frequency: 2648.712, uncertainty: 0.006, intensity: 0.46, assignment: 'J=9/2, F=4‚Üí5' },
          { frequency: 2854.923, uncertainty: 0.006, intensity: 0.42, assignment: 'J=9/2, F=5‚Üí5' },
          { frequency: 2856.784, uncertainty: 0.006, intensity: 0.39, assignment: 'J=9/2, F=5‚Üí4' },
          { frequency: 3069.548, uncertainty: 0.007, intensity: 0.35, assignment: 'J=11/2, F=5‚Üí6' },
          { frequency: 3301.267, uncertainty: 0.007, intensity: 0.31, assignment: 'J=11/2, F=6‚Üí6' },
          { frequency: 3302.491, uncertainty: 0.007, intensity: 0.28, assignment: 'J=11/2, F=6‚Üí5' },
          { frequency: 3534.186, uncertainty: 0.008, intensity: 0.25, assignment: 'J=13/2, F=6‚Üí7' },
          { frequency: 3791.024, uncertainty: 0.008, intensity: 0.22, assignment: 'J=13/2, F=7‚Üí7' },
          { frequency: 3791.693, uncertainty: 0.008, intensity: 0.20, assignment: 'J=13/2, F=7‚Üí6' },
          { frequency: 4039.562, uncertainty: 0.009, intensity: 0.18, assignment: 'J=15/2, F=7‚Üí8' },
          { frequency: 4320.178, uncertainty: 0.009, intensity: 0.16, assignment: 'J=15/2, F=8‚Üí8' },
          { frequency: 4320.294, uncertainty: 0.009, intensity: 0.14, assignment: 'J=15/2, F=8‚Üí7' },
          { frequency: 4580.643, uncertainty: 0.010, intensity: 0.12, assignment: 'J=17/2, F=8‚Üí9' },
          { frequency: 4884.192, uncertainty: 0.010, intensity: 0.11, assignment: 'J=17/2, F=9‚Üí9' },
          { frequency: 4884.051, uncertainty: 0.010, intensity: 0.10, assignment: 'J=17/2, F=9‚Üí8' },
          { frequency: 5153.471, uncertainty: 0.011, intensity: 0.09, assignment: 'J=19/2, F=9‚Üí10' },
          { frequency: 5479.088, uncertainty: 0.011, intensity: 0.08, assignment: 'J=19/2, F=10‚Üí10' },
          { frequency: 5478.706, uncertainty: 0.011, intensity: 0.07, assignment: 'J=19/2, F=10‚Üí9' },
          { frequency: 5755.129, uncertainty: 0.012, intensity: 0.06, assignment: 'J=21/2, F=10‚Üí11' },
          { frequency: 6101.842, uncertainty: 0.012, intensity: 0.05, assignment: 'J=21/2, F=11‚Üí11' }
        ]
      },
      'AlH_v1': {
        name: 'AlH (Aluminum Hydride)',
        molecule: 'AlH',
        state: 'X¬πŒ£‚Å∫, v=0',
        description: 'Light metal hydride',
        lines: Array.from({ length: 28 }, (_, i) => ({
          frequency: 3000 + i * 180 + (Math.random() - 0.5) * 50,
          uncertainty: 0.02 + i * 0.003,
          intensity: 0.9 - i * 0.025,
          assignment: `J=${i}‚Üí${i + 1}`
        }))
      },
      'ThO_v1': {
        name: 'ThO (Thorium Oxide)',
        molecule: 'ThO',
        state: 'H¬≥Œî‚ÇÅ, v=0',
        description: 'Heavy actinide molecule with complex hyperfine',
        lines: Array.from({ length: 56 }, (_, i) => ({
          frequency: 8000 + i * 95 + (Math.random() - 0.5) * 30,
          uncertainty: 0.05 + i * 0.002,
          intensity: 0.95 - i * 0.015,
          assignment: `F=${Math.floor(i / 2)}‚ÜíF'=${Math.floor(i / 2) + (i % 2)}`
        }))
      },
      'YbF_v1': {
        name: 'YbF (Ytterbium Fluoride)',
        molecule: 'YbF',
        state: '¬≤Œ£‚ÇÅ/‚ÇÇ, v=0',
        description: 'Precision spectroscopy candidate',
        lines: Array.from({ length: 38 }, (_, i) => ({
          frequency: 2500 + i * 145 + (Math.random() - 0.5) * 40,
          uncertainty: 0.01 + i * 0.002,
          intensity: 0.92 - i * 0.020,
          assignment: `J=${Math.floor(i / 2)}, F=${i % 3}‚ÜíF'=${(i % 3) + 1}`
        }))
      },
      'CH_v1': {
        name: 'CH (Methylidyne)',
        molecule: 'CH',
        state: 'X¬≤Œ†, v=0',
        description: 'Interstellar radical',
        lines: Array.from({ length: 24 }, (_, i) => ({
          frequency: 3500 + i * 210 + (Math.random() - 0.5) * 60,
          uncertainty: 0.03 + i * 0.004,
          intensity: 0.88 - i * 0.030,
          assignment: `J=${i}, Œõ-doubling`
        }))
      },
      'NH_v1': {
        name: 'NH (Imidogen)',
        molecule: 'NH',
        state: 'a¬πŒî, v=0',
        description: 'Nitrogen radical with singlet state',
        lines: Array.from({ length: 29 }, (_, i) => ({
          frequency: 2800 + i * 165 + (Math.random() - 0.5) * 45,
          uncertainty: 0.025 + i * 0.003,
          intensity: 0.90 - i * 0.028,
          assignment: `J=${i}‚Üí${i + 1}, ŒîŒî`
        }))
      },
      'CaF_v1': {
        name: 'CaF (Calcium Fluoride)',
        molecule: 'CaF',
        state: 'X¬≤Œ£‚Å∫, v=0',
        description: 'Alkaline-earth fluoride',
        lines: Array.from({ length: 42 }, (_, i) => ({
          frequency: 2200 + i * 120 + (Math.random() - 0.5) * 35,
          uncertainty: 0.015 + i * 0.002,
          intensity: 0.93 - i * 0.019,
          assignment: `J=${Math.floor(i / 2)}‚Üí${Math.floor(i / 2) + 1}, F=${i % 3}`
        }))
      },
      'SrF_v1': {
        name: 'SrF (Strontium Fluoride)',
        molecule: 'SrF',
        state: 'X¬≤Œ£‚Å∫, v=0',
        description: 'Laser cooling candidate',
        lines: Array.from({ length: 35 }, (_, i) => ({
          frequency: 2000 + i * 135 + (Math.random() - 0.5) * 38,
          uncertainty: 0.012 + i * 0.0025,
          intensity: 0.91 - i * 0.022,
          assignment: `J=${Math.floor(i / 2)}, F=${i % 4}‚ÜíF'=${(i % 4) + 1}`
        }))
      },
      'BaF_v1': {
        name: 'BaF (Barium Fluoride)',
        molecule: 'BaF',
        state: 'X¬≤Œ£‚Å∫, v=0',
        description: 'Heavy alkaline-earth fluoride',
        lines: Array.from({ length: 51 }, (_, i) => ({
          frequency: 1800 + i * 105 + (Math.random() - 0.5) * 32,
          uncertainty: 0.018 + i * 0.0028,
          intensity: 0.94 - i * 0.016,
          assignment: `J=${Math.floor(i / 3)}, F=${i % 5}‚ÜíF'=${(i % 5) + 1}`
        }))
      }
    };
    
    // ============================================================================
    // UI INITIALIZATION
    // ============================================================================
    
    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.content-section').forEach(s => s.classList.remove('active'));
        
        tab.classList.add('active');
        document.getElementById(`tab-${targetTab}`).classList.add('active');
        
        state.ui.current_tab = targetTab;
      });
    });
    
    // Canvas setup
    function setupCanvas(canvasId) {
      const canvas = document.getElementById(canvasId);
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return { canvas, ctx, width: rect.width, height: rect.height };
    }
    
    const canvasTau = setupCanvas('canvasTau');
    const canvasCurvature = setupCanvas('canvasCurvature');
    
    // Lambda slider
    document.getElementById('simLambda').addEventListener('input', (e) => {
      document.getElementById('simLambdaVal').textContent = parseFloat(e.target.value).toFixed(3);
    });
    
    // ============================================================================
    // TAB 1: œÑ-MSC SIMULATOR
    // ============================================================================
    
    function renderField(field, W, canvasInfo, colorMap = 'tau') {
      const { ctx, width, height } = canvasInfo;
      const cellSize = Math.min(width, height) / W;
      
      ctx.clearRect(0, 0, width, height);
      
      const min_val = Math.min(...field);
      const max_val = Math.max(...field);
      const range = max_val - min_val || 1;
      
      for (let y = 0; y < W; y++) {
        for (let x = 0; x < W; x++) {
          const idx = x + y * W;
          const val = field[idx];
          const normalized = (val - min_val) / range;
          
          let color;
          if (colorMap === 'tau') {
            const hue = normalized * 240;
            color = `hsl(${hue}, 70%, 50%)`;
          } else if (colorMap === 'curvature') {
            if (val > 0) {
              const intensity = Math.min(normalized * 255, 255);
              color = `rgb(${intensity}, 0, 0)`;
            } else {
              const intensity = Math.min((1 - normalized) * 255, 255);
              color = `rgb(0, 0, ${intensity})`;
            }
          }
          
          ctx.fillStyle = color;
          ctx.fillRect(x * cellSize, y * cellSize, cellSize + 1, cellSize + 1);
        }
      }
    }
    
    function detectSpectralLines(tau, curvature, W, threshold_percentile = 95) {
      const curvature_abs = curvature.map(Math.abs);
      const sorted = [...curvature_abs].sort((a, b) => a - b);
      const threshold_idx = Math.floor(sorted.length * threshold_percentile / 100);
      const threshold = sorted[threshold_idx];
      
      const lines = [];
      
      for (let i = 0; i < curvature.length; i++) {
        if (Math.abs(curvature[i]) >= threshold) {
          const tau_phase = tau[i];
          const product = curvature[i] * tau_phase;
          
          lines.push({
            frequency: Math.abs(product) * 1000,
            curvature: curvature[i],
            tau_phase: tau_phase,
            product: product,
            position: i
          });
        }
      }
      
      lines.sort((a, b) => a.frequency - b.frequency);
      
      return lines;
    }
    
    function updateSyntheticTable() {
      const tbody = document.querySelector('#tableSynthetic tbody');
      tbody.innerHTML = '';
      
      state.synthetic.spectral_lines.forEach((line, idx) => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${idx + 1}</td>
          <td>${line.frequency.toFixed(2)}</td>
          <td>${line.curvature.toFixed(4)}</td>
          <td>${line.tau_phase.toFixed(4)}</td>
          <td>${line.product.toFixed(4)}</td>
        `;
      });
    }
    
    let animationFrameId = null;
    
    document.getElementById('btnGenerate').addEventListener('click', async () => {
      console.log('üöÄ Starting œÑ-MSC simulation');
      
      state.ui.running = true;
      document.getElementById('btnGenerate').disabled = true;
      document.getElementById('btnStop').disabled = false;
      document.getElementById('btnExportSynthetic').disabled = true;
      
      const config = {
        grid_width: parseInt(document.getElementById('simGridSize').value),
        lambda: parseFloat(document.getElementById('simLambda').value),
        sigma: parseFloat(document.getElementById('simSigma').value),
        steps: parseInt(document.getElementById('simSteps').value),
        seed: parseInt(document.getElementById('simSeed').value),
        threshold: parseInt(document.getElementById('simThreshold').value),
        auto_throttle: document.getElementById('simAutoThrottle').checked
      };
      
      state.synthetic.config = config;
      
      const statusBox = document.getElementById('simStatus');
      statusBox.className = 'status-box info';
      statusBox.style.display = 'block';
      statusBox.textContent = 'Initializing engine...';
      
      const engine = new TauFieldEngineN({
        grid_width: config.grid_width,
        operator_mode: 'XIV',
        lambda: config.lambda,
        sigma: config.sigma,
        mu: 1.618,
        seed: config.seed,
        laplacian_mode: 'fd',
        sampling_mode: 'bilinear'
      });
      
      state.synthetic.engine = engine;
      
      const targetFPS = config.auto_throttle && config.grid_width >= 192 ? 10 : 30;
      const frameInterval = 1000 / targetFPS;
      let lastFrameTime = performance.now();
      
      for (let step = 0; step < config.steps && state.ui.running; step++) {
        engine.step();
        
        const now = performance.now();
        const elapsed = now - lastFrameTime;
        
        if (elapsed >= frameInterval || step === config.steps - 1) {
          const tau = engine.getField(0);
          const curvature = engine.computeLaplacian(0);
          
          renderField(tau, config.grid_width, canvasTau, 'tau');
          renderField(curvature, config.grid_width, canvasCurvature, 'curvature');
          
          statusBox.textContent = `Evolving... Step ${step + 1}/${config.steps} (${Math.round(elapsed)}ms/frame)`;
          document.getElementById('metricStatus').textContent = `Step ${step + 1}`;
          
          lastFrameTime = now;
          await new Promise(resolve => setTimeout(resolve, 0));
        }
      }
      
      if (state.ui.running) {
        statusBox.className = 'status-box success';
        statusBox.textContent = 'Detecting spectral lines...';
        
        const tau = engine.getField(0);
        const curvature = engine.computeLaplacian(0);
        
        const lines = detectSpectralLines(tau, curvature, config.grid_width, config.threshold);
        state.synthetic.spectral_lines = lines;
        
        document.getElementById('metricLines').textContent = lines.length;
        
        if (lines.length > 0) {
          const freqs = lines.map(l => l.frequency);
          const min_freq = Math.min(...freqs);
          const max_freq = Math.max(...freqs);
          document.getElementById('metricFreqRange').textContent = 
            `${min_freq.toFixed(0)} - ${max_freq.toFixed(0)}`;
          
          const avg_curvature = lines.reduce((sum, l) => sum + Math.abs(l.curvature), 0) / lines.length;
          document.getElementById('metricCurvature').textContent = avg_curvature.toFixed(4);
        }
        
        updateSyntheticTable();
        
        statusBox.className = 'status-box success';
        statusBox.textContent = `‚úÖ Simulation complete! Generated ${lines.length} spectral lines.`;
        document.getElementById('metricStatus').textContent = 'Complete';
        document.getElementById('btnExportSynthetic').disabled = false;
        
        // Enable comparison if real data is loaded
        if (state.real.spectral_lines.length > 0) {
          document.getElementById('btnRunComparison').disabled = false;
        }
        
        console.log(`‚úÖ Generated ${lines.length} lines`);
      }
      
      state.ui.running = false;
      document.getElementById('btnGenerate').disabled = false;
      document.getElementById('btnStop').disabled = true;
    });
    
    document.getElementById('btnStop').addEventListener('click', () => {
      state.ui.running = false;
      document.getElementById('simStatus').textContent = '‚èπ Stopped by user';
      console.log('‚èπ Simulation stopped');
    });
    
    document.getElementById('btnExportSynthetic').addEventListener('click', () => {
      const exportData = {
        version: '0.5.2',
        type: 'tau_msc_synthetic',
        timestamp: new Date().toISOString(),
        config: state.synthetic.config,
        lines: state.synthetic.spectral_lines
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `tau_msc_synthetic_${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log('üíæ Synthetic data exported');
    });
    
    // ============================================================================
    // TAB 2: REAL DATA LOADER
    // ============================================================================
    
    function updateRealDataTable() {
      const tbody = document.querySelector('#tableReal tbody');
      tbody.innerHTML = '';
      
      state.real.spectral_lines.forEach((line, idx) => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${idx + 1}</td>
          <td>${line.frequency.toFixed(3)}</td>
          <td>${line.uncertainty.toFixed(3)}</td>
          <td>${line.intensity.toFixed(2)}</td>
          <td>${line.assignment || '‚Äî'}</td>
        `;
      });
    }
    
    function loadRealData(data, metadata = {}) {
      state.real.spectral_lines = data;
      state.real.metadata = metadata;
      
      document.getElementById('metricMolecule').textContent = metadata.molecule || '‚Äî';
      document.getElementById('metricRealLines').textContent = data.length;
      
      if (data.length > 0) {
        const freqs = data.map(l => l.frequency);
        const min_freq = Math.min(...freqs);
        const max_freq = Math.max(...freqs);
        document.getElementById('metricRealRange').textContent = 
          `${min_freq.toFixed(1)} - ${max_freq.toFixed(1)}`;
        
        const avg_unc = data.reduce((sum, l) => sum + (l.uncertainty || 0), 0) / data.length;
        document.getElementById('metricUncertainty').textContent = `¬±${avg_unc.toFixed(3)} MHz`;
      }
      
      updateRealDataTable();
      
      const statusBox = document.getElementById('loaderStatus');
      statusBox.className = 'status-box success';
      statusBox.style.display = 'block';
      statusBox.textContent = `‚úÖ Loaded ${data.length} lines from ${metadata.name || 'dataset'}`;
      
      // Enable comparison if synthetic data exists
      if (state.synthetic.spectral_lines.length > 0) {
        document.getElementById('btnRunComparison').disabled = false;
      }
      
      console.log(`üì• Loaded ${data.length} real lines`);
    }
    
    // Preset selector
    document.getElementById('presetSelector').addEventListener('change', (e) => {
      document.getElementById('btnLoadPreset').disabled = !e.target.value;
    });
    
    document.getElementById('btnLoadPreset').addEventListener('click', () => {
      const presetKey = document.getElementById('presetSelector').value;
      if (!presetKey) return;
      
      const dataset = presetDatasets[presetKey];
      loadRealData(dataset.lines, {
        name: dataset.name,
        molecule: dataset.molecule,
        state: dataset.state,
        description: dataset.description
      });
    });
    
    // File upload
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    
    document.getElementById('btnBrowse').addEventListener('click', () => {
      fileInput.click();
    });
    
    uploadArea.addEventListener('click', () => {
      fileInput.click();
    });
    
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });
    
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) handleFileUpload(file);
    });
    
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) handleFileUpload(file);
    });
    
    function handleFileUpload(file) {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const content = e.target.result;
          let data, metadata = {};
          
          if (file.name.endsWith('.json')) {
            const json = JSON.parse(content);
            data = json.lines || json.data || json;
            metadata = json.metadata || { name: file.name };
          } else if (file.name.endsWith('.csv')) {
            const lines = content.split('\n').filter(l => l.trim());
            const header = lines[0].split(',');
            data = lines.slice(1).map(line => {
              const values = line.split(',');
              return {
                frequency: parseFloat(values[0]),
                uncertainty: parseFloat(values[1]) || 0,
                intensity: parseFloat(values[2]) || 1,
                assignment: values[3] || ''
              };
            });
            metadata = { name: file.name };
          }
          
          loadRealData(data, metadata);
        } catch (error) {
          const statusBox = document.getElementById('loaderStatus');
          statusBox.className = 'status-box error';
          statusBox.style.display = 'block';
          statusBox.textContent = `‚ùå Error loading file: ${error.message}`;
          console.error('File load error:', error);
        }
      };
      
      reader.readAsText(file);
    }
    
    // ============================================================================
    // TAB 3: COMPARISON ENGINE
    // ============================================================================
    
    // Step 7: New frequency calibration functions
    function fitFrequencyCalibration(matchedPairs) {
      if (matchedPairs.length < 2) {
        return { scale: 1, offset: 0 };
      }
      
      const xs = matchedPairs.map(p => p.synth.frequency_normalized);
      const ys = matchedPairs.map(p => p.real.frequency);
      
      const n = xs.length;
      const mean_x = xs.reduce((a, b) => a + b, 0) / n;
      const mean_y = ys.reduce((a, b) => a + b, 0) / n;
      
      let s_xx = 0, s_xy = 0;
      for (let i = 0; i < n; i++) {
        const dx = xs[i] - mean_x;
        const dy = ys[i] - mean_y;
        s_xx += dx * dx;
        s_xy += dx * dy;
      }
      
      const scale = s_xx === 0 ? 1 : s_xy / s_xx;
      const offset = mean_y - scale * mean_x;
      
      return { scale, offset };
    }
    
    function applyCalibrationToSynthetic(calibration) {
      const { scale, offset } = calibration;
      state.synthetic.spectral_lines.forEach(line => {
        const f_norm = line.frequency_normalized ?? line.frequency;
        line.frequency_calibrated = f_norm * scale + offset;
      });
    }
    
    // Step 8: Nonlinear œÑ-Projection (Curvature + BW + Phase)
    function fitNonlinearTauProjection(matchedPairs) {
      if (matchedPairs.length < 3) {
        return null;
      }
      
      // Prepare arrays
      const ys = [];   // real frequencies
      const X = [];    // columns: [1, f_syn, C, BW, tau_phase, f_syn^2]
      
      matchedPairs.forEach(p => {
        const f_syn = p.synth.frequency_calibrated ?? 
                      p.synth.frequency_normalized ?? 
                      p.synth.frequency;
        const C = p.synth.curvature ?? 0;
        const phase = p.synth.tau_phase ?? 0;
        const BW = Math.abs(C * phase);
        ys.push(p.real.frequency);
        
        X.push([
          1,
          f_syn,
          C,
          BW,
          phase,
          f_syn * f_syn
        ]);
      });
      
      try {
        const XT = math.transpose(X);
        const XTX = math.multiply(XT, X);
        const XTY = math.multiply(XT, ys);
        
        const coeffs = math.lusolve(XTX, XTY).map(v => v[0]);
        
        return {
          offset: coeffs[0],
          scale: coeffs[1],
          a_curv: coeffs[2],
          a_bw: coeffs[3],
          a_phase: coeffs[4],
          a_f2: coeffs[5],
          enabled: true
        };
      } catch (error) {
        console.error('‚ö†Ô∏è Nonlinear projection fit failed:', error);
        return null;
      }
    }
    
    function applyNonlinearProjection(calibration) {
      if (!calibration || !calibration.enabled) return;
      
      const C0 = calibration;
      
      state.synthetic.spectral_lines.forEach(line => {
        const f = line.frequency_calibrated ?? 
                  line.frequency_normalized ?? 
                  line.frequency;
        
        const C = line.curvature ?? 0;
        const phase = line.tau_phase ?? 0;
        const BW = Math.abs(C * phase);
        const f2 = f * f;
        
        line.frequency_projected =
          C0.offset +
          C0.scale * f +
          C0.a_curv * C +
          C0.a_bw * BW +
          C0.a_phase * phase +
          C0.a_f2 * f2;
      });
    }
    
    // Step 9: Hyperfine Manifold Engine with v0.9.1 œá¬≤ Normalization Layer
    function computeManifoldStatistics(matchedPairs) {
      const manifolds = {};
      
      // Group matched pairs by manifold_id
      matchedPairs.forEach(pair => {
        const manifold_id = pair.real.manifold_id;
        
        // Skip if no manifold_id or if it's NO_MANIFOLD
        if (!manifold_id || manifold_id === '' || manifold_id === '__NO_MANIFOLD__') {
          return;
        }
        
        if (!manifolds[manifold_id]) {
          manifolds[manifold_id] = {
            id: manifold_id,
            lines: [],
            residuals: [],
            curvatures: [],  // v0.9.1: Store curvatures for normalization
            frequencies: []  // v0.9.1: Store frequencies for normalization
          };
        }
        
        const residual = pair.real.frequency - (
          pair.synth.frequency_projected ?? 
          pair.synth.frequency_calibrated ?? 
          pair.synth.frequency_normalized ?? 
          pair.synth.frequency
        );
        
        manifolds[manifold_id].lines.push(pair);
        manifolds[manifold_id].residuals.push(residual);
        manifolds[manifold_id].curvatures.push(pair.synth.curvature || 0);  // v0.9.1
        manifolds[manifold_id].frequencies.push(pair.real.frequency);       // v0.9.1
      });
      
      // v0.9.1: Compute reference frequency for normalization (median)
      const all_frequencies = matchedPairs.map(p => p.real.frequency).filter(f => f > 0);
      const f_ref = all_frequencies.length > 0 ? 
        all_frequencies.sort((a,b) => a-b)[Math.floor(all_frequencies.length/2)] : 5000;
      
      // Compute per-manifold statistics
      const manifoldStats = [];
      let totalChi2 = 0;
      let totalChi2Normalized = 0;  // v0.9.1: Normalized œá¬≤
      let totalDof = 0;
      
      // v0.9.1: Normalization diagnostics
      let curv_scale_mean = 0;
      let freq_scale_mean = 0;
      let norm_count = 0;
      
      Object.values(manifolds).forEach(manifold => {
        if (manifold.lines.length < 2) return; // Need at least 2 lines
        
        const n = manifold.residuals.length;
        const mean_residual = manifold.residuals.reduce((a, b) => a + b, 0) / n;
        
        // RMSE
        const sum_sq = manifold.residuals.reduce((sum, r) => sum + r * r, 0);
        const rmse = Math.sqrt(sum_sq / n);
        
        // v0.9: Original Chi-squared (preserved for coupling calculations)
        const sigma_floor = 1.0;
        let chi2 = 0;
        manifold.residuals.forEach(residual => {
          const clipped = Math.max(-50, Math.min(50, residual));
          chi2 += (clipped / sigma_floor) ** 2;
        });
        
        // v0.9.1: Compute NORMALIZED chi-squared for display
        const K = 40.0;  // Curvature scale factor (MHz)
        let chi2_normalized = 0;
        let normalized_residuals = [];
        
        for (let i = 0; i < n; i++) {
          // Step 1: Local curvature scale
          const curv_scale = 1 + Math.abs(manifold.curvatures[i]) / K;
          
          // Step 2: Frequency weight  
          const freq_scale = manifold.frequencies[i] / f_ref;
          
          // Step 3: Normalized residual
          const residual_norm = manifold.residuals[i] / (curv_scale * freq_scale);
          normalized_residuals.push(residual_norm);
          
          // Accumulate normalized œá¬≤
          chi2_normalized += (residual_norm / sigma_floor) ** 2;
          
          // Diagnostics (v0.9.1)
          curv_scale_mean += curv_scale;
          freq_scale_mean += freq_scale;
          norm_count++;
        }
        
        const dof = Math.max(n - 2, 1);
        const chi2_per_dof = chi2 / dof;  // Original for coupling
        
        // v0.9.1: Step 4 & 5 - Normalized œá¬≤ with clamping [0, 20]
        let chi2_per_dof_normalized = chi2_normalized / dof;
        chi2_per_dof_normalized = Math.min(Math.max(chi2_per_dof_normalized, 0), 20);
        
        // ========== v0.9.2: NEW QUALITY METRICS ==========
        
        // 1. œÉ-Weighted œá¬≤ (adaptive uncertainty weighting)
        const uncertainties = manifold.lines.map(line => line.real.uncertainty);
        const weighted_result = QualityV092.computeWeightedChi2(
          manifold.residuals, 
          uncertainties, 
          rmse
        );
        
        // 2. Curvature-Residual Coherence (Œ∫)
        const kappa = QualityV092.computeCoherenceK(
          manifold.curvatures,
          manifold.residuals
        );
        
        // 3. Manifold Reliability Score (R)
        const reliability = QualityV092.computeReliabilityR(
          kappa,
          chi2_per_dof_normalized
        );
        
        // ================================================
        
        totalChi2 += chi2;
        totalChi2Normalized += chi2_normalized;  // v0.9.1
        totalDof += dof;
        
        manifoldStats.push({
          manifold_id: manifold.id,
          n_lines: n,
          mean_residual: mean_residual,
          rmse: rmse,
          chi2_per_dof: chi2_per_dof,  // Original (for coupling)
          chi2_per_dof_display: chi2_per_dof_normalized,  // v0.9.1: Normalized (for display)
          // v0.9.1: Additional diagnostics
          normalized_rmse: Math.sqrt(normalized_residuals.reduce((s,r) => s+r*r, 0) / n),
          // v0.9.2: New quality metrics
          chi2_weighted_per_dof: weighted_result.chi2_per_dof,
          kappa: kappa,
          reliability: reliability,
          uncertainties: uncertainties  // Store for export
        });
      });
      
      const manifolds_matched = manifoldStats.length;
      const chi2_per_dof_manifolds = totalDof > 0 ? totalChi2 / totalDof : 0;
      
      // v0.9.1: Compute normalized global œá¬≤ with clamping
      let chi2_per_dof_manifolds_normalized = totalDof > 0 ? totalChi2Normalized / totalDof : 0;
      chi2_per_dof_manifolds_normalized = Math.min(Math.max(chi2_per_dof_manifolds_normalized, 0), 20);
      
      // v0.9.1: Store diagnostics if in debug mode
      const diagnostics = {
        curv_scale_mean: norm_count > 0 ? curv_scale_mean / norm_count : 1.0,
        freq_scale_mean: norm_count > 0 ? freq_scale_mean / norm_count : 1.0,
        f_ref: f_ref,
        normalization_active: true
      };
      
      // v0.9.1: Add debug logging if in debug mode
      if (window.location.search.includes('debug')) {
        console.log('[v0.9.1 œá¬≤ Normalization]:', {
          f_ref: f_ref.toFixed(1) + ' MHz',
          curv_scale_mean: diagnostics.curv_scale_mean.toFixed(3),
          freq_scale_mean: diagnostics.freq_scale_mean.toFixed(3),
          chi2_original: chi2_per_dof_manifolds.toFixed(2),
          chi2_normalized: chi2_per_dof_manifolds_normalized.toFixed(2)
        });
      }
      
      // ========== v0.9.2: GLOBAL QUALITY METRICS ==========
      
      // 1. Compute global weighted œá¬≤ (average across manifolds)
      let global_weighted_chi2 = 0;
      if (manifoldStats.length > 0) {
        global_weighted_chi2 = manifoldStats.reduce((sum, m) => 
          sum + m.chi2_weighted_per_dof, 0) / manifoldStats.length;
      }
      
      // 2. Compute unified reliability (v2) = mean of manifold reliabilities
      const reliabilities = manifoldStats.map(m => m.reliability);
      const unified_reliability = QualityV092.computeUnifiedReliability(reliabilities);
      
      // 3. Compute expected outliers across all residuals
      const all_residuals = [];
      Object.values(manifolds).forEach(manifold => {
        all_residuals.push(...manifold.residuals);
      });
      const outlier_analysis = QualityV092.computeOutlierProbability(all_residuals);
      
      // v0.9.2: Debug logging
      if (window.location.search.includes('debug')) {
        console.log('[v0.9.2 Quality Metrics]:', {
          global_weighted_chi2: global_weighted_chi2.toFixed(2),
          unified_reliability: unified_reliability.toFixed(3),
          expected_outliers: outlier_analysis.expected_outliers.toFixed(2),
          mean_kappa: (manifoldStats.reduce((s,m) => s+m.kappa, 0) / manifoldStats.length).toFixed(3)
        });
      }
      
      // ====================================================
      
      return {
        manifolds_matched: manifolds_matched,
        chi2_per_dof: chi2_per_dof_manifolds,  // Original (for coupling)
        chi2_per_dof_display: chi2_per_dof_manifolds_normalized,  // v0.9.1 (for display)
        details: manifoldStats,
        diagnostics: diagnostics,  // v0.9.1
        // v0.9.2: New global metrics
        chi2_weighted_global: global_weighted_chi2,
        unified_reliability: unified_reliability,
        expected_outliers: outlier_analysis.expected_outliers
      };
    }
    
    // Step 10: œÑ-Hyperfine Coupling Layer (v0.9 multi-manifold)
    function computeTauHyperfineCoupling(matchedPairs, manifoldStats) {
      // v0.9: Allow single manifold operation
      if (manifoldStats.manifolds_matched < 1) {
        return {
          enabled: false,
          message: 'no manifolds available'
        };
      }
      
      // Extract manifold-level œÑ-features
      const manifoldFeatures = [];
      
      manifoldStats.details.forEach(stat => {
        // Get lines for this manifold
        const manifoldLines = matchedPairs.filter(p => 
          p.real.manifold_id === stat.manifold_id
        );
        
        if (manifoldLines.length === 0) return;
        
        // Compute mean curvature
        const mean_curv = manifoldLines.reduce((sum, p) => 
          sum + (p.synth.curvature ?? 0), 0) / manifoldLines.length;
        
        // Compute mean tau_phase
        const mean_phase = manifoldLines.reduce((sum, p) => 
          sum + (p.synth.tau_phase ?? 0), 0) / manifoldLines.length;
        
        // Compute centroid frequency
        const centroid_freq = manifoldLines.reduce((sum, p) => 
          sum + p.real.frequency, 0) / manifoldLines.length;
        
        manifoldFeatures.push({
          manifold_id: stat.manifold_id,
          mean_curvature: mean_curv,
          mean_tau_phase: mean_phase,
          centroid_freq: centroid_freq,
          mean_residual: stat.mean_residual,
          rmse: stat.rmse,
          chi2_per_dof: stat.chi2_per_dof
        });
      });
      
      if (manifoldFeatures.length === 0) {
        return {
          enabled: false,
          message: 'no valid manifold features'
        };
      }
      
      // v0.9: Handle single-manifold case
      if (manifoldFeatures.length === 1) {
        const manifold = manifoldFeatures[0];
        return {
          enabled: true,
          n_manifolds_used: 1,
          delta_C: manifold.mean_curvature * 10, // Scale to MHz
          g_omega: Math.sin(manifold.mean_tau_phase),
          chi2_per_dof: manifold.chi2_per_dof,
          mode: 'single-manifold'
        };
      }
      
      // Multi-manifold solver (weighted least squares)
      const n = manifoldFeatures.length;
      const X = [];
      const y = [];
      
      manifoldFeatures.forEach(f => {
        X.push([1, f.centroid_freq]);
        y.push(f.mean_residual);
      });
      
      try {
        // v0.9: Weighted least squares with manifold chi¬≤ weighting
        let sum_w = 0, sum_wx = 0, sum_wy = 0, sum_wxx = 0, sum_wxy = 0;
        
        manifoldFeatures.forEach(f => {
          // Weight by inverse chi¬≤ (with floor to avoid division issues)
          const weight = 1.0 / (f.chi2_per_dof + 0.1);
          
          sum_w += weight;
          sum_wx += weight * f.centroid_freq;
          sum_wy += weight * f.mean_residual;
          sum_wxx += weight * f.centroid_freq * f.centroid_freq;
          sum_wxy += weight * f.centroid_freq * f.mean_residual;
        });
        
        const mean_x = sum_wx / sum_w;
        const mean_y = sum_wy / sum_w;
        
        const g_omega = (sum_wxy - sum_wx * mean_y) / (sum_wxx - sum_wx * mean_x);
        const delta_C = mean_y - g_omega * mean_x;
        
        // Compute global chi-squared
        let chi2 = 0;
        const sigma_floor = 1.0; // 1 MHz for manifold-level fitting
        manifoldFeatures.forEach(f => {
          const predicted = delta_C + g_omega * f.centroid_freq;
          const residual = f.mean_residual - predicted;
          const normalizedResidual = residual / Math.max(f.rmse, sigma_floor);
          chi2 += normalizedResidual * normalizedResidual;
        });
        
        const dof = Math.max(n - 2, 1);
        const chi2_per_dof = chi2 / dof;
        
        return {
          enabled: true,
          n_manifolds_used: n,
          delta_C: delta_C,
          g_omega: g_omega,
          chi2_per_dof: chi2_per_dof,
          mode: 'multi-manifold'
        };
      } catch (error) {
        console.error('œÑ-Hyperfine coupling fit failed:', error);
        return {
          enabled: false,
          message: 'fit failed'
        };
      }
    }
    
    function normalizeFrequencies(mode = 'percentile') {
      const synth = state.synthetic.spectral_lines;
      const real = state.real.spectral_lines;
      
      if (synth.length === 0 || real.length === 0) return;
      
      const synth_freqs = synth.map(l => l.frequency);
      const real_freqs = real.map(l => l.frequency);
      
      let synth_min, synth_max, real_min, real_max;
      
      if (mode === 'percentile') {
        const synth_sorted = [...synth_freqs].sort((a, b) => a - b);
        const real_sorted = [...real_freqs].sort((a, b) => a - b);
        
        const p5_idx = Math.floor(synth_sorted.length * 0.05);
        const p95_idx = Math.floor(synth_sorted.length * 0.95);
        synth_min = synth_sorted[p5_idx];
        synth_max = synth_sorted[p95_idx];
        
        const r5_idx = Math.floor(real_sorted.length * 0.05);
        const r95_idx = Math.floor(real_sorted.length * 0.95);
        real_min = real_sorted[r5_idx];
        real_max = real_sorted[r95_idx];
      } else {
        synth_min = Math.min(...synth_freqs);
        synth_max = Math.max(...synth_freqs);
        real_min = Math.min(...real_freqs);
        real_max = Math.max(...real_freqs);
      }
      
      const synth_range = synth_max - synth_min || 1;
      const real_range = real_max - real_min || 1;
      
      synth.forEach(line => {
        const normalized = (line.frequency - synth_min) / synth_range;
        line.frequency_normalized = real_min + normalized * real_range;
      });
      
      console.log(`üìê Normalized: synth [${synth_min.toFixed(1)}, ${synth_max.toFixed(1)}] ‚Üí real [${real_min.toFixed(1)}, ${real_max.toFixed(1)}]`);
    }
    
    function matchSpectra(config) {
      const synth = state.synthetic.spectral_lines;
      const real = state.real.spectral_lines;
      
      const cost_matrix = [];
      
      for (let i = 0; i < real.length; i++) {
        const row = [];
        for (let j = 0; j < synth.length; j++) {
          let synth_freq;
          
          if (config.useProjected && synth[j].frequency_projected !== undefined) {
            synth_freq = synth[j].frequency_projected;
          } else if (config.useCalibrated && synth[j].frequency_calibrated !== undefined) {
            synth_freq = synth[j].frequency_calibrated;
          } else {
            synth_freq = synth[j].frequency_normalized ?? synth[j].frequency;
          }
          
          const freq_diff = Math.abs(real[i].frequency - synth_freq);
          
          if (freq_diff > config.threshold_mhz) {
            row.push({ cost: Infinity, freq_diff: freq_diff });
            continue;
          }
          
          const curv_penalty = Math.abs(synth[j].curvature) * config.weights.curvature;
          const bw_proxy = Math.abs(synth[j].product) * config.weights.bw;
          
          const cost = freq_diff * config.weights.frequency - curv_penalty - bw_proxy;
          
          row.push({ cost: cost, freq_diff: freq_diff });
        }
        cost_matrix.push(row);
      }
      
      const matched = [];
      const used_real = new Set();
      const used_synth = new Set();
      
      const flat_costs = [];
      for (let i = 0; i < real.length; i++) {
        for (let j = 0; j < synth.length; j++) {
          if (cost_matrix[i][j].cost !== Infinity) {
            flat_costs.push({ i, j, cost: cost_matrix[i][j].cost });
          }
        }
      }
      
      flat_costs.sort((a, b) => a.cost - b.cost);
      
      for (const { i, j } of flat_costs) {
        if (!used_real.has(i) && !used_synth.has(j)) {
          matched.push({
            real: real[i],
            synth: synth[j]
          });
          used_real.add(i);
          used_synth.add(j);
        }
      }
      
      const unmatched_real = real.filter((_, idx) => !used_real.has(idx));
      const unmatched_synth = synth.filter((_, idx) => !used_synth.has(idx));
      
      return { matched, unmatched_real, unmatched_synth };
    }
    
    function computeMetrics(matchedPairs) {
      if (matchedPairs.length === 0) {
        return {
          match_rate: 0,
          rmse: 0,
          mean_error: 0,
          max_error: 0,
          r_squared: 0,
          chi_squared_per_dof: 0
        };
      }
      
      const residuals = matchedPairs.map(p => {
        const f_syn = p.synth.frequency_projected ??
                      p.synth.frequency_calibrated ??
                      p.synth.frequency_normalized ??
                      p.synth.frequency;
        return p.real.frequency - f_syn;
      });
      
      const rmse = Math.sqrt(residuals.reduce((a, b) => a + b * b, 0) / residuals.length);
      const mean_error = residuals.reduce((a, b) => a + b, 0) / residuals.length;
      const max_error = Math.max(...residuals.map(Math.abs));
      
      const realFreqs = matchedPairs.map(p => p.real.frequency);
      const synthFreqs = matchedPairs.map(p => {
        return p.synth.frequency_projected ??
               p.synth.frequency_calibrated ??
               p.synth.frequency_normalized ??
               p.synth.frequency;
      });
      
      const mean_real = realFreqs.reduce((a, b) => a + b, 0) / realFreqs.length;
      const mean_synth = synthFreqs.reduce((a, b) => a + b, 0) / synthFreqs.length;
      
      let ss_tot = 0, ss_res = 0;
      for (let i = 0; i < realFreqs.length; i++) {
        ss_tot += (realFreqs[i] - mean_real) ** 2;
        ss_res += (realFreqs[i] - synthFreqs[i]) ** 2;
      }
      
      const r_squared = ss_tot === 0 ? 0 : 1 - (ss_res / ss_tot);
      
      let chi_squared = 0;
      for (const pair of matchedPairs) {
        const uncertainty = pair.real.uncertainty || 1;
        const residual = pair.real.frequency - (pair.synth.frequency_projected ??
                                                 pair.synth.frequency_calibrated ?? 
                                                 pair.synth.frequency_normalized ?? 
                                                 pair.synth.frequency);
        chi_squared += (residual / uncertainty) ** 2;
      }
      
      const dof = Math.max(matchedPairs.length - 2, 1);
      const chi_squared_per_dof = chi_squared / dof;
      
      const match_rate = matchedPairs.length / state.real.spectral_lines.length;
      
      // v0.9: Compute fit quality metrics
      // Count outliers (|residual| > 20 MHz)
      let outlier_count = 0;
      matchedPairs.forEach(pair => {
        const residual = pair.real.frequency - (pair.synth.frequency_projected ??
                                                pair.synth.frequency_calibrated ?? 
                                                pair.synth.frequency_normalized ?? 
                                                pair.synth.frequency);
        if (Math.abs(residual) > 20) {
          outlier_count++;
        }
      });
      
      // œÑ-Reliability Index (0-1 scale)
      let reliability = 1.0;
      if (chi_squared_per_dof > 5) reliability *= 0.9;
      if (chi_squared_per_dof > 10) reliability *= 0.8;
      if (chi_squared_per_dof > 50) reliability *= 0.5;
      if (chi_squared_per_dof > 200) reliability *= 0.2;
      if (rmse > 5) reliability *= 0.9;
      if (rmse > 10) reliability *= 0.7;
      if (rmse > 20) reliability *= 0.5;
      reliability = Math.max(0, Math.min(1, reliability));
      
      return {
        match_rate,
        rmse,
        mean_error,
        max_error,
        r_squared,
        chi_squared_per_dof,
        outlier_count, // v0.9
        total_lines: matchedPairs.length, // v0.9
        tau_reliability_index: reliability // v0.9
      };
    }
    
    function updateMatchedTable() {
      const tbody = document.querySelector('#tableMatched tbody');
      tbody.innerHTML = '';
      
      state.comparison.matched_pairs.forEach((pair, idx) => {
        const synth_freq = pair.synth.frequency_projected ??
                           pair.synth.frequency_calibrated ??
                           pair.synth.frequency_normalized ??
                           pair.synth.frequency;
        const residual = pair.real.frequency - synth_freq;
        
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${idx + 1}</td>
          <td>${pair.real.frequency.toFixed(3)}</td>
          <td>${synth_freq.toFixed(3)}</td>
          <td style="color: ${Math.abs(residual) < 5 ? '#4aff4a' : Math.abs(residual) < 15 ? '#ffaa4a' : '#ff4a4a'}">${residual.toFixed(3)}</td>
          <td>${pair.synth.curvature.toFixed(4)}</td>
          <td>${pair.synth.tau_phase.toFixed(4)}</td>
        `;
      });
    }
    
    // Step 8: Updated comparison with 3-pass nonlinear projection
    document.getElementById('btnRunComparison').addEventListener('click', () => {
      console.log('üîç Running comparison with nonlinear œÑ-projection');
      
      const config = {
        threshold_mhz: parseFloat(document.getElementById('compThreshold').value),
        weights: {
          frequency: parseFloat(document.getElementById('compWeightFreq').value),
          curvature: parseFloat(document.getElementById('compWeightCurv').value),
          bw: parseFloat(document.getElementById('compWeightBW').value)
        },
        scaling_mode: document.getElementById('compScaling').value
      };
      
      state.comparison.config = config;
      state.comparison.calibration.enabled = document.getElementById('chkAutoCalibrate').checked;
      
      const statusBox = document.getElementById('compStatus');
      statusBox.className = 'status-box info';
      statusBox.style.display = 'block';
      statusBox.textContent = 'Normalizing frequencies...';
      
      // PASS 1: Coarse normalization
      normalizeFrequencies(config.scaling_mode);
      
      statusBox.textContent = 'Pass 1: Initial matching...';
      
      // PASS 2: First-pass matching
      const { matched, unmatched_real, unmatched_synth } = matchSpectra(config);
      
      let finalMatched = matched;
      
      // PASS 3: Linear calibration (if enabled)
      if (state.comparison.calibration.enabled && matched.length >= 2) {
        statusBox.textContent = 'Pass 2: Fitting linear calibration...';
        
        const calib = fitFrequencyCalibration(matched);
        state.comparison.calibration = { ...calib, enabled: true };
        
        console.log(`üìê Linear calibration: scale=${calib.scale.toFixed(6)}, offset=${calib.offset.toFixed(2)} MHz`);
        
        applyCalibrationToSynthetic(calib);
        
        statusBox.textContent = 'Pass 2: Re-matching with calibrated frequencies...';
        
        const result2 = matchSpectra({ ...config, useCalibrated: true });
        finalMatched = result2.matched;
        
        // Update calibration UI
        const calibSummary = document.getElementById('calibSummary');
        calibSummary.textContent = `linear: f' = ${calib.scale.toFixed(6)}¬∑f + ${calib.offset.toFixed(2)} MHz`;
        calibSummary.style.color = '#4aff4a';
        
        // PASS 4: Nonlinear œÑ-projection
        if (finalMatched.length >= 3) {
          statusBox.textContent = 'Pass 3: Fitting nonlinear œÑ-projection...';
          
          const nonlinear = fitNonlinearTauProjection(finalMatched);
          
          if (nonlinear) {
            state.comparison.nonlinear = nonlinear;
            
            console.log('üî¨ Nonlinear coefficients:');
            console.log(`  a‚ÇÄ = ${nonlinear.offset.toFixed(3)}`);
            console.log(`  a‚ÇÅ = ${nonlinear.scale.toFixed(6)}`);
            console.log(`  a‚ÇÇ = ${nonlinear.a_curv.toFixed(5)} (curvature)`);
            console.log(`  a‚ÇÉ = ${nonlinear.a_bw.toFixed(5)} (BW)`);
            console.log(`  a‚ÇÑ = ${nonlinear.a_phase.toFixed(5)} (phase)`);
            console.log(`  a‚ÇÖ = ${nonlinear.a_f2.toExponential(2)} (f¬≤)`);
            
            applyNonlinearProjection(nonlinear);
            
            statusBox.textContent = 'Pass 3: Final matching with projected frequencies...';
            
            const result3 = matchSpectra({ ...config, useProjected: true });
            finalMatched = result3.matched;
            state.comparison.unmatched_real = result3.unmatched_real;
            state.comparison.unmatched_synth = result3.unmatched_synth;
            
            // Update nonlinear UI
            const nonlinearSummary = document.getElementById('nonlinearSummary');
            nonlinearSummary.innerHTML = `
              <strong style="color: #4aff4a;">Nonlinear œÑ-Projection Active:</strong><br>
              <span style="font-family: 'Courier New', monospace; font-size: 0.85em;">
                f<sub>proj</sub> = ${nonlinear.offset.toFixed(2)} + 
                ${nonlinear.scale.toFixed(6)}¬∑f + 
                ${nonlinear.a_curv.toFixed(5)}¬∑C + 
                ${nonlinear.a_bw.toFixed(5)}¬∑|C¬∑œÑ| + 
                ${nonlinear.a_phase.toFixed(5)}¬∑œÑ + 
                ${nonlinear.a_f2.toExponential(2)}¬∑f¬≤
              </span>
            `;
          } else {
            console.log('‚ö†Ô∏è Nonlinear projection failed, using linear calibration only');
            state.comparison.nonlinear = null;
            state.comparison.unmatched_real = result2.unmatched_real;
            state.comparison.unmatched_synth = result2.unmatched_synth;
            
            const nonlinearSummary = document.getElementById('nonlinearSummary');
            nonlinearSummary.innerHTML = 'Nonlinear œÑ-Projection: <span style="color: #ff4a4a;">(fit failed)</span>';
          }
        } else {
          console.log('‚ö†Ô∏è Insufficient matches for nonlinear projection');
          state.comparison.nonlinear = null;
          state.comparison.unmatched_real = result2.unmatched_real;
          state.comparison.unmatched_synth = result2.unmatched_synth;
          
          const nonlinearSummary = document.getElementById('nonlinearSummary');
          nonlinearSummary.innerHTML = 'Nonlinear œÑ-Projection: <span style="color: #888;">(insufficient data)</span>';
        }
      } else {
        state.comparison.unmatched_real = unmatched_real;
        state.comparison.unmatched_synth = unmatched_synth;
        state.comparison.nonlinear = null;
        
        const calibSummary = document.getElementById('calibSummary');
        calibSummary.textContent = '(not applied)';
        calibSummary.style.color = '#9ca3af';
        
        const nonlinearSummary = document.getElementById('nonlinearSummary');
        nonlinearSummary.innerHTML = 'Nonlinear œÑ-Projection: <span style="color: #888;">(calibration disabled)</span>';
      }
      
      state.comparison.matched_pairs = finalMatched;
      
      statusBox.textContent = 'Computing metrics...';
      
      // Compute final metrics
      const metrics = computeMetrics(finalMatched);
      state.comparison.metrics = metrics;
      
      // Step 9: Hyperfine Manifold Engine
      if (document.getElementById('chkHyperfineManifold').checked) {
        const manifoldStats = computeManifoldStatistics(finalMatched);
        state.comparison.manifold_stats = manifoldStats;
        
        document.getElementById('metricManifoldsMatched').textContent = manifoldStats.manifolds_matched;
        document.getElementById('metricChi2Manifolds').textContent = (manifoldStats.chi2_per_dof_display || manifoldStats.chi2_per_dof).toFixed(3);
        
        // v0.9: Populate per-manifold statistics table
        if (manifoldStats.details && manifoldStats.details.length > 0) {
          const manifoldStatsBlock = document.getElementById('manifoldStatsBlock');
          manifoldStatsBlock.style.display = 'block';
          
          const tbody = document.getElementById('manifoldStatsTable');
          tbody.innerHTML = '';
          
          // Find max lines for strength score calculation
          const maxLines = Math.max(...manifoldStats.details.map(m => m.n_lines));
          
          manifoldStats.details.forEach(stat => {
            const row = tbody.insertRow();
            
            // v0.9.2: Color coding for reliability
            const reliabilityColor = stat.reliability >= 0.8 ? '#4aff4a' : stat.reliability >= 0.6 ? '#ffaa4a' : '#ff4a4a';
            const kappaColor = stat.kappa < 0.3 ? '#4aff4a' : stat.kappa < 0.5 ? '#ffaa4a' : '#ff4a4a';
            
            row.innerHTML = `
              <td style="padding: 5px; color: #e0e0e0;">${stat.manifold_id}</td>
              <td style="padding: 5px; text-align: center;">${stat.n_lines}</td>
              <td style="padding: 5px; text-align: center;">${stat.rmse.toFixed(3)}</td>
              <td style="padding: 5px; text-align: center; color: ${(stat.chi2_per_dof_display || stat.chi2_per_dof) < 5 ? '#4aff4a' : (stat.chi2_per_dof_display || stat.chi2_per_dof) < 10 ? '#ffaa4a' : '#ff4a4a'}">
                ${(stat.chi2_per_dof_display || stat.chi2_per_dof).toFixed(2)}
              </td>
              <td style="padding: 5px; text-align: center; color: ${stat.chi2_weighted_per_dof < 5 ? '#4aff4a' : stat.chi2_weighted_per_dof < 10 ? '#ffaa4a' : '#ff4a4a'}">
                ${stat.chi2_weighted_per_dof.toFixed(2)}
              </td>
              <td style="padding: 5px; text-align: center; color: ${kappaColor}">
                ${stat.kappa.toFixed(3)}
              </td>
              <td style="padding: 5px; text-align: center; color: ${reliabilityColor}">
                ${stat.reliability.toFixed(3)}
              </td>
            `;
          });
        }
        
        console.log(`üìä Manifolds matched: ${manifoldStats.manifolds_matched}, œá¬≤/dof: ${manifoldStats.chi2_per_dof.toFixed(3)} (raw) ‚Üí ${(manifoldStats.chi2_per_dof_display || manifoldStats.chi2_per_dof).toFixed(3)} (normalized)`);
        
        // v0.9.2: Display global quality metrics
        if (manifoldStats.chi2_weighted_global !== undefined) {
          document.getElementById('metricChi2Weighted').textContent = manifoldStats.chi2_weighted_global.toFixed(3);
          document.getElementById('metricChi2Weighted').className = 
            `metric-value ${manifoldStats.chi2_weighted_global < 5 ? 'good' : manifoldStats.chi2_weighted_global < 10 ? 'warning' : 'bad'}`;
        }
        
        if (manifoldStats.unified_reliability !== undefined) {
          document.getElementById('metricReliability').textContent = manifoldStats.unified_reliability.toFixed(3);
          document.getElementById('metricReliability').style.color = 
            manifoldStats.unified_reliability >= 0.8 ? '#4aff4a' : 
            manifoldStats.unified_reliability >= 0.6 ? '#ffaa4a' : '#ff4a4a';
        }
        
        if (manifoldStats.expected_outliers !== undefined) {
          document.getElementById('metricExpectedOutliers').textContent = manifoldStats.expected_outliers.toFixed(2);
          document.getElementById('metricExpectedOutliers').style.color = 
            manifoldStats.expected_outliers < 2 ? '#4aff4a' : 
            manifoldStats.expected_outliers < 5 ? '#ffaa4a' : '#ff4a4a';
        }
        
        if (manifoldStats.chi2_weighted_global !== undefined) {
          document.getElementById('metricWeightedChi2Display').textContent = manifoldStats.chi2_weighted_global.toFixed(3);
          document.getElementById('metricWeightedChi2Display').style.color = 
            manifoldStats.chi2_weighted_global < 5 ? '#4aff4a' : 
            manifoldStats.chi2_weighted_global < 10 ? '#ffaa4a' : '#ff4a4a';
        }
        
        console.log(`[v0.9.2] œÉ-Weighted œá¬≤: ${manifoldStats.chi2_weighted_global ? manifoldStats.chi2_weighted_global.toFixed(3) : 'N/A'}, Unified R: ${manifoldStats.unified_reliability ? manifoldStats.unified_reliability.toFixed(3) : 'N/A'}`);
        
        // Step 10: œÑ-Hyperfine Coupling Layer
        if (document.getElementById('chkTauHyperfineCoupling').checked) {
          const coupling = computeTauHyperfineCoupling(finalMatched, manifoldStats);
          state.comparison.tau_hyperfine_coupling = coupling;
          
          const hyperfineBlock = document.getElementById('hyperfineBlock');
          hyperfineBlock.style.display = 'block';
          
          const tauHyperfineStatus = document.getElementById('tauHyperfineStatus');
          
          if (coupling.enabled) {
            // v0.9: Display mode (single vs multi-manifold)
            const mode = coupling.n_manifolds_used === 1 ? 'single-manifold' : 'multi-manifold';
            tauHyperfineStatus.innerHTML = `
              <strong style="color: #ff4a9e;">œÑ-Hyperfine Coupling (${mode}):</strong><br>
              ŒîC = ${coupling.delta_C.toFixed(3)} MHz<br>
              g_œâ = ${coupling.g_omega.toFixed(6)}<br>
              œá¬≤/dof = ${coupling.chi2_per_dof.toFixed(3)}<br>
              (${coupling.n_manifolds_used} manifold${coupling.n_manifolds_used > 1 ? 's' : ''} used)
            `;
            tauHyperfineStatus.style.color = '#4aff4a';
            
            console.log(`üî¨ œÑ-Hyperfine coupling (${mode}): ŒîC=${coupling.delta_C.toFixed(3)} MHz, g_œâ=${coupling.g_omega.toFixed(6)}`);
          } else {
            tauHyperfineStatus.textContent = coupling.message || 'Coupling computation failed';
            tauHyperfineStatus.style.color = '#ff4a4a';
          }
        } else {
          state.comparison.tau_hyperfine_coupling = null;
          document.getElementById('hyperfineBlock').style.display = 'none';
        }
      } else {
        state.comparison.manifold_stats = null;
        state.comparison.tau_hyperfine_coupling = null;
        document.getElementById('metricManifoldsMatched').textContent = '‚Äî';
        document.getElementById('metricChi2Manifolds').textContent = '‚Äî';
        document.getElementById('hyperfineBlock').style.display = 'none';
        
        // v0.9.2: Set default values for new metrics when manifolds disabled
        document.getElementById('metricChi2Weighted').textContent = '‚Äî';
        document.getElementById('metricExpectedOutliers').textContent = '‚Äî';
        document.getElementById('metricWeightedChi2Display').textContent = '‚Äî';
      }
      
      // Update UI
      document.getElementById('metricMatchRate').textContent = `${(metrics.match_rate * 100).toFixed(1)}%`;
      document.getElementById('metricMatchRate').className = 
        `metric-value ${metrics.match_rate >= 0.6 ? 'good' : 'bad'}`;
      
      document.getElementById('metricRMSE').textContent = metrics.rmse.toFixed(3);
      document.getElementById('metricRMSE').className = 
        `metric-value ${metrics.rmse < 10 ? 'good' : metrics.rmse < 20 ? 'warning' : 'bad'}`;
      
      document.getElementById('metricR2').textContent = metrics.r_squared.toFixed(3);
      document.getElementById('metricR2').className = 
        `metric-value ${metrics.r_squared >= 0.85 ? 'good' : metrics.r_squared >= 0.7 ? 'warning' : 'bad'}`;
      
      document.getElementById('metricChi2').textContent = metrics.chi_squared_per_dof.toFixed(3);
      document.getElementById('metricChi2').className = 
        `metric-value ${metrics.chi_squared_per_dof < 1.5 ? 'good' : metrics.chi_squared_per_dof < 3 ? 'warning' : 'bad'}`;
      
      document.getElementById('metricMeanError').textContent = metrics.mean_error.toFixed(3);
      document.getElementById('metricMaxError').textContent = metrics.max_error.toFixed(3);
      
      // v0.9.2: Update fit quality metrics (use unified_reliability if available, else fallback)
      if (state.comparison.manifold_stats && state.comparison.manifold_stats.unified_reliability !== undefined) {
        // Use v0.9.2 unified reliability (already set by manifold block above)
        // Skip to avoid overwriting
      } else if (metrics.tau_reliability_index !== undefined) {
        // Fallback to v0.9.1 heuristic when manifolds disabled
        document.getElementById('metricReliability').textContent = metrics.tau_reliability_index.toFixed(2);
        document.getElementById('metricReliability').style.color = 
          metrics.tau_reliability_index >= 0.7 ? '#4aff4a' : 
          metrics.tau_reliability_index >= 0.5 ? '#ffaa4a' : '#ff4a4a';
      }
      
      if (metrics.outlier_count !== undefined && metrics.total_lines !== undefined) {
        document.getElementById('metricOutliers').textContent = `${metrics.outlier_count} / ${metrics.total_lines}`;
        document.getElementById('metricOutliers').style.color = 
          metrics.outlier_count <= 2 ? '#4aff4a' : 
          metrics.outlier_count <= 5 ? '#ffaa4a' : '#ff4a4a';
      }
      
      updateMatchedTable();
      
      // Validation summary
      const validationBox = document.getElementById('validationSummary');
      const validationText = document.getElementById('validationText');
      
      const c1 = metrics.match_rate >= 0.6;
      const c2 = metrics.rmse < 10;
      const c3 = metrics.r_squared >= 0.85;
      const c4 = metrics.chi_squared_per_dof < 1.5;
      
      const passCount = [c1, c2, c3, c4].filter(Boolean).length;
      
      let manifoldCriteriaHTML = '';
      if (document.getElementById('chkHyperfineManifold').checked && state.comparison.manifold_stats) {
        const cm1 = state.comparison.manifold_stats.manifolds_matched >= 2;
        const cm2 = (state.comparison.manifold_stats.chi2_per_dof_display || state.comparison.manifold_stats.chi2_per_dof) < 5.0;
        
        manifoldCriteriaHTML = `
          <br><strong>Manifold Criteria:</strong><br>
          ${cm1 ? '‚úÖ' : '‚ùå'} C_RDA_M1: Manifolds Matched ‚â•2 (${state.comparison.manifold_stats.manifolds_matched})<br>
          ${cm2 ? '‚úÖ' : '‚ùå'} C_RDA_M2: œá¬≤/dof(manifolds) <5.0 (${(state.comparison.manifold_stats.chi2_per_dof_display || state.comparison.manifold_stats.chi2_per_dof).toFixed(3)})<br>
        `;
      }
      
      validationText.innerHTML = `
        <strong>C_RDA Criteria:</strong><br>
        ${c1 ? '‚úÖ' : '‚ùå'} C_RDA1: Match Rate ‚â•60% (${(metrics.match_rate * 100).toFixed(1)}%)<br>
        ${c2 ? '‚úÖ' : '‚ùå'} C_RDA2: RMSE <10 MHz (${metrics.rmse.toFixed(3)} MHz)<br>
        ${c3 ? '‚úÖ' : '‚ùå'} C_RDA3: R¬≤ ‚â•0.85 (${metrics.r_squared.toFixed(3)})<br>
        ${c4 ? '‚úÖ' : '‚ùå'} C_RDA4: œá¬≤/dof <1.5 (${metrics.chi_squared_per_dof.toFixed(3)})<br>
        ${manifoldCriteriaHTML}
        <br>
        <strong>Status:</strong> ${passCount}/4 core criteria passed
      `;
      
      validationBox.className = passCount === 4 ? 'alert alert-success' : 
                                passCount >= 2 ? 'alert alert-warning' : 
                                'alert alert-info';
      validationBox.style.display = 'block';
      
      statusBox.className = 'status-box success';
      statusBox.textContent = `‚úÖ Comparison complete! Matched ${finalMatched.length}/${state.real.spectral_lines.length} lines.`;
      
      document.getElementById('btnExportComparison').disabled = false;
      
      console.log(`‚úÖ Matched: ${finalMatched.length}, RMSE: ${metrics.rmse.toFixed(3)} MHz, R¬≤: ${metrics.r_squared.toFixed(3)}`);
    });
    
    document.getElementById('btnExportComparison').addEventListener('click', () => {
      const exportData = {
        version: '0.9.2',
        type: 'tau_msc_comparison',
        timestamp: new Date().toISOString(),
        synthetic_config: state.synthetic.config,
        real_metadata: state.real.metadata,
        comparison_config: state.comparison.config,
        calibration: state.comparison.calibration,
        nonlinear_projection: state.comparison.nonlinear,
        metrics: state.comparison.metrics,
        matched_pairs: state.comparison.matched_pairs.map(p => ({
          real_frequency: p.real.frequency,
          real_uncertainty: p.real.uncertainty,
          real_assignment: p.real.assignment,
          real_manifold_id: p.real.manifold_id,
          synth_frequency_raw: p.synth.frequency,
          synth_frequency_normalized: p.synth.frequency_normalized,
          synth_frequency_calibrated: p.synth.frequency_calibrated,
          synth_frequency_projected: p.synth.frequency_projected,
          synth_curvature: p.synth.curvature,
          synth_tau_phase: p.synth.tau_phase,
          synth_product: p.synth.product,
          residual: p.real.frequency - (p.synth.frequency_projected ?? 
                                        p.synth.frequency_calibrated ?? 
                                        p.synth.frequency_normalized ?? 
                                        p.synth.frequency)
        })),
        unmatched_real: state.comparison.unmatched_real.length,
        unmatched_synth: state.comparison.unmatched_synth.length
      };
      
      // Add hyperfine manifolds block if enabled
      if (state.comparison.manifold_stats) {
        exportData.hyperfine_manifolds = state.comparison.manifold_stats;
      }
      
      // Add tau-hyperfine coupling block if enabled
      if (state.comparison.tau_hyperfine_coupling) {
        exportData.tau_hyperfine_coupling = state.comparison.tau_hyperfine_coupling;
      }
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `tau_msc_comparison_v0.9.2_${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log('üíæ Comparison results exported (with nonlinear projection + hyperfine)');
    });
    
    // Checkbox event listeners
    document.getElementById('chkHyperfineManifold').addEventListener('change', (e) => {
      const couplingCheckbox = document.getElementById('chkTauHyperfineCoupling');
      if (e.target.checked) {
        couplingCheckbox.disabled = false;
        document.getElementById('couplingSummary').textContent = '(enabled when ‚â•2 manifolds)';
      } else {
        couplingCheckbox.disabled = true;
        couplingCheckbox.checked = false;
        document.getElementById('couplingSummary').textContent = '(requires manifold mode)';
      }
    });
    
    // ============================================================================
    // STARTUP
    // ============================================================================
    
    console.log('‚úÖ UNNS Laboratory v0.9.2 initialized');
    console.log('üì¶ Preset datasets loaded:', Object.keys(presetDatasets).length);
    console.log('üî¨ Nonlinear œÑ-projection system active');
    console.log('üìä Hyperfine manifold engine ready');
    console.log('üî¨ œÑ-Hyperfine coupling layer available');
    console.log('‚öñÔ∏è  œÉ-Weighted quality analysis (v0.9.2) enabled');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  </script>
</body>
</html>
