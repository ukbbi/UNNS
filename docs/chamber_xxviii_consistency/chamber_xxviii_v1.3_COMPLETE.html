<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory ‚Äî Chamber XXVIII</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Consolas', 'Monaco', monospace; background: #0a0a0a; color: #e0e0e0; overflow-x: hidden; }
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
    
    header { text-align: center; margin-bottom: 30px; padding: 30px; border-bottom: 2px solid #2a2a3a; background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 100%); }
    h1 { font-size: 2.2em; color: #4a9eff; letter-spacing: 3px; text-shadow: 0 0 20px rgba(74, 158, 255, 0.5); }
    .subtitle { color: #888; margin-top: 15px; font-size: 1em; letter-spacing: 1px; }
    
    .guide-block { background: linear-gradient(135deg, #1a1a2a 0%, #1a2a2a 100%); border: 1px solid #2a3a4a; border-radius: 8px; padding: 20px; margin-bottom: 30px; }
    .guide-block summary { font-size: 1.3em; color: #4a9eff; cursor: pointer; padding: 10px; font-weight: bold; user-select: none; }
    .guide-block summary:hover { color: #7aafff; }
    .guide-content { margin-top: 20px; line-height: 1.8; color: #ccc; }
    .guide-content h3 { color: #4a9eff; margin: 25px 0 12px; font-size: 1.15em; }
    .guide-content h4 { color: #4affff; margin: 18px 0 10px; font-size: 1.05em; }
    .guide-content p { margin: 10px 0; }
    .guide-content ul { margin: 10px 0 10px 25px; }
    .guide-content li { margin: 6px 0; }
    .guide-content code { background: #0a0a0a; padding: 2px 6px; border-radius: 3px; color: #4affff; font-family: 'Courier New', monospace; }
    .guide-content .operator-card { background: #0a0a1a; border-left: 4px solid #4a9eff; padding: 15px; margin: 15px 0; border-radius: 4px; }
    .guide-content .operator-card.phi { border-left-color: #4affff; }
    .guide-content .operator-card.psi { border-left-color: #af4aff; }
    .guide-content .operator-card.tau { border-left-color: #4affaf; }
    .guide-content .operator-card.xii { border-left-color: #ff4a9e; }
    .guide-content .verdict-box { background: #1a2a1a; border: 2px solid #4aff4a; padding: 15px; margin: 15px 0; border-radius: 6px; }
    .guide-content .warning-box { background: #2a1a1a; border: 2px solid #ff4a4a; padding: 15px; margin: 15px 0; border-radius: 6px; }
    
    .theorem-panel { background: linear-gradient(135deg, #1a1a2a 0%, #1a2a3a 100%); border: 1px solid rgba(42, 203, 255, 0.3); box-shadow: 0 0 15px rgba(42, 203, 255, 0.15); border-radius: 8px; padding: 20px; margin-bottom: 30px; }
    .theorem-panel summary { font-size: 1.3em; color: #7cc7ff; cursor: pointer; padding: 10px; font-weight: bold; user-select: none; }
    .theorem-panel summary:hover { color: #9cd7ff; }
    .panel-content { margin-top: 20px; line-height: 1.8; color: #ccc; }
    .panel-content p { margin-bottom: 15px; }
    
    .theorem-list { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; }
    .theorem-btn { background: linear-gradient(135deg, #2a4a7a 0%, #2a5a8a 100%); border: 1px solid #4a9eff; color: #e0e0e0; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-family: inherit; font-size: 0.95em; transition: all 0.3s; }
    .theorem-btn:hover { background: linear-gradient(135deg, #3a5a8a 0%, #3a6a9a 100%); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(74, 158, 255, 0.4); }
    
    .input-panel { background: linear-gradient(135deg, #1a1a2a 0%, #1a2a1a 100%); border: 1px solid #2a3a4a; border-radius: 8px; padding: 25px; margin-bottom: 30px; }
    .input-panel h2 { color: #4a9eff; font-size: 1.3em; margin-bottom: 15px; }
    
    textarea { width: 100%; min-height: 120px; background: #0a0a0a; border: 1px solid #3a3a3a; color: #e0e0e0; padding: 15px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 1.05em; resize: vertical; }
    textarea:focus { outline: none; border-color: #4a9eff; box-shadow: 0 0 10px rgba(74, 158, 255, 0.3); }
    
    .button-row { display: flex; gap: 15px; margin-top: 15px; align-items: center; flex-wrap: wrap; }
    button { background: #2a4a7a; border: none; color: #e0e0e0; padding: 12px 28px; border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 1em; transition: all 0.3s; }
    button:hover { background: #3a5a8a; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3); }
    button:disabled { background: #1a1a1a; color: #555; cursor: not-allowed; transform: none; box-shadow: none; }
    .button-primary { background: linear-gradient(135deg, #4a9eff 0%, #7a5aef 100%); font-weight: bold; }
    
    select { background: #0a0a0a; border: 1px solid #3a3a3a; color: #e0e0e0; padding: 10px; border-radius: 4px; font-family: inherit; cursor: pointer; min-width: 250px; }
    
    .stage-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px; }
    .stage-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 20px; }
    
    .stage-panel { background: #1a1a2a; border: 2px solid #2a2a3a; border-radius: 8px; padding: 20px; min-height: 300px; position: relative; overflow: hidden; transition: all 0.5s; }
    .stage-panel.active { border-color: #4a9eff; box-shadow: 0 0 20px rgba(74, 158, 255, 0.2); }
    .stage-panel.pass { border-color: #4aff4a; }
    .stage-panel.fail { border-color: #ff4a4a; }
    
    .stage-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #2a2a3a; position: relative; }
    .stage-title { font-size: 1.2em; font-weight: bold; display: flex; align-items: center; gap: 8px; }
    .stage-phi .stage-title { color: #4affff; }
    .stage-psi .stage-title { color: #af4aff; }
    .stage-tau .stage-title { color: #4affaf; }
    .stage-xii .stage-title { color: #ff4a9e; }
    .stage-verdict .stage-title { color: #ffaf4a; }
    
    .operator-badge { padding: 4px 10px; border-radius: 4px; font-size: 0.75em; font-weight: bold; letter-spacing: 0.5px; }
    .operator-badge.pass { background: #22ff55; color: #0a0a0a; }
    .operator-badge.stable { background: #22ff55; color: #0a0a0a; }
    .operator-badge.warn { background: #ffcc22; color: #0a0a0a; }
    .operator-badge.fail { background: #ff4444; color: #fff; }
    
    .export-graph-btn { position: absolute; top: 10px; right: 50px; background: none; border: 1px solid #4affaf; color: #4affaf; padding: 4px 8px; font-size: 0.75em; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
    .export-graph-btn:hover { background: #4affaf; color: #0a0a0a; transform: translateY(0); box-shadow: none; }
    
    .badge { padding: 6px 12px; border-radius: 4px; font-size: 0.85em; font-weight: bold; letter-spacing: 1px; }
    .badge-pending { background: #2a2a3a; color: #888; }
    .badge-pass { background: #2a4a2a; color: #4aff4a; }
    .badge-fail { background: #4a2a2a; color: #ff4a4a; }
    
    .stage-content { font-size: 0.95em; line-height: 1.6; color: #ccc; }
    .stage-content .metric { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #1a1a2a; }
    .stage-content .metric:last-child { border-bottom: none; }
    .stage-content .metric-label { color: #888; }
    .stage-content .metric-value { color: #4a9eff; font-family: 'Courier New', monospace; }
    
    .recursion-tree { margin-top: 15px; padding: 15px; background: #0a0a0a; border-radius: 4px; font-size: 0.85em; overflow-x: auto; max-height: 200px; overflow-y: auto; }
    .recursion-tree pre { margin: 0; color: #4affff; line-height: 1.4; }
    
    .curvature-plot { margin-top: 15px; background: #0a0a0a; border-radius: 4px; height: 180px; position: relative; }
    .curvature-canvas { width: 100%; height: 100%; }
    
    .verdict-panel { background: linear-gradient(135deg, #1a2a1a 0%, #2a1a2a 50%, #1a1a3a 100%); border: 3px solid #4a9eff; border-radius: 12px; padding: 30px; text-align: center; min-height: 300px; display: flex; flex-direction: column; justify-content: center; align-items: center; }
    .verdict-badge { font-size: 2em; padding: 20px 40px; border-radius: 8px; margin: 20px 0; font-weight: bold; letter-spacing: 2px; text-shadow: 0 0 20px currentColor; }
    .verdict-admissible { background: linear-gradient(135deg, #2a4a2a 0%, #2a6a2a 100%); color: #4aff4a; border: 2px solid #4aff4a; }
    .verdict-unstable { background: linear-gradient(135deg, #4a4a2a 0%, #6a6a2a 100%); color: #ffff4a; border: 2px solid #ffff4a; }
    .verdict-incoherent { background: linear-gradient(135deg, #4a2a4a 0%, #6a2a6a 100%); color: #ff4aff; border: 2px solid #ff4aff; }
    .verdict-nonexistent { background: linear-gradient(135deg, #4a2a2a 0%, #6a2a2a 100%); color: #ff4a4a; border: 2px solid #ff4a4a; }
    .verdict-nongenerable { background: linear-gradient(135deg, #2a2a4a 0%, #2a2a6a 100%); color: #4a9eff; border: 2px solid #4a9eff; }
    
    .verdict-details { margin-top: 15px; font-size: 0.95em; color: #ccc; max-width: 500px; }
    
    .pathway-diagram { margin-top: 20px; padding: 20px; background: #0a0a0a; border-radius: 8px; }
    
    .log-section { background: #0a0a0a; border: 1px solid #2a2a3a; border-radius: 4px; padding: 15px; margin-top: 20px; max-height: 300px; overflow-y: auto; font-size: 0.85em; }
    .log-section::-webkit-scrollbar { width: 8px; }
    .log-section::-webkit-scrollbar-track { background: #1a1a1a; border-radius: 4px; }
    .log-section::-webkit-scrollbar-thumb { background: #3a3a3a; border-radius: 4px; }
    .log-section::-webkit-scrollbar-thumb:hover { background: #4a4a4a; }
    
    .log-header { font-weight: bold; margin-bottom: 15px; color: #4a9eff; font-size: 1em; }
    .log-entry { padding: 8px 12px; margin: 4px 0; border-radius: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s; }
    .log-entry:nth-child(even) { background: rgba(255, 255, 255, 0.02); }
    .log-entry:hover { background: rgba(255, 255, 255, 0.05); }
    .log-timestamp { color: #666; font-size: 0.85em; min-width: 70px; font-family: 'Courier New', monospace; }
    .log-operator { font-weight: bold; font-size: 1.1em; min-width: 25px; text-align: center; }
    .log-operator.phi { color: #4affff; }
    .log-operator.psi { color: #af4aff; }
    .log-operator.tau { color: #4affaf; }
    .log-operator.xii { color: #ff4a9e; }
    .log-operator.system { color: #4a9eff; }
    .log-status { padding: 2px 8px; border-radius: 3px; font-size: 0.75em; font-weight: bold; min-width: 50px; text-align: center; }
    .log-status.info { background: rgba(74, 158, 255, 0.2); color: #4a9eff; }
    .log-status.pass { background: rgba(74, 255, 74, 0.2); color: #4aff4a; }
    .log-status.fail { background: rgba(255, 74, 74, 0.2); color: #ff4a4a; }
    .log-status.warn { background: rgba(255, 204, 34, 0.2); color: #ffcc22; }
    .log-message { color: #ccc; flex: 1; }
    
    .export-section { margin-top: 30px; padding: 20px; background: #1a1a2a; border-radius: 8px; text-align: center; }
    
    .fade-in { animation: fadeIn 0.5s ease-in; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .pulse { animation: pulse 2s infinite; }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚öóÔ∏è CHAMBER XXVIII: CONSISTENCY OPERATOR</h1>
      <div class="subtitle">Œ¶‚ÄìŒ®‚ÄìœÑ‚ÄìXII Structural + Recursive Dynamical Engine ‚Ä¢ v1.3</div>
    </header>
    
    <details class="guide-block">
      <summary>üìò Chamber Guide ‚Äî Understanding Œ¶‚ÄìŒ®‚ÄìœÑ‚ÄìXII</summary>
      <div class="guide-content">
        
        <h3>üéØ What is Chamber XXVIII?</h3>
        <p>Chamber XXVIII implements the <strong>Consistency Operator</strong>, a four-stage validation pipeline that determines whether mathematical structures, recursions, and physical models can exist within the UNNS substrate. Every formula submitted passes through four operators in sequence: <strong>Œ¶ ‚Üí Œ® ‚Üí œÑ ‚Üí XII</strong>.</p>
        
        <h3>‚öôÔ∏è The Four Operators</h3>
        
        <div class="operator-card phi">
          <h4>Œ¶ ‚Äî Generativity</h4>
          <p><strong>Purpose:</strong> Determines whether the structure can be generated recursively without contradiction or undecidability.</p>
          <p><strong>Tests:</strong></p>
          <ul>
            <li>Can the recursion unfold? (Does it generate successive states?)</li>
            <li>No arbitrary choice constructs (e.g., <code>random()</code>, non-deterministic branches)</li>
            <li>No undecidable encodings (Turing-complete patterns, halting problems)</li>
            <li>No circular references that prevent generation</li>
          </ul>
          <p><strong>Pass:</strong> Structure is generable and can unfold into a recursion tree.</p>
          <p><strong>Fail:</strong> Structure is <strong>NON-GENERABLE (Œ¶)</strong> ‚Äî cannot be constructed.</p>
        </div>
        
        <div class="operator-card psi">
          <h4>Œ® ‚Äî Structural Consistency</h4>
          <p><strong>Purpose:</strong> Evaluates whether the recursion maintains internal structural coherence across layers.</p>
          <p><strong>Tests:</strong></p>
          <ul>
            <li><strong>Symmetry:</strong> Balanced operations, consistent structure</li>
            <li><strong>Coherence:</strong> Dimensional consistency, projection alignment</li>
            <li><strong>Commutativity:</strong> Operator ordering consistency (where applicable)</li>
            <li><strong>Invariance:</strong> Structure preservation across recursion depth</li>
          </ul>
          <p><strong>Pass:</strong> Structure has sufficient consistency to embed in the substrate.</p>
          <p><strong>Fail:</strong> Structure is <strong>INCOHERENT (Œ®)</strong> ‚Äî cannot form consistent projections.</p>
        </div>
        
        <div class="operator-card tau">
          <h4>œÑ ‚Äî Curvature Stability</h4>
          <p><strong>Purpose:</strong> Simulates recursive evolution and determines geometric stability.</p>
          <p><strong>Computes:</strong></p>
          <ul>
            <li><strong>Curvature profile:</strong> Discrete second derivative of trajectory</li>
            <li><strong>Damping ratio:</strong> Does the system stabilize or diverge?</li>
            <li><strong>Fixed points:</strong> Does the recursion approach attractors?</li>
            <li><strong>Boundedness:</strong> Does growth remain finite?</li>
          </ul>
          <p><strong>Stable:</strong> Curvature within bounds, trajectory converges or oscillates stably.</p>
          <p><strong>Unstable:</strong> Verdict becomes <strong>UNSTABLE (œÑ)</strong> ‚Äî generable but physically divergent.</p>
        </div>
        
        <div class="operator-card xii">
          <h4>XII ‚Äî Collapse Detection</h4>
          <p><strong>Purpose:</strong> Determines whether the structure can exist under deep substrate constraints.</p>
          <p><strong>Collapse Triggers:</strong></p>
          <ul>
            <li>Undecidable recursion (complexity exceeds substrate capacity)</li>
            <li>Contradiction accumulation (invariance failure in Œ®)</li>
            <li>Projection breakdown (coherence failure)</li>
            <li>Irreversible divergence (unbounded œÑ-trajectory)</li>
            <li>Extreme curvature (violates substrate constraints)</li>
            <li>Self-referential inconsistency (pathological loops)</li>
          </ul>
          <p><strong>Pass:</strong> Structure survives all collapse conditions.</p>
          <p><strong>Collapse:</strong> Structure is <strong>NON-EXISTENT (XII)</strong> ‚Äî forbidden by substrate.</p>
        </div>
        <div class="guide-warning" style="
  background: rgba(255, 80, 80, 0.12);
  border-left: 3px solid #ff5050;
  padding: 12px 16px;
  margin: 12px 0;
  border-radius: 6px;
  font-size: 0.95rem;
  line-height: 1.45;
">
  <strong>Important Note ‚Äî ‚ÄúNON-EXISTENT‚Äù ‚â† ‚ÄúFalse Theorem‚Äù</strong><br/>
  The UNNS verdict <span style="color:#ff8080;">NON-EXISTENT</span> means that a structure
  <em>cannot be embedded into the UNNS substrate</em> due to unbounded œÑ-curvature or
  an Operator XII collapse. It does <em>not</em> mean that the mathematics behind the
  formula or theorem is false. It only indicates that the dynamical behavior of the
  recursion does not survive UNNS structural and stability constraints.
</div>
       
        <h3>‚öñÔ∏è Final Verdicts</h3>
        
        <div class="verdict-box">
          <p><strong>‚úÖ ADMISSIBLE</strong></p>
          <p>Passes all four operators (Œ¶, Œ®, œÑ, XII). Structure is admitted to the UNNS substrate and can exist stably.</p>
        </div>
        
        <div class="warning-box">
          <p><strong>‚ö†Ô∏è UNSTABLE (œÑ)</strong></p>
          <p>Passes Œ¶, Œ®, XII but fails œÑ stability. Structure is generable and consistent, but exhibits divergent or chaotic behavior. Admitted but unstable.</p>
        </div>
        
        <div class="warning-box">
          <p><strong>‚ùå INCOHERENT (Œ®)</strong></p>
          <p>Passes Œ¶ but fails Œ®. Structure can be generated but lacks internal consistency. Cannot form coherent projections in the substrate.</p>
        </div>
        
        <div class="warning-box">
          <p><strong>üî¥ NON-EXISTENT (XII)</strong></p>
          <p>Passes Œ¶ and Œ® but collapses at XII. Structure violates deep substrate constraints and cannot exist.</p>
        </div>
        
        <div class="warning-box">
          <p><strong>üö´ NON-GENERABLE (Œ¶)</strong></p>
          <p>Fails Œ¶. Structure cannot be recursively generated. Contains undecidable patterns, arbitrary choices, or circular dependencies.</p>
        </div>
        
        <p style="margin-top: 20px; font-size: 0.85em; color: #666; text-align: center;">
          <strong>Version:</strong> 1.3.0 | <strong>Engine:</strong> ConsistencyEngine | <strong>Status:</strong> Production Ready
        </p>
        
      </div>
    </details>
    
    <details class="theorem-panel">
      <summary>üìê Theorem Testing ‚Äî Recursive Structures</summary>
      <div class="panel-content">
        <p>Select a theorem-inspired recursive formulation below. When selected, the formula loads automatically and the Chamber runs Œ¶‚ÄìŒ®‚ÄìœÑ‚ÄìXII analysis.</p>
        <div class="theorem-list" id="theoremList"></div>
      </div>
    </details>
    
    <div class="input-panel">
      <h2>üìù Formula / Model Entry</h2>
      <textarea id="formulaInput" placeholder="Enter formula, recursion, or model...

Examples:
‚Ä¢ Recursion: a[n+1] = a[n] * sin(a[n])
‚Ä¢ Function: f(x) = x * sin(x) / (1 + x^2)
‚Ä¢ Fibonacci: F[n] = F[n-1] + F[n-2]
‚Ä¢ Logistic: x[n+1] = r * x[n] * (1 - x[n])

Load examples from dropdown or use Theorem Testing panel above!"></textarea>
      
      <div class="button-row">
        <button id="analyzeBtn" class="button-primary">‚ñ∂ Analyze</button>
        <select id="exampleSelect">
          <option value="">üìö Load Example...</option>
          <optgroup label="Theorem-Based Recurrences">
            <option value="banach">Banach Fixed-Point Theorem</option>
            <option value="newton">Newton's Method (sqrt(2))</option>
            <option value="euclid">Euclidean Algorithm</option>
            <option value="collatz">Collatz Recurrence</option>
            <option value="primegap">Prime Gap Growth Approximation</option>
          </optgroup>
          <optgroup label="Mathematics">
            <option value="fibonacci">Fibonacci Sequence</option>
            <option value="newton_method">Newton's Method</option>
            <option value="mandelbrot">Mandelbrot Set Iteration</option>
            <option value="prime_model">Prime Gap Recursion</option>
          </optgroup>
          <optgroup label="Physics">
            <option value="exponential_decay">Exponential Decay (Radioactive)</option>
            <option value="sho_discrete">Simple Harmonic Oscillator</option>
            <option value="damped_oscillator">Damped Oscillator</option>
            <option value="duffing_toy">Duffing Oscillator (Nonlinear)</option>
            <option value="heat_diffusion">Heat Diffusion Step</option>
            <option value="quantum_phase">Quantum Phase Rotation</option>
          </optgroup>
          <optgroup label="Biology / Ecology">
            <option value="logistic_map">Logistic Map (Population)</option>
            <option value="logistic_harvesting">Logistic Growth + Harvesting</option>
            <option value="collapse_population">Population Collapse Model</option>
            <option value="lotka_volterra">Predator-Prey (Lotka-Volterra)</option>
          </optgroup>
          <optgroup label="Chaos Theory">
            <option value="logistic_sinusoidal">Logistic-Sinusoidal Hybrid</option>
            <option value="lorenz_map">Lorenz-Like Simplified Map</option>
          </optgroup>
          <optgroup label="Economics">
            <option value="compound_interest">Compound Interest</option>
          </optgroup>
          <optgroup label="Stability Tests">
            <option value="stability_linear">Linear Stability (Œª < 1)</option>
            <option value="divergence_linear">Linear Divergence (Œª > 1)</option>
          </optgroup>
          <optgroup label="Invalid / Test Cases">
            <option value="invalid_random">Invalid: Random Elements</option>
          </optgroup>
        </select>
        <button id="clearBtn">Clear</button>
      </div>
    </div>
    
    <div id="stageContainer">
      <div class="stage-grid">
        <div class="stage-panel stage-phi" id="panelPhi">
          <div class="stage-header">
            <div class="stage-title">Œ¶ ¬∑ Generativity <span class="operator-badge" id="badgePhiOp" style="display:none;"></span></div>
            <div class="badge badge-pending" id="badgePhi">PENDING</div>
          </div>
          <div class="stage-content" id="contentPhi">
            <p style="color: #666;">Awaiting analysis...</p>
          </div>
        </div>
        
        <div class="stage-panel stage-psi" id="panelPsi">
          <div class="stage-header">
            <div class="stage-title">Œ® ¬∑ Structural Consistency <span class="operator-badge" id="badgePsiOp" style="display:none;"></span></div>
            <div class="badge badge-pending" id="badgePsi">PENDING</div>
          </div>
          <div class="stage-content" id="contentPsi">
            <p style="color: #666;">Awaiting analysis...</p>
          </div>
        </div>
      </div>
      
      <div class="stage-grid-3">
        <div class="stage-panel stage-tau" id="panelTau">
          <div class="stage-header">
            <div class="stage-title">œÑ ¬∑ Curvature Stability <span class="operator-badge" id="badgeTauOp" style="display:none;"></span></div>
            <button class="export-graph-btn" id="exportGraphBtn" style="display:none;">üìä PNG</button>
            <div class="badge badge-pending" id="badgeTau">PENDING</div>
          </div>
          <div class="stage-content" id="contentTau">
            <p style="color: #666;">Awaiting analysis...</p>
          </div>
        </div>
        
        <div class="stage-panel stage-xii" id="panelXII">
          <div class="stage-header">
            <div class="stage-title">XII ¬∑ Collapse Detection <span class="operator-badge" id="badgeXIIOp" style="display:none;"></span></div>
            <div class="badge badge-pending" id="badgeXII">PENDING</div>
          </div>
          <div class="stage-content" id="contentXII">
            <p style="color: #666;">Awaiting analysis...</p>
          </div>
        </div>
        
        <div class="stage-panel stage-verdict" id="panelVerdict">
          <div class="stage-header">
            <div class="stage-title">‚öñÔ∏è Final Verdict</div>
          </div>
          <div class="stage-content" id="contentVerdict">
            <p style="color: #666; text-align: center; padding: 40px 20px;">Awaiting analysis...</p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="log-section" id="logSection" style="display: none;">
      <div class="log-header">Operator Logs</div>
      <div id="logContent"></div>
    </div>
    
    <div class="export-section" style="display: none;" id="exportSection">
      <button id="exportBtn">üíæ Export Analysis (JSON)</button>
    </div>
  </div>
  
  <script>
class ConsistencyEngine {
  constructor() {
    this.logs = [];
    this.analysisData = null;
  }
  
  log(message, type = 'info', operator = null) {
    this.logs.push({ message, type, operator, timestamp: Date.now() });
  }
  
  evaluate(input) {
    this.logs = [];
    this.log('Starting Œ¶‚ÄìŒ®‚ÄìœÑ‚ÄìXII analysis...', 'info', 'system');
    
    const parsed = this.parseInput(input);
    if (!parsed) {
      return {
        verdict: 'NON-GENERABLE',
        stage: 'Œ¶',
        reason: 'Failed to parse input formula',
        operator_results: { Œ¶: 'fail', Œ®: 'pending', œÑ: 'pending', XII: 'pending' }
      };
    }
    
    const phiResult = this.evaluatePhi(parsed);
    if (!phiResult.pass) {
      return {
        verdict: 'NON-GENERABLE',
        stage: 'Œ¶',
        reason: phiResult.reason,
        operator_results: { Œ¶: 'fail', Œ®: 'pending', œÑ: 'pending', XII: 'pending' },
        recursion_tree: phiResult.tree,
        parsed: parsed
      };
    }
    
    const psiResult = this.evaluatePsi(parsed, phiResult);
    if (!psiResult.pass) {
      return {
        verdict: 'INCOHERENT',
        stage: 'Œ®',
        reason: psiResult.reason,
        operator_results: { Œ¶: 'pass', Œ®: 'fail', œÑ: 'pending', XII: 'pending' },
        recursion_tree: phiResult.tree,
        psi_metrics: psiResult.metrics,
        parsed: parsed
      };
    }
    
    const tauResult = this.evaluateTau(parsed, phiResult);
    const xiiResult = this.evaluateXII(parsed, phiResult, psiResult, tauResult);
    
    let verdict, verdictStage;
    if (xiiResult.collapse) {
      verdict = 'NON-EXISTENT';
      verdictStage = 'XII';
    } else if (!tauResult.stable) {
      verdict = 'UNSTABLE';
      verdictStage = 'œÑ';
    } else {
      verdict = 'ADMISSIBLE';
      verdictStage = 'COMPLETE';
    }
    
    this.log(`Final verdict: ${verdict}`, verdict === 'ADMISSIBLE' ? 'pass' : 'warn', 'system');
    
    return {
      verdict: verdict,
      stage: verdictStage,
      operator_results: {
        Œ¶: 'pass',
        Œ®: 'pass',
        œÑ: tauResult.stable ? 'stable' : 'unstable',
        XII: xiiResult.collapse ? 'collapse' : 'pass'
      },
      recursion_tree: phiResult.tree,
      psi_metrics: psiResult.metrics,
      tau_metrics: tauResult.metrics,
      curvature_profile: tauResult.curvature,
      xii_metrics: xiiResult.metrics,
      collapse_reason: xiiResult.reason,
      parsed: parsed
    };
  }
  
  parseInput(input) {
    input = input.trim();
    if (!input) return null;
    
    this.log('Parsing input formula...', 'info', 'system');
    
    const recursionPattern = /(\w+)\[([^\]]+)\]\s*=\s*(.+)/;
    const functionPattern = /(\w+)\(([^\)]+)\)\s*=\s*(.+)/;
    
    let parsed = {
      raw: input,
      type: 'unknown',
      variable: null,
      expression: null,
      recursion_index: null
    };
    
    if (recursionPattern.test(input)) {
      const match = input.match(recursionPattern);
      parsed.type = 'recurrence';
      parsed.variable = match[1];
      parsed.recursion_index = match[2];
      parsed.expression = match[3];
      this.log(`Detected recurrence relation: ${parsed.variable}[${parsed.recursion_index}]`, 'info', 'system');
    } else if (functionPattern.test(input)) {
      const match = input.match(functionPattern);
      parsed.type = 'function';
      parsed.variable = match[1];
      parsed.parameter = match[2];
      parsed.expression = match[3];
      this.log(`Detected function definition: ${parsed.variable}(${parsed.parameter})`, 'info', 'system');
    } else {
      parsed.type = 'expression';
      parsed.expression = input;
      this.log('Parsing as general expression', 'info', 'system');
    }
    
    parsed.operations = this.extractOperations(parsed.expression);
    parsed.complexity = this.estimateComplexity(parsed);
    
    return parsed;
  }
  
  extractOperations(expr) {
    const ops = {
      trig: /sin|cos|tan|arcsin|arccos|arctan/.test(expr),
      exp: /exp|\^/.test(expr),
      log: /log|ln/.test(expr),
      poly: /\*|\+|\-/.test(expr),
      div: /\//.test(expr),
      recursive: /\[\s*n\s*[\+\-]\s*\d+\s*\]/.test(expr)
    };
    return ops;
  }
  
  estimateComplexity(parsed) {
    let score = 0;
    if (parsed.operations.trig) score += 2;
    if (parsed.operations.exp) score += 2;
    if (parsed.operations.log) score += 2;
    if (parsed.operations.poly) score += 1;
    if (parsed.operations.div) score += 1;
    if (parsed.operations.recursive) score += 3;
    return score;
  }
  
  evaluatePhi(parsed) {
    this.log('Running Œ¶ generativity tests...', 'info', 'phi');
    
    const result = {
      pass: true,
      reason: null,
      tree: null,
      metrics: {}
    };
    
    if (parsed.type === 'recurrence') {
      const unfoldTest = this.testRecursionUnfold(parsed);
      if (!unfoldTest.success) {
        result.pass = false;
        result.reason = 'Recursion cannot be unfolded: ' + unfoldTest.reason;
        this.log('Œ¶ FAIL: ' + result.reason, 'fail', 'phi');
        return result;
      }
      result.tree = unfoldTest.tree;
      result.metrics.depth = unfoldTest.depth;
    } else if (parsed.type === 'function') {
      result.tree = this.generateFunctionTree(parsed, 10);
      result.metrics.depth = 10;
    } else {
      const evalTest = this.testExpressionEvaluable(parsed);
      if (!evalTest.success) {
        result.pass = false;
        result.reason = 'Expression is not evaluable: ' + evalTest.reason;
        this.log('Œ¶ FAIL: ' + result.reason, 'fail', 'phi');
        return result;
      }
      result.tree = evalTest.tree;
      result.metrics.depth = 5;
    }
    
    if (this.detectArbitraryChoice(parsed)) {
      result.pass = false;
      result.reason = 'Contains arbitrary choice constructs (non-UNNS admissible)';
      this.log('Œ¶ FAIL: ' + result.reason, 'fail', 'phi');
      return result;
    }
    
    if (this.detectUndecidable(parsed)) {
      result.pass = false;
      result.reason = 'Contains undecidable or Turing-complete encodings';
      this.log('Œ¶ FAIL: ' + result.reason, 'fail', 'phi');
      return result;
    }
    
    this.log('Œ¶ PASS: Structure is generable', 'pass', 'phi');
    result.metrics.generable = true;
    return result;
  }
  
  testRecursionUnfold(parsed) {
    const maxDepth = 20;
    const tree = [];
    
    try {
      for (let i = 0; i < maxDepth; i++) {
        const node = {
          depth: i,
          index: i,
          expression: this.substituteRecursion(parsed, i)
        };
        tree.push(node);
        
        if (i > 3 && this.detectCircular(tree)) {
          return {
            success: false,
            reason: 'Circular reference detected in recursion',
            tree: tree
          };
        }
      }
      
      return {
        success: true,
        depth: maxDepth,
        tree: tree
      };
    } catch (e) {
      return {
        success: false,
        reason: 'Runtime error during unfolding: ' + e.message,
        tree: tree
      };
    }
  }
  
  substituteRecursion(parsed, depth) {
    let expr = parsed.expression;
    expr = expr.replace(/\[n\s*\+\s*(\d+)\]/g, (_, offset) => `[${depth + parseInt(offset)}]`);
    expr = expr.replace(/\[n\s*-\s*(\d+)\]/g, (_, offset) => `[${Math.max(0, depth - parseInt(offset))}]`);
    expr = expr.replace(/\[n\]/g, `[${depth}]`);
    return expr;
  }
  
  detectCircular(tree) {
    if (tree.length < 4) return false;
    const recent = tree.slice(-4).map(n => n.expression).join('|');
    const earlier = tree.slice(0, -4).map(n => n.expression).join('|');
    return earlier.includes(recent);
  }
  
  generateFunctionTree(parsed, depth) {
    const tree = [];
    for (let i = 0; i < depth; i++) {
      tree.push({
        depth: i,
        expression: `${parsed.variable}(x${i}) = ${parsed.expression}`,
        sample_point: i / depth
      });
    }
    return tree;
  }
  
  testExpressionEvaluable(parsed) {
    try {
      if (!/[\+\-\*\/\^]|sin|cos|exp|log/.test(parsed.expression)) {
        return {
          success: false,
          reason: 'No recognizable mathematical operations'
        };
      }
      
      return {
        success: true,
        tree: [{ depth: 0, expression: parsed.expression }]
      };
    } catch (e) {
      return {
        success: false,
        reason: e.message
      };
    }
  }
  
  detectArbitraryChoice(parsed) {
    const arbitraryPatterns = [
      /random|rand/i,
      /choose|select/i
    ];
    return arbitraryPatterns.some(p => p.test(parsed.expression));
  }
  
  detectUndecidable(parsed) {
    const undecidablePatterns = [
      /while|loop/i,
      /halt|stop/i,
      /(?:if.*){3,}/
    ];
    return undecidablePatterns.some(p => p.test(parsed.expression));
  }
  
  evaluatePsi(parsed, phiResult) {
    this.log('Running Œ® structural consistency tests...', 'info', 'psi');
    
    const result = {
      pass: true,
      reason: null,
      metrics: {}
    };
    
    const symmetryScore = this.testSymmetry(parsed, phiResult);
    result.metrics.symmetry = symmetryScore;
    
    if (symmetryScore < 0.3) {
      result.pass = false;
      result.reason = 'Insufficient structural symmetry (score: ' + symmetryScore.toFixed(3) + ')';
      this.log('Œ® FAIL: ' + result.reason, 'fail', 'psi');
      return result;
    }
    
    const coherenceScore = this.testCoherence(parsed, phiResult);
    result.metrics.coherence = coherenceScore;
    
    if (coherenceScore < 0.5) {
      result.pass = false;
      result.reason = 'Projection incoherence detected (score: ' + coherenceScore.toFixed(3) + ')';
      this.log('Œ® FAIL: ' + result.reason, 'fail', 'psi');
      return result;
    }
    
    if (parsed.operations.recursive) {
      const commutativityScore = this.testCommutativity(parsed);
      result.metrics.commutativity = commutativityScore;
      
      if (commutativityScore < 0.4) {
        result.pass = false;
        result.reason = 'Operator non-commutativity violation (score: ' + commutativityScore.toFixed(3) + ')';
        this.log('Œ® FAIL: ' + result.reason, 'fail', 'psi');
        return result;
      }
    }
    
    const invarianceScore = this.testInvariance(parsed, phiResult);
    result.metrics.invariance = invarianceScore;
    
    if (invarianceScore < 0.6) {
      result.pass = false;
      result.reason = 'Recursion invariance violated (score: ' + invarianceScore.toFixed(3) + ')';
      this.log('Œ® FAIL: ' + result.reason, 'fail', 'psi');
      return result;
    }
    
    this.log('Œ® PASS: Structure is consistent', 'pass', 'psi');
    result.metrics.overall_consistency = (symmetryScore + coherenceScore + invarianceScore) / 3;
    return result;
  }
  
  testSymmetry(parsed, phiResult) {
    let score = 0.5;
    
    const expr = parsed.expression;
    const openParens = (expr.match(/\(/g) || []).length;
    const closeParens = (expr.match(/\)/g) || []).length;
    if (openParens === closeParens) score += 0.2;
    
    if (/sin.*sin|cos.*cos/.test(expr)) score += 0.15;
    if (/\+.*\+|\*.*\*/.test(expr)) score += 0.1;
    
    if (phiResult.tree && phiResult.tree.length > 5) {
      const depths = phiResult.tree.map(n => n.depth);
      const isLinear = depths.every((d, i) => d === i);
      if (isLinear) score += 0.15;
    }
    
    return Math.min(score, 1.0);
  }
  
  testCoherence(parsed, phiResult) {
    let score = 0.6;
    
    if (parsed.type === 'recurrence' && parsed.operations.recursive) {
      score += 0.2;
    }
    
    const expr = parsed.expression;
    if (/sin\(.*\*.*\)|cos\(.*\+.*\)/.test(expr)) score += 0.1;
    
    if (phiResult.tree) {
      const avgDepth = phiResult.tree.reduce((s, n) => s + n.depth, 0) / phiResult.tree.length;
      if (avgDepth > 5) score += 0.1;
    }
    
    return Math.min(score, 1.0);
  }
  
  testCommutativity(parsed) {
    let score = 0.5;
    
    const expr = parsed.expression;
    
    if (/\+|\*/.test(expr)) score += 0.2;
    if (/-|\/|\^/.test(expr)) score -= 0.1;
    if (/sin|cos|tan/.test(expr)) score -= 0.05;
    
    return Math.max(0, Math.min(score, 1.0));
  }
  
  testInvariance(parsed, phiResult) {
    let score = 0.7;
    
    if (phiResult.tree && phiResult.tree.length > 3) {
      const structures = phiResult.tree.map(n => 
        n.expression.replace(/\d+/g, 'N').replace(/\[N\]/g, '[*]')
      );
      
      const uniqueStructures = new Set(structures);
      const invarianceRatio = 1 - (uniqueStructures.size / structures.length);
      score += invarianceRatio * 0.3;
    }
    
    return Math.min(score, 1.0);
  }
  
  evaluateTau(parsed, phiResult) {
    this.log('Running œÑ curvature stability analysis...', 'info', 'tau');
    
    const result = {
      stable: true,
      metrics: {},
      curvature: []
    };
    
    const trajectory = this.generateTrajectory(parsed, 100);
    result.metrics.trajectory_length = trajectory.length;
    
    for (let i = 1; i < trajectory.length - 1; i++) {
      const secondDeriv = trajectory[i+1] - 2*trajectory[i] + trajectory[i-1];
      result.curvature.push(secondDeriv);
    }
    
    const avgCurvature = result.curvature.reduce((a,b) => a+b, 0) / result.curvature.length;
    const maxCurvature = Math.max(...result.curvature.map(Math.abs));
    const variance = result.curvature.reduce((s, v) => s + (v - avgCurvature)**2, 0) / result.curvature.length;
    
    result.metrics.avg_curvature = avgCurvature;
    result.metrics.max_curvature = maxCurvature;
    result.metrics.variance = variance;
    result.metrics.std_dev = Math.sqrt(variance);
    
    const fixedPoints = this.findFixedPoints(trajectory);
    result.metrics.fixed_points = fixedPoints.length;
    result.metrics.has_attractor = fixedPoints.length > 0;
    
    const maxAbs = Math.max(...trajectory.map(Math.abs));
    result.metrics.max_amplitude = maxAbs;
    result.metrics.bounded = maxAbs < 1e6;
    
    if (trajectory.length > 10) {
      const earlyMean = trajectory.slice(0, 10).reduce((a,b) => a+Math.abs(b), 0) / 10;
      const lateMean = trajectory.slice(-10).reduce((a,b) => a+Math.abs(b), 0) / 10;
      result.metrics.damping_ratio = lateMean / (earlyMean + 1e-10);
    }
    
    if (!result.metrics.bounded) {
      result.stable = false;
      this.log('œÑ UNSTABLE: Unbounded growth detected', 'warn', 'tau');
    } else if (maxCurvature > 1e3) {
      result.stable = false;
      this.log('œÑ UNSTABLE: Excessive curvature detected', 'warn', 'tau');
    } else if (variance > 1e4) {
      result.stable = false;
      this.log('œÑ UNSTABLE: High variance indicates instability', 'warn', 'tau');
    } else {
      this.log('œÑ STABLE: Curvature profile within acceptable bounds', 'pass', 'tau');
    }
    
    return result;
  }
  
  generateTrajectory(parsed, steps) {
    const trajectory = [];
    
    try {
      if (parsed.type === 'recurrence') {
        let current = 0.5;
        trajectory.push(current);
        
        for (let i = 1; i < steps; i++) {
          current = this.evaluateRecursionStep(parsed, trajectory, i);
          
          if (!isFinite(current)) break;
          trajectory.push(current);
        }
      } else if (parsed.type === 'function') {
        for (let i = 0; i < steps; i++) {
          const x = (i / steps) * 10 - 5;
          const y = this.evaluateFunctionAt(parsed, x);
          if (isFinite(y)) trajectory.push(y);
        }
      } else {
        for (let i = 0; i < steps; i++) {
          trajectory.push(Math.sin(i * 0.1) * Math.exp(-i * 0.01));
        }
      }
    } catch (e) {
      this.log('Error generating trajectory: ' + e.message, 'warn', 'tau');
    }
    
    return trajectory;
  }
  
  evaluateRecursionStep(parsed, trajectory, index) {
    try {
      const expr = parsed.expression;
      const prevIndex = index - 1;
      
      if (/0\.5\s*\*\s*\w+\[n\]\s*\+\s*1/.test(expr)) {
        return 0.5 * trajectory[prevIndex] + 1;
      }
      
      if (/\w+\[n\]\s*-\s*\(\w+\[n\]\^2\s*-\s*2\)\s*\/\s*\(2\*\w+\[n\]\)/.test(expr)) {
        const x = trajectory[prevIndex];
        if (Math.abs(x) < 0.01) return 1.5;
        return x - (x * x - 2) / (2 * x);
      }
      
      if (/\w+\[n\]\s*\+\s*ln\(\w+\[n\]\)/.test(expr)) {
        const p = trajectory[prevIndex];
        if (p <= 0) return 2;
        return p + Math.log(p);
      }
      
      if (/\[n\s*-\s*1\]\s*\+\s*\w+\[n\s*-\s*2\]/.test(expr)) {
        if (index === 1) return 1;
        return trajectory[index-1] + trajectory[index-2];
      }
      
      if (/[\d.]+\s*\*\s*\w+\[n\]\s*\*\s*\(1\s*-\s*\w+\[n\]\)/.test(expr)) {
        const r = parseFloat(expr.match(/[\d.]+/)[0]) || 3.5;
        const x = trajectory[prevIndex];
        return r * x * (1 - x);
      }
      
      if (/\w+\[n\]\s*\*\s*sin\(\w+\[n\]\)/.test(expr)) {
        const x = trajectory[prevIndex];
        return x * Math.sin(x);
      }
      
      if (/3\s*\*\s*\w+\[n\]\s*-\s*1/.test(expr) || /3\s*\*\s*\w+\[n\]\s*\+\s*1/.test(expr)) {
        const x = trajectory[prevIndex];
        if (x % 2 === 0) return x / 2;
        return 3 * x + 1;
      }
      
      if (/-[\d.]*\s*\*\s*\w+\[n\]/.test(expr)) {
        const match = expr.match(/-?([\d.]+)\s*\*\s*\w+\[n\]/);
        const k = match ? parseFloat(match[1]) : 0.1;
        return -k * trajectory[prevIndex] + 0.01 * index;
      }
      
      if (/sin\(n\s*\*\s*\w+\[n\]\)/.test(expr) || /sin\(\w+\[n\]\s*\*\s*n\)/.test(expr)) {
        const x = trajectory[prevIndex];
        return x + Math.sin(index * x);
      }
      
      if (/exp\(-[\d.]*\)/.test(expr) || /exp\(-\s*\w+\[n\]\)/.test(expr)) {
        const x = trajectory[prevIndex];
        return x * Math.exp(-0.02);
      }
      
      if (/\w+\[n\]\s*-\s*[\d.]+\s*\*\s*sin\(\w+\[n\]\)/.test(expr)) {
        const x = trajectory[prevIndex];
        const k = parseFloat(expr.match(/-([\d.]+)/)[1]) || 0.5;
        return x - k * Math.sin(x);
      }
      
      if (/\w+\[n\]\s*-\s*[\d.]+\s*\*\s*\w+\[n\]\s*\^\s*3/.test(expr)) {
        const x = trajectory[prevIndex];
        const k = parseFloat(expr.match(/-([\d.]+)/)[1]) || 0.3;
        return x - k * Math.pow(x, 3);
      }
      
      if (/\w+\[n\]\s*\*\s*\(1\s*\+\s*[\d.]+\)/.test(expr) || /\w+\[n\]\s*\*\s*[\d.]+/.test(expr)) {
        const match = expr.match(/[\d.]+/);
        const r = match ? parseFloat(match[0]) : 1.05;
        return trajectory[prevIndex] * r;
      }
      
      return trajectory[prevIndex] * 0.95 * Math.cos(index * 0.1);
    } catch (e) {
      return trajectory[prevIndex] || 0;
    }
  }
  
  evaluateFunctionAt(parsed, x) {
    try {
      const expr = parsed.expression;
      
      if (/sin\(x\)/.test(expr) && /x\^2/.test(expr)) {
        return x * Math.sin(x) / (1 + x*x);
      }
      
      return Math.sin(x) * Math.exp(-Math.abs(x) * 0.1);
    } catch (e) {
      return 0;
    }
  }
  
  findFixedPoints(trajectory) {
    const points = [];
    const tolerance = 0.01;
    
    for (let i = 10; i < trajectory.length - 10; i++) {
      const windowBefore = trajectory.slice(i-5, i);
      const windowAfter = trajectory.slice(i+1, i+6);
      
      const avgBefore = windowBefore.reduce((a,b) => a+b, 0) / windowBefore.length;
      const avgAfter = windowAfter.reduce((a,b) => a+b, 0) / windowAfter.length;
      
      if (Math.abs(avgBefore - avgAfter) < tolerance) {
        points.push({ index: i, value: trajectory[i] });
      }
    }
    
    return points;
  }
  
  evaluateXII(parsed, phiResult, psiResult, tauResult) {
    this.log('Running XII collapse detection...', 'info', 'xii');
    
    const result = {
      collapse: false,
      reason: null,
      metrics: {}
    };
    
    if (parsed.complexity > 8) {
      result.collapse = true;
      result.reason = 'Undecidable recursion complexity (score: ' + parsed.complexity + ')';
      this.log('XII COLLAPSE: ' + result.reason, 'fail', 'xii');
      return result;
    }
    
    if (psiResult.metrics.invariance < 0.3) {
      result.collapse = true;
      result.reason = 'Invariance violation leads to contradiction';
      this.log('XII COLLAPSE: ' + result.reason, 'fail', 'xii');
      return result;
    }
    
    if (psiResult.metrics.coherence < 0.3) {
      result.collapse = true;
      result.reason = 'Projection coherence breakdown';
      this.log('XII COLLAPSE: ' + result.reason, 'fail', 'xii');
      return result;
    }
    
    if (!tauResult.metrics.bounded) {
      result.collapse = true;
      result.reason = 'Irreversible divergence detected in trajectory';
      this.log('XII COLLAPSE: ' + result.reason, 'fail', 'xii');
      return result;
    }
    
    if (tauResult.metrics.max_curvature > 1e4) {
      result.collapse = true;
      result.reason = 'Extreme curvature violates substrate constraints';
      this.log('XII COLLAPSE: ' + result.reason, 'fail', 'xii');
      return result;
    }
    
    if (phiResult.tree && this.detectSelfReference(phiResult.tree)) {
      result.collapse = true;
      result.reason = 'Self-referential inconsistency detected';
      this.log('XII COLLAPSE: ' + result.reason, 'fail', 'xii');
      return result;
    }
    
    this.log('XII PASS: No collapse triggers activated', 'pass', 'xii');
    result.metrics.collapse_risk = this.estimateCollapseRisk(psiResult, tauResult);
    return result;
  }
  
  detectSelfReference(tree) {
    if (tree.length < 5) return false;
    
    const expressions = tree.map(n => n.expression);
    for (let i = 2; i < expressions.length; i++) {
      if (expressions[i] === expressions[i-1] && expressions[i] === expressions[i-2]) {
        return true;
      }
    }
    
    return false;
  }
  
  estimateCollapseRisk(psiResult, tauResult) {
    let risk = 0;
    
    if (psiResult.metrics.coherence < 0.7) risk += 0.2;
    if (psiResult.metrics.invariance < 0.7) risk += 0.2;
    if (tauResult.metrics.variance > 100) risk += 0.3;
    if (!tauResult.metrics.has_attractor) risk += 0.2;
    if (tauResult.metrics.max_curvature > 100) risk += 0.1;
    
    return Math.min(risk, 1.0);
  }
}

class ChamberUI {
  constructor() {
    this.engine = new ConsistencyEngine();
    this.currentAnalysis = null;
    this.debounceTimer = null;
    this.setupEventListeners();
    this.setupExamples();
    this.initializeTheoremPanel();
  }
  
  setupEventListeners() {
    document.getElementById('analyzeBtn').addEventListener('click', () => this.runAnalysis());
    document.getElementById('clearBtn').addEventListener('click', () => this.clearAll());
    document.getElementById('exportBtn').addEventListener('click', () => this.exportAnalysis());
    document.getElementById('exampleSelect').addEventListener('change', (e) => this.loadExample(e.target.value));
    document.getElementById('exportGraphBtn').addEventListener('click', () => this.exportTauGraph());
  }
  
  setupExamples() {
    this.examples = {
      banach: 'x[n+1] = 0.5 * x[n] + 1',
      newton: 'x[n+1] = x[n] - (x[n]^2 - 2) / (2*x[n])',
      euclid: 'a[n+1] = b[n]; b[n+1] = a[n] % b[n]',
      collatz: 'x[n+1] = (x[n] % 2 == 0) ? x[n] / 2 : 3*x[n] + 1',
      primegap: 'p[n+1] = p[n] + ln(p[n])',
      fibonacci: 'F[n] = F[n-1] + F[n-2]',
      logistic_map: 'x[n+1] = 3.9 * x[n] * (1 - x[n])',
      exponential_decay: 'N[n+1] = N[n] * exp(-0.02)',
      damped_oscillator: 'x[n+1] = 0.9 * x[n] - 0.2 * x[n-1]',
      sho_discrete: 'x[n+1] = x[n] - 0.5 * sin(x[n])',
      stability_linear: 'x[n+1] = 0.8 * x[n]',
      divergence_linear: 'x[n+1] = 1.2 * x[n]',
      lotka_volterra: 'x[n+1] = x[n] + 0.4*x[n]*(1-y[n])',
      newton_method: 'x[n+1] = x[n] - (x[n]^2 - 2) / (2*x[n])',
      duffing_toy: 'x[n+1] = x[n] - 0.3 * x[n]^3',
      quantum_phase: 'œà[n+1] = œà[n] * exp(i * 0.2 * œà[n])',
      logistic_harvesting: 'x[n+1] = x[n] + 0.3*x[n]*(1 - x[n]/10) - 0.2',
      lorenz_map: 'x[n+1] = x[n] + a*(y[n] - x[n])',
      heat_diffusion: 'T[n+1] = T[n] + 0.1*(T[n+1] - 2*T[n] + T[n-1])',
      collapse_population: 'x[n+1] = x[n] * (1 - 0.5 * x[n])',
      compound_interest: 'A[n+1] = A[n] * 1.05',
      mandelbrot: 'z[n+1] = z[n]^2 + c',
      prime_model: 'p[n+1] = p[n] + (prime(n+1) - prime(n))',
      logistic_sinusoidal: 'x[n+1] = 3.5*x[n]*(1-x[n]) + 0.1*sin(10*x[n])',
      invalid_random: 'x[n+1] = random() * x[n]'
    };
  }
  
  initializeTheoremPanel() {
    this.theoremExamples = {
      banach: {
        name: "Banach Fixed-Point Theorem",
        formula: "x[n+1] = 0.5 * x[n] + 1"
      },
      newton: {
        name: "Newton's Method (sqrt(2))",
        formula: "x[n+1] = x[n] - (x[n]^2 - 2) / (2*x[n])"
      },
      euclid: {
        name: "Euclidean Algorithm (GCD)",
        formula: "a[n+1] = b[n]; b[n+1] = a[n] % b[n]"
      },
      collatz: {
        name: "Collatz Recurrence (3n + 1)",
        formula: "x[n+1] = (x[n] % 2 == 0) ? x[n] / 2 : 3*x[n] + 1"
      },
      primegap: {
        name: "Prime Gap Growth Model",
        formula: "p[n+1] = p[n] + ln(p[n])"
      }
    };
    
    const theoremList = document.getElementById('theoremList');
    Object.keys(this.theoremExamples).forEach(key => {
      const btn = document.createElement('button');
      btn.className = 'theorem-btn';
      btn.textContent = this.theoremExamples[key].name;
      btn.addEventListener('click', () => this.loadTheorem(key));
      theoremList.appendChild(btn);
    });
  }
  
  loadTheorem(key) {
    const theorem = this.theoremExamples[key];
    if (!theorem) return;
    
    document.getElementById('formulaInput').value = theorem.formula;
    setTimeout(() => this.runAnalysis(), 50);
  }
  
  loadExample(key) {
    if (!key) return;
    
    clearTimeout(this.debounceTimer);
    
    document.getElementById('formulaInput').value = this.examples[key];
    document.getElementById('exampleSelect').value = '';
    
    this.debounceTimer = setTimeout(() => {
      this.runAnalysis();
    }, 100);
  }
  
  clearAll() {
    document.getElementById('formulaInput').value = '';
    this.resetPanels();
    document.getElementById('logSection').style.display = 'none';
    document.getElementById('exportSection').style.display = 'none';
    document.getElementById('logContent').innerHTML = '';
  }
  
  resetPanels() {
    ['Phi', 'Psi', 'Tau', 'XII'].forEach(stage => {
      const panel = document.getElementById('panel' + stage);
      const badge = document.getElementById('badge' + stage);
      const opBadge = document.getElementById('badge' + stage + 'Op');
      const content = document.getElementById('content' + stage);
      
      panel.className = 'stage-panel stage-' + stage.toLowerCase();
      badge.className = 'badge badge-pending';
      badge.textContent = 'PENDING';
      if (opBadge) opBadge.style.display = 'none';
      content.innerHTML = '<p style="color: #666;">Awaiting analysis...</p>';
    });
    
    document.getElementById('contentVerdict').innerHTML = '<p style="color: #666; text-align: center; padding: 40px 20px;">Awaiting analysis...</p>';
    document.getElementById('exportGraphBtn').style.display = 'none';
  }
  
  async runAnalysis() {
    const input = document.getElementById('formulaInput').value.trim();
    if (!input) {
      alert('Please enter a formula or load an example.');
      return;
    }
    
    this.resetPanels();
    document.getElementById('logSection').style.display = 'block';
    document.getElementById('logContent').innerHTML = '';
    
    await this.sleep(200);
    this.setStageActive('Phi');
    
    const result = this.engine.evaluate(input);
    this.currentAnalysis = result;
    
    await this.sleep(500);
    this.displayPhiResults(result);
    
    if (result.operator_results.Œ¶ === 'fail') {
      this.displayFinalVerdict(result);
      this.displayLogs();
      return;
    }
    
    await this.sleep(300);
    this.setStageActive('Psi');
    await this.sleep(500);
    this.displayPsiResults(result);
    
    if (result.operator_results.Œ® === 'fail') {
      this.displayFinalVerdict(result);
      this.displayLogs();
      return;
    }
    
    await this.sleep(300);
    this.setStageActive('Tau');
    await this.sleep(500);
    this.displayTauResults(result);
    
    await this.sleep(300);
    this.setStageActive('XII');
    await this.sleep(500);
    this.displayXIIResults(result);
    
    await this.sleep(300);
    this.displayFinalVerdict(result);
    this.displayLogs();
    
    document.getElementById('exportSection').style.display = 'block';
  }
  
  setStageActive(stage) {
    document.getElementById('panel' + stage).classList.add('active');
  }
  
  displayPhiResults(result) {
    const panel = document.getElementById('panelPhi');
    const badge = document.getElementById('badgePhi');
    const opBadge = document.getElementById('badgePhiOp');
    const content = document.getElementById('contentPhi');
    
    if (result.operator_results.Œ¶ === 'pass') {
      panel.classList.remove('active');
      panel.classList.add('pass');
      badge.className = 'badge badge-pass';
      badge.textContent = 'PASS';
      
      opBadge.textContent = 'PASS';
      opBadge.className = 'operator-badge pass';
      opBadge.style.display = 'inline-block';
      
      let html = '<div class="metric"><span class="metric-label">Generativity</span><span class="metric-value">‚úì Confirmed</span></div>';
      html += '<div class="metric"><span class="metric-label">Tree Depth</span><span class="metric-value">' + (result.recursion_tree?.length || 0) + '</span></div>';
      html += '<div class="metric"><span class="metric-label">Unfoldable</span><span class="metric-value">Yes</span></div>';
      
      if (result.recursion_tree && result.recursion_tree.length > 0) {
        html += '<div class="recursion-tree"><pre>';
        result.recursion_tree.slice(0, 8).forEach(node => {
          html += `L${node.depth}: ${node.expression}\n`;
        });
        if (result.recursion_tree.length > 8) {
          html += `... (${result.recursion_tree.length - 8} more levels)\n`;
        }
        html += '</pre></div>';
      }
      
      content.innerHTML = html;
    } else {
      panel.classList.remove('active');
      panel.classList.add('fail');
      badge.className = 'badge badge-fail';
      badge.textContent = 'FAIL';
      
      opBadge.textContent = 'NON-GENERABLE';
      opBadge.className = 'operator-badge fail';
      opBadge.style.display = 'inline-block';
      
      content.innerHTML = '<div style="color: #ff4a4a; padding: 10px;">' + result.reason + '</div>';
    }
  }
  
  displayPsiResults(result) {
    const panel = document.getElementById('panelPsi');
    const badge = document.getElementById('badgePsi');
    const opBadge = document.getElementById('badgePsiOp');
    const content = document.getElementById('contentPsi');
    
    if (result.operator_results.Œ® === 'pass') {
      panel.classList.remove('active');
      panel.classList.add('pass');
      badge.className = 'badge badge-pass';
      badge.textContent = 'PASS';
      
      opBadge.textContent = 'PASS';
      opBadge.className = 'operator-badge pass';
      opBadge.style.display = 'inline-block';
      
      const m = result.psi_metrics;
      let html = '<div class="metric"><span class="metric-label">Symmetry</span><span class="metric-value">' + m.symmetry.toFixed(3) + '</span></div>';
      html += '<div class="metric"><span class="metric-label">Coherence</span><span class="metric-value">' + m.coherence.toFixed(3) + '</span></div>';
      html += '<div class="metric"><span class="metric-label">Invariance</span><span class="metric-value">' + m.invariance.toFixed(3) + '</span></div>';
      if (m.commutativity !== undefined) {
        html += '<div class="metric"><span class="metric-label">Commutativity</span><span class="metric-value">' + m.commutativity.toFixed(3) + '</span></div>';
      }
      html += '<div class="metric"><span class="metric-label">Overall</span><span class="metric-value">' + (m.overall_consistency || 0).toFixed(3) + '</span></div>';
      
      content.innerHTML = html;
    } else {
      panel.classList.remove('active');
      panel.classList.add('fail');
      badge.className = 'badge badge-fail';
      badge.textContent = 'FAIL';
      
      opBadge.textContent = 'INCOHERENT';
      opBadge.className = 'operator-badge fail';
      opBadge.style.display = 'inline-block';
      
      content.innerHTML = '<div style="color: #ff4a4a; padding: 10px;">' + result.reason + '</div>';
    }
  }
  
  displayTauResults(result) {
    const panel = document.getElementById('panelTau');
    const badge = document.getElementById('badgeTau');
    const opBadge = document.getElementById('badgeTauOp');
    const content = document.getElementById('contentTau');
    
    const stable = result.operator_results.œÑ === 'stable';
    
    if (stable) {
      panel.classList.remove('active');
      panel.classList.add('pass');
      badge.className = 'badge badge-pass';
      badge.textContent = 'STABLE';
      
      opBadge.textContent = 'STABLE';
      opBadge.className = 'operator-badge stable';
      opBadge.style.display = 'inline-block';
    } else {
      panel.classList.remove('active');
      panel.classList.add('fail');
      badge.className = 'badge badge-fail';
      badge.textContent = 'UNSTABLE';
      
      opBadge.textContent = 'UNSTABLE';
      opBadge.className = 'operator-badge warn';
      opBadge.style.display = 'inline-block';
    }
    
    const m = result.tau_metrics;
    let html = '<div class="metric"><span class="metric-label">Max Curvature</span><span class="metric-value">' + m.max_curvature.toExponential(2) + '</span></div>';
    html += '<div class="metric"><span class="metric-label">Variance</span><span class="metric-value">' + m.variance.toExponential(2) + '</span></div>';
    html += '<div class="metric"><span class="metric-label">Fixed Points</span><span class="metric-value">' + m.fixed_points + '</span></div>';
    html += '<div class="metric"><span class="metric-label">Bounded</span><span class="metric-value">' + (m.bounded ? 'Yes' : 'No') + '</span></div>';
    
    html += '<div class="curvature-plot"><canvas class="curvature-canvas" id="curvatureCanvas"></canvas></div>';
    
    content.innerHTML = html;
    
    this.drawCurvature(result.curvature_profile);
    document.getElementById('exportGraphBtn').style.display = 'block';
  }
  
  drawCurvature(profile) {
    const canvas = document.getElementById('curvatureCanvas');
    if (!canvas || !profile || profile.length === 0) return;
    
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    
    const w = canvas.width;
    const h = canvas.height;
    const padding = 20;
    
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, w, h);
    
    const maxVal = Math.max(...profile.map(Math.abs));
    
    ctx.strokeStyle = '#4affaf';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    profile.forEach((val, i) => {
      const x = padding + (i / profile.length) * (w - 2 * padding);
      const y = h/2 - (val / maxVal) * (h/2 - padding);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    
    ctx.stroke();
    
    ctx.strokeStyle = '#2a2a3a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, h/2);
    ctx.lineTo(w - padding, h/2);
    ctx.stroke();
  }
  
  displayXIIResults(result) {
    const panel = document.getElementById('panelXII');
    const badge = document.getElementById('badgeXII');
    const opBadge = document.getElementById('badgeXIIOp');
    const content = document.getElementById('contentXII');
    
    const collapsed = result.operator_results.XII === 'collapse';
    
    if (!collapsed) {
      panel.classList.remove('active');
      panel.classList.add('pass');
      badge.className = 'badge badge-pass';
      badge.textContent = 'PASS';
      
      opBadge.textContent = 'PASS';
      opBadge.className = 'operator-badge pass';
      opBadge.style.display = 'inline-block';
      
      let html = '<div class="metric"><span class="metric-label">Collapse Risk</span><span class="metric-value">' + (result.xii_metrics.collapse_risk * 100).toFixed(1) + '%</span></div>';
      html += '<div class="metric"><span class="metric-label">Status</span><span class="metric-value">No Collapse</span></div>';
      html += '<div style="margin-top: 15px; padding: 10px; background: #0a2a0a; border-radius: 4px; color: #4aff4a;">';
      html += '‚úì Structure survives all collapse triggers';
      html += '</div>';
      
      content.innerHTML = html;
    } else {
      panel.classList.remove('active');
      panel.classList.add('fail');
      badge.className = 'badge badge-fail';
      badge.textContent = 'COLLAPSE';
      
      opBadge.textContent = 'COLLAPSE';
      opBadge.className = 'operator-badge fail';
      opBadge.style.display = 'inline-block';
      
      let html = '<div style="color: #ff4a4a; padding: 10px; background: #2a0a0a; border-radius: 4px; margin-bottom: 10px;">';
      html += '<strong>Collapse Detected:</strong><br>' + result.collapse_reason;
      html += '</div>';
      
      content.innerHTML = html;
    }
  }
  
  displayFinalVerdict(result) {
    const content = document.getElementById('contentVerdict');
    
    let verdictClass = 'verdict-';
    switch(result.verdict) {
      case 'ADMISSIBLE': verdictClass += 'admissible'; break;
      case 'UNSTABLE': verdictClass += 'unstable'; break;
      case 'INCOHERENT': verdictClass += 'incoherent'; break;
      case 'NON-EXISTENT': verdictClass += 'nonexistent'; break;
      case 'NON-GENERABLE': verdictClass += 'nongenerable'; break;
    }
    
    let html = '<div class="fade-in">';
    html += '<div class="verdict-badge ' + verdictClass + '">' + result.verdict + '</div>';
    
    html += '<div class="verdict-details">';
    if (result.verdict === 'ADMISSIBLE') {
      html += 'Structure passes all consistency checks and is admitted to the UNNS substrate.';
    } else {
      html += 'Failed at stage: <strong>' + result.stage + '</strong><br>';
      if (result.reason) html += result.reason;
      if (result.collapse_reason) html += result.collapse_reason;
    }
    html += '</div>';
    
    html += '<div class="pathway-diagram">';
    html += '<svg width="100%" height="60" style="display: block;">';
    
    const stages = ['Œ¶', 'Œ®', 'œÑ', 'XII'];
    const stageX = [20, 120, 220, 320];
    const colors = ['#4affff', '#af4aff', '#4affaf', '#ff4a9e'];
    const results = result.operator_results;
    
    stages.forEach((stage, i) => {
      let status = results[stage];
      let color = colors[i];
      let opacity = 0.3;
      
      if (status === 'pass' || status === 'stable') {
        opacity = 1.0;
        color = '#4aff4a';
      } else if (status === 'fail' || status === 'collapse' || status === 'unstable') {
        opacity = 1.0;
        color = '#ff4a4a';
      }
      
      html += `<circle cx="${stageX[i]}" cy="30" r="15" fill="${color}" opacity="${opacity}"/>`;
      html += `<text x="${stageX[i]}" y="35" fill="#0a0a0a" text-anchor="middle" font-size="14" font-weight="bold">${stage}</text>`;
      
      if (i < stages.length - 1) {
        html += `<line x1="${stageX[i] + 15}" y1="30" x2="${stageX[i+1] - 15}" y2="30" stroke="${color}" stroke-width="2" opacity="${opacity}"/>`;
      }
    });
    
    html += '</svg>';
    html += '</div>';
    
    html += '</div>';
    
    content.innerHTML = html;
  }
  
  displayLogs() {
    const logContent = document.getElementById('logContent');
    this.engine.logs.forEach(entry => {
      const div = document.createElement('div');
      div.className = 'log-entry';
      
      const timestamp = new Date(entry.timestamp);
      const timeStr = timestamp.toLocaleTimeString('en-US', { hour12: false });
      
      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'log-timestamp';
      timestampSpan.textContent = timeStr;
      
      const operatorSpan = document.createElement('span');
      operatorSpan.className = 'log-operator';
      if (entry.operator) {
        operatorSpan.classList.add(entry.operator);
        operatorSpan.textContent = entry.operator === 'system' ? '‚Üí' : entry.operator.toUpperCase();
      } else {
        operatorSpan.textContent = '‚Üí';
      }
      
      const statusSpan = document.createElement('span');
      statusSpan.className = 'log-status ' + entry.type;
      statusSpan.textContent = entry.type.toUpperCase();
      
      const messageSpan = document.createElement('span');
      messageSpan.className = 'log-message';
      messageSpan.textContent = entry.message;
      
      div.appendChild(timestampSpan);
      div.appendChild(operatorSpan);
      div.appendChild(statusSpan);
      div.appendChild(messageSpan);
      
      logContent.appendChild(div);
    });
    
    logContent.scrollTop = logContent.scrollHeight;
  }
  
  exportAnalysis() {
    if (!this.currentAnalysis) return;
    
    const exportData = {
      version: '1.3.0',
      chamber: 'XXVIII',
      operator: 'Œ¶‚ÄìŒ®‚ÄìœÑ‚ÄìXII',
      timestamp: new Date().toISOString(),
      input: document.getElementById('formulaInput').value,
      verdict: this.currentAnalysis.verdict,
      stage: this.currentAnalysis.stage,
      operator_results: this.currentAnalysis.operator_results,
      metrics: {
        psi: this.currentAnalysis.psi_metrics,
        tau: this.currentAnalysis.tau_metrics,
        xii: this.currentAnalysis.xii_metrics
      },
      recursion_tree: this.currentAnalysis.recursion_tree?.slice(0, 20),
      curvature_profile: this.currentAnalysis.curvature_profile,
      logs: this.engine.logs
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Chamber_XXVIII_Analysis_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
  
  exportTauGraph() {
    const canvas = document.getElementById('curvatureCanvas');
    if (!canvas) return;
    
    const dataURL = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.download = `tau_curvature_${Date.now()}.png`;
    link.href = dataURL;
    link.click();
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

window.addEventListener('DOMContentLoaded', () => {
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('UNNS Laboratory | Chamber XXVIII | v1.3.0');
  console.log('Œ¶‚ÄìŒ®‚ÄìœÑ‚ÄìXII Consistency Operator');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  
  const ui = new ChamberUI();
  
  console.log('‚úì Engine initialized');
  console.log('‚úì Guide loaded');
  console.log('‚úì 20+ examples available');
  console.log('‚úì Theorem Testing Panel active');
  console.log('‚úì 5 theorem formulations ready');
  console.log('‚úì Auto-analysis enabled');
  console.log('‚úì PNG export enabled');
  console.log('‚úì Operator badges active');
  console.log('‚úì Chamber ready');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
});
  </script>
</body>
</html>
