<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>τon Field Theory | UNNS Framework</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0a0a14;
            color: #e5e7eb;
            line-height: 1.6;
            overflow-x: hidden;
        }

        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.6;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 100px 20px 80px;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1));
            border-radius: 20px;
            margin-bottom: 60px;
            border: 1px solid rgba(139, 92, 246, 0.3);
            position: relative;
        }

        h1 {
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, #06b6d4, #8b5cf6, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            letter-spacing: -2px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .subtitle {
            font-size: 1.5rem;
            color: #9ca3af;
            margin-bottom: 30px;
        }

        .hero-equations {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        .hero-eq {
            text-align: center;
        }

        .hero-eq-label {
            font-size: 0.9rem;
            color: #06b6d4;
            margin-bottom: 10px;
        }

        .hero-eq-formula {
            font-size: 2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #fff;
        }

        .arrow {
            font-size: 2.5rem;
            color: #8b5cf6;
        }

        section {
            background: rgba(17, 24, 39, 0.8);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 20px;
            padding: 60px 40px;
            margin-bottom: 40px;
            backdrop-filter: blur(10px);
        }

        h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #06b6d4, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section-subtitle {
            font-size: 1.2rem;
            color: #9ca3af;
            margin-bottom: 40px;
        }

        .concept-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-top: 30px;
        }

        .concept-box {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 15px;
            padding: 30px;
        }

        .concept-box h3 {
            color: #06b6d4;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .concept-box p {
            color: #d1d5db;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .concept-list {
            list-style: none;
            padding-left: 0;
        }

        .concept-list li {
            padding: 10px 0;
            padding-left: 25px;
            position: relative;
            color: #d1d5db;
        }

        .concept-list li:before {
            content: "→";
            position: absolute;
            left: 0;
            color: #8b5cf6;
            font-weight: bold;
        }

        .eq-group {
            margin-bottom: 40px;
        }

        .eq-group h3 {
            color: #ec4899;
            font-size: 1.8rem;
            margin-bottom: 25px;
        }

        .equation-box {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .equation-box:hover {
            border-color: rgba(6, 182, 212, 0.6);
            box-shadow: 0 0 30px rgba(6, 182, 212, 0.2);
            transform: translateY(-2px);
        }

        .eq-label {
            color: #06b6d4;
            font-size: 0.9rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .eq-formula {
            font-family: 'Courier New', monospace;
            font-size: 1.3rem;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }

        .eq-description {
            color: #9ca3af;
            font-size: 0.95rem;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 15px;
            overflow: hidden;
            margin-top: 30px;
        }

        #interactiveCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .canvas-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(6, 182, 212, 0.4);
            border-radius: 10px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            max-width: 400px;
        }

        .canvas-info div {
            margin-bottom: 8px;
            color: #06b6d4;
            line-height: 1.4;
        }

        .canvas-info .hint {
            color: #8b5cf6;
            margin-top: 12px;
            font-style: italic;
        }

        .roundtrip-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .rt-box {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(236, 72, 153, 0.1));
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 15px;
            padding: 30px;
        }

        .rt-box h3 {
            color: #ec4899;
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        .philosophy-content {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1));
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 15px;
            padding: 40px;
            margin-top: 30px;
        }

        .philosophy-quote {
            font-size: 1.5rem;
            font-style: italic;
            color: #a78bfa;
            text-align: center;
            margin: 40px 0;
            padding: 30px;
            border-left: 4px solid #8b5cf6;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .papers-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        .paper-card {
            background: linear-gradient(135deg, rgba(17, 24, 39, 0.9), rgba(31, 41, 55, 0.9));
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 15px;
            padding: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
            text-decoration: none;
            display: block;
            color: inherit;
        }

        .paper-card:hover {
            border-color: rgba(6, 182, 212, 0.6);
            box-shadow: 0 0 40px rgba(6, 182, 212, 0.3);
            transform: translateX(10px);
        }

        .paper-card h3 {
            color: #06b6d4;
            font-size: 1.3rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .paper-card h3:after {
            content: "→";
            font-size: 1.5rem;
            color: #8b5cf6;
        }

        .paper-card p {
            color: #9ca3af;
            line-height: 1.6;
        }

        footer {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            margin-top: 60px;
        }

        .diagram-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 15px;
            overflow: hidden;
            margin: 30px 0;
        }

        .diagram-canvas {
            width: 100%;
            height: 100%;
        }

        .diagram-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(6, 182, 212, 0.4);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #06b6d4;
            pointer-events: none;
            font-family: 'Courier New', monospace;
        }

        .visual-demo {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(139, 92, 246, 0.1));
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
        }

        .gauge-visual {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 40px 20px;
            position: relative;
            flex-wrap: wrap;
            gap: 20px;
        }

        .gauge-circle {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            position: relative;
            transition: all 0.5s ease;
        }

        .gauge-circle:hover {
            transform: scale(1.15);
        }

        .gauge-u1 {
            background: radial-gradient(circle, rgba(6, 182, 212, 0.3), rgba(6, 182, 212, 0.1));
            border: 3px solid #06b6d4;
            color: #06b6d4;
            animation: pulse 2s ease-in-out infinite;
        }

        .gauge-su2 {
            background: radial-gradient(circle, rgba(139, 92, 246, 0.3), rgba(139, 92, 246, 0.1));
            border: 3px solid #8b5cf6;
            color: #8b5cf6;
            animation: pulse 2.5s ease-in-out infinite;
        }

        .gauge-dk {
            background: radial-gradient(circle, rgba(236, 72, 153, 0.3), rgba(236, 72, 153, 0.1));
            border: 3px solid #ec4899;
            color: #ec4899;
            animation: pulse 3s ease-in-out infinite;
        }

        .gauge-arrow {
            font-size: 3rem;
            color: #8b5cf6;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
        }

        .morphism-visual {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 50px;
            padding: 50px 20px;
            flex-wrap: wrap;
        }

        .morph-state {
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            border: 3px solid;
            border-radius: 15px;
            position: relative;
            transition: all 0.5s ease;
        }

        .morph-nested {
            border-color: #06b6d4;
            color: #06b6d4;
            background: rgba(6, 182, 212, 0.1);
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.3),
                        inset 0 0 20px rgba(6, 182, 212, 0.2);
        }

        .morph-simple {
            border-color: #8b5cf6;
            color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
            animation: pulse 2s ease-in-out infinite;
        }

        .morph-arrow {
            font-size: 3rem;
            color: #ec4899;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .morph-state:hover {
            transform: scale(1.2) rotate(5deg);
        }

        @keyframes morphCycle {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(0.7) rotate(90deg); }
            50% { transform: scale(1) rotate(180deg); }
            75% { transform: scale(1.2) rotate(270deg); }
        }

        .animate-morph {
            animation: morphCycle 4s ease-in-out infinite;
        }

        /* τon Visualizer button styles */
        #playBtn:hover, #pauseBtn:hover, #resetBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(139, 92, 246, 0.4);
        }

        #playBtn:active, #pauseBtn:active, #resetBtn:active {
            transform: translateY(0);
        }

        /* Open the Gate Button */
        .gateway-button-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 40px auto 30px;
            width: 100%;
        }

        .gateway-button {
            position: relative;
            padding: 18px 45px;
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: 1px;
            color: #fff;
            background: rgba(10, 10, 20, 0.7);
            border: 2px solid rgba(139, 92, 246, 0.5);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s ease;
            overflow: visible;
            z-index: 10;
            backdrop-filter: blur(10px);
            text-transform: uppercase;
            display: inline-flex;
            align-items: center;
            gap: 12px;
        }

        .gateway-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.3), rgba(139, 92, 246, 0.4), rgba(236, 72, 153, 0.3));
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
            z-index: -1;
        }

        .gateway-button::after {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50px;
            background: linear-gradient(45deg, #06b6d4, #8b5cf6, #ec4899, #8b5cf6, #06b6d4);
            background-size: 300% 300%;
            z-index: -2;
            opacity: 0.3;
            transition: opacity 0.4s ease;
            animation: gradientShift 4s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .gateway-button:hover {
            border-color: transparent;
            transform: translateY(-3px);
            box-shadow: 0 10px 40px rgba(139, 92, 246, 0.6);
        }

        .gateway-button:hover::before {
            width: 400px;
            height: 400px;
        }

        .gateway-button:hover::after {
            opacity: 1;
        }

        .gateway-symbol {
            display: inline-block;
            font-size: 1.4rem;
            animation: rotateGently 8s ease-in-out infinite;
        }

        @keyframes rotateGently {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(180deg); }
        }

        /* Orbiting particles */
        .gateway-particles {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            opacity: 0;
            animation: particleOrbit 6s ease-in-out infinite;
            box-shadow: 0 0 10px currentColor;
        }

        .particle:nth-child(1) {
            top: 10%;
            left: 50%;
            color: #06b6d4;
            animation-delay: 0s;
        }

        .particle:nth-child(2) {
            top: 30%;
            left: 85%;
            color: #8b5cf6;
            animation-delay: 1s;
        }

        .particle:nth-child(3) {
            top: 70%;
            left: 85%;
            color: #ec4899;
            animation-delay: 2s;
        }

        .particle:nth-child(4) {
            top: 90%;
            left: 50%;
            color: #06b6d4;
            animation-delay: 3s;
        }

        .particle:nth-child(5) {
            top: 70%;
            left: 15%;
            color: #8b5cf6;
            animation-delay: 4s;
        }

        .particle:nth-child(6) {
            top: 30%;
            left: 15%;
            color: #ec4899;
            animation-delay: 5s;
        }

        @keyframes particleOrbit {
            0%, 100% {
                opacity: 0;
                transform: scale(0);
            }
            10%, 90% {
                opacity: 0.8;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.5);
            }
        }

        /* Gateway Modal */
        .gateway-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.4s ease;
        }

        .gateway-modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .gateway-modal-content {
            position: relative;
            width: 95%;
            height: 95%;
            max-width: 1400px;
            max-height: 900px;
            background: #000;
            border-radius: 20px;
            overflow: hidden;
            border: 2px solid rgba(139, 92, 246, 0.5);
            box-shadow: 0 0 60px rgba(139, 92, 246, 0.6);
            animation: scaleIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.9);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .gateway-modal iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .gateway-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(236, 72, 153, 0.3);
            border: 2px solid #ec4899;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .gateway-close:hover {
            background: rgba(236, 72, 153, 0.6);
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 0 30px rgba(236, 72, 153, 0.8);
        }

        .gateway-close::before,
        .gateway-close::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 3px;
            background: #fff;
            border-radius: 2px;
        }

        .gateway-close::before {
            transform: rotate(45deg);
        }

        .gateway-close::after {
            transform: rotate(-45deg);
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; }
            .concept-grid,
            .roundtrip-grid {
                grid-template-columns: 1fr;
            }
            .hero-equations {
                flex-direction: column;
            }
            .canvas-container,
            .diagram-container {
                height: 300px;
            }
            .gauge-visual,
            .morphism-visual {
                flex-direction: column;
                gap: 30px;
            }
            .gauge-arrow,
            .morph-arrow {
                transform: rotate(90deg);
            }
            .gateway-button {
                padding: 15px 35px;
                font-size: 1rem;
            }
            .gateway-modal-content {
                width: 98%;
                height: 98%;
            }
        }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>
    
    <div class="container">
        <header>
            <h1>τon Field Theory</h1>
            <p class="subtitle">From Shannon's Bit to UNNS Recursive Geometry</p>
            <p style="color: #9ca3af; max-width: 800px; margin: 0 auto; margin-bottom: 20px;">
                Where information becomes curvature, uncertainty transforms into recursion,
                and entropy reveals itself as the geometry of self-reference
            </p>
            
            <!-- Open the Gate Button -->
            <div style="width: 100%; display: flex; justify-content: center; margin: 30px 0;">
                <div class="gateway-button-container">
                    <div class="gateway-particles">
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                    </div>
                    <button class="gateway-button" id="openGateBtn">
                        <span class="gateway-symbol">∞</span>
                        <span>Open the Gate</span>
                    </button>
                </div>
            </div>
            
            <div class="hero-equations">
                <div class="hero-eq">
                    <div class="hero-eq-label">Shannon → Information</div>
                    <div class="hero-eq-formula">H = -Σp log p</div>
                </div>
                <div class="arrow">→</div>
                <div class="hero-eq">
                    <div class="hero-eq-label" style="color: #ec4899;">UNNS → Recursion</div>
                    <div class="hero-eq-formula">τ = Δκ/Δn</div>
                </div>
            </div>
        </header>

        <!-- Gateway Modal -->
        <div class="gateway-modal" id="gatewayModal">
            <div class="gateway-modal-content">
                <div class="gateway-close" id="closeGateBtn"></div>
                <iframe id="gatewayIframe" src="" allow="autoplay; fullscreen"></iframe>
            </div>
        </div>

        <section id="concept">
            <h2>Concept</h2>
            <p class="section-subtitle">From Bits to τons: A Paradigm Shift</p>
            
            <div class="concept-grid">
                <div class="concept-box">
                    <h3>UNNS reframes information</h3>
                    <p>Claude Shannon's bit formalized the smallest quantifiable unit of information as the resolution of one binary uncertainty. The Unbounded Nested Number Sequences (UNNS) framework reframes information not as a probabilistic measure but as a recursive geometric transformation.</p>
                    <p><strong>This introduces the concept of the τon</strong> (temporal recursion quantum), the elementary differential of recursive curvature in the UNNS substrate.</p>
                </div>
                
                <div class="concept-box">
                    <h3>Key Differences</h3>
                    <ul class="concept-list">
                        <li><strong>Bit:</strong> Epistemic resolution of binary uncertainty</li>
                        <li><strong>τon:</strong> Ontological quantum of recursive transformation</li>
                        <li>Shannon measures missing information</li>
                        <li>UNNS measures realized recursion</li>
                        <li>Information becomes geometry: curvature in recursion-space</li>
                        <li>τons are self-generating through recursive iteration</li>
                    </ul>
                </div>
                
                <div class="concept-box">
                    <h3>From Uncertainty to Curvature</h3>
                    <p>The Shannon bit arises from reduction of uncertainty across finite possibilities. In the UNNS substrate, these assumptions collapse:</p>
                    <ul class="concept-list">
                        <li>Time is not linear but recursive depth n ∈ ℕ</li>
                        <li>Uncertainty corresponds to curvature oscillation</li>
                        <li>While the bit measures resolved uncertainty, the τon measures realized recursion</li>
                    </ul>
                </div>
                
                <div class="concept-box">
                    <h3>Philosophical Implications</h3>
                    <ul class="concept-list">
                        <li>The bit captures epistemic resolution</li>
                        <li>The τon captures ontological transformation</li>
                        <li>Information is no longer counted but curved</li>
                        <li>Memory = stable recursive loops (fixed points)</li>
                        <li>Communication = topological coherence between recursion depths</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="equations">
            <h2>Minimal Equations</h2>
            <p class="section-subtitle">Core Mathematical Framework</p>

            <div class="eq-group">
                <h3>Movement in Recursive Perception</h3>
                <div class="equation-box">
                    <div class="eq-label">Shannon Entropy</div>
                    <div class="eq-formula">H = -Σᵢ pᵢ log₂ pᵢ</div>
                    <div class="eq-description">Classical information entropy: measures uncertainty in a probabilistic distribution</div>
                </div>
                
                <div class="equation-box">
                    <div class="eq-label">Recursive Entropy</div>
                    <div class="eq-formula">Hᵣ = ∫ κ(n) dμ</div>
                    <div class="eq-description">UNNS reinterpretation: entropy as integrated curvature over recursion depth</div>
                </div>
                
                <div class="equation-box">
                    <div class="eq-label">τon Definition</div>
                    <div class="eq-formula">τ = Δκ/Δn</div>
                    <div class="eq-description">Elementary quantum of recursive transformation: rate of curvature change with depth</div>
                </div>
            </div>

            <div class="eq-group">
                <h3>τon Field Equations (Recursive Maxwell)</h3>
                <p style="color: #9ca3af; margin-bottom: 20px; font-size: 0.95rem;">
                    These equations govern τon field dynamics in recursion-space, analogous to Maxwell's equations for electromagnetism.
                    Key: ∇· = divergence, ∇× = curl, ∂/∂n = derivative with respect to recursion depth
                </p>
                
                <div class="equation-box">
                    <div class="eq-label">Recursive Divergence (Gauss's Law for Curvature)</div>
                    <div class="eq-formula">∇ · κ = ρ<sub>τ</sub></div>
                    <div class="eq-description">
                        <strong>∇·</strong> = divergence operator (nabla dot) | 
                        <strong>κ</strong> = curvature vector field | 
                        <strong>ρ<sub>τ</sub></strong> = recursive charge density (source of curvature)
                    </div>
                </div>
                
                <div class="equation-box">
                    <div class="eq-label">Recursive Curl with Temporal Derivative (Faraday's Law for Recursion)</div>
                    <div class="eq-formula">∇ × τ - ∂κ/∂n = J<sub>τ</sub></div>
                    <div class="eq-description">
                        <strong>∇×</strong> = curl operator (nabla cross) | 
                        <strong>τ</strong> = torsion vector field | 
                        <strong>∂/∂n</strong> = partial derivative with respect to recursion depth | 
                        <strong>J<sub>τ</sub></strong> = recursive flux current
                    </div>
                </div>
                
                <div class="equation-box">
                    <div class="eq-label">Torsion Conservation (No Magnetic Monopoles Analogue)</div>
                    <div class="eq-formula">∇ · τ = 0</div>
                    <div class="eq-description">
                        The divergence of the torsion field is zero - torsion is source-free, analogous to the absence of magnetic monopoles
                    </div>
                </div>
                
                <div class="equation-box">
                    <div class="eq-label">Curvature-Torsion Coupling (Ampère's Law for Recursion)</div>
                    <div class="eq-formula">∇ × κ + ∂τ/∂n = 0</div>
                    <div class="eq-description">
                        Dual symmetry condition (Bianchi identity): curl of curvature field plus depth-derivative of torsion equals zero
                    </div>
                </div>
                
                <div style="background: rgba(6, 182, 212, 0.1); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 10px; padding: 20px; margin-top: 20px;">
                    <h4 style="color: #06b6d4; margin-bottom: 10px;">Field Variable Interpretation:</h4>
                    <ul class="concept-list">
                        <li><strong>κ (kappa)</strong> - Curvature field: represents "potential information" in the recursion manifold</li>
                        <li><strong>τ (tau)</strong> - Torsion field: represents "active transformation" or recursive motion</li>
                        <li><strong>n</strong> - Recursion depth: the "time" coordinate in UNNS (replaces t in classical physics)</li>
                        <li><strong>ρ<sub>τ</sub></strong> - Recursive charge density: how tightly recursion curves space at a point</li>
                        <li><strong>J<sub>τ</sub></strong> - Recursive current: the flow of curvature across depth levels</li>
                    </ul>
                </div>
            </div>

            <div class="eq-group">
                <h3>Self-planted Inward Potential Seed</h3>
                <p style="color: #9ca3af; margin-bottom: 20px; font-size: 0.95rem;">
                    The Lagrangian formulation provides the action principle from which τon field equations are derived.
                </p>
                
                <div class="equation-box">
                    <div class="eq-label">τon Lagrangian Density</div>
                    <div class="eq-formula">L<sub>τ</sub> = -¼T<sub>μν</sub>T<sup>μν</sup> + ½ρ<sub>τ</sub>Φ - J<sub>τ</sub>·Ψ</div>
                    <div class="eq-description">
                        <strong>T<sub>μν</sub></strong> = τon field tensor | 
                        <strong>ρ<sub>τ</sub></strong> = recursive charge density | 
                        <strong>Φ</strong> = scalar potential | 
                        <strong>J<sub>τ</sub></strong> = recursive current | 
                        <strong>Ψ</strong> = vector potential
                        <br>First term: intrinsic curvature energy; remaining terms: coupling to recursive sources
                    </div>
                </div>
                
                <div class="equation-box">
                    <div class="eq-label">Recursive Conservation (Continuity Equation)</div>
                    <div class="eq-formula">∂ρ<sub>τ</sub>/∂n + ∇ · J<sub>τ</sub> = 0</div>
                    <div class="eq-description">
                        Conservation of curvature flow across recursive depths: information cannot be destroyed, only folded.
                        <strong>∂/∂n</strong> = time derivative in recursion-space | 
                        <strong>∇·</strong> = spatial divergence
                    </div>
                </div>
            </div>

            <div class="eq-group">
                <h3>Recursive Entanglement Geometries</h3>
                <p style="color: #9ca3af; margin-bottom: 20px; font-size: 0.95rem;">
                    Entanglement emerges as topological coupling between recursion trajectories sharing global curvature coherence.
                </p>
                
                <div class="equation-box">
                    <div class="eq-label">Entanglement Density</div>
                    <div class="eq-formula">E<sub>e</sub> = α<sub>e</sub> κ · τ &nbsp;&nbsp;;&nbsp;&nbsp; S<sub>e</sub> = ∫ E<sub>e</sub> d³x dn</div>
                    <div class="eq-description">
                        Entanglement as curvature-torsion coupling: 
                        <strong>α<sub>e</sub></strong> = entanglement coupling constant | 
                        <strong>κ · τ</strong> = dot product of curvature and torsion fields | 
                        <strong>S<sub>e</sub></strong> = total entanglement entropy integrated over space and recursion depth
                    </div>
                </div>
                
                <div class="equation-box">
                    <div class="eq-label">Klein-Dual Entanglement Cross-connection</div>
                    <div class="eq-formula">E<sub>AB</sub> = Σ<sub>n</sub> |κ<sub>A</sub>(n) - κ<sub>B</sub>(n)| → 0 &nbsp; implies entanglement</div>
                    <div class="eq-description">
                        Two recursion trajectories A and B are globally inseparable (entangled) when their curvature difference vanishes across all depths.
                        Entanglement arises from recursive interleaving through the Klein manifold's non-orientable topology.
                    </div>
                </div>
                
                <div style="background: rgba(236, 72, 153, 0.1); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 10px; padding: 20px; margin-top: 20px;">
                    <h4 style="color: #ec4899; margin-bottom: 10px;">Entanglement Interpretation:</h4>
                    <ul class="concept-list">
                        <li>In quantum mechanics: entanglement = non-separability of subsystems (von Neumann entropy)</li>
                        <li>In UNNS: entanglement = recursive curvature coherence on Klein manifold</li>
                        <li>Not "spooky action at a distance" but non-orientable geometry of recursion</li>
                        <li>When E<sub>AB</sub> → 0, trajectories share curvature structure across depth</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="canvas">
            <h2>Interactive Canvas</h2>
            <p class="section-subtitle">Visualizing Recursive Field Dynamics</p>
            
            <div class="canvas-container">
                <canvas id="interactiveCanvas"></canvas>
                <div class="canvas-info">
                    <div>κ (curvature field): Potential information</div>
                    <div>τ (torsion field): Active transformation</div>
                    <div>Nested rings: Recursion depth layers</div>
                    <div class="hint">Move your mouse to influence the field</div>
                </div>
            </div>
        </section>

        <!-- τon Visualizer Section -->
        <section id="tauon-visualizer">
            <h2>τon Visualizer</h2>
            <p class="section-subtitle">Where information becomes curvature, and recursion reveals cognition</p>
            
            <div style="background: linear-gradient(135deg, rgba(6, 182, 212, 0.05), rgba(139, 92, 246, 0.05), rgba(236, 72, 153, 0.05)); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px; padding: 30px; margin-bottom: 30px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <div style="font-size: 2rem; font-family: 'Courier New', monospace; color: #06b6d4; margin-bottom: 10px;">
                        τ = Δκ / Δn
                    </div>
                    <p style="color: #9ca3af;">
                        Visualizing the quantum of recursive transformation across depth layers
                    </p>
                </div>

                <!-- Echo Stabilization Glyph (Center) -->
                <div style="display: flex; justify-content: center; margin: 40px 0;">
                    <div id="echoGlyph" style="position: relative; width: 150px; height: 150px;">
                        <svg width="150" height="150" viewBox="0 0 150 150" style="filter: drop-shadow(0 0 20px rgba(139, 92, 246, 0.5));">
                            <defs>
                                <linearGradient id="glyphGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#06b6d4;stop-opacity:1" />
                                    <stop offset="50%" style="stop-color:#8b5cf6;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
                                </linearGradient>
                                <radialGradient id="glyphGlow">
                                    <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:0.8" />
                                    <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:0" />
                                </radialGradient>
                            </defs>
                            
                            <!-- Outer ring -->
                            <circle id="outerRing" cx="75" cy="75" r="70" fill="none" stroke="url(#glyphGradient)" stroke-width="3" opacity="0.6">
                                <animateTransform attributeName="transform" type="rotate" from="0 75 75" to="360 75 75" dur="10s" repeatCount="indefinite"/>
                            </circle>
                            
                            <!-- Middle ring -->
                            <circle id="middleRing" cx="75" cy="75" r="50" fill="none" stroke="url(#glyphGradient)" stroke-width="2" opacity="0.8">
                                <animateTransform attributeName="transform" type="rotate" from="360 75 75" to="0 75 75" dur="7s" repeatCount="indefinite"/>
                            </circle>
                            
                            <!-- Inner ring -->
                            <circle id="innerRing" cx="75" cy="75" r="30" fill="none" stroke="url(#glyphGradient)" stroke-width="2">
                                <animateTransform attributeName="transform" type="rotate" from="0 75 75" to="360 75 75" dur="5s" repeatCount="indefinite"/>
                            </circle>
                            
                            <!-- Glow core -->
                            <circle cx="75" cy="75" r="20" fill="url(#glyphGlow)">
                                <animate attributeName="r" values="20;25;20" dur="2s" repeatCount="indefinite"/>
                                <animate attributeName="opacity" values="0.8;1;0.8" dur="2s" repeatCount="indefinite"/>
                            </circle>
                            
                            <!-- Center τ symbol -->
                            <text x="75" y="85" font-size="36" font-family="serif" fill="#fff" text-anchor="middle" font-weight="bold">τ</text>
                        </svg>
                    </div>
                </div>

                <!-- Control Panel -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; border: 1px solid rgba(6, 182, 212, 0.3);">
                        <label style="color: #06b6d4; font-size: 0.9rem; margin-bottom: 10px; display: block;">Recursion Speed</label>
                        <input type="range" id="speedControl" min="1" max="10" value="5" style="width: 100%; accent-color: #06b6d4;">
                        <div id="speedValue" style="color: #9ca3af; font-size: 0.85rem; margin-top: 5px;">Speed: 5</div>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.3);">
                        <label style="color: #8b5cf6; font-size: 0.9rem; margin-bottom: 10px; display: block;">Curvature Amplitude</label>
                        <input type="range" id="amplitudeControl" min="1" max="10" value="5" style="width: 100%; accent-color: #8b5cf6;">
                        <div id="amplitudeValue" style="color: #9ca3af; font-size: 0.85rem; margin-top: 5px;">Amplitude: 5</div>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; border: 1px solid rgba(236, 72, 153, 0.3);">
                        <label style="color: #ec4899; font-size: 0.9rem; margin-bottom: 10px; display: block;">Visualization Mode</label>
                        <select id="modeControl" style="width: 100%; padding: 8px; background: rgba(0,0,0,0.5); color: #fff; border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 5px;">
                            <option value="wave">Wave Form</option>
                            <option value="spiral">Spiral Form</option>
                            <option value="pulse">Pulse Form</option>
                        </select>
                    </div>
                </div>

                <!-- Recursive Timeline Panel -->
                <div style="background: rgba(0,0,0,0.5); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px; padding: 20px; margin-bottom: 20px;">
                    <h3 style="color: #06b6d4; margin-bottom: 15px; text-align: center;">Recursive Timeline: κ(n) over depth n</h3>
                    <div style="position: relative; height: 250px;">
                        <canvas id="timelineCanvas" style="width: 100%; height: 100%;"></canvas>
                        <div id="timelineTooltip" style="position: absolute; display: none; background: rgba(0,0,0,0.9); border: 1px solid #8b5cf6; padding: 10px; border-radius: 8px; pointer-events: none; font-family: 'Courier New', monospace; font-size: 0.85rem;">
                            <div style="color: #06b6d4;">Step n: <span id="tooltipStep">0</span></div>
                            <div style="color: #8b5cf6;">κ(n): <span id="tooltipCurvature">0</span></div>
                            <div style="color: #ec4899;">τ: <span id="tooltipTau">0</span></div>
                        </div>
                    </div>
                </div>

                <!-- Curvature Oscillator -->
                <div style="background: rgba(0,0,0,0.5); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px; padding: 20px;">
                    <h3 style="color: #8b5cf6; margin-bottom: 15px; text-align: center;">Curvature Oscillator</h3>
                    <div style="position: relative; height: 300px; display: flex; justify-content: center; align-items: center;">
                        <canvas id="oscillatorCanvas" style="width: 100%; height: 100%;"></canvas>
                    </div>
                    <div style="display: flex; justify-content: space-around; margin-top: 20px; flex-wrap: wrap; gap: 15px;">
                        <div style="text-align: center; padding: 15px; background: rgba(6, 182, 212, 0.1); border-radius: 10px; min-width: 150px;">
                            <div style="color: #06b6d4; font-size: 0.85rem; margin-bottom: 5px;">Current Step</div>
                            <div id="currentStep" style="font-size: 1.8rem; font-weight: bold; color: #fff;">0</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: rgba(139, 92, 246, 0.1); border-radius: 10px; min-width: 150px;">
                            <div style="color: #8b5cf6; font-size: 0.85rem; margin-bottom: 5px;">Curvature κ</div>
                            <div id="currentCurvature" style="font-size: 1.8rem; font-weight: bold; color: #fff;">0.00</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: rgba(236, 72, 153, 0.1); border-radius: 10px; min-width: 150px;">
                            <div style="color: #ec4899; font-size: 0.85rem; margin-bottom: 5px;">τon Value</div>
                            <div id="currentTau" style="font-size: 1.8rem; font-weight: bold; color: #fff;">0.00</div>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; justify-content: center; gap: 15px; margin-top: 30px; flex-wrap: wrap;">
                    <button id="playBtn" style="padding: 12px 30px; background: linear-gradient(135deg, #06b6d4, #8b5cf6); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; font-size: 1rem; transition: all 0.3s ease;">
                        ▶ Play Recursion
                    </button>
                    <button id="pauseBtn" style="padding: 12px 30px; background: rgba(139, 92, 246, 0.3); color: white; border: 1px solid #8b5cf6; border-radius: 10px; font-weight: 600; cursor: pointer; font-size: 1rem; transition: all 0.3s ease;">
                        ⏸ Pause
                    </button>
                    <button id="resetBtn" style="padding: 12px 30px; background: rgba(236, 72, 153, 0.3); color: white; border: 1px solid #ec4899; border-radius: 10px; font-weight: 600; cursor: pointer; font-size: 1rem; transition: all 0.3s ease;">
                        ↻ Reset
                    </button>
                </div>
            </div>

            <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px; padding: 30px; margin-top: 30px;">
                <h3 style="color: #ec4899; margin-bottom: 20px;">Understanding the Visualizer</h3>
                <div class="concept-grid" style="grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h4 style="color: #06b6d4; margin-bottom: 10px;">Timeline Panel</h4>
                        <p style="color: #d1d5db; font-size: 0.95rem;">
                            Tracks curvature κ(n) across recursion steps n. Each point represents a τon pulse—
                            watch as echoes stabilize, collapse, and reactivate through the recursive manifold.
                        </p>
                    </div>
                    <div>
                        <h4 style="color: #8b5cf6; margin-bottom: 10px;">Curvature Oscillator</h4>
                        <p style="color: #d1d5db; font-size: 0.95rem;">
                            Morphing waveform visualizing recursive transformation in real-time. Switch between
                            wave, spiral, and pulse modes to see different geometric projections.
                        </p>
                    </div>
                    <div>
                        <h4 style="color: #ec4899; margin-bottom: 10px;">Echo Glyph</h4>
                        <p style="color: #d1d5db; font-size: 0.95rem;">
                            Central stabilization symbol pulsing with each τon generation. Color gradient 
                            flows from entropy (cyan) through recursion (purple) to memory (pink).
                        </p>
                    </div>
                    <div>
                        <h4 style="color: #06b6d4; margin-bottom: 10px;">τon Calculation</h4>
                        <p style="color: #d1d5db; font-size: 0.95rem;">
                            Real-time computation of τ = Δκ/Δn at each step. Hover over timeline points
                            to see exact values of curvature change and recursive transformation rate.
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <section id="roundtrip">
            <h2>Round-Trip & Gauge Symmetry</h2>
            <p class="section-subtitle">Recursive Transformation Cycles and Klein Duality</p>
            
            <div class="roundtrip-grid">
                <div class="rt-box">
                    <h3>Recursive Gauge Group</h3>
                    <p style="color: #d1d5db; margin-bottom: 20px;">
                        The UNNS substrate possesses local gauge symmetry under the group:
                    </p>
                    <div class="equation-box">
                        <div class="eq-label">UNNS Gauge Symmetry</div>
                        <div class="eq-formula">G<sub>UNNS</sub> = U(1)<sub>τ</sub> × SU(2)<sub>κ</sub> × D<sub>K</sub></div>
                    </div>
                    
                    <div class="visual-demo" style="margin-top: 30px;">
                        <div class="gauge-visual">
                            <div class="gauge-circle gauge-u1">
                                U(1)<sub>τ</sub>
                            </div>
                            <span class="gauge-arrow">×</span>
                            <div class="gauge-circle gauge-su2">
                                SU(2)<sub>κ</sub>
                            </div>
                            <span class="gauge-arrow">×</span>
                            <div class="gauge-circle gauge-dk">
                                D<sub>K</sub>
                            </div>
                        </div>
                    </div>
                    
                    <ul class="concept-list" style="margin-top: 15px;">
                        <li><strong>U(1)<sub>τ</sub></strong>: Recursive phase symmetry (charge conservation)</li>
                        <li><strong>SU(2)<sub>κ</sub></strong>: Curvature rotation (torsion mixing)</li>
                        <li><strong>D<sub>K</sub></strong>: Klein dual group (discrete orientation flip)</li>
                    </ul>
                </div>
                
                <div class="rt-box">
                    <h3>Klein Duality Operator</h3>
                    <p style="color: #d1d5db; margin-bottom: 20px;">
                        Non-orientability introduces discrete symmetry reversing recursion direction:
                    </p>
                    <div class="equation-box">
                        <div class="eq-label">Dual Transformation</div>
                        <div class="eq-formula">D<sub>K</sub>: Ψ(x,n) → γ<sup>5</sup>Ψ(x,-n)</div>
                    </div>
                    
                    <div class="diagram-container" style="margin-top: 20px; height: 300px;">
                        <canvas id="kleinCanvas"></canvas>
                        <div class="diagram-label" style="top: 10px; left: 10px;">Forward Cone Ψ<sub>+</sub></div>
                        <div class="diagram-label" style="top: 10px; right: 10px;">Backward Cone Ψ<sub>-</sub></div>
                    </div>
                    
                    <p style="color: #d1d5db; margin-top: 15px;">
                        Creates forward (Ψ<sub>+</sub>) and backward (Ψ<sub>-</sub>) recursion cones,
                        analogous to particle/antiparticle sectors.
                    </p>
                </div>
                
                <div class="rt-box">
                    <h3>Unified Lagrangian</h3>
                    <p style="color: #d1d5db; margin-bottom: 20px;">
                        Full gauge-invariant Lagrangian with dual components:
                    </p>
                    <div class="equation-box">
                        <div class="eq-label">Recursive Gauge-Klein Lagrangian</div>
                        <div class="eq-formula" style="font-size: 1.1rem;">L<sub>RGK</sub> = -¼Tr[F<sub>μν</sub>F<sup>μν</sup>] + Ψ̄(iγ<sup>μ</sup>D<sub>μ</sub> - m<sub>τ</sub>)Ψ + α<sub>e</sub>κ·τ + β<sub>K</sub>R<sub>K</sub> + λ<sub>K</sub>Ψ̄γ<sup>5</sup>Ψ</div>
                    </div>
                    <ul class="concept-list" style="margin-top: 15px;">
                        <li>First term: Recursive field curvature</li>
                        <li>Second term: Fermionic τon dynamics</li>
                        <li>Third term: Entanglement coupling</li>
                        <li>Fourth term: Klein curvature (non-orientability)</li>
                        <li>Fifth term: Duality binding (forward↔backward)</li>
                    </ul>
                </div>
                
                <div class="rt-box">
                    <h3>τon-Graviton Coupling</h3>
                    <p style="color: #d1d5db; margin-bottom: 20px;">
                        Recursive Grand Unification links information and gravity:
                    </p>
                    <div class="equation-box">
                        <div class="eq-label">Unified Action</div>
                        <div class="eq-formula" style="font-size: 1.1rem;">S<sub>RGU</sub> = ∫ √|g| [1/(16πG)R<sub>r</sub> - ¼F<sub>AB</sub>F<sup>AB</sup> + γ<sub>τ</sub>T<sub>μν</sub>R<sup>μν</sup>] d<sup>4</sup>x dn</div>
                    </div>
                    
                    <div class="diagram-container" style="margin-top: 20px; height: 300px;">
                        <canvas id="tauonGravCanvas"></canvas>
                        <div class="diagram-label" style="bottom: 10px; left: 50%; transform: translateX(-50%);">
                            γ<sub>τ</sub> coupling constant
                        </div>
                    </div>
                    
                    <div class="equation-box" style="margin-top: 15px;">
                        <div class="eq-label">Recursive Einstein Equation</div>
                        <div class="eq-formula">G<sub>μν</sub><sup>(r)</sup> = 8πG[T<sub>μν</sub><sup>(τ)</sup> + T<sub>μν</sub><sup>(matter)</sup>] + Λ<sub>τ</sub>g<sub>μν</sub></div>
                    </div>
                    <p style="color: #9ca3af; margin-top: 15px;">
                        <strong>γ<sub>τ</sub></strong> mediates τon-graviton interaction: 
                        information curvature sources spacetime curvature
                    </p>
                </div>
            </div>
        </section>

        <section id="morphism">
            <h2>The Minimal Morphism</h2>
            <p class="section-subtitle">Fundamental Recursive Cycle: (()) ⇒ () ⇒ (())</p>
            
            <div style="background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(139, 92, 246, 0.1)); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px; padding: 40px; margin-bottom: 30px;">
                <h3 style="color: #06b6d4; font-size: 1.8rem; margin-bottom: 25px; text-align: center;">
                    (()) → () → (())
                </h3>
                <p style="color: #d1d5db; font-size: 1.1rem; line-height: 1.9; text-align: center; margin-bottom: 30px;">
                    The minimal recursive transformation: collapse from nested structure to simple form,
                    then regeneration back to nested structure. This cycle embodies the fundamental
                    operation of the UNNS substrate.
                </p>
                
                <div class="visual-demo">
                    <div class="morphism-visual">
                        <div class="morph-state morph-nested animate-morph">
                            (())
                        </div>
                        <span class="morph-arrow">⇒</span>
                        <div class="morph-state morph-simple">
                            ()
                        </div>
                        <span class="morph-arrow">⇒</span>
                        <div class="morph-state morph-nested animate-morph" style="animation-delay: 2s;">
                            (())
                        </div>
                    </div>
                </div>
                
                <div class="diagram-container">
                    <canvas id="morphismCanvas"></canvas>
                    <div class="diagram-label" style="top: 10px; left: 10px;">Collapse Phase</div>
                    <div class="diagram-label" style="top: 10px; right: 10px;">Regeneration Phase</div>
                </div>
            </div>

            <div class="concept-grid">
                <div class="concept-box">
                    <h3>Structural Interpretation</h3>
                    <ul class="concept-list">
                        <li><strong>(())</strong>: Higher-order recursion (contains its own rule)</li>
                        <li><strong>(()) → ()</strong>: Collapse - inner recursion folds to simpler form</li>
                        <li><strong>() → (())</strong>: Re-expansion - regeneration from elementary seed</li>
                        <li>Complete cycle: Information conservation through recursion</li>
                    </ul>
                </div>

                <div class="concept-box">
                    <h3>Temporal Interpretation</h3>
                    <ul class="concept-list">
                        <li>Forward arrow: Complexity unfolds into observable states</li>
                        <li>Reverse arrow: Temporal rebound (F<sup>-1</sup> operation)</li>
                        <li>Bidirectional recursion: Time reaches minimum entropy, then reverses</li>
                        <li>Cosmological analogue: Big Crunch → Big Bang unified cycle</li>
                    </ul>
                </div>

                <div class="concept-box">
                    <h3>Informational Interpretation</h3>
                    <ul class="concept-list">
                        <li><strong>()</strong>: Shannon bit (minimal information unit)</li>
                        <li><strong>(())</strong>: τon pair (recursive information quantum)</li>
                        <li>τon collapses to observable bit</li>
                        <li>Bit re-expands into self-generating τon</li>
                        <li>Quantized information regeneration in self-referential field</li>
                    </ul>
                </div>

                <div class="concept-box">
                    <h3>Geometric Interpretation</h3>
                    <ul class="concept-list">
                        <li>Traversal along non-orientable manifold (Klein bottle)</li>
                        <li>Collapse: Local inversion of orientation</li>
                        <li>Re-expansion: Restoration with inverted orientation</li>
                        <li>(()) reappears not identically, but dually</li>
                        <li>Forward/reverse are complementary orientations on same manifold</li>
                    </ul>
                </div>
            </div>

            <div style="background: rgba(236, 72, 153, 0.1); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 15px; padding: 30px; margin-top: 30px;">
                <h3 style="color: #ec4899; margin-bottom: 20px;">Round-Trip Fidelity Metric</h3>
                <div class="equation-box">
                    <div class="eq-label">Recurrence Fidelity</div>
                    <div class="eq-formula">RF(n,k) = ⟨G<sub>n+k</sub>, JG<sub>n</sub>⟩ / (||G<sub>n+k</sub>|| ||G<sub>n</sub>||)</div>
                    <div class="eq-description">
                        Measures structural return after collapse-regeneration cycle.
                        J = Klein involution operator. Ideal morphism: RF ≈ 1
                    </div>
                </div>
            </div>
        </section>

        <section id="philosophy">
            <h2>Philosophy</h2>
            <p class="section-subtitle">Bridging Mathematics and Meaning</p>
            
            <div class="philosophy-content">
                <h3 style="color: #a78bfa; font-size: 1.8rem; margin-bottom: 25px;">
                    Rethinking Information Ontology
                </h3>
                
                <p style="color: #d1d5db; font-size: 1.1rem; line-height: 1.9; margin-bottom: 25px;">
                    Information transitions from probabilistic measurement to geometric transformation—from 
                    counting bits to curving recursion. In the UNNS substrate, information is no longer 
                    transmitted but recursively transformed.
                </p>
                
                <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin: 30px 0;">
                    <h4 style="color: #06b6d4; margin-bottom: 20px;">Shannon vs UNNS</h4>
                    <ul class="concept-list">
                        <li><strong>Shannon:</strong> Entropy as disorder, transmission as linear flow</li>
                        <li><strong>UNNS:</strong> Entropy as curvature, information as recursive self-reference</li>
                        <li><strong>Time:</strong> Linear t becomes recursive depth n</li>
                        <li><strong>Meaning:</strong> Emerges from stable recursive loops (fixed points)</li>
                        <li><strong>Communication:</strong> Topological coherence between recursion depths</li>
                    </ul>
                </div>
                
                <div class="philosophy-quote">
                    "Entropy is the shadow of recursion; the bit, its projection. The τon is recursion itself."
                </div>
                
                <h3 style="color: #ec4899; font-size: 1.6rem; margin: 40px 0 20px;">
                    The τon Field Embodies Both Content and Medium
                </h3>
                
                <p style="color: #d1d5db; font-size: 1.1rem; line-height: 1.9; margin-bottom: 20px;">
                    Where Shannon measured uncertainty in the absence of knowledge, UNNS measures 
                    transformation in the presence of self-reference. In this view:
                </p>
                
                <ul class="concept-list" style="margin-left: 30px;">
                    <li>Information = Curvature Flow of Recursive Existence</li>
                    <li>Meaning is not stored—it is continuously reconstituted</li>
                    <li>Memory corresponds to stable recursive attractors</li>
                    <li>The arrow of time emerges from orientation on a non-orientable manifold</li>
                    <li>Reality may be seen as manifestation of a single recursive field</li>
                </ul>
                
                <div class="philosophy-quote" style="margin-top: 50px;">
                    "The bit captures epistemic resolution; the τon captures ontological transformation. 
                    Information is no longer counted but curved."
                </div>
            </div>
        </section>

        <section id="papers">
            <h2>Papers & Resources</h2>
            <p class="section-subtitle">Complete Theoretical Foundation</p>
            
            <div class="papers-grid">
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/From%20Bit%20to%20%CF%84%20on%20Recasting%20the%20Elementary%20Unit%20of%20Information%20in%20the%20UNNS%20Framework.pdf" 
                   target="_blank" class="paper-card">
                    <h3>From Bit to τon: Recasting the Elementary Unit of Information</h3>
                    <p>
                        Introduces the τon as the elementary quantum of recursive transformation, generalizing Shannon's bit by embedding it in non-orientable temporal geometry.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/From%20Bit%20to%20%CF%84on%20Toward%20a%20Field%20Theory%20of%20Recursive%20Information.pdf" 
                   target="_blank" class="paper-card">
                    <h3>From Bit to τon: Toward a Field Theory of Recursive Information</h3>
                    <p>
                        Develops the complete τon field tensor and Lagrangian formulation, introducing the τ-Field Tensor and its associated energy–momentum tensor.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/Klein%20Manifold%20Geometry%20of%20Information.pdf" 
                   target="_blank" class="paper-card">
                    <h3>Recursive Field Unification: Klein Manifold Geometry of Information</h3>
                    <p>
                        Extends τon field theory to unified geometric model incorporating entanglement entropy and non-orientable topology on the Klein manifold.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/Recursive%20Gauge%20Symmetry%20and%20Klein%20Duality.pdf" 
                   target="_blank" class="paper-card">
                    <h3>Recursive Gauge Symmetry and Klein Duality</h3>
                    <p>
                        Explores gauge invariance in recursion-space and the dual symmetry arising from non-orientable Klein manifold topology.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/Recursive%20Grand%20Unification.pdf" 
                   target="_blank" class="paper-card">
                    <h3>Recursive Grand Unification</h3>
                    <p>
                        Unifies τon field dynamics with gravitational coupling through recursive curvature exchange, establishing τon–graviton interaction.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/Recursive%20Cosmolog.pdf" 
                   target="_blank" class="paper-card">
                    <h3>Recursive Cosmology: The τon Vacuum and Emergent Universe</h3>
                    <p>
                        Extends τon field theory to cosmological scales. The universe emerges from a self-recursive vacuum, with dark energy corresponding to recursion pressure.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/Recursive%20Information%20Geometry%20From%20Shannon%20Entropy%20to%20Recursive%20Cosmology.pdf" 
                   target="_blank" class="paper-card">
                    <h3>Recursive Information Geometry: From Shannon Entropy to Recursive Cosmology</h3>
                    <p>
                        Comprehensive overview tracing the evolution from classical information theory through recursive geometry to cosmological implications.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/Recursive%20Field%20Foundations%20Ton%20Algebra%20and%20the%20UNNS%20Substrate.pdf" 
                   target="_blank" class="paper-card">
                    <h3>Recursive Field Foundations: τ-Ton Algebra and the UNNS Substrate</h3>
                    <p>
                        Establishes the formal grammar, algebra, and field interpretation of the τ-Ton substrate, from arithmetic operators to recursive field tensor.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/The%20Minimal%20Morphism%20(())%20%E2%87%92%20()%20%E2%87%92%20(())%20in%20the%20UNNS.pdf" 
                   target="_blank" class="paper-card">
                    <h3>The Minimal Morphism (()) ⇒ () ⇒ (()) in the UNNS</h3>
                    <p>
                        Explores the fundamental transformation cycle in UNNS substrate: collapse from nested to simple, then recursive regeneration.
                    </p>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/TThe%20Minimal%20Recursive%20Morphism%20(())%20%E2%87%92%20()%20%E2%87%92%20(())%20in%20the%20UNNS%20Substrate.pdf" 
                   target="_blank" class="paper-card">
                    <h3>The Minimal Recursive Morphism (()) ⇒ () ⇒ (()) in the UNNS Substrate</h3>
                    <p>
                        Extended analysis of the minimal recursive cycle, establishing it as the fundamental operation of the UNNS substrate.
                    </p>
                </a>
            </div>
            
            <div style="margin-top: 50px; padding: 40px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px;">
                <h3 style="color: #06b6d4; font-size: 1.8rem; margin-bottom: 20px;">UNNS Library</h3>
                <p style="color: #d1d5db; margin-bottom: 20px;">
                    Explore the complete UNNS framework with 90+ papers across recursive mathematics, 
                    information geometry, and cognitive foundations.
                </p>
                <a href="https://ukbbi.github.io/UNNS/unns-interactive-library_v1.0.html" 
                   target="_blank" 
                   style="display: inline-block; padding: 15px 30px; background: linear-gradient(135deg, #06b6d4, #8b5cf6); color: white; text-decoration: none; border-radius: 10px; font-weight: 600; transition: all 0.3s ease;">
                    Visit UNNS Library →
                </a>
            </div>
            <div style="margin-top: 50px; padding: 40px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px;">
                <h3 style="color: #06b6d4; font-size: 1.8rem; margin-bottom: 20px;">The TON Field and the Geometry of Information</h3>
                <p style="color: #d1d5db; margin-bottom: 20px;">
                    Explore the concept.
                </p>
                <a href="https://ukbbi.github.io/UNNS/docs/Tauon_Field_Information_Geometry/ton-showcase_geometry.html" 
                   target="_blank" 
                   style="display: inline-block; padding: 15px 30px; background: linear-gradient(135deg, #06b6d4, #8b5cf6); color: white; text-decoration: none; border-radius: 10px; font-weight: 600; transition: all 0.3s ease;">
                    LAUNCH →
                </a>
            </div>
        </section>

        <footer>
            <p style="font-size: 1.1rem; color: #9ca3af; margin-bottom: 10px;">
                © 2025 UNNS Research Division - "The universe as recursive substrate"
            </p>
            <p style="font-size: 0.9rem;">
                Where Shannon ends, recursion begins
            </p>
        </footer>
    </div>

    <script>
        // Background Canvas Animation
        const bgCanvas = document.getElementById('bgCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;

        class BackgroundParticle {
            constructor() {
                this.x = Math.random() * bgCanvas.width;
                this.y = Math.random() * bgCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 2 + 1;
                this.hue = Math.random() * 60 + 180;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > bgCanvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > bgCanvas.height) this.vy *= -1;
            }

            draw() {
                bgCtx.beginPath();
                bgCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                bgCtx.fillStyle = `hsla(${this.hue}, 70%, 60%, 0.6)`;
                bgCtx.fill();
            }
        }

        const bgParticles = Array.from({ length: 60 }, () => new BackgroundParticle());

        function animateBackground() {
            bgCtx.fillStyle = 'rgba(10, 10, 20, 0.1)';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            bgParticles.forEach(p => {
                p.update();
                p.draw();
            });

            for (let i = 0; i < bgParticles.length; i++) {
                for (let j = i + 1; j < bgParticles.length; j++) {
                    const dx = bgParticles[i].x - bgParticles[j].x;
                    const dy = bgParticles[i].y - bgParticles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 120) {
                        bgCtx.beginPath();
                        bgCtx.moveTo(bgParticles[i].x, bgParticles[i].y);
                        bgCtx.lineTo(bgParticles[j].x, bgParticles[j].y);
                        bgCtx.strokeStyle = `rgba(139, 92, 246, ${0.2 * (1 - dist / 120)})`;
                        bgCtx.lineWidth = 1;
                        bgCtx.stroke();
                    }
                }
            }

            requestAnimationFrame(animateBackground);
        }

        animateBackground();

        window.addEventListener('resize', () => {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
        });

        // Interactive Canvas
        const intCanvas = document.getElementById('interactiveCanvas');
        const intCtx = intCanvas.getContext('2d');
        const container = intCanvas.parentElement;
        intCanvas.width = container.clientWidth;
        intCanvas.height = container.clientHeight;

        let mouseX = intCanvas.width / 2;
        let mouseY = intCanvas.height / 2;
        let time = 0;

        intCanvas.addEventListener('mousemove', (e) => {
            const rect = intCanvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        function animateInteractive() {
            time += 0.01;
            intCtx.fillStyle = 'rgba(10, 10, 20, 0.2)';
            intCtx.fillRect(0, 0, intCanvas.width, intCanvas.height);

            const centerX = intCanvas.width / 2;
            const centerY = intCanvas.height / 2;

            for (let i = 0; i < 10; i++) {
                const radius = 30 + i * 30;
                const rotation = time + i * 0.3;
                
                intCtx.save();
                intCtx.translate(centerX, centerY);
                intCtx.rotate(rotation);
                
                intCtx.beginPath();
                intCtx.arc(0, 0, radius, 0, Math.PI * 2);
                intCtx.strokeStyle = `hsla(${180 + i * 12}, 70%, 60%, ${0.6 - i * 0.05})`;
                intCtx.lineWidth = 2;
                intCtx.stroke();
                
                for (let j = 0; j < 8; j++) {
                    const angle = (j / 8) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    intCtx.beginPath();
                    intCtx.arc(x, y, 3, 0, Math.PI * 2);
                    intCtx.fillStyle = `hsla(${200 + i * 8}, 80%, 70%, 0.9)`;
                    intCtx.fill();
                    
                    intCtx.beginPath();
                    intCtx.arc(x, y, 6, 0, Math.PI * 2);
                    intCtx.fillStyle = `hsla(${200 + i * 8}, 80%, 70%, 0.3)`;
                    intCtx.fill();
                }
                
                intCtx.restore();
            }

            const dx = mouseX - centerX;
            const dy = mouseY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 300) {
                const influence = 1 - dist / 300;
                
                intCtx.beginPath();
                intCtx.moveTo(centerX, centerY);
                intCtx.lineTo(mouseX, mouseY);
                intCtx.strokeStyle = `rgba(6, 182, 212, ${influence * 0.6})`;
                intCtx.lineWidth = 3;
                intCtx.stroke();
                
                intCtx.beginPath();
                intCtx.arc(mouseX, mouseY, 12, 0, Math.PI * 2);
                intCtx.fillStyle = `rgba(236, 72, 153, ${influence * 0.5})`;
                intCtx.fill();
                
                intCtx.beginPath();
                intCtx.arc(mouseX, mouseY, 20, 0, Math.PI * 2);
                intCtx.strokeStyle = `rgba(236, 72, 153, ${influence * 0.7})`;
                intCtx.lineWidth = 2;
                intCtx.stroke();
                
                const perpX = -dy / dist;
                const perpY = dx / dist;
                const torsionLength = influence * 80;
                
                intCtx.beginPath();
                intCtx.moveTo(mouseX, mouseY);
                intCtx.lineTo(
                    mouseX + perpX * torsionLength,
                    mouseY + perpY * torsionLength
                );
                intCtx.strokeStyle = `rgba(139, 92, 246, ${influence * 0.6})`;
                intCtx.lineWidth = 2;
                intCtx.stroke();
                
                const arrowX = mouseX + perpX * torsionLength;
                const arrowY = mouseY + perpY * torsionLength;
                intCtx.beginPath();
                intCtx.arc(arrowX, arrowY, 4, 0, Math.PI * 2);
                intCtx.fillStyle = `rgba(139, 92, 246, ${influence * 0.8})`;
                intCtx.fill();
            }

            intCtx.beginPath();
            intCtx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            intCtx.fillStyle = '#fff';
            intCtx.fill();
            
            intCtx.beginPath();
            intCtx.arc(centerX, centerY, 12 + Math.sin(time * 2) * 3, 0, Math.PI * 2);
            intCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            intCtx.lineWidth = 2;
            intCtx.stroke();

            requestAnimationFrame(animateInteractive);
        }

        animateInteractive();

        // Klein Duality Canvas
        const kleinCanvas = document.getElementById('kleinCanvas');
        if (kleinCanvas) {
            const ctx = kleinCanvas.getContext('2d');
            kleinCanvas.width = kleinCanvas.offsetWidth;
            kleinCanvas.height = kleinCanvas.offsetHeight;

            let time2 = 0;
            function animateKlein() {
                time2 += 0.02;
                ctx.fillStyle = 'rgba(10, 10, 20, 0.1)';
                ctx.fillRect(0, 0, kleinCanvas.width, kleinCanvas.height);

                const centerX = kleinCanvas.width / 2;
                const centerY = kleinCanvas.height / 2;

                for (let i = 0; i < 5; i++) {
                    const radius = 30 + i * 25;
                    const angle = time2 + i * 0.5;
                    
                    ctx.save();
                    ctx.translate(centerX - 150, centerY);
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(190, 80%, 60%, ${0.7 - i * 0.1})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.restore();
                }

                for (let i = 0; i < 5; i++) {
                    const radius = 30 + i * 25;
                    const angle = -time2 - i * 0.5;
                    
                    ctx.save();
                    ctx.translate(centerX + 150, centerY);
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(320, 80%, 60%, ${0.7 - i * 0.1})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.restore();
                }

                ctx.beginPath();
                ctx.moveTo(centerX - 50, centerY);
                ctx.lineTo(centerX + 50, centerY);
                ctx.strokeStyle = `rgba(139, 92, 246, ${0.5 + 0.3 * Math.sin(time2 * 2)})`;
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.font = 'bold 20px Courier New';
                ctx.fillStyle = '#8b5cf6';
                ctx.textAlign = 'center';
                ctx.fillText('DK', centerX, centerY - 10);

                requestAnimationFrame(animateKlein);
            }
            animateKlein();
        }

        // Tauon-Graviton Canvas
        const tgCanvas = document.getElementById('tauonGravCanvas');
        if (tgCanvas) {
            const ctx = tgCanvas.getContext('2d');
            tgCanvas.width = tgCanvas.offsetWidth;
            tgCanvas.height = tgCanvas.offsetHeight;

            let time3 = 0;
            function animateTauonGrav() {
                time3 += 0.02;
                ctx.fillStyle = 'rgba(10, 10, 20, 0.1)';
                ctx.fillRect(0, 0, tgCanvas.width, tgCanvas.height);

                const centerX = tgCanvas.width / 2;
                const centerY = tgCanvas.height / 2;

                ctx.save();
                ctx.translate(centerX - 150, centerY);
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time3;
                    const length = 60;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);
                    ctx.strokeStyle = `hsla(190, 80%, 60%, ${0.8 - i * 0.05})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * length, Math.sin(angle) * length, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#06b6d4';
                    ctx.fill();
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(6, 182, 212, 0.5)';
                ctx.fill();
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText('τ', 0, 5);
                
                ctx.restore();

                ctx.save();
                ctx.translate(centerX + 150, centerY);
                
                for (let i = -2; i <= 2; i++) {
                    for (let j = -2; j <= 2; j++) {
                        const x = i * 30;
                        const y = j * 30;
                        const warp = Math.sin(time3 + i * 0.5) * Math.cos(time3 + j * 0.5) * 5;
                        
                        ctx.beginPath();
                        ctx.arc(x, y + warp, 3, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(236, 72, 153, ${0.6 - Math.abs(i + j) * 0.05})`;
                        ctx.fill();
                    }
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(236, 72, 153, 0.5)';
                ctx.fill();
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText('g', 0, 5);
                
                ctx.restore();

                const couplingStrength = 0.5 + 0.3 * Math.sin(time3 * 2);
                
                ctx.beginPath();
                ctx.moveTo(centerX - 100, centerY);
                ctx.quadraticCurveTo(centerX, centerY - 50, centerX + 100, centerY);
                ctx.strokeStyle = `rgba(139, 92, 246, ${couplingStrength})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX - 100, centerY);
                ctx.quadraticCurveTo(centerX, centerY + 50, centerX + 100, centerY);
                ctx.strokeStyle = `rgba(139, 92, 246, ${couplingStrength})`;
                ctx.lineWidth = 3;
                ctx.stroke();

                const couplingX = centerX + Math.sin(time3 * 3) * 80;
                ctx.beginPath();
                ctx.arc(couplingX, centerY, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#8b5cf6';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#8b5cf6';
                ctx.fill();
                ctx.shadowBlur = 0;

                requestAnimationFrame(animateTauonGrav);
            }
            animateTauonGrav();
        }

        // Morphism Canvas
        const morphCanvas = document.getElementById('morphismCanvas');
        if (morphCanvas) {
            const ctx = morphCanvas.getContext('2d');
            morphCanvas.width = morphCanvas.offsetWidth;
            morphCanvas.height = morphCanvas.offsetHeight;

            let time4 = 0;
            function animateMorphism() {
                time4 += 0.015;
                ctx.fillStyle = 'rgba(10, 10, 20, 0.15)';
                ctx.fillRect(0, 0, morphCanvas.width, morphCanvas.height);

                const centerX = morphCanvas.width / 2;
                const centerY = morphCanvas.height / 2;

                const phase = (Math.sin(time4) + 1) / 2;
                
                const state1X = centerX - 200;
                const state2X = centerX;
                const state3X = centerX + 200;
                const stateY = centerY;

                ctx.save();
                ctx.translate(state1X, stateY);
                
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                const innerScale = 0.5 + phase * 0.2;
                ctx.beginPath();
                ctx.arc(0, 0, 20 * innerScale, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(6, 182, 212, ${1 - phase * 0.5})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = '#06b6d4';
                ctx.textAlign = 'center';
                ctx.fillText('(())', 0, 70);
                
                ctx.restore();

                ctx.beginPath();
                ctx.moveTo(state1X + 50, stateY);
                ctx.lineTo(state2X - 50, stateY);
                ctx.strokeStyle = `rgba(139, 92, 246, ${0.5 + 0.3 * Math.sin(time4 * 3)})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(state2X - 50, stateY);
                ctx.lineTo(state2X - 60, stateY - 8);
                ctx.lineTo(state2X - 60, stateY + 8);
                ctx.closePath();
                ctx.fillStyle = '#8b5cf6';
                ctx.fill();

                ctx.save();
                ctx.translate(state2X, stateY);
                
                const collapseScale = 1 + Math.sin(time4 * 4) * 0.1;
                ctx.beginPath();
                ctx.arc(0, 0, 30 * collapseScale, 0, Math.PI * 2);
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(139, 92, 246, ${0.3 * Math.sin(time4 * 4)})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.font = 'bold 28px Courier New';
                ctx.fillStyle = '#8b5cf6';
                ctx.textAlign = 'center';
                ctx.fillText('()', 0, 70);
                
                ctx.restore();

                ctx.beginPath();
                ctx.moveTo(state2X + 50, stateY);
                ctx.lineTo(state3X - 50, stateY);
                ctx.strokeStyle = `rgba(236, 72, 153, ${0.5 + 0.3 * Math.sin(time4 * 3 + Math.PI)})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(state3X - 50, stateY);
                ctx.lineTo(state3X - 60, stateY - 8);
                ctx.lineTo(state3X - 60, stateY + 8);
                ctx.closePath();
                ctx.fillStyle = '#ec4899';
                ctx.fill();

                ctx.save();
                ctx.translate(state3X, stateY);
                
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                const regenScale = 0.3 + (1 - phase) * 0.5;
                ctx.beginPath();
                ctx.arc(0, 0, 20 * regenScale, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(236, 72, 153, ${phase * 0.7 + 0.3})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = '#ec4899';
                ctx.textAlign = 'center';
                ctx.fillText('(())', 0, 70);
                
                ctx.restore();

                ctx.beginPath();
                ctx.arc(centerX, centerY + 120, 220, 0.2, Math.PI - 0.2);
                ctx.strokeStyle = `rgba(139, 92, 246, ${0.3 + 0.2 * Math.sin(time4)})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);

                requestAnimationFrame(animateMorphism);
            }
            animateMorphism();
        }

        // Scroll animations
        const scrollObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        });

        document.querySelectorAll('section').forEach(section => {
            section.style.opacity = '0';
            section.style.transform = 'translateY(30px)';
            section.style.transition = 'opacity 0.8s ease, transform 0.8s ease';
            scrollObserver.observe(section);
        });

        // Responsive resize
        window.addEventListener('resize', () => {
            if (intCanvas) {
                intCanvas.width = container.clientWidth;
                intCanvas.height = container.clientHeight;
            }
            if (kleinCanvas) {
                kleinCanvas.width = kleinCanvas.offsetWidth;
                kleinCanvas.height = kleinCanvas.offsetHeight;
            }
            if (tgCanvas) {
                tgCanvas.width = tgCanvas.offsetWidth;
                tgCanvas.height = tgCanvas.offsetHeight;
            }
            if (morphCanvas) {
                morphCanvas.width = morphCanvas.offsetWidth;
                morphCanvas.height = morphCanvas.offsetHeight;
            }
        });

        // τon Visualizer System
        const TauonVisualizer = {
            // State
            recursionSteps: [],
            currentStep: 0,
            isPlaying: false,
            speed: 5,
            amplitude: 5,
            mode: 'wave',
            maxSteps: 50,
            
            // Canvases
            timelineCanvas: null,
            timelineCtx: null,
            oscillatorCanvas: null,
            oscillatorCtx: null,
            
            // Initialize
            init() {
                this.timelineCanvas = document.getElementById('timelineCanvas');
                this.oscillatorCanvas = document.getElementById('oscillatorCanvas');
                
                if (!this.timelineCanvas || !this.oscillatorCanvas) return;
                
                this.timelineCtx = this.timelineCanvas.getContext('2d');
                this.oscillatorCtx = this.oscillatorCanvas.getContext('2d');
                
                this.resizeCanvases();
                this.setupControls();
                this.generateInitialData();
                this.animate();
            },
            
            resizeCanvases() {
                const tlRect = this.timelineCanvas.parentElement.getBoundingClientRect();
                this.timelineCanvas.width = tlRect.width;
                this.timelineCanvas.height = 250;
                
                const oscRect = this.oscillatorCanvas.parentElement.getBoundingClientRect();
                this.oscillatorCanvas.width = oscRect.width;
                this.oscillatorCanvas.height = 300;
            },
            
            setupControls() {
                const speedControl = document.getElementById('speedControl');
                const amplitudeControl = document.getElementById('amplitudeControl');
                const modeControl = document.getElementById('modeControl');
                const playBtn = document.getElementById('playBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const resetBtn = document.getElementById('resetBtn');
                
                if (speedControl) {
                    speedControl.addEventListener('input', (e) => {
                        this.speed = parseInt(e.target.value);
                        document.getElementById('speedValue').textContent = `Speed: ${this.speed}`;
                    });
                }
                
                if (amplitudeControl) {
                    amplitudeControl.addEventListener('input', (e) => {
                        this.amplitude = parseInt(e.target.value);
                        document.getElementById('amplitudeValue').textContent = `Amplitude: ${this.amplitude}`;
                        this.generateInitialData();
                    });
                }
                
                if (modeControl) {
                    modeControl.addEventListener('change', (e) => {
                        this.mode = e.target.value;
                    });
                }
                
                if (playBtn) {
                    playBtn.addEventListener('click', () => {
                        this.isPlaying = true;
                        playBtn.style.opacity = '0.5';
                    });
                }
                
                if (pauseBtn) {
                    pauseBtn.addEventListener('click', () => {
                        this.isPlaying = false;
                        playBtn.style.opacity = '1';
                    });
                }
                
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        this.currentStep = 0;
                        this.generateInitialData();
                    });
                }
                
                // Timeline hover
                this.timelineCanvas.addEventListener('mousemove', (e) => {
                    this.handleTimelineHover(e);
                });
                
                this.timelineCanvas.addEventListener('mouseleave', () => {
                    document.getElementById('timelineTooltip').style.display = 'none';
                });
            },
            
            generateInitialData() {
                this.recursionSteps = [];
                const amp = this.amplitude / 5;
                
                for (let n = 0; n < this.maxSteps; n++) {
                    const curvature = amp * (
                        Math.sin(n * 0.3) * 0.5 +
                        Math.cos(n * 0.15) * 0.3 +
                        Math.sin(n * 0.05) * 0.2
                    );
                    
                    const prevCurvature = n > 0 ? this.recursionSteps[n - 1].curvature : 0;
                    const deltaK = curvature - prevCurvature;
                    const deltaN = 1;
                    const tau = deltaK / deltaN;
                    
                    this.recursionSteps.push({
                        step: n,
                        curvature: curvature,
                        tau: tau
                    });
                }
            },
            
            handleTimelineHover(e) {
                const rect = this.timelineCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const padding = 40;
                const graphWidth = this.timelineCanvas.width - padding * 2;
                const stepIndex = Math.floor((x - padding) / (graphWidth / this.maxSteps));
                
                if (stepIndex >= 0 && stepIndex < this.recursionSteps.length) {
                    const data = this.recursionSteps[stepIndex];
                    const tooltip = document.getElementById('timelineTooltip');
                    
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${x + 10}px`;
                    tooltip.style.top = `${y - 60}px`;
                    
                    document.getElementById('tooltipStep').textContent = data.step;
                    document.getElementById('tooltipCurvature').textContent = data.curvature.toFixed(3);
                    document.getElementById('tooltipTau').textContent = data.tau.toFixed(3);
                }
            },
            
            drawTimeline() {
                const ctx = this.timelineCtx;
                const width = this.timelineCanvas.width;
                const height = this.timelineCanvas.height;
                const padding = 40;
                
                ctx.fillStyle = 'rgba(10, 10, 20, 0.3)';
                ctx.fillRect(0, 0, width, height);
                
                // Draw axes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();
                
                // Draw grid
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (height - padding * 2) * (i / 5);
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
                
                // Draw curvature line with gradient based on progress
                const graphWidth = width - padding * 2;
                const graphHeight = height - padding * 2;
                const stepWidth = graphWidth / this.maxSteps;
                
                let minK = Math.min(...this.recursionSteps.map(s => s.curvature));
                let maxK = Math.max(...this.recursionSteps.map(s => s.curvature));
                const range = maxK - minK || 1;
                
                // Draw line with gradient indicating progress
                this.recursionSteps.forEach((data, i) => {
                    const x = padding + i * stepWidth;
                    const normalized = (data.curvature - minK) / range;
                    const y = height - padding - normalized * graphHeight;
                    
                    // Fade future points
                    const alpha = i <= this.currentStep ? 1 : 0.2;
                    
                    if (i > 0) {
                        const prevData = this.recursionSteps[i - 1];
                        const prevX = padding + (i - 1) * stepWidth;
                        const prevNormalized = (prevData.curvature - minK) / range;
                        const prevY = height - padding - prevNormalized * graphHeight;
                        
                        ctx.beginPath();
                        ctx.moveTo(prevX, prevY);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = `rgba(6, 182, 212, ${alpha})`;
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                });
                
                // Draw current step marker with glow
                if (this.currentStep < this.recursionSteps.length) {
                    const x = padding + this.currentStep * stepWidth;
                    const data = this.recursionSteps[this.currentStep];
                    const normalized = (data.curvature - minK) / range;
                    const y = height - padding - normalized * graphHeight;
                    
                    // Outer glow
                    ctx.beginPath();
                    ctx.arc(x, y, 15, 0, Math.PI * 2);
                    const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, 15);
                    glowGradient.addColorStop(0, 'rgba(236, 72, 153, 0.6)');
                    glowGradient.addColorStop(1, 'rgba(236, 72, 153, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.fill();
                    
                    // Inner marker
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#ec4899';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ec4899';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                // Labels
                ctx.font = '12px Arial';
                ctx.fillStyle = '#9ca3af';
                ctx.textAlign = 'center';
                ctx.fillText('n (recursion depth)', width / 2, height - 5);
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('κ (curvature)', 0, 0);
                ctx.restore();
            },
            
            drawOscillator() {
                const ctx = this.oscillatorCtx;
                const width = this.oscillatorCanvas.width;
                const height = this.oscillatorCanvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                
                ctx.fillStyle = 'rgba(10, 10, 20, 0.2)';
                ctx.fillRect(0, 0, width, height);
                
                if (this.currentStep >= this.recursionSteps.length) return;
                
                const currentData = this.recursionSteps[this.currentStep];
                
                if (this.mode === 'wave') {
                    this.drawWaveForm(ctx, width, height, centerY);
                } else if (this.mode === 'spiral') {
                    this.drawSpiralForm(ctx, centerX, centerY);
                } else if (this.mode === 'pulse') {
                    this.drawPulseForm(ctx, centerX, centerY);
                }
            },
            
            drawWaveForm(ctx, width, height, centerY) {
                const numPoints = Math.min(this.currentStep + 1, 100);
                const startIndex = Math.max(0, this.currentStep - 99);
                
                ctx.beginPath();
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 3;
                
                for (let i = 0; i < numPoints; i++) {
                    const dataIndex = startIndex + i;
                    if (dataIndex >= this.recursionSteps.length) break;
                    
                    const data = this.recursionSteps[dataIndex];
                    const x = (i / numPoints) * width;
                    const y = centerY - data.curvature * 80;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                ctx.stroke();
                
                // Draw gradient fill
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, 'rgba(6, 182, 212, 0.3)');
                gradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.3)');
                gradient.addColorStop(1, 'rgba(236, 72, 153, 0.3)');
                ctx.fillStyle = gradient;
                ctx.fill();
            },
            
            drawSpiralForm(ctx, centerX, centerY) {
                const numPoints = Math.min(this.currentStep + 1, 200);
                
                ctx.beginPath();
                
                for (let i = 0; i < numPoints; i++) {
                    const dataIndex = Math.max(0, this.currentStep - numPoints + i);
                    if (dataIndex >= this.recursionSteps.length) break;
                    
                    const data = this.recursionSteps[dataIndex];
                    const angle = (i / numPoints) * Math.PI * 6;
                    const radius = 20 + (i / numPoints) * 100 + data.curvature * 30;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 150);
                gradient.addColorStop(0, '#06b6d4');
                gradient.addColorStop(0.5, '#8b5cf6');
                gradient.addColorStop(1, '#ec4899');
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.stroke();
            },
            
            drawPulseForm(ctx, centerX, centerY) {
                const data = this.recursionSteps[this.currentStep];
                const baseRadius = 80;
                const pulse = Math.abs(data.curvature) * 50;
                
                for (let i = 0; i < 5; i++) {
                    const radius = baseRadius + pulse * (1 - i * 0.2);
                    const alpha = 0.6 - i * 0.1;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    gradient.addColorStop(0, `rgba(139, 92, 246, ${alpha})`);
                    gradient.addColorStop(1, `rgba(139, 92, 246, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
                
                // Center dot
                ctx.beginPath();
                ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                ctx.fillStyle = '#ec4899';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ec4899';
                ctx.fill();
                ctx.shadowBlur = 0;
            },
            
            updateDisplays() {
                if (this.currentStep >= this.recursionSteps.length) return;
                
                const data = this.recursionSteps[this.currentStep];
                
                document.getElementById('currentStep').textContent = data.step;
                document.getElementById('currentCurvature').textContent = data.curvature.toFixed(3);
                document.getElementById('currentTau').textContent = data.tau.toFixed(3);
            },
            
            animate() {
                this.drawTimeline();
                this.drawOscillator();
                this.updateDisplays();
                
                if (this.isPlaying) {
                    this.currentStep += this.speed / 5;
                    
                    // Loop back to beginning when reaching the end
                    if (this.currentStep >= this.recursionSteps.length - 1) {
                        this.currentStep = 0;
                    }
                }
                
                this.currentStep = Math.floor(this.currentStep);
                
                requestAnimationFrame(() => this.animate());
            }
        };

        // Initialize τon Visualizer when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => TauonVisualizer.init());
        } else {
            TauonVisualizer.init();
        }

        // Add τon visualizer to window resize
        window.addEventListener('resize', () => {
            if (TauonVisualizer.timelineCanvas) {
                TauonVisualizer.resizeCanvases();
            }
        });

        // Gateway Modal Functionality
        const gatewayModal = document.getElementById('gatewayModal');
        const gatewayIframe = document.getElementById('gatewayIframe');
        const openGateBtn = document.getElementById('openGateBtn');
        const closeGateBtn = document.getElementById('closeGateBtn');

        function openGateway() {
            gatewayIframe.src = 'https://ukbbi.github.io/UNNS/unns-ceremonial-gateway.html';
            gatewayModal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeGateway() {
            gatewayModal.classList.remove('active');
            gatewayIframe.src = '';
            document.body.style.overflow = 'auto';
        }

        if (openGateBtn) {
            openGateBtn.addEventListener('click', openGateway);
        }

        if (closeGateBtn) {
            closeGateBtn.addEventListener('click', closeGateway);
        }

        // Close on background click
        if (gatewayModal) {
            gatewayModal.addEventListener('click', (e) => {
                if (e.target === gatewayModal) {
                    closeGateway();
                }
            });
        }

        // Close on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && gatewayModal.classList.contains('active')) {
                closeGateway();
            }
        });
    </script>
</body>
</html>