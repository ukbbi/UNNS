<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory ‚Äî Chamber XXIV (QASD)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Consolas', 'Monaco', monospace; 
      background: #0a0a0a; 
      color: #e0e0e0;
      overflow-x: hidden;
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    
    /* Header */
    header { 
      text-align: center; 
      margin-bottom: 30px; 
      padding: 20px; 
      border-bottom: 2px solid #2a2a2a;
      background: linear-gradient(135deg, #0a1a2a 0%, #1a0a2a 100%);
    }
    h1 { 
      font-size: 2em; 
      color: #4a9eff; 
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(74, 158, 255, 0.3);
    }
    .subtitle { 
      color: #888; 
      margin-top: 10px; 
      font-size: 0.9em; 
    }
    
    /* Panels */
    .panel { 
      background: #1a1a1a; 
      border: 1px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 20px; 
      margin-bottom: 20px;
    }
    .panel-title { 
      font-size: 1.2em; 
      color: #4a9eff; 
      margin-bottom: 15px; 
      padding-bottom: 10px; 
      border-bottom: 1px solid #2a2a2a;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .panel-badge {
      font-size: 0.7em;
      padding: 3px 8px;
      border-radius: 3px;
      background: #2a4a2a;
      color: #4aff4a;
    }
    
    /* Controls */
    .controls { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
      gap: 15px; 
      margin-bottom: 20px; 
    }
    .control-group { display: flex; flex-direction: column; }
    label { 
      font-size: 0.9em; 
      color: #aaa; 
      margin-bottom: 5px; 
    }
    input[type="number"], input[type="text"], select, textarea { 
      background: #0a0a0a; 
      border: 1px solid #3a3a3a; 
      color: #e0e0e0; 
      padding: 8px; 
      border-radius: 4px; 
      font-family: inherit;
      font-size: 0.9em;
    }
    textarea {
      resize: vertical;
      min-height: 100px;
      font-family: 'Consolas', monospace;
    }
    
    button { 
      background: #2a4a7a; 
      border: none; 
      color: #e0e0e0; 
      padding: 12px 24px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-family: inherit;
      margin-right: 10px;
      margin-bottom: 10px;
      transition: background 0.2s;
    }
    button:hover { background: #3a5a8a; }
    button:disabled { 
      background: #1a1a1a; 
      color: #555; 
      cursor: not-allowed; 
    }
    .button-primary { background: #4a9eff; }
    .button-primary:hover { background: #5aaeff; }
    .button-success { background: #2a7a4a; }
    .button-success:hover { background: #3a8a5a; }
    .button-warning { background: #7a4a2a; }
    .button-warning:hover { background: #8a5a3a; }
    
    /* Canvas containers */
    .canvas-container { 
      position: relative; 
      background: #000; 
      border: 1px solid #2a2a2a; 
      border-radius: 4px;
      min-height: 300px;
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      display: block;
    }
    .canvas-label { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      background: rgba(0,0,0,0.8); 
      padding: 5px 10px; 
      border-radius: 3px; 
      font-size: 0.9em; 
      color: #4a9eff;
      border: 1px solid #2a2a2a;
    }
    
    /* Grid layouts */
    .two-col { 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 20px; 
    }
    .three-col { 
      display: grid; 
      grid-template-columns: repeat(3, 1fr); 
      gap: 20px; 
    }
    
    /* Metrics */
    .metrics { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
      gap: 10px; 
      margin-top: 15px; 
    }
    .metric { 
      background: #0a0a0a; 
      padding: 10px; 
      border-radius: 4px; 
      border: 1px solid #2a2a2a;
    }
    .metric-label { 
      font-size: 0.8em; 
      color: #888; 
      margin-bottom: 5px; 
    }
    .metric-value { 
      font-size: 1.2em; 
      color: #4a9eff; 
      font-weight: bold; 
    }
    .metric-value.success { color: #4aff4a; }
    .metric-value.warning { color: #ffa54a; }
    .metric-value.danger { color: #ff4a4a; }
    
    /* Status messages */
    .status { 
      padding: 10px; 
      border-radius: 4px; 
      margin-top: 15px; 
      font-size: 0.9em;
      display: none;
    }
    .status.info { background: #1a2a3a; color: #4a9eff; }
    .status.success { background: #1a3a2a; color: #4aff4a; }
    .status.warning { background: #3a2a1a; color: #ffa54a; }
    .status.error { background: #3a1a1a; color: #ff4a4a; }
    
    /* Operator word display */
    .operator-word {
      background: #0a0a0a;
      padding: 15px;
      border-radius: 4px;
      border: 1px solid #2a2a2a;
      font-family: 'Courier New', monospace;
      font-size: 0.85em;
      max-height: 200px;
      overflow-y: auto;
    }
    .operator-item {
      padding: 5px;
      margin: 3px 0;
      background: #1a1a1a;
      border-left: 3px solid #4a9eff;
      display: flex;
      justify-content: space-between;
    }
    .operator-name { color: #4a9eff; font-weight: bold; }
    .operator-targets { color: #888; }
    
    /* UPI colormap */
    .upi-legend {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background: #0a0a0a;
      border-radius: 4px;
      margin-top: 10px;
      font-size: 0.8em;
    }
    .upi-legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .upi-color-box {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid #2a2a2a;
    }
    
    /* Code examples */
    .code-example {
      background: #0a0a0a;
      padding: 15px;
      border-radius: 4px;
      border-left: 3px solid #4a9eff;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      font-size: 0.85em;
      overflow-x: auto;
    }
    
    /* Collapsible sections */
    .collapsible {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .collapsible::before {
      content: '‚ñº';
      font-size: 0.8em;
      transition: transform 0.2s;
    }
    .collapsible.collapsed::before {
      transform: rotate(-90deg);
    }
    .collapsible-content {
      max-height: 1000px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .collapsible-content.collapsed {
      max-height: 0;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .two-col, .three-col { grid-template-columns: 1fr; }
    }
    
    /* UNNS Gradient Blocks */
    .unns-gradient-block {
      padding: 20px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .unns-gradient-guide {
      background: linear-gradient(135deg, #0a1a0a 0%, #0a0a1a 50%, #1a0a1a 100%);
      border: 1px solid #2a2a2a;
    }
    .unns-gradient-guide h2 {
      text-shadow: 0 0 10px rgba(74, 255, 74, 0.3);
    }
    .unns-gradient-guide h3 {
      text-shadow: 0 0 8px rgba(74, 158, 255, 0.2);
    }
    
    /* Canvas Tooltips */
    .canvas-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.95);
      border: 1px solid #4a9eff;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 0.85em;
      color: #e0e0e0;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      display: none;
    }
    .canvas-tooltip.visible {
      display: block;
    }
    .canvas-tooltip .tooltip-label {
      color: #4a9eff;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .canvas-tooltip .tooltip-value {
      color: #4aff4a;
      font-family: 'Courier New', monospace;
    }
    .canvas-tooltip .tooltip-value.warning {
      color: #ffa54a;
    }
    .canvas-tooltip .tooltip-value.danger {
      color: #ff4a4a;
    }
    .canvas-tooltip .tooltip-info {
      color: #888;
      font-size: 0.9em;
      margin-top: 4px;
    }
    
    /* Phase-E Correlation Matrix */
    .phasee-mtx td, .phasee-mtx th {
      text-align:center;
    }
    .phasee-none { background:#111827; color:#6b7280; }
    .phasee-weak { background:#1e1e2e; color:#cbd5e1; }
    .phasee-pos { background:rgba(34,197,94,0.35); color:#ecfdf5; }
    .phasee-pos-strong { background:rgba(34,197,94,0.75); color:#ecfdf5; font-weight:600; }
    .phasee-neg { background:rgba(248,113,113,0.35); color:#fee2e2; }
    .phasee-neg-strong { background:rgba(248,113,113,0.75); color:#fef2f2; font-weight:600; }
    
    /* Highlight mode - intense glow effects */
    .phasee-pos-strong.highlight-mode { 
      background:rgba(34,197,94,0.95); 
      box-shadow: 0 0 8px rgba(34,197,94,0.8), inset 0 0 4px rgba(34,197,94,0.5);
      font-weight: 700;
      color: #fff;
    }
    .phasee-neg-strong.highlight-mode { 
      background:rgba(248,113,113,0.95); 
      box-shadow: 0 0 8px rgba(248,113,113,0.8), inset 0 0 4px rgba(248,113,113,0.5);
      font-weight: 700;
      color: #fff;
    }
    .phasee-pos.highlight-mode { 
      background:rgba(34,197,94,0.55); 
      box-shadow: 0 0 4px rgba(34,197,94,0.4);
    }
    .phasee-neg.highlight-mode { 
      background:rgba(248,113,113,0.55); 
      box-shadow: 0 0 4px rgba(248,113,113,0.4);
    }
    
    /* Matrix Interpretation Panel */
    .phaseE-interpretation-card {
      background: rgba(20, 25, 35, 0.65);
      border: 1px solid rgba(120,150,255,0.25);
      border-radius: 8px;
      margin-top: 1.5rem;
      padding: 0;
    }

    .phaseE-interpretation-header {
      background: linear-gradient(90deg, #222b40, #1b2230);
      padding: 0.9rem 1.2rem;
      color: #9cbcff;
      font-weight: 600;
      font-size: 1.05rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
    }

    .phaseE-interpretation-body {
      padding: 1rem 1.4rem;
      color: #d5e0ff;
      font-size: 0.92rem;
      display: none;
    }

    .phaseE-interpretation-body h4 {
      color: #a8c7ff;
      margin-top: 1rem;
      margin-bottom: 0.4rem;
    }
    
    /* SHAI Panel */
    #shaiPanel {
      margin-top: 1.5rem;
      border-radius: 8px;
      border: 1px solid rgba(120,150,255,0.25);
      background: rgba(16, 20, 30, 0.8);
    }

    #shaiPanel .phaseE-panel-header {
      padding: 0.8rem 1.1rem;
      font-weight: 600;
      color: #a8c7ff;
      background: linear-gradient(90deg, #1f2838, #161d2b);
    }

    #shaiPanel .phaseE-panel-body {
      padding: 0.9rem 1.2rem;
      font-size: 0.9rem;
      color: #d8e1ff;
    }

    #shaiPanel h4 {
      margin-top: 0.9rem;
      margin-bottom: 0.4rem;
      color: #9ebcff;
    }

    .phaseE-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 0.8rem;
      font-size: 0.88rem;
    }

    .phaseE-table th,
    .phaseE-table td {
      padding: 0.35rem 0.4rem;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }

    .phaseE-table th {
      text-align: left;
      color: #b9d4ff;
      background: rgba(35,45,65,0.7);
    }

    .shai-badge {
      font-weight: 600;
    }

    .shai-badge-A { color: #8cffc9; }
    .shai-badge-B { color: #ffe48c; }
    .shai-badge-C { color: #ffb57a; }
    .shai-badge-D { color: #ff7d7d; }
    
    /* Download buttons */
    .unns-download-row { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 1rem; 
      margin: 1rem 0; 
    }
    .unns-download-btn {
      padding: 10px 18px;
      background: linear-gradient(135deg, #243344, #335566);
      color: #cfeaff;
      text-decoration: none;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.12);
      transition: 0.2s;
      font-size: 0.9em;
      white-space: nowrap;
    }
    .unns-download-btn:hover {
      background: linear-gradient(135deg, #335566, #446677);
      color: white;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(74, 158, 255, 0.2);
    }
    
    /* Gradient blocks */
    .unns-gradient-block {
      background: linear-gradient(135deg, #1a2a3a 0%, #2a1a3a 100%);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid rgba(74, 158, 255, 0.3);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚öõÔ∏è CHAMBER XXIV: QUANTUM ALGORITHM STRUCTURAL DIAGNOSTICS</h1>
      <div class="subtitle">QASD ‚Äî Operator XXIV ‚Äî Algorithm Nest Analysis Engine</div>
    </header>
    
    <!-- Input Panel -->
    <div class="panel" id="xxivInputPanel">
      <div class="panel-title">
        <span>Algorithm Input</span>
        <span class="panel-badge">JSON IR</span>
      </div>
      
      <div class="controls">
        <div class="control-group">
          <label>Algorithm Name</label>
          <input type="text" id="algName" value="Test Algorithm">
        </div>
        <div class="control-group">
          <label>Qubits</label>
          <input type="number" id="algQubits" value="3" min="1" max="20">
        </div>
        <div class="control-group">
          <label>Seed</label>
          <input type="number" id="algSeed" value="137" min="1">
        </div>
        <div class="control-group">
          <label>Mode</label>
          <select id="algMode">
            <option value="strict">Strict</option>
            <option value="relaxed" selected>Relaxed</option>
          </select>
        </div>
      </div>
      
      <div class="control-group">
        <label>Algorithm JSON (Quantum IR)</label>
        <textarea id="algJSON" placeholder='{"algorithm_name": "...", "qubits": 3, "operators": [...]}'></textarea>
      </div>
      
      <div style="margin-top: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <select id="exampleSelector" style="flex: 0 0 auto; min-width: 200px;">
          <option value="grover">Grover Search (3-qubit)</option>
          <option value="qft5">QFT-5 (simplified)</option>
          <option value="toffoli">Toffoli (CCNOT)</option>
          <option value="qaoa1">QAOA-1 MaxCut</option>
          <option value="qaoa2">QAOA-2 MaxCut (stress test)</option>
          <option value="vqe">VQE Ansatz (2-qubit)</option>
        </select>
        <button id="btnLoadExample" class="button-primary">üìã Load Example</button>
        <button id="btnImport" class="button-success">‚¨ÜÔ∏è Import Algorithm</button>
        <button id="btnClear" class="button-warning">üóëÔ∏è Clear</button>
      </div>
      
      <div id="statusImport" class="status"></div>
    </div>
    
    <!-- Operator Word Panel -->
    <div class="panel" id="xxivOperatorWordPanel">
      <div class="panel-title">
        <span>UNNS Operator Word</span>
        <span class="panel-badge" id="badgeOperators">0 ops</span>
      </div>
      <div id="operatorWordDisplay" class="operator-word">
        <div style="color: #666; text-align: center; padding: 20px;">
          No algorithm loaded
        </div>
      </div>
    </div>
    
    <!-- Diagnostics Control -->
    <div class="panel">
      <div class="panel-title">Diagnostic Controls</div>
      
      <div class="controls">
        <div class="control-group">
          <label>Enable Optimization</label>
          <select id="enableOpt">
            <option value="false">No</option>
            <option value="true">Yes</option>
          </select>
        </div>
      </div>
      
      <div style="margin-top: 15px;">
        <button id="btnRunDiagnostics" class="button-primary" disabled>‚ñ∂Ô∏è Run Diagnostics</button>
        <button id="btnExport" class="button-success" disabled>üíæ Export JSON</button>
      </div>
      
      <div id="statusDiagnostics" class="status"></div>
    </div>
    
    <!-- Metrics Panel -->
    <div class="panel">
      <div class="panel-title">Diagnostic Metrics</div>
      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Algorithm Depth</div>
          <div class="metric-value" id="metricDepth">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Max œÑ-Curvature</div>
          <div class="metric-value" id="metricMaxTau">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Peak œÜ-Resonance</div>
          <div class="metric-value" id="metricPeakPhi">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Max UPI</div>
          <div class="metric-value" id="metricMaxUPI">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Closure Stability</div>
          <div class="metric-value" id="metricClosure">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Residue Density</div>
          <div class="metric-value" id="metricResidue">‚Äî</div>
        </div>
      </div>
    </div>
    
    <!-- Validation Panel -->
    <div class="panel" id="xxivValidationPanel">
      <div class="panel-title">
        <span>Validation Report</span>
        <span class="panel-badge" id="validationSummaryBadge">Not run</span>
      </div>

      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Schema & Lengths</div>
          <div class="metric-value" id="metricValLengths">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Metrics Consistency</div>
          <div class="metric-value" id="metricValMetrics">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Value Ranges</div>
          <div class="metric-value" id="metricValRanges">‚Äî</div>
        </div>
        <div class="metric">
          <div class="metric-label">Residue Graph</div>
          <div class="metric-value" id="metricValGraph">‚Äî</div>
        </div>
      </div>

      <div id="validationStatus" class="status info" style="margin-top:15px; display:none;"></div>

      <div style="margin-top:10px; font-size:0.85em; color:#888;">
        <ul id="validationChecksList" style="margin-left:18px; line-height:1.6;"></ul>
      </div>
    </div>
    
    <!-- Visualization Panels -->
    <div class="two-col">
      <!-- œÑ-Curvature Profile -->
      <div class="panel" id="xxivTauPanel">
        <div class="panel-title">œÑ-Curvature Profile</div>
        <div class="canvas-container">
          <canvas id="canvasTau"></canvas>
          <div class="canvas-label">Structural Strain Timeline</div>
          <div class="canvas-tooltip" id="tooltipTau"></div>
        </div>
      </div>
      
      <!-- œÜ-Resonance Spectrum -->
      <div class="panel" id="xxivPhiPanel">
        <div class="panel-title">œÜ-Resonance Spectrum</div>
        <div class="canvas-container">
          <canvas id="canvasPhi"></canvas>
          <div class="canvas-label">Depth Resonance Density</div>
          <div class="canvas-tooltip" id="tooltipPhi"></div>
        </div>
      </div>
    </div>
    
    <div class="two-col">
      <!-- UPI Field -->
      <div class="panel" id="xxivUPIPanel">
        <div class="panel-title">UPI Paradox Field</div>
        <div class="canvas-container">
          <canvas id="canvasUPI"></canvas>
          <div class="canvas-label">Interferential Instability</div>
          <div class="canvas-tooltip" id="tooltipUPI"></div>
        </div>
        <div class="upi-legend">
          <div class="upi-legend-item">
            <div class="upi-color-box" style="background: #2a7a2a;"></div>
            <span>Stable (&lt;0.4)</span>
          </div>
          <div class="upi-legend-item">
            <div class="upi-color-box" style="background: #7a7a2a;"></div>
            <span>Mild (0.4-0.75)</span>
          </div>
          <div class="upi-legend-item">
            <div class="upi-color-box" style="background: #7a2a2a;"></div>
            <span>Paradox (&gt;0.75)</span>
          </div>
        </div>
      </div>
      
      <!-- Closure Stability -->
      <div class="panel" id="xxivClosurePanel">
        <div class="panel-title">Closure Stability Index</div>
        <div class="canvas-container">
          <canvas id="canvasClosure"></canvas>
          <div class="canvas-label">Structure Conservation</div>
          <div class="canvas-tooltip" id="tooltipClosure"></div>
        </div>
      </div>
    </div>
    
    <!-- Residue Flow -->
    <div class="panel" id="xxivResiduePanel">
      <div class="panel-title">Residue & Torsion Flow</div>
      <div class="canvas-container" style="min-height: 400px;">
        <canvas id="canvasResidue"></canvas>
        <div class="canvas-label">Decoherence Propagation</div>
        <div class="canvas-tooltip" id="tooltipResidue"></div>
      </div>
    </div>
    
    <!-- Optimization Panel -->
    <div class="panel" id="xxivOptimizationPanel" style="display: none;">
      <div class="panel-title">œÑ-Path Optimization Results</div>
      <div id="optimizationResults" style="padding: 15px; background: #0a0a0a; border-radius: 4px;">
        <div style="color: #666; text-align: center; padding: 20px;">
          No optimization performed
        </div>
      </div>
    </div>
    
    <!-- Interpretation Guide -->
    <div class="panel">
      <div class="panel-title collapsible" id="interpretToggle">
        <span>üîç How to Read Diagnostics</span>
      </div>
      <div class="collapsible-content" id="interpretContent">
        <div class="unns-gradient-block unns-gradient-guide" style="margin-top: 15px;">
          <h2 style="color: #4aff4a; font-size: 1.3em; margin-bottom: 20px;">How to Read Chamber XXIV Diagnostics</h2>

          <h3 style="color: #4a9eff; font-size: 1.1em; margin: 20px 0 10px;">1. œÑ-Curvature Profile (Structural Strain)</h3>
          <ul style="margin: 10px 0 10px 20px; line-height: 1.8;">
            <li><strong style="color: #4aff4a;">Gentle rise</strong> ‚Üí algorithm builds structure gradually; good for stability.</li>
            <li><strong style="color: #ffa54a;">Sharp spikes</strong> ‚Üí fragile layers; small hardware noise may have big effects.</li>
            <li><strong style="color: #ff4a9e;">Frequent zig-zags</strong> ‚Üí many "twist / untwist" operations, often in complex ansatz circuits.</li>
          </ul>

          <h3 style="color: #4a9eff; font-size: 1.1em; margin: 20px 0 10px;">2. œÜ-Resonance Spectrum (Depth Resonance)</h3>
          <ul style="margin: 10px 0 10px 20px; line-height: 1.8;">
            <li><strong style="color: #4aff4a;">Flat œÜ</strong> ‚Üí shallow phase structure; often simple or highly symmetric circuits.</li>
            <li><strong style="color: #4a9eff;">Staircase œÜ</strong> ‚Üí layered amplification (typical in Grover-like algorithms).</li>
            <li><strong style="color: #ff4a9e;">Strong single peak</strong> ‚Üí one depth scale dominates; interesting candidate for œÑ-geodesic design.</li>
          </ul>

          <h3 style="color: #4a9eff; font-size: 1.1em; margin: 20px 0 10px;">3. UPI Paradox Field (Interferential Instability)</h3>
          <ul style="margin: 10px 0 10px 20px; line-height: 1.8;">
            <li><strong style="color: #4aff4a;">UPI &lt; 0.4 (green)</strong> ‚Üí structurally stable interference.</li>
            <li><strong style="color: #ffa54a;">UPI 0.4‚Äì0.75 (yellow)</strong> ‚Üí delicate zones; monitor these layers on real hardware.</li>
            <li><strong style="color: #ff4a4a;">UPI &gt; 0.75 (red)</strong> ‚Üí paradox corridors; if they appear, consider redesigning that segment.</li>
          </ul>

          <h3 style="color: #4a9eff; font-size: 1.1em; margin: 20px 0 10px;">4. Closure Stability Index</h3>
          <ul style="margin: 10px 0 10px 20px; line-height: 1.8;">
            <li><strong style="color: #4aff4a;">Close to 1</strong> ‚Üí the algorithm conserves structure well at that stage.</li>
            <li><strong style="color: #4a9eff;">Gradual decline</strong> ‚Üí acceptable "wear and tear" of structure over depth.</li>
            <li><strong style="color: #ff4a4a;">Sudden drops</strong> ‚Üí suspect regions for decoherence amplification.</li>
          </ul>

          <h3 style="color: #4a9eff; font-size: 1.1em; margin: 20px 0 10px;">5. Residue and Torsion Flow</h3>
          <ul style="margin: 10px 0 10px 20px; line-height: 1.8;">
            <li><strong style="color: #4aff4a;">Small residues and smooth edges</strong> ‚Üí clean structural evolution.</li>
            <li><strong style="color: #4a9eff;">Growing residues towards the end</strong> ‚Üí expected when approaching measurement.</li>
            <li><strong style="color: #ff4a4a;">Early residue spikes</strong> ‚Üí problematic entangling patterns; often a sign of overly sharp control logic.</li>
          </ul>

          <h3 style="color: #4a9eff; font-size: 1.1em; margin: 20px 0 10px;">6. Quick Health Checklist</h3>
          <div style="background: #1a2a1a; padding: 15px; border-radius: 4px; border-left: 3px solid #4aff4a; margin: 10px 0;">
            <ul style="margin: 0 0 0 20px; line-height: 1.8;">
              <li>Max œÑ-curvature <strong style="color: #4aff4a;">&lt; 2.0</strong> ‚Üí structurally gentle.</li>
              <li>Max UPI <strong style="color: #4aff4a;">&lt; 0.5</strong> ‚Üí low paradox pressure.</li>
              <li>Closure index mostly <strong style="color: #4aff4a;">&gt; 0.7</strong> ‚Üí structure largely preserved.</li>
              <li>œÜ-spectrum without violent spikes ‚Üí smooth depth geometry.</li>
            </ul>
          </div>

          <p style="margin: 20px 0 10px; line-height: 1.6;">
            An algorithm that passes this checklist is considered <strong style="color: #4aff4a;">structurally healthy</strong> inside the UNNS Substrate.
            Algorithms that fail it are still interesting, but they may be better suited for experimental or 
            high-precision contexts rather than noisy devices.
          </p>

          <div style="background: #2a1a3a; padding: 15px; border-radius: 4px; border-left: 3px solid #ff4a9e; margin: 20px 0;">
            <h4 style="color: #ff4a9e; margin-bottom: 10px;">üí° Practical Interpretation Tips</h4>
            <ul style="margin: 0 0 0 20px; line-height: 1.6;">
              <li><strong>Compare similar algorithms:</strong> Run both QAOA-1 and QAOA-2 to see how an extra layer affects structural health.</li>
              <li><strong>Track problem areas:</strong> Layers with high UPI + low closure + high œÑ are triple-threat fragility points.</li>
              <li><strong>Optimize iteratively:</strong> If validation shows red zones, try reordering gates or inserting identity barriers.</li>
              <li><strong>Hardware correlation:</strong> High residue flow often correlates with gates that need high-fidelity on real devices.</li>
            </ul>
          </div>

          <div style="background: #1a2a3a; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <h4 style="color: #4a9eff; margin-bottom: 10px;">üìä Reading the Visualizations</h4>
            <p style="margin-bottom: 10px;"><strong>œÑ-Curvature Graph:</strong></p>
            <ul style="margin: 0 0 15px 20px; line-height: 1.6;">
              <li>Look for the <em>envelope</em> (overall trend) rather than individual points</li>
              <li>Upward trend = complexity building; downward = structure relaxing</li>
              <li>Plateau regions = stable computation windows</li>
            </ul>
            
            <p style="margin-bottom: 10px;"><strong>UPI Field Bars:</strong></p>
            <ul style="margin: 0 0 15px 20px; line-height: 1.6;">
              <li>Green bars = safe to run on noisy hardware</li>
              <li>Yellow bars = monitor carefully, may need error mitigation</li>
              <li>Red bars = critical sections requiring high-fidelity gates</li>
            </ul>
            
            <p style="margin-bottom: 10px;"><strong>Residue Flow Network:</strong></p>
            <ul style="margin: 0 20px; line-height: 1.6;">
              <li>Thick edges = strong decoherence propagation paths</li>
              <li>Large nodes = residue accumulation points</li>
              <li>Isolated nodes = well-contained operations</li>
            </ul>
          </div>

          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #2a2a2a; font-size: 0.85em; color: #666;">
            <strong>Note:</strong> These interpretations are based on UNNS substrate theory. Correlation with quantum hardware performance is an active research area. Use diagnostics as <em>structural guidance</em> rather than definitive predictions.
          </div>
        </div>
      </div>
    </div>
    
    <!-- Guide -->
    <div class="panel">
      <div class="panel-title collapsible" id="guideToggle">
        <span>üìö Chamber Guide & Theory</span>
      </div>
      <div class="collapsible-content" id="guideContent">
        <div style="line-height: 1.6; color: #aaa; padding-top: 15px;">
          <h3 style="color: #4a9eff; margin-bottom: 10px;">Chamber XXIV: Quantum Algorithm Structural Diagnostics</h3>
          
          <p><strong>Purpose:</strong> Chamber XXIV analyzes quantum algorithms by translating them into UNNS operator sequences and computing substrate-level diagnostics including curvature profiles, œÜ-resonance spectra, paradox density (UPI), and closure stability.</p>
          
          <h4 style="color: #4a9eff; margin: 20px 0 10px;">Input Format (JSON IR)</h4>
          <div class="code-example">{
  "algorithm_name": "Grover Search",
  "qubits": 3,
  "operators": [
    {"op": "H", "targets": [0, 1, 2]},
    {"op": "CNOT", "targets": [0, 1]},
    {"op": "MEASURE", "targets": [0]}
  ]
}</div>
          
          <h4 style="color: #4a9eff; margin: 20px 0 10px;">Gate ‚Üí UNNS Operator Mapping</h4>
          <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 0.9em;">
            <tr style="border-bottom: 1px solid #2a2a2a;">
              <th style="text-align: left; padding: 8px; color: #4a9eff;">Quantum Gate</th>
              <th style="text-align: left; padding: 8px; color: #4a9eff;">UNNS Operator</th>
              <th style="text-align: left; padding: 8px; color: #4a9eff;">Effect</th>
            </tr>
            <tr style="border-bottom: 1px solid #1a1a1a;">
              <td style="padding: 8px;">H (Hadamard)</td>
              <td style="padding: 8px;">APERTURE</td>
              <td style="padding: 8px;">Superposition expansion, œÜ‚Üë</td>
            </tr>
            <tr style="border-bottom: 1px solid #1a1a1a;">
              <td style="padding: 8px;">X, Y, Z</td>
              <td style="padding: 8px;">FOLD2 / PRISM</td>
              <td style="padding: 8px;">Torsion, œÑ‚Üë</td>
            </tr>
            <tr style="border-bottom: 1px solid #1a1a1a;">
              <td style="padding: 8px;">CNOT</td>
              <td style="padding: 8px;">INTERLACE</td>
              <td style="padding: 8px;">Entanglement, œÑ spike, residue</td>
            </tr>
            <tr style="border-bottom: 1px solid #1a1a1a;">
              <td style="padding: 8px;">Phase (S, T)</td>
              <td style="padding: 8px;">œÜ-SCALE</td>
              <td style="padding: 8px;">Phase perturbation, œÜ‚Üë</td>
            </tr>
            <tr style="border-bottom: 1px solid #1a1a1a;">
              <td style="padding: 8px;">SWAP</td>
              <td style="padding: 8px;">CLOSURE</td>
              <td style="padding: 8px;">Exchange, closure recalc</td>
            </tr>
            <tr>
              <td style="padding: 8px;">MEASURE</td>
              <td style="padding: 8px;">COLLAPSE</td>
              <td style="padding: 8px;">Residue propagation, closure‚Üì</td>
            </tr>
          </table>
          
          <h4 style="color: #4a9eff; margin: 20px 0 10px;">Diagnostic Outputs</h4>
          <ul style="margin: 10px 0 10px 20px; line-height: 1.8;">
            <li><strong>œÑ-Curvature Profile:</strong> Measures structural strain at each layer. High curvature indicates recursion pressure and potential bottlenecks.</li>
            <li><strong>œÜ-Resonance Spectrum:</strong> Spectral density showing where the algorithm "stretches" its nest structure maximally.</li>
            <li><strong>UPI Field:</strong> Paradox pressure (Unified Paradox Index). UPI &gt; 0.75 indicates paradox corridors requiring attention.</li>
            <li><strong>Closure Stability:</strong> Conservation of algorithmic structure. Drops indicate latent fragility points.</li>
            <li><strong>Residue Flow:</strong> Propagation of decoherence echoes through the algorithm's structure.</li>
          </ul>
          
          <h4 style="color: #4a9eff; margin: 20px 0 10px;">Interpretation Guidelines</h4>
          <div style="background: #1a2a3a; padding: 15px; border-radius: 4px; margin: 10px 0;">
            <p style="margin-bottom: 10px;"><strong style="color: #4aff4a;">Healthy Algorithm:</strong></p>
            <ul style="margin-left: 20px; line-height: 1.6;">
              <li>Max œÑ-curvature &lt; 2.0</li>
              <li>UPI mostly &lt; 0.5</li>
              <li>Closure index &gt; 0.7</li>
              <li>Smooth œÜ-spectrum (no sharp spikes)</li>
            </ul>
          </div>
          
          <div style="background: #3a2a1a; padding: 15px; border-radius: 4px; margin: 10px 0;">
            <p style="margin-bottom: 10px;"><strong style="color: #ffa54a;">Warning Signs:</strong></p>
            <ul style="margin-left: 20px; line-height: 1.6;">
              <li>œÑ-curvature spikes &gt; 3.0</li>
              <li>Sustained UPI &gt; 0.75</li>
              <li>Closure drops below 0.5</li>
              <li>Residue accumulation zones</li>
            </ul>
          </div>
          
          <h4 style="color: #4a9eff; margin: 20px 0 10px;">Supported Gates</h4>
          <p>H, X, Y, Z, S, T, CNOT, CZ, SWAP, MEASURE, plus direct UNNS operators: XIII (INTERLACE), XIV (œÜ-SCALE), XV (PRISM), XVI (CLOSURE), XVII, XVIII, APERTURE, FOLD2, COLLAPSE</p>
          
          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #2a2a2a;">
            <p style="font-size: 0.85em; color: #666;">
              <strong>Version:</strong> 1.0.0 | <strong>Engine:</strong> QASD Nest Analyzer | <strong>Status:</strong> Production Ready
            </p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- ========================================== -->
    <!-- PHASE-E HYBRID CORRELATION SUITE PANEL     -->
    <!-- ========================================== -->
    
    <div class="panel" id="xxivPhaseEPanel" style="display: none;">
      <div class="panel-title">
        <span>‚öóÔ∏è Phase-E Hybrid Correlation Suite</span>
        <span style="background: #2a4a2a; color: #4aff4a; font-size: 0.65em; padding: 3px 8px; border-radius: 3px; margin-left: 10px;">v1.0 Hybrid</span>
      </div>
      
      <div style="color: #888; font-size: 0.85em; margin-bottom: 15px; padding: 10px; background: #0a0a0a; border-left: 3px solid #4a9eff;">
        Supports: Real hardware (IBM, IonQ, Rigetti, OQC, Quantinuum) + Simulators (ideal, depolarizing, dephasing, amplitude damping)
      </div>
      
      <div style="margin-bottom: 15px;">
        <button id="btnPhaseELoadCircuits" style="background: #2a4a7a; border: none; color: #e0e0e0; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px;">üìÇ Load Circuit Batch</button>
        <button id="btnPhaseEImportHardware" style="background: #2a4a7a; border: none; color: #e0e0e0; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px;">üìä Import Hardware Logs</button>
        <button id="btnPhaseERun" style="background: #4a9eff; border: none; color: #e0e0e0; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px;" disabled>‚ñ∂Ô∏è Run Correlation</button>
        <button id="btnPhaseEExport" style="background: #2a4a7a; border: none; color: #e0e0e0; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px;" disabled>üíæ Export Hybrid Bundle</button>
        <button id="btnHighlightCorr" style="background: #556677; border: none; color: #e0e0e0; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px;" disabled>üéØ Highlight Strong Correlations</button>
        <button onclick="document.getElementById('xxivPhaseEPanel').style.display='none'" style="background: #4a2a2a; border: none; color: #e0e0e0; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px;">‚úñÔ∏è Close</button>
      </div>
      
      <div id="phaseEStatus" style="padding: 10px; border-radius: 4px; margin-top: 10px; font-size: 0.9em; display: none;"></div>
      
      <div class="metrics" style="margin-top: 15px;">
        <div class="metric">
          <div class="metric-label">Circuits Loaded</div>
          <div class="metric-value" id="phaseECountCircuits">0</div>
        </div>
        <div class="metric">
          <div class="metric-label">Hardware Platforms</div>
          <div class="metric-value" id="phaseECountPlatforms">0</div>
        </div>
        <div class="metric">
          <div class="metric-label">Phase-E Records</div>
          <div class="metric-value" id="phaseECountRecords">0</div>
        </div>
        <div class="metric">
          <div class="metric-label">Substrate Metrics</div>
          <div class="metric-value">17</div>
        </div>
        <div class="metric">
          <div class="metric-label">Hardware Metrics</div>
          <div class="metric-value" id="phaseEHardwareMetrics">10</div>
        </div>
      </div>
      
      <div id="phaseECorrMatrixContainer" style="margin-top: 20px;"></div>
      
      <!-- =======================
           MATRIX INTERPRETATION PANEL
           ======================= -->
      <div class="phaseE-interpretation-card">
          <div class="phaseE-interpretation-header" onclick="toggleMatrixInterpretation()">
              <span>üìä Matrix Interpretation Panel</span>
              <span id="interpArrow">‚ñº</span>
          </div>

          <div id="matrixInterpretationBody" class="phaseE-interpretation-body">

              <h4>1. Global Pattern Summary</h4>
              <p id="interp_global">
                  The Phase-E matrix shows structural‚Äìphysical correlations across UNNS metrics
                  and real hardware noise channels. Loading patterns‚Ä¶
              </p>

              <h4>2. œÑ-Curvature Correlations</h4>
              <p id="interp_tau">
                  Loading œÑ-curvature interpretation‚Ä¶
              </p>

              <h4>3. œÜ-Resonance Correlations</h4>
              <p id="interp_phi">
                  Loading œÜ-resonance interpretation‚Ä¶
              </p>

              <h4>4. Closure-Field Correlations</h4>
              <p id="interp_closure">
                  Loading closure interpretation‚Ä¶
              </p>

              <h4>5. UPI & Paradox Dynamics</h4>
              <p id="interp_upi">
                  Loading UPI interpretation‚Ä¶
              </p>

              <h4>6. Residue & Torsion Flow</h4>
              <p id="interp_residue">
                  Loading residue/torsion interpretation‚Ä¶
              </p>

          </div>
      </div>
      
      <!-- =======================
           SHAI ‚Äî ALIGNMENT PANEL
           ======================= -->
      <div id="shaiPanel" class="phaseE-interpretation-card" style="display: none;">
        <div class="phaseE-panel-header">
          üî∑ SHAI ‚Äî Substrate‚ÄìHardware Alignment Index
        </div>
        <div class="phaseE-panel-body">

          <h4>Global Summary</h4>
          <div id="shaiGlobal"></div>

          <h4>SHAI by Platform</h4>
          <table id="shaiPlatformTable" class="phaseE-table">
            <!-- populated by JS -->
          </table>

          <h4>SHAI by Algorithm</h4>
          <table id="shaiAlgorithmTable" class="phaseE-table">
            <!-- populated by JS -->
          </table>

        </div>
      </div>
    </div>
    
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         EXTENDED PHASE-E GUIDE (COLLAPSIBLE)
         ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    
    <div class="panel" style="margin-top: 30px; border: 2px solid #4a9eff;">
      <div class="panel-title" style="font-size: 1.4em; cursor: pointer;" onclick="toggleExtendedGuide()">
        <span>üìö Phase-E Extended Research Guide</span>
        <span id="extendedGuideArrow" style="float: right;">‚ñº</span>
      </div>
      
      <div id="extendedGuideBody" style="display: none;">
      <!-- Download Buttons -->
      <div style="padding: 20px;">
        <h3 style="color: #4a9eff; margin-bottom: 15px;">üì• Sample Datasets</h3>
        <p style="color: #aaa; margin-bottom: 15px;">Download pre-configured circuit batches and hardware logs for immediate Phase-E testing:</p>
        
        <div class="unns-download-row">
          <a class="unns-download-btn" href="/media/unns/phaseE_circuits_minimal.json" download>
            üì• Circuit Batch (Minimal)
          </a>
          <a class="unns-download-btn" href="/media/unns/phaseE_hardware_FULL.json" download>
            üì• Hardware Logs (Full)
          </a>
          <a class="unns-download-btn" href="/media/unns/phaseE_circuits_advanced.json" download>
            üì• Circuit Batch (Advanced)
          </a>
          <a class="unns-download-btn" href="/media/unns/phaseE_hardware_extreme.json" download>
            üì• Hardware Logs (Extreme Noise)
          </a>
        </div>
        
        <div style="background: #1a2a3a; padding: 15px; border-radius: 6px; margin-top: 20px; border-left: 3px solid #4a9eff;">
          <h4 style="color: #4aff4a; margin-bottom: 10px;">Advanced Dataset Contents</h4>
          <p style="margin-bottom: 10px; color: #ccc;">The advanced circuit batch includes deep quantum algorithms:</p>
          <ul style="margin-left: 20px; line-height: 1.8; color: #aaa;">
            <li><strong>QAOA-3</strong> ‚Äî 3-layer Quantum Approximate Optimization Algorithm</li>
            <li><strong>VQE-H‚ÇÇ</strong> ‚Äî Variational Quantum Eigensolver for molecular hydrogen</li>
            <li><strong>QFT5_v2</strong> ‚Äî 5-qubit Quantum Fourier Transform</li>
            <li><strong>Random Ansatz depth-20</strong> ‚Äî Stress test for deep circuits</li>
            <li><strong>Clifford-Depth-16</strong> ‚Äî Stabilizer circuit for benchmarking</li>
            <li><strong>Grover-8-qubit</strong> ‚Äî Search oracle implementation</li>
          </ul>
          
          <p style="margin-top: 15px; margin-bottom: 10px; color: #ccc;">Extreme noise models simulate:</p>
          <ul style="margin-left: 20px; line-height: 1.8; color: #aaa;">
            <li><strong>Amplitude damping (12%)</strong> ‚Äî Energy relaxation effects</li>
            <li><strong>Correlated noise</strong> ‚Äî Cross-talk between qubits</li>
            <li><strong>Mixed noise channels</strong> ‚Äî Realistic NISQ environments</li>
          </ul>
        </div>
      </div>
      
      <!-- SVG Diagram 1: Phase-E Flow -->
      <div style="padding: 20px; border-top: 1px solid #2a2a2a;">
        <h3 style="color: #4a9eff; margin-bottom: 15px;">üîÑ Phase-E Processing Pipeline</h3>
        <svg width="100%" height="180" viewBox="0 0 780 180" xmlns="http://www.w3.org/2000/svg">
          <rect x="20" y="50" width="160" height="60" rx="8"
                fill="#223344" stroke="#66aaff" stroke-width="2"></rect>
          <text x="100" y="85" fill="#cfeaff" text-anchor="middle" font-size="14">JSON Inputs</text>
          
          <rect x="240" y="50" width="200" height="60" rx="8"
                fill="#224433" stroke="#88ccff" stroke-width="2"></rect>
          <text x="340" y="85" fill="#cfeaff" text-anchor="middle" font-size="14">Phase-E Engine</text>
          
          <rect x="480" y="50" width="260" height="60" rx="8"
                fill="#226633" stroke="#99ffaa" stroke-width="2"></rect>
          <text x="610" y="85" fill="#d8ffd8" text-anchor="middle" font-size="14">
            Correlation Matrix + Interpretation
          </text>
          
          <line x1="180" y1="80" x2="240" y2="80" stroke="#66aaff" stroke-width="3"/>
          <line x1="440" y1="80" x2="480" y2="80" stroke="#88ccff" stroke-width="3"/>
        </svg>
      </div>
      
      <!-- SVG Diagram 2: SHAI Flow -->
      <div style="padding: 20px; border-top: 1px solid #2a2a2a;">
        <h3 style="color: #4a9eff; margin-bottom: 15px;">üî∑ SHAI Computation Flow</h3>
        <svg width="100%" height="160" viewBox="0 0 850 160" xmlns="http://www.w3.org/2000/svg">
          <rect x="20" y="40" width="220" height="60" rx="8"
                fill="#223344" stroke="#55aaff" stroke-width="2"></rect>
          <text x="130" y="75" fill="#cfeaff" text-anchor="middle" font-size="14">UNNS Substrate</text>
          
          <rect x="300" y="40" width="220" height="60" rx="8"
                fill="#223322" stroke="#77dd77" stroke-width="2"></rect>
          <text x="410" y="75" fill="#ddffdd" text-anchor="middle" font-size="14">Hardware Metrics</text>
          
          <rect x="580" y="40" width="250" height="60" rx="8"
                fill="#331111" stroke="#ff8888" stroke-width="2"></rect>
          <text x="705" y="75" fill="#ffdddd" text-anchor="middle" font-size="14">SHAI Alignment Score</text>
          
          <line x1="240" y1="70" x2="300" y2="70" stroke="#66aaff" stroke-width="3"/>
          <line x1="520" y1="70" x2="580" y2="70" stroke="#77dd77" stroke-width="3"/>
        </svg>
      </div>
      
      <!-- Phase-E for Researchers -->
      <div style="padding: 20px; border-top: 1px solid #2a2a2a;">
        <div class="unns-gradient-block" style="background: linear-gradient(135deg, #1a2a3a 0%, #2a1a3a 100%); padding: 20px; border-radius: 8px; border: 1px solid rgba(74, 158, 255, 0.3);">
          <h2 style="color: #4aff4a; margin-bottom: 15px;">Phase-E for Researchers</h2>
          
          <p style="margin-bottom: 15px; line-height: 1.6;">
            Phase-E is the first system in quantum information science that connects
            <strong style="color: #4a9eff;">algorithmic structure (UNNS substrate)</strong> with
            <strong style="color: #ffa54a;">hardware behavior (NISQ metrics)</strong> in a quantitative,
            reproducible way.
          </p>
          
          <h3 style="color: #4a9eff; margin: 20px 0 10px;">What You Can Investigate</h3>
          <ul style="margin-left: 20px; line-height: 1.8; color: #ccc;">
            <li><strong style="color: #8cffc9;">How circuit depth interacts with œÑ-Curvature</strong><br>
                <span style="color: #aaa; font-size: 0.9em;">‚Üí Does hardware stress scale with recursive strain?</span></li>
            
            <li><strong style="color: #8cffc9;">Which hardware platforms are more œÜ-stable?</strong><br>
                <span style="color: #aaa; font-size: 0.9em;">‚Üí Are certain qubit technologies less phase-sensitive?</span></li>
            
            <li><strong style="color: #8cffc9;">Does closure stability predict fidelity?</strong><br>
                <span style="color: #aaa; font-size: 0.9em;">‚Üí Strong correlations suggest "closure" captures robustness.</span></li>
            
            <li><strong style="color: #8cffc9;">When does UPI spike?</strong><br>
                <span style="color: #aaa; font-size: 0.9em;">‚Üí Late-stage collapse behaviour may indicate fragility zones.</span></li>
            
            <li><strong style="color: #8cffc9;">Cross-algorithm universals</strong><br>
                <span style="color: #aaa; font-size: 0.9em;">‚Üí Does QFT behave like Grover at the substrate level?</span></li>
          </ul>
          
          <h3 style="color: #4a9eff; margin: 20px 0 10px;">Why Phase-E Matters</h3>
          <div style="background: rgba(74, 255, 74, 0.1); padding: 15px; border-radius: 4px; border-left: 3px solid #4aff4a; margin-top: 10px;">
            <p style="line-height: 1.6;">
              For the first time, we can say:
              <em style="color: #ffe48c;">"This algorithmic structure aligns (or misaligns) with this hardware model."</em>
              This is historically new and opens a research direction that did not exist before UNNS.
            </p>
          </div>
        </div>
      </div>
      
      <!-- Phase-E for Developers -->
      <div style="padding: 20px; border-top: 1px solid #2a2a2a;">
        <div class="unns-gradient-block" style="background: linear-gradient(135deg, #1a2a1a 0%, #1a1a2a 100%); padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 165, 74, 0.3);">
          <h2 style="color: #ffa54a; margin-bottom: 15px;">üß© Phase-E for Developers</h2>
          
          <p style="margin-bottom: 15px; line-height: 1.6;">
            The Phase-E Suite exposes a stable input structure:
            <code style="background: #0a0a0a; padding: 2px 6px; border-radius: 3px; color: #4a9eff;">records[]</code> and 
            <code style="background: #0a0a0a; padding: 2px 6px; border-radius: 3px; color: #4a9eff;">hardware[]</code>.
            If you can construct these two arrays, the engine will:
          </p>
          
          <ul style="margin-left: 20px; line-height: 1.8; color: #ccc;">
            <li>‚úì Auto-detect platforms</li>
            <li>‚úì Auto-resolve metric columns</li>
            <li>‚úì Compute correlation matrices</li>
            <li>‚úì Build SHAI tables</li>
            <li>‚úì Produce detailed interpretation</li>
          </ul>
          
          <h3 style="color: #ffa54a; margin: 20px 0 10px;">Developer Tips</h3>
          <div style="background: rgba(255, 165, 74, 0.05); padding: 15px; border-radius: 4px; border-left: 3px solid #ffa54a;">
            <ul style="margin-left: 20px; line-height: 1.8; color: #aaa; font-size: 0.95em;">
              <li>Use <code style="background: #0a0a0a; padding: 2px 4px; border-radius: 2px;">platform_tag</code> consistently in both circuit and hardware files.</li>
              <li>Metrics must be numeric (no strings).</li>
              <li>Missing metrics automatically become <code style="background: #0a0a0a; padding: 2px 4px; border-radius: 2px;">null</code> and are ignored.</li>
              <li>The engine tolerates variable-length metric sets.</li>
              <li>SHAI requires the overlap of at least 4 substrate metrics + 4 hardware metrics.</li>
              <li>Export bundles are versioned (Phase-E v1.1 + SHAI v0.1).</li>
            </ul>
          </div>
          
          <h3 style="color: #ffa54a; margin: 20px 0 10px;">API Surface</h3>
          <div class="code-example" style="background: #0a0a0a; padding: 15px; border-radius: 4px; border: 1px solid #2a2a2a; font-size: 0.85em; overflow-x: auto;">
<span style="color: #888;">// Core API methods</span>
PhaseECore.loadCircuitsBatch(json)
PhaseECore.loadHardwareLogs(json)
PhaseECore.runDiagnosticsOnAll(onProgress)
PhaseECore.computeCorrelationMatrix()
PhaseECore.computeSHAI()
PhaseECore.buildPhaseEBundle()

<span style="color: #888;">// UI rendering</span>
PhaseEUI._renderMatrix(corrMatrix)
PhaseEUI.renderSHAI(core)
PhaseEUI._toggleHighlight()</div>
        </div>
      </div>
      
      <!-- SVG Diagram 3: Algorithm Nest to Phase-E -->
      <div style="padding: 20px; border-top: 1px solid #2a2a2a;">
        <h3 style="color: #4a9eff; margin-bottom: 15px;">üî¨ Algorithm ‚Üí UNNS ‚Üí Phase-E Pipeline</h3>
        <svg width="100%" height="220" viewBox="0 0 900 220" xmlns="http://www.w3.org/2000/svg">
          <rect x="20"  y="80" width="200" height="60" rx="8"
                fill="#223344" stroke="#aaffaa" stroke-width="2"/>
          <text x="120" y="115" fill="#cfeaff" text-anchor="middle" font-size="14">
            Algorithm Nest (XXIV)
          </text>
          
          <rect x="260" y="40" width="170" height="40" rx="8"
                fill="#224444" stroke="#88aaff" stroke-width="2"/>
          <text x="345" y="65" fill="#cfeaff" text-anchor="middle" font-size="14">œÑ-Curvature</text>
          
          <rect x="260" y="100" width="170" height="40" rx="8"
                fill="#224444" stroke="#88aaff" stroke-width="2"/>
          <text x="345" y="125" fill="#cfeaff" text-anchor="middle" font-size="14">œÜ-Resonance</text>
          
          <rect x="260" y="160" width="170" height="40" rx="8"
                fill="#224444" stroke="#88aaff" stroke-width="2"/>
          <text x="345" y="185" fill="#cfeaff" text-anchor="middle" font-size="14">Closure / UPI</text>
          
          <rect x="480" y="80" width="240" height="60" rx="8"
                fill="#226622" stroke="#99ff99" stroke-width="2"></rect>
          <text x="600" y="115" fill="#ddffdd" text-anchor="middle" font-size="14">Phase-E Pipelines</text>
          
          <line x1="220" y1="110" x2="260" y2="60"  stroke="#aaffaa" stroke-width="3"/>
          <line x1="220" y1="110" x2="260" y2="120" stroke="#aaffaa" stroke-width="3"/>
          <line x1="220" y1="110" x2="260" y2="180" stroke="#aaffaa" stroke-width="3"/>
          <line x1="430" y1="60" x2="480" y2="110" stroke="#99ff99" stroke-width="3"/>
          <line x1="430" y1="120" x2="480" y2="110" stroke="#99ff99" stroke-width="3"/>
          <line x1="430" y1="180" x2="480" y2="110" stroke="#99ff99" stroke-width="3"/>
        </svg>
      </div>
      </div><!-- End extendedGuideBody -->
    </div>
    
    <!-- Phase-E Activation Button -->
    <div style="text-align: center; margin: 20px 0;">
      <button id="btnActivatePhaseE" onclick="document.getElementById('xxivPhaseEPanel').style.display='block'; this.style.display='none';" 
              style="background: linear-gradient(135deg, #2a4a7a 0%, #4a2a7a 100%); border: none; color: #e0e0e0; font-size: 1.1em; padding: 15px 30px; border-radius: 6px; cursor: pointer; box-shadow: 0 4px 8px rgba(74, 158, 255, 0.2);">
        üî¨ Activate Phase-E Hybrid Mode
      </button>
    </div>
    
  </div>
  
  <script>
/**
 * UNNS Laboratory ‚Äî Chamber XXIV: Quantum Algorithm Structural Diagnostics
 * Version 1.0.0
 * 
 * Analyzes quantum algorithms via UNNS operator mapping and substrate diagnostics:
 * - œÑ-curvature profile (structural strain)
 * - œÜ-resonance spectrum (depth resonance)
 * - UPI paradox field (interferential instability)
 * - Closure stability (structure conservation)
 * - Residue & torsion flow (decoherence propagation)
 */

console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('UNNS Chamber XXIV | QASD | v1.0.0');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

// ==========================================
// GATE ‚Üí OPERATOR MAPPING
// ==========================================

const GATE_MAP = {
  // Standard quantum gates
  'H': 'APERTURE',
  'X': 'FOLD2',
  'Y': 'FOLD2',
  'Z': 'PRISM',
  'S': 'PRISM',
  'T': 'PRISM',
  'CNOT': 'INTERLACE',
  'CZ': 'PRISM',
  'SWAP': 'CLOSURE',
  'MEASURE': 'COLLAPSE',
  
  // Direct UNNS operators (passthrough)
  'XIII': 'INTERLACE',
  'XIV': 'PHI_SCALE',
  'XV': 'PRISM',
  'XVI': 'CLOSURE',
  'XVII': 'GEOMETRY',
  'XVIII': 'HORIZON',
  'APERTURE': 'APERTURE',
  'FOLD2': 'FOLD2',
  'PRISM': 'PRISM',
  'INTERLACE': 'INTERLACE',
  'CLOSURE': 'CLOSURE',
  'COLLAPSE': 'COLLAPSE'
};

// ==========================================
// KERNEL FUNCTIONS
// ==========================================

class OperatorKernels {
  constructor(seed = 137) {
    this.rng = this.createSeededRNG(seed);
  }
  
  createSeededRNG(seed) {
    let state = seed >>> 0;
    return {
      random() {
        state = (state * 1664525 + 1013904223) >>> 0;
        return state / 4294967296;
      },
      gaussian() {
        let u1 = this.random();
        let u2 = this.random();
        if (u1 < 1e-10) u1 = 1e-10;
        return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      }
    };
  }
  
  // APERTURE: Superposition expansion
  apertureKernel(state, targets) {
    return {
      phi_delta: 0.3 * targets.length,
      tau_delta: 0.05 * targets.length,
      torsion_delta: 0.1,
      residue_delta: 0.0,
      closure_delta: 0.0
    };
  }
  
  // FOLD2: Local torsion
  foldKernel(state, targets) {
    return {
      phi_delta: 0.0,
      tau_delta: 0.4 * targets.length,
      torsion_delta: 0.5 * targets.length,
      residue_delta: 0.1,
      closure_delta: 0.0
    };
  }
  
  // PRISM: Phase-like warping
  prismKernel(state, targets) {
    return {
      phi_delta: 0.25 * targets.length,
      tau_delta: 0.2 * targets.length,
      torsion_delta: 0.15,
      residue_delta: 0.05,
      closure_delta: 0.0
    };
  }
  
  // INTERLACE: Entanglement (high œÑ spike)
  interlaceKernel(state, targets) {
    const coupling_factor = targets.length > 1 ? targets.length * 0.5 : 1.0;
    return {
      phi_delta: 0.1,
      tau_delta: 0.8 * coupling_factor,
      torsion_delta: 0.6 * coupling_factor,
      residue_delta: 0.3 * coupling_factor,
      closure_delta: -0.1
    };
  }
  
  // CLOSURE: Exchange/swap
  closureKernel(state, targets) {
    return {
      phi_delta: 0.0,
      tau_delta: 0.15,
      torsion_delta: 0.1,
      residue_delta: 0.0,
      closure_delta: 0.05 // Slight closure recalc
    };
  }
  
  // COLLAPSE: Measurement
  collapseKernel(state, targets) {
    return {
      phi_delta: 0.0,
      tau_delta: 0.1,
      torsion_delta: 0.2,
      residue_delta: 0.5 * targets.length,
      closure_delta: -0.3 // Closure drop
    };
  }
  
  // PHI_SCALE: Phase perturbation (XIV)
  phiScaleKernel(state, targets) {
    return {
      phi_delta: 0.4 * targets.length,
      tau_delta: 0.1,
      torsion_delta: 0.1,
      residue_delta: 0.0,
      closure_delta: 0.0
    };
  }
  
  // GEOMETRY: Curvature analysis (XVII)
  geometryKernel(state, targets) {
    return {
      phi_delta: 0.2,
      tau_delta: 0.6 * targets.length,
      torsion_delta: 0.4,
      residue_delta: 0.1,
      closure_delta: 0.0
    };
  }
  
  // HORIZON: Boundary effects (XVIII)
  horizonKernel(state, targets) {
    return {
      phi_delta: 0.15,
      tau_delta: 0.3,
      torsion_delta: 0.25,
      residue_delta: 0.2,
      closure_delta: -0.05
    };
  }
}

// ==========================================
// NEST TRACE BUILDER
// ==========================================

class NestTraceBuilder {
  constructor(operatorWord, qubits, mode = 'relaxed', seed = 137) {
    this.operatorWord = operatorWord;
    this.qubits = qubits;
    this.mode = mode;
    this.kernels = new OperatorKernels(seed);
    this.trace = [];
    
    // Smoothing parameters for relaxed mode
    this.tau_lowpass = mode === 'relaxed' ? 0.7 : 1.0;
    this.phi_lowpass = mode === 'relaxed' ? 0.6 : 1.0;
    this.upi_norm = mode === 'relaxed';
  }
  
  build() {
    let state = {
      phi: 0.0,
      tau: 0.0,
      torsion: 0.0,
      residue: 0.0,
      closure: 1.0
    };
    
    this.trace = [];
    
    for (let i = 0; i < this.operatorWord.length; i++) {
      const op = this.operatorWord[i];
      const unnsOp = GATE_MAP[op.op] || 'UNKNOWN';
      
      // Execute kernel
      let delta;
      switch(unnsOp) {
        case 'APERTURE':
          delta = this.kernels.apertureKernel(state, op.targets);
          break;
        case 'FOLD2':
          delta = this.kernels.foldKernel(state, op.targets);
          break;
        case 'PRISM':
          delta = this.kernels.prismKernel(state, op.targets);
          break;
        case 'INTERLACE':
          delta = this.kernels.interlaceKernel(state, op.targets);
          break;
        case 'CLOSURE':
          delta = this.kernels.closureKernel(state, op.targets);
          break;
        case 'COLLAPSE':
          delta = this.kernels.collapseKernel(state, op.targets);
          break;
        case 'PHI_SCALE':
          delta = this.kernels.phiScaleKernel(state, op.targets);
          break;
        case 'GEOMETRY':
          delta = this.kernels.geometryKernel(state, op.targets);
          break;
        case 'HORIZON':
          delta = this.kernels.horizonKernel(state, op.targets);
          break;
        default:
          // Unknown operator - minimal impact
          delta = {
            phi_delta: 0.05,
            tau_delta: 0.05,
            torsion_delta: 0.05,
            residue_delta: 0.05,
            closure_delta: 0.0
          };
      }
      
      // Update state
      state.phi += delta.phi_delta;
      state.tau += delta.tau_delta;
      state.torsion += delta.torsion_delta;
      state.residue += delta.residue_delta;
      state.closure = Math.max(0, Math.min(1, state.closure + delta.closure_delta));
      
      // Apply smoothing in relaxed mode
      if (this.mode === 'relaxed' && this.trace.length > 0) {
        const prev = this.trace[this.trace.length - 1];
        state.tau = this.tau_lowpass * state.tau + (1 - this.tau_lowpass) * prev.tau_local;
        state.phi = this.phi_lowpass * state.phi + (1 - this.phi_lowpass) * prev.phi_local;
      }
      
      // Store trace entry
      this.trace.push({
        layer: i,
        op: op.op,
        unns_op: unnsOp,
        targets: op.targets,
        phi_local: state.phi,
        tau_local: state.tau,
        torsion_local: state.torsion,
        residue_local: state.residue,
        closure_local: state.closure
      });
    }
    
    return this.trace;
  }
}

// ==========================================
// DIAGNOSTICS ENGINE
// ==========================================

class DiagnosticsEngine {
  constructor(trace, mode = 'relaxed') {
    this.trace = trace;
    this.mode = mode;
    this.results = null;
  }
  
  compute() {
    const tau_profile = this.trace.map(t => t.tau_local);
    const phi_spectrum = this.trace.map(t => t.phi_local);
    const upi_field = this.computeUPIField();
    const residue_graph = this.buildResidueGraph();
    const closure_index = this.trace.map(t => t.closure_local);
    
    this.results = {
      tau_profile,
      phi_spectrum,
      upi_field,
      residue_graph,
      closure_index,
      metrics: {
        max_tau: Math.max(...tau_profile),
        peak_phi: Math.max(...phi_spectrum),
        max_upi: Math.max(...upi_field),
        min_closure: Math.min(...closure_index),
        avg_residue: this.trace.reduce((s, t) => s + t.residue_local, 0) / this.trace.length
      }
    };
    
    return this.results;
  }
  
  computeUPIField() {
    // UPI = normalized paradox pressure
    // Based on œÑ, œÜ, and residue interaction
    return this.trace.map((t, i) => {
      const tau_contrib = Math.min(1, t.tau_local / 3.0);
      const phi_contrib = Math.min(1, t.phi_local / 2.0);
      const residue_contrib = Math.min(1, t.residue_local);
      const torsion_contrib = Math.min(1, t.torsion_local / 2.0);
      
      let upi = 0.3 * tau_contrib + 0.2 * phi_contrib + 0.3 * residue_contrib + 0.2 * torsion_contrib;
      
      // Normalize if in relaxed mode
      if (this.mode === 'relaxed') {
        upi = upi / Math.sqrt(this.trace.length);
      }
      
      return Math.min(1, upi);
    });
  }
  
  buildResidueGraph() {
    // Build propagation graph
    const nodes = this.trace.map((t, i) => ({
      layer: i,
      residue: t.residue_local,
      torsion: t.torsion_local
    }));
    
    const edges = [];
    for (let i = 0; i < this.trace.length - 1; i++) {
      const weight = this.trace[i].residue_local * this.trace[i+1].torsion_local;
      edges.push({
        from: i,
        to: i + 1,
        weight: weight
      });
    }
    
    return { nodes, edges };
  }
}

// ==========================================
// VALIDATION ENGINE
// ==========================================

class XXIVValidationEngine {
  constructor(exportData) {
    this.data = exportData;
    this.errors = [];
    this.warnings = [];
  }

  run() {
    const d = this.data.diagnostics;
    const trace = this.data.trace;
    const depth = this.data.algorithm.depth;

    // 1) Length checks
    this.checkArrayLength(d.tau_profile, depth, 'tau_profile');
    this.checkArrayLength(d.phi_spectrum, depth, 'phi_spectrum');
    this.checkArrayLength(d.upi_field, depth, 'upi_field');
    this.checkArrayLength(d.closure_index, depth, 'closure_index');
    this.checkArrayLength(d.residue_graph.nodes, depth, 'residue_graph.nodes');
    this.checkArrayLength(d.residue_graph.edges, depth - 1, 'residue_graph.edges');

    // 2) Metrics consistency
    this.checkMetric('max_tau',
      Math.max(...d.tau_profile),
      d.metrics.max_tau,
      1e-6
    );
    this.checkMetric('peak_phi',
      Math.max(...d.phi_spectrum),
      d.metrics.peak_phi,
      1e-6
    );
    this.checkMetric('max_upi',
      Math.max(...d.upi_field),
      d.metrics.max_upi,
      1e-6
    );
    this.checkMetric('min_closure',
      Math.min(...d.closure_index),
      d.metrics.min_closure,
      1e-6
    );

    // 3) Ranges
    d.upi_field.forEach((v, i) => {
      if (v < 0 || v > 1) this.errors.push(`UPI out of [0,1] at layer ${i}: ${v}`);
    });
    d.closure_index.forEach((v, i) => {
      if (v < 0 || v > 1) this.errors.push(`Closure out of [0,1] at layer ${i}: ${v}`);
    });

    // 4) Residue graph sanity
    d.residue_graph.edges.forEach((e, idx) => {
      if (e.to !== e.from + 1) {
        this.warnings.push(`Non-sequential edge at index ${idx}: ${e.from}‚Üí${e.to}`);
      }
    });

    // 5) Trace alignment
    if (trace.length !== depth) {
      this.errors.push(`Trace length (${trace.length}) != depth (${depth})`);
    }

    return {
      ok: this.errors.length === 0,
      errors: this.errors,
      warnings: this.warnings
    };
  }

  checkArrayLength(arr, expected, label) {
    if (!Array.isArray(arr)) {
      this.errors.push(`${label} is not an array`);
      return;
    }
    if (arr.length !== expected) {
      this.errors.push(`${label}.length (${arr.length}) != depth (${expected})`);
    }
  }

  checkMetric(label, recomputed, reported, eps) {
    if (Math.abs(recomputed - reported) > eps) {
      this.warnings.push(
        `Metric mismatch for ${label}: recomputed=${recomputed}, reported=${reported}`
      );
    }
  }
}

// ==========================================
// VISUALIZATION
// ==========================================

class DiagnosticsRenderer {
  constructor() {
    this.canvases = {
      tau: document.getElementById('canvasTau'),
      phi: document.getElementById('canvasPhi'),
      upi: document.getElementById('canvasUPI'),
      closure: document.getElementById('canvasClosure'),
      residue: document.getElementById('canvasResidue')
    };
    
    this.tooltips = {
      tau: document.getElementById('tooltipTau'),
      phi: document.getElementById('tooltipPhi'),
      upi: document.getElementById('tooltipUPI'),
      closure: document.getElementById('tooltipClosure'),
      residue: document.getElementById('tooltipResidue')
    };
    
    this.contexts = {};
    for (let key in this.canvases) {
      this.contexts[key] = this.canvases[key].getContext('2d');
    }
    
    // Store data for tooltips
    this.data = null;
    this.trace = null;
    
    this.setupCanvases();
    this.setupTooltips();
  }
  
  setupCanvases() {
    const dpr = window.devicePixelRatio || 1;
    for (let key in this.canvases) {
      const canvas = this.canvases[key];
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = this.contexts[key];
      ctx.scale(dpr, dpr);
    }
  }
  
  setupTooltips() {
    // Tau profile tooltips
    this.canvases.tau.addEventListener('mousemove', (e) => this.handleTauTooltip(e));
    this.canvases.tau.addEventListener('mouseleave', () => this.hideTooltip('tau'));
    
    // Phi spectrum tooltips
    this.canvases.phi.addEventListener('mousemove', (e) => this.handlePhiTooltip(e));
    this.canvases.phi.addEventListener('mouseleave', () => this.hideTooltip('phi'));
    
    // UPI field tooltips
    this.canvases.upi.addEventListener('mousemove', (e) => this.handleUPITooltip(e));
    this.canvases.upi.addEventListener('mouseleave', () => this.hideTooltip('upi'));
    
    // Closure tooltips
    this.canvases.closure.addEventListener('mousemove', (e) => this.handleClosureTooltip(e));
    this.canvases.closure.addEventListener('mouseleave', () => this.hideTooltip('closure'));
    
    // Residue graph tooltips
    this.canvases.residue.addEventListener('mousemove', (e) => this.handleResidueTooltip(e));
    this.canvases.residue.addEventListener('mouseleave', () => this.hideTooltip('residue'));
  }
  
  hideTooltip(key) {
    this.tooltips[key].classList.remove('visible');
  }
  
  showTooltip(key, x, y, content) {
    const tooltip = this.tooltips[key];
    tooltip.innerHTML = content;
    tooltip.style.left = `${x + 10}px`;
    tooltip.style.top = `${y + 10}px`;
    tooltip.classList.add('visible');
  }
  
  handleTauTooltip(e) {
    if (!this.data || !this.trace) return;
    
    const rect = this.canvases.tau.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const padding = 40;
    
    if (x < padding || x > rect.width - padding) return;
    
    const plotW = rect.width - 2 * padding;
    const layer = Math.floor((x - padding) / plotW * this.data.tau_profile.length);
    
    if (layer >= 0 && layer < this.data.tau_profile.length) {
      const tau = this.data.tau_profile[layer];
      const op = this.trace[layer];
      
      let status = tau < 1.0 ? 'Low' : tau < 2.0 ? 'Moderate' : 'High';
      let statusClass = tau < 1.0 ? '' : tau < 2.0 ? 'warning' : 'danger';
      
      const content = `
        <div class="tooltip-label">Layer ${layer}</div>
        <div>Operator: ${op.op} ‚Üí ${op.unns_op}</div>
        <div>œÑ-Curvature: <span class="tooltip-value ${statusClass}">${tau.toFixed(4)}</span></div>
        <div>Targets: [${op.targets.join(', ')}]</div>
        <div class="tooltip-info">Structural strain: ${status}</div>
      `;
      
      this.showTooltip('tau', e.clientX - rect.left, e.clientY - rect.top, content);
    }
  }
  
  handlePhiTooltip(e) {
    if (!this.data || !this.trace) return;
    
    const rect = this.canvases.phi.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const padding = 40;
    
    if (x < padding || x > rect.width - padding) return;
    
    const plotW = rect.width - 2 * padding;
    const layer = Math.floor((x - padding) / plotW * this.data.phi_spectrum.length);
    
    if (layer >= 0 && layer < this.data.phi_spectrum.length) {
      const phi = this.data.phi_spectrum[layer];
      const op = this.trace[layer];
      
      const content = `
        <div class="tooltip-label">Layer ${layer}</div>
        <div>Operator: ${op.op} ‚Üí ${op.unns_op}</div>
        <div>œÜ-Resonance: <span class="tooltip-value">${phi.toFixed(4)}</span></div>
        <div>Targets: [${op.targets.join(', ')}]</div>
        <div class="tooltip-info">Depth resonance accumulation</div>
      `;
      
      this.showTooltip('phi', e.clientX - rect.left, e.clientY - rect.top, content);
    }
  }
  
  handleUPITooltip(e) {
    if (!this.data || !this.trace) return;
    
    const rect = this.canvases.upi.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const padding = 40;
    
    if (x < padding || x > rect.width - padding) return;
    
    const plotW = rect.width - 2 * padding;
    const barWidth = plotW / this.data.upi_field.length;
    const layer = Math.floor((x - padding) / barWidth);
    
    if (layer >= 0 && layer < this.data.upi_field.length) {
      const upi = this.data.upi_field[layer];
      const op = this.trace[layer];
      
      let status, statusClass;
      if (upi < 0.4) {
        status = 'Stable';
        statusClass = '';
      } else if (upi < 0.75) {
        status = 'Delicate';
        statusClass = 'warning';
      } else {
        status = 'Paradox Corridor';
        statusClass = 'danger';
      }
      
      const content = `
        <div class="tooltip-label">Layer ${layer}</div>
        <div>Operator: ${op.op} ‚Üí ${op.unns_op}</div>
        <div>UPI: <span class="tooltip-value ${statusClass}">${upi.toFixed(4)}</span></div>
        <div>Targets: [${op.targets.join(', ')}]</div>
        <div class="tooltip-info">Status: ${status}</div>
      `;
      
      this.showTooltip('upi', e.clientX - rect.left, e.clientY - rect.top, content);
    }
  }
  
  handleClosureTooltip(e) {
    if (!this.data || !this.trace) return;
    
    const rect = this.canvases.closure.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const padding = 40;
    
    if (x < padding || x > rect.width - padding) return;
    
    const plotW = rect.width - 2 * padding;
    const layer = Math.floor((x - padding) / plotW * this.data.closure_index.length);
    
    if (layer >= 0 && layer < this.data.closure_index.length) {
      const closure = this.data.closure_index[layer];
      const op = this.trace[layer];
      
      let status = closure > 0.8 ? 'Excellent' : closure > 0.6 ? 'Good' : 'Degraded';
      let statusClass = closure > 0.8 ? '' : closure > 0.6 ? 'warning' : 'danger';
      
      const content = `
        <div class="tooltip-label">Layer ${layer}</div>
        <div>Operator: ${op.op} ‚Üí ${op.unns_op}</div>
        <div>Closure: <span class="tooltip-value ${statusClass}">${closure.toFixed(4)}</span></div>
        <div>Targets: [${op.targets.join(', ')}]</div>
        <div class="tooltip-info">Conservation: ${status}</div>
      `;
      
      this.showTooltip('closure', e.clientX - rect.left, e.clientY - rect.top, content);
    }
  }
  
  handleResidueTooltip(e) {
    if (!this.data || !this.trace) return;
    
    const rect = this.canvases.residue.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const padding = 40;
    
    const graph = this.data.residue_graph;
    const plotW = rect.width - 2 * padding;
    const plotH = rect.height - 2 * padding;
    
    // Check if hovering over a node
    const nodePositions = graph.nodes.map((node, i) => {
      const x = padding + (i / (graph.nodes.length - 1)) * plotW;
      const y = rect.height / 2 + (node.torsion - 0.5) * plotH * 0.4;
      return { x, y, ...node };
    });
    
    const maxResidue = Math.max(...graph.nodes.map(n => n.residue), 1);
    
    for (let i = 0; i < nodePositions.length; i++) {
      const node = nodePositions[i];
      const radius = 3 + (node.residue / maxResidue) * 8;
      const dist = Math.sqrt((mouseX - node.x) ** 2 + (mouseY - node.y) ** 2);
      
      if (dist < radius + 5) {
        const op = this.trace[node.layer];
        
        let status = node.residue < 0.3 ? 'Low' : node.residue < 0.6 ? 'Moderate' : 'High';
        let statusClass = node.residue < 0.3 ? '' : node.residue < 0.6 ? 'warning' : 'danger';
        
        const content = `
          <div class="tooltip-label">Layer ${node.layer}</div>
          <div>Operator: ${op.op} ‚Üí ${op.unns_op}</div>
          <div>Residue: <span class="tooltip-value ${statusClass}">${node.residue.toFixed(4)}</span></div>
          <div>Torsion: <span class="tooltip-value">${node.torsion.toFixed(4)}</span></div>
          <div class="tooltip-info">Decoherence: ${status}</div>
        `;
        
        this.showTooltip('residue', mouseX, mouseY, content);
        return;
      }
    }
    
    this.hideTooltip('residue');
  }
  
  renderAll(results, trace) {
    this.data = results;
    this.trace = trace;
    
    this.renderProfile(results.tau_profile, 'tau', '#4a9eff', 'œÑ-Curvature');
    this.renderProfile(results.phi_spectrum, 'phi', '#ff4a9e', 'œÜ-Resonance');
    this.renderUPIField(results.upi_field);
    this.renderProfile(results.closure_index, 'closure', '#4aff4a', 'Closure', 0, 1);
    this.renderResidueGraph(results.residue_graph);
  }
  
  renderProfile(data, canvasKey, color, label, yMin = null, yMax = null) {
    const canvas = this.canvases[canvasKey];
    const ctx = this.contexts[canvasKey];
    const rect = canvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    const padding = 40;
    
    ctx.clearRect(0, 0, w, h);
    
    if (data.length === 0) return;
    
    const min = yMin !== null ? yMin : Math.min(...data);
    const max = yMax !== null ? yMax : Math.max(...data);
    const range = max - min || 1;
    
    const plotW = w - 2 * padding;
    const plotH = h - 2 * padding;
    
    // Draw axes
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, h - padding);
    ctx.lineTo(w - padding, h - padding);
    ctx.stroke();
    
    // Draw data
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i < data.length; i++) {
      const x = padding + (i / (data.length - 1)) * plotW;
      const y = h - padding - ((data[i] - min) / range) * plotH;
      
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    // Labels
    ctx.fillStyle = '#888';
    ctx.font = '11px Consolas';
    ctx.fillText(`Min: ${min.toFixed(3)}`, padding, h - 10);
    ctx.fillText(`Max: ${max.toFixed(3)}`, w - padding - 80, h - 10);
    ctx.fillText(label, padding, padding - 10);
  }
  
  renderUPIField(upi_data) {
    const canvas = this.canvases.upi;
    const ctx = this.contexts.upi;
    const rect = canvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    const padding = 40;
    
    ctx.clearRect(0, 0, w, h);
    
    if (upi_data.length === 0) return;
    
    const plotW = w - 2 * padding;
    const plotH = h - 2 * padding;
    const barWidth = plotW / upi_data.length;
    
    // Draw bars with color coding
    for (let i = 0; i < upi_data.length; i++) {
      const upi = upi_data[i];
      const x = padding + i * barWidth;
      const barHeight = upi * plotH;
      const y = h - padding - barHeight;
      
      // Color based on UPI value
      let color;
      if (upi < 0.4) color = '#2a7a2a';
      else if (upi < 0.75) color = '#7a7a2a';
      else color = '#7a2a2a';
      
      ctx.fillStyle = color;
      ctx.fillRect(x, y, barWidth - 1, barHeight);
    }
    
    // Draw threshold lines
    ctx.strokeStyle = '#888';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 1;
    
    // 0.4 threshold
    let y = h - padding - 0.4 * plotH;
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(w - padding, y);
    ctx.stroke();
    
    // 0.75 threshold
    y = h - padding - 0.75 * plotH;
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(w - padding, y);
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // Labels
    ctx.fillStyle = '#888';
    ctx.font = '11px Consolas';
    ctx.fillText('UPI Field', padding, padding - 10);
    ctx.fillText('0.4', padding + 5, h - padding - 0.4 * plotH - 5);
    ctx.fillText('0.75', padding + 5, h - padding - 0.75 * plotH - 5);
  }
  
  renderResidueGraph(graph) {
    const canvas = this.canvases.residue;
    const ctx = this.contexts.residue;
    const rect = canvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    const padding = 40;
    
    ctx.clearRect(0, 0, w, h);
    
    if (graph.nodes.length === 0) return;
    
    const plotW = w - 2 * padding;
    const plotH = h - 2 * padding;
    
    // Layout nodes in a flow diagram
    const nodePositions = graph.nodes.map((node, i) => {
      const x = padding + (i / (graph.nodes.length - 1)) * plotW;
      const y = h / 2 + (node.torsion - 0.5) * plotH * 0.4;
      return { x, y, ...node };
    });
    
    // Draw edges with width based on weight
    const maxWeight = Math.max(...graph.edges.map(e => e.weight), 1);
    
    ctx.strokeStyle = '#4a9eff';
    graph.edges.forEach(edge => {
      const from = nodePositions[edge.from];
      const to = nodePositions[edge.to];
      const width = 1 + (edge.weight / maxWeight) * 5;
      
      ctx.lineWidth = width;
      ctx.globalAlpha = 0.3 + (edge.weight / maxWeight) * 0.5;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
    });
    
    ctx.globalAlpha = 1.0;
    
    // Draw nodes with size based on residue
    const maxResidue = Math.max(...graph.nodes.map(n => n.residue), 1);
    
    nodePositions.forEach(node => {
      const radius = 3 + (node.residue / maxResidue) * 8;
      
      ctx.fillStyle = node.residue > 0.5 ? '#ff4a4a' : '#4aff4a';
      ctx.beginPath();
      ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);
      ctx.fill();
      
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.stroke();
    });
    
    // Labels
    ctx.fillStyle = '#888';
    ctx.font = '11px Consolas';
    ctx.fillText('Residue Propagation Flow', padding, padding - 10);
    ctx.fillText('Node size = residue density', padding, h - 10);
    ctx.fillText('Edge width = propagation strength', w - padding - 200, h - 10);
  }
}

// ==========================================
// UI CONTROLLER
// ==========================================

class ChamberXXIVController {
  constructor() {
    this.algorithm = null;
    this.operatorWord = null;
    this.trace = null;
    this.diagnostics = null;
    this.renderer = new DiagnosticsRenderer();
    
    this.setupEventListeners();
    this.setupGuideToggle();
  }
  
  setupEventListeners() {
    document.getElementById('btnLoadExample').addEventListener('click', () => this.loadExample());
    document.getElementById('btnImport').addEventListener('click', () => this.importAlgorithm());
    document.getElementById('btnClear').addEventListener('click', () => this.clear());
    document.getElementById('btnRunDiagnostics').addEventListener('click', () => this.runDiagnostics());
    document.getElementById('btnExport').addEventListener('click', () => this.exportResults());
  }
  
  setupGuideToggle() {
    const guideToggle = document.getElementById('guideToggle');
    const guideContent = document.getElementById('guideContent');
    const interpretToggle = document.getElementById('interpretToggle');
    const interpretContent = document.getElementById('interpretContent');
    
    guideToggle.addEventListener('click', () => {
      guideToggle.classList.toggle('collapsed');
      guideContent.classList.toggle('collapsed');
    });
    
    interpretToggle.addEventListener('click', () => {
      interpretToggle.classList.toggle('collapsed');
      interpretContent.classList.toggle('collapsed');
    });
    
    // Start interpretation guide collapsed by default
    interpretToggle.classList.add('collapsed');
    interpretContent.classList.add('collapsed');
  }
  
  loadExample() {
    const selector = document.getElementById('exampleSelector').value;
    let example;
    
    switch(selector) {
      case 'grover':
        example = {
          "algorithm_name": "Grover Search (3-qubit)",
          "qubits": 3,
          "operators": [
            {"op": "H", "targets": [0, 1, 2]},
            {"op": "X", "targets": [0, 1]},
            {"op": "CNOT", "targets": [1, 2]},
            {"op": "H", "targets": [0]},
            {"op": "CNOT", "targets": [0, 1]},
            {"op": "H", "targets": [0]},
            {"op": "X", "targets": [0, 1]},
            {"op": "CZ", "targets": [1, 2]},
            {"op": "X", "targets": [0, 1]},
            {"op": "H", "targets": [0, 1, 2]},
            {"op": "MEASURE", "targets": [0, 1, 2]}
          ]
        };
        break;
        
      case 'qft5':
        example = {
          "algorithm_name": "QFT-5 (simplified)",
          "qubits": 5,
          "operators": [
            { "op": "H", "targets": [0] },
            { "op": "CZ", "targets": [0,1] },
            { "op": "CZ", "targets": [0,2] },
            { "op": "CZ", "targets": [0,3] },
            { "op": "CZ", "targets": [0,4] },
            { "op": "H", "targets": [1] },
            { "op": "CZ", "targets": [1,2] },
            { "op": "CZ", "targets": [1,3] },
            { "op": "CZ", "targets": [1,4] },
            { "op": "H", "targets": [2] },
            { "op": "CZ", "targets": [2,3] },
            { "op": "CZ", "targets": [2,4] },
            { "op": "H", "targets": [3] },
            { "op": "CZ", "targets": [3,4] },
            { "op": "H", "targets": [4] },
            { "op": "SWAP", "targets": [0,4] },
            { "op": "SWAP", "targets": [1,3] },
            { "op": "MEASURE", "targets": [0,1,2,3,4] }
          ]
        };
        break;
        
      case 'toffoli':
        example = {
          "algorithm_name": "Toffoli (3-qubit)",
          "qubits": 3,
          "operators": [
            { "op": "H", "targets": [2] },
            { "op": "CNOT", "targets": [1,2] },
            { "op": "T", "targets": [2] },
            { "op": "CNOT", "targets": [0,2] },
            { "op": "T", "targets": [2] },
            { "op": "CNOT", "targets": [1,2] },
            { "op": "T", "targets": [2] },
            { "op": "CNOT", "targets": [0,2] },
            { "op": "S", "targets": [2] },
            { "op": "H", "targets": [2] },
            { "op": "MEASURE", "targets": [0,1,2] }
          ]
        };
        break;
        
      case 'qaoa1':
        example = {
          "algorithm_name": "QAOA-1 MaxCut (3-ring)",
          "qubits": 3,
          "operators": [
            { "op": "H", "targets": [0,1,2] },
            { "op": "CZ", "targets": [0,1] },
            { "op": "CZ", "targets": [1,2] },
            { "op": "CZ", "targets": [2,0] },
            { "op": "X", "targets": [0] },
            { "op": "X", "targets": [1] },
            { "op": "X", "targets": [2] },
            { "op": "MEASURE", "targets": [0,1,2] }
          ]
        };
        break;
        
      case 'qaoa2':
        example = {
          "algorithm_name": "QAOA-2 MaxCut (3-ring)",
          "qubits": 3,
          "operators": [
            { "op": "H", "targets": [0,1,2] },
            { "op": "CZ", "targets": [0,1] },
            { "op": "CZ", "targets": [1,2] },
            { "op": "CZ", "targets": [2,0] },
            { "op": "X", "targets": [0,1,2] },
            { "op": "CZ", "targets": [0,1] },
            { "op": "CZ", "targets": [1,2] },
            { "op": "CZ", "targets": [2,0] },
            { "op": "X", "targets": [0,1,2] },
            { "op": "MEASURE", "targets": [0,1,2] }
          ]
        };
        break;
        
      case 'vqe':
        example = {
          "algorithm_name": "VQE Ansatz (2-qubit)",
          "qubits": 2,
          "operators": [
            { "op": "H", "targets": [0] },
            { "op": "CNOT", "targets": [0,1] },
            { "op": "Z", "targets": [0] },
            { "op": "X", "targets": [1] },
            { "op": "Z", "targets": [1] },
            { "op": "CNOT", "targets": [0,1] },
            { "op": "MEASURE", "targets": [0,1] }
          ]
        };
        break;
    }
    
    document.getElementById('algJSON').value = JSON.stringify(example, null, 2);
    document.getElementById('algName').value = example.algorithm_name;
    document.getElementById('algQubits').value = example.qubits;
    
    this.showStatus('statusImport', `Example loaded: ${example.algorithm_name}`, 'info');
    console.log(`üìã Example algorithm loaded: ${example.algorithm_name}`);
  }
  
  importAlgorithm() {
    try {
      const jsonText = document.getElementById('algJSON').value.trim();
      if (!jsonText) {
        throw new Error('No JSON provided');
      }
      
      this.algorithm = JSON.parse(jsonText);
      
      // Validate schema
      if (!this.algorithm.algorithm_name || !this.algorithm.qubits || !this.algorithm.operators) {
        throw new Error('Invalid schema: missing required fields');
      }
      
      if (!Array.isArray(this.algorithm.operators)) {
        throw new Error('operators must be an array');
      }
      
      // Map to operator word
      this.operatorWord = this.algorithm.operators.map(op => {
        if (!op.op || !op.targets) {
          throw new Error('Each operator must have "op" and "targets"');
        }
        return {
          op: op.op,
          targets: Array.isArray(op.targets) ? op.targets : [op.targets],
          params: op.params || {}
        };
      });
      
      // Update UI
      this.displayOperatorWord();
      document.getElementById('btnRunDiagnostics').disabled = false;
      
      this.showStatus('statusImport', `Algorithm imported: ${this.operatorWord.length} operators`, 'success');
      console.log(`‚úÖ Imported: ${this.algorithm.algorithm_name} (${this.operatorWord.length} ops)`);
      
    } catch (error) {
      this.showStatus('statusImport', `Import error: ${error.message}`, 'error');
      console.error('‚ùå Import error:', error);
    }
  }
  
  displayOperatorWord() {
    const display = document.getElementById('operatorWordDisplay');
    display.innerHTML = '';
    
    this.operatorWord.forEach((op, i) => {
      const unnsOp = GATE_MAP[op.op] || 'UNKNOWN';
      const item = document.createElement('div');
      item.className = 'operator-item';
      item.innerHTML = `
        <div>
          <span style="color: #666;">${i}:</span>
          <span class="operator-name">${op.op}</span>
          <span style="color: #888;"> ‚Üí ${unnsOp}</span>
        </div>
        <div class="operator-targets">targets: [${op.targets.join(', ')}]</div>
      `;
      display.appendChild(item);
    });
    
    document.getElementById('badgeOperators').textContent = `${this.operatorWord.length} ops`;
  }
  
  runDiagnostics() {
    try {
      this.showStatus('statusDiagnostics', 'Building nest trace...', 'info');
      console.log('üöÄ Running diagnostics...');
      
      const mode = document.getElementById('algMode').value;
      const seed = parseInt(document.getElementById('algSeed').value);
      const qubits = this.algorithm.qubits;
      
      // Build trace
      const builder = new NestTraceBuilder(this.operatorWord, qubits, mode, seed);
      this.trace = builder.build();
      
      this.showStatus('statusDiagnostics', 'Computing diagnostics...', 'info');
      
      // Compute diagnostics
      const engine = new DiagnosticsEngine(this.trace, mode);
      this.diagnostics = engine.compute();
      
      // Update metrics
      this.updateMetrics();
      
      // Render visualizations
      this.renderer.renderAll(this.diagnostics, this.trace);
      
      // Build exportData snapshot for validation
      const exportData = {
        version: '1.0.0',
        chamber: 'XXIV',
        operator: 'QASD',
        timestamp: new Date().toISOString(),
        algorithm: {
          name: this.algorithm.algorithm_name,
          qubits: this.algorithm.qubits,
          depth: this.operatorWord.length
        },
        diagnostics: this.diagnostics,
        trace: this.trace
      };
      
      // Run validation automatically
      this.runValidation(exportData);
      
      document.getElementById('btnExport').disabled = false;
      this.showStatus('statusDiagnostics', 'Diagnostics complete!', 'success');
      console.log('‚úÖ Diagnostics complete');
      
    } catch (error) {
      this.showStatus('statusDiagnostics', `Error: ${error.message}`, 'error');
      console.error('‚ùå Diagnostic error:', error);
    }
  }
  
  updateMetrics() {
    const m = this.diagnostics.metrics;
    
    document.getElementById('metricDepth').textContent = this.trace.length;
    document.getElementById('metricMaxTau').textContent = m.max_tau.toFixed(3);
    document.getElementById('metricPeakPhi').textContent = m.peak_phi.toFixed(3);
    document.getElementById('metricMaxUPI').textContent = m.max_upi.toFixed(3);
    document.getElementById('metricClosure').textContent = m.min_closure.toFixed(3);
    document.getElementById('metricResidue').textContent = m.avg_residue.toFixed(3);
    
    // Color coding
    const maxTauElem = document.getElementById('metricMaxTau');
    if (m.max_tau < 2.0) maxTauElem.className = 'metric-value success';
    else if (m.max_tau < 3.0) maxTauElem.className = 'metric-value warning';
    else maxTauElem.className = 'metric-value danger';
    
    const maxUPIElem = document.getElementById('metricMaxUPI');
    if (m.max_upi < 0.5) maxUPIElem.className = 'metric-value success';
    else if (m.max_upi < 0.75) maxUPIElem.className = 'metric-value warning';
    else maxUPIElem.className = 'metric-value danger';
    
    const closureElem = document.getElementById('metricClosure');
    if (m.min_closure > 0.7) closureElem.className = 'metric-value success';
    else if (m.min_closure > 0.5) closureElem.className = 'metric-value warning';
    else closureElem.className = 'metric-value danger';
  }
  
  exportResults() {
    if (!this.diagnostics) {
      alert('No diagnostics to export');
      return;
    }
    
    const exportData = {
      version: '1.0.0',
      chamber: 'XXIV',
      operator: 'QASD',
      timestamp: new Date().toISOString(),
      algorithm: {
        name: this.algorithm.algorithm_name,
        qubits: this.algorithm.qubits,
        depth: this.operatorWord.length
      },
      diagnostics: {
        tau_profile: this.diagnostics.tau_profile,
        phi_spectrum: this.diagnostics.phi_spectrum,
        upi_field: this.diagnostics.upi_field,
        closure_index: this.diagnostics.closure_index,
        residue_graph: this.diagnostics.residue_graph,
        metrics: this.diagnostics.metrics
      },
      trace: this.trace
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const timestamp = exportData.timestamp.split('T')[0];
    a.download = `XXIV_QASD_${this.algorithm.algorithm_name.replace(/\s+/g, '_')}_${timestamp}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    console.log('üíæ Results exported:', a.download);
  }
  
  runValidation(exportData) {
    const validator = new XXIVValidationEngine(exportData);
    const result = validator.run();

    const badge = document.getElementById('validationSummaryBadge');
    const status = document.getElementById('validationStatus');
    const list = document.getElementById('validationChecksList');

    list.innerHTML = '';

    if (result.ok && result.warnings.length === 0) {
      badge.textContent = 'VALID';
      badge.style.background = '#2a4a2a';
      badge.style.color = '#4aff4a';
      status.className = 'status success';
      status.textContent = 'All structural checks passed.';
      status.style.display = 'block';
    } else if (result.ok && result.warnings.length > 0) {
      badge.textContent = 'VALID (warnings)';
      badge.style.background = '#7a4a2a';
      badge.style.color = '#ffa54a';
      status.className = 'status warning';
      status.textContent = 'Valid, but some non-critical mismatches were found.';
      status.style.display = 'block';
    } else {
      badge.textContent = 'INVALID';
      badge.style.background = '#7a2a2a';
      badge.style.color = '#ff4a4a';
      status.className = 'status error';
      status.textContent = 'Errors detected in exported diagnostics.';
      status.style.display = 'block';
    }

    // Metrics mini-status
    this.setValidationMetric('metricValLengths',
      result.errors.some(e => e.includes('length')) ? '‚úñ' : '‚úî',
      result.errors.some(e => e.includes('length')) ? 'danger' : 'success'
    );
    this.setValidationMetric('metricValMetrics',
      result.warnings.some(e => e.includes('Metric')) ? '‚ö†' : '‚úî',
      result.warnings.some(e => e.includes('Metric')) ? 'warning' : 'success'
    );
    this.setValidationMetric('metricValRanges',
      result.errors.some(e => e.includes('UPI') || e.includes('Closure')) ? '‚úñ' : '‚úî',
      result.errors.some(e => e.includes('UPI') || e.includes('Closure')) ? 'danger' : 'success'
    );
    this.setValidationMetric('metricValGraph',
      result.warnings.some(e => e.includes('edge')) ? '‚ö†' : '‚úî',
      result.warnings.some(e => e.includes('edge')) ? 'warning' : 'success'
    );

    // Populate list
    [...result.errors, ...result.warnings].forEach(msg => {
      const li = document.createElement('li');
      li.textContent = msg;
      li.style.color = msg.includes('Metric') || msg.includes('edge')
        ? '#ffa54a'
        : '#ff4a4a';
      list.appendChild(li);
    });
    
    console.log('üîç Validation complete:', result.ok ? 'VALID' : 'INVALID',
                `(${result.errors.length} errors, ${result.warnings.length} warnings)`);
  }
  
  setValidationMetric(id, symbol, tone) {
    const el = document.getElementById(id);
    el.textContent = symbol;
    el.className = `metric-value ${tone}`;
  }
  
  clear() {
    document.getElementById('algJSON').value = '';
    document.getElementById('operatorWordDisplay').innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No algorithm loaded</div>';
    document.getElementById('badgeOperators').textContent = '0 ops';
    document.getElementById('btnRunDiagnostics').disabled = true;
    document.getElementById('btnExport').disabled = true;
    
    this.algorithm = null;
    this.operatorWord = null;
    this.trace = null;
    this.diagnostics = null;
    
    // Clear canvases
    for (let key in this.renderer.contexts) {
      const canvas = this.renderer.canvases[key];
      const ctx = this.renderer.contexts[key];
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    // Reset metrics
    ['metricDepth', 'metricMaxTau', 'metricPeakPhi', 'metricMaxUPI', 'metricClosure', 'metricResidue'].forEach(id => {
      document.getElementById(id).textContent = '‚Äî';
      document.getElementById(id).className = 'metric-value';
    });
    
    // Reset validation panel
    document.getElementById('validationSummaryBadge').textContent = 'Not run';
    document.getElementById('validationSummaryBadge').style.background = '#2a4a2a';
    document.getElementById('validationSummaryBadge').style.color = '#4aff4a';
    ['metricValLengths', 'metricValMetrics', 'metricValRanges', 'metricValGraph'].forEach(id => {
      document.getElementById(id).textContent = '‚Äî';
      document.getElementById(id).className = 'metric-value';
    });
    document.getElementById('validationChecksList').innerHTML = '';
    this.hideStatus('validationStatus');
    
    this.hideStatus('statusImport');
    this.hideStatus('statusDiagnostics');
    
    console.log('üóëÔ∏è Chamber cleared');
  }
  
  showStatus(id, message, type) {
    const elem = document.getElementById(id);
    elem.textContent = message;
    elem.className = `status ${type}`;
    elem.style.display = 'block';
  }
  
  hideStatus(id) {
    document.getElementById(id).style.display = 'none';
  }
}

// ==========================================
// INITIALIZATION
// ==========================================

window.addEventListener('DOMContentLoaded', () => {
  console.log('‚úÖ Chamber XXIV initialized');
  const controller = new ChamberXXIVController();
  window.chamberXXIV = controller; // Expose for debugging
});

console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

// ============================================================
// ===============   PHASE-E HELPER FUNCTIONS   ===============
// ============================================================

function phaseE_pearson(xs, ys) {
    const n = Math.min(xs.length, ys.length);
    if (n === 0) return null;
    let sx=0, sy=0, sxx=0, syy=0, sxy=0, cnt=0;
    for (let i=0;i<n;i++){
        const x=xs[i], y=ys[i];
        if (x==null || y==null || !isFinite(x) || !isFinite(y)) continue;
        sx+=x; sy+=y; sxx+=x*x; syy+=y*y; sxy+=x*y; cnt++;
    }
    if (!cnt) return null;
    const mx=sx/cnt, my=sy/cnt;
    const cov=(sxy/cnt)-mx*my;
    const vx=(sxx/cnt)-mx*mx;
    const vy=(syy/cnt)-my*my;
    if (vx<=0 || vy<=0) return null;
    return cov/Math.sqrt(vx*vy);
}

function phaseE_downloadJSON(obj, filename){
    const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download=filename;
    document.body.appendChild(a); a.click();
    setTimeout(()=>{document.body.removeChild(a);URL.revokeObjectURL(url)},0);
}

function phaseE_readFileAsText(file){
    return new Promise((resolve,reject)=>{
        const fr=new FileReader();
        fr.onload=()=>resolve(fr.result);
        fr.onerror=(e)=>reject(e);
        fr.readAsText(file);
    });
}

// ============================================================
// ===============   PHASE-E METRICS EXTRACTOR   ==============
// ============================================================
const PhaseEMetrics={
  fromXXIVDiagnostics:function(d,trace){
    d=d||{};
    const tau=d.tau_profile||[];
    const phi=d.phi_spectrum||[];
    const upi=d.upi_field||[];
    const cl=d.closure_index||[];
    const nodes=(d.residue_graph&&d.residue_graph.nodes)?d.residue_graph.nodes:[];

    const mean=a=>a.length?a.reduce((x,y)=>x+y,0)/a.length:0;

    return{
      tau_max:tau.length?Math.max(...tau):0,
      tau_mean:mean(tau),
      tau_slope:tau.length>=2?(tau.at(-1)-tau[0]):0,

      phi_peak:phi.length?Math.max(...phi):0,
      phi_var:phi.length?(phi.reduce((s,v)=>s+(v-mean(phi))**2,0)/phi.length):0,
      phi_bandwidth:phi.length?(Math.max(...phi)-Math.min(...phi)):0,

      upi_max:upi.length?Math.max(...upi):0,
      upi_integral:upi.reduce((x,y)=>x+y,0),
      upi_slope:upi.length>=2?(upi.at(-1)-upi[0]):0,

      closure_min:cl.length?Math.min(...cl):0,
      closure_mean:mean(cl),
      closure_prod:cl.length?cl.reduce((x,y)=>x*y,1):0,
      closure_deviation:cl.length?(Math.max(...cl)-Math.min(...cl)):0,

      residue_density:nodes.length?mean(nodes.map(n=>n.residue||0)):0,
      residue_peak:nodes.length?Math.max(...nodes.map(n=>n.residue||0)):0,
      torsion_events:nodes.filter(n=>(n.torsion||0)>1.0).length,

      depth:tau.length||phi.length||upi.length||cl.length||(trace?trace.length:0)||0
    };
  }
};

// ============================================================
// ====================   PHASE-E CORE   =======================
// ============================================================

class PhaseECore{
  constructor(chamber){
    this.chamber=chamber;
    this.circuits=[];
    this.hardwareLogs=[];
    this.records=[];
  }

  loadCircuitsBatch(json){
    const arr=(typeof json==='string')?JSON.parse(json):json;
    if(!Array.isArray(arr)) throw new Error("Circuit batch must be an array");
    this.circuits=arr.map((c,i)=>({
      circuit_id:c.circuit_id||(c.algorithm_name||'Circuit')+'_'+(i+1),
      algorithm_name:c.algorithm_name||('Circuit_'+(i+1)),
      family:c.family||null,
      qubits:c.qubits,
      operators:c.operators||[]
    }));
  }

  loadHardwareLogs(json){
    const arr=(typeof json==='string')?JSON.parse(json):json;
    if(!Array.isArray(arr)) throw new Error("Hardware logs must be an array");
    this.hardwareLogs=arr.map(h=>({...h}));
  }

  async runDiagnosticsOnAll(onProgress){
    console.log('üî¨ PhaseECore: runDiagnosticsOnAll started');
    console.log('Circuits to process:', this.circuits.length);
    console.log('Hardware logs available:', this.hardwareLogs.length);
    
    this.records=[];
    
    for(let i=0;i<this.circuits.length;i++){
      const C=this.circuits[i];
      const progressMsg = `Running diagnostics for ${C.circuit_id} (${i+1}/${this.circuits.length})`;
      console.log(progressMsg);
      onProgress&&onProgress(progressMsg);

      try {
        // --- IMPORT CIRCUIT INTO CHAMBER XXIV ---
        console.log('  Setting algorithm:', C.circuit_id);
        this.chamber.algorithm = C;
        
        // Build trace
        console.log('  Building trace...');
        const builder = new NestTraceBuilder(C.operators, C.qubits, 'relaxed', 137);
        this.chamber.trace = builder.build();
        console.log('  Trace built:', this.chamber.trace.length, 'steps');
        
        // Run diagnostics
        console.log('  Running diagnostics...');
        const engine = new DiagnosticsEngine(this.chamber.trace, 'relaxed');
        this.chamber.diagnostics = engine.compute();
        console.log('  Diagnostics computed');

        const diag=this.chamber.diagnostics||{};
        const trace=this.chamber.trace||[];
        
        console.log('  Extracting substrate metrics...');
        const substrate=PhaseEMetrics.fromXXIVDiagnostics(diag,trace);
        console.log('  Substrate metrics:', substrate);

        const hardwareMatches=this.hardwareLogs.filter(h=>h.circuit_id===C.circuit_id);
        console.log('  Hardware matches found:', hardwareMatches.length);
        
        if(!hardwareMatches.length){
          this.records.push({circuit_id:C.circuit_id, family:C.family, substrate, hardware:null});
          console.warn('  ‚ö†Ô∏è No hardware logs for', C.circuit_id);
        } else {
          hardwareMatches.forEach(hw=>{
            this.records.push({circuit_id:C.circuit_id, family:C.family, substrate, hardware:hw});
          });
          console.log('  ‚úÖ Created', hardwareMatches.length, 'records');
        }
      } catch (error) {
        console.error('  ‚ùå Error processing circuit', C.circuit_id, ':', error);
        console.error('  Stack:', error.stack);
      }
    }
    
    console.log('‚úÖ PhaseECore: All diagnostics complete');
    console.log('Total records generated:', this.records.length);
  }

  computeCorrelationMatrix(){
    const sKeys=[
      'tau_max','tau_mean','tau_slope',
      'phi_peak','phi_var','phi_bandwidth',
      'upi_max','upi_integral','upi_slope',
      'closure_min','closure_mean','closure_prod','closure_deviation',
      'residue_density','residue_peak','torsion_events'
    ];
    const hKeys=[
      'fidelity','error_rate','leakage',
      'entropy_peak','entropy_var',
      'noise_sensitivity','t1_mean','t2_mean',
      'gate_errors','readout_error','coherence_decay'
    ];

    const matrix=[];
    for(const s of sKeys){
      const row=[];
      for(const h of hKeys){
        const xs=[], ys=[];
        for(const r of this.records){
          if(!r.hardware||!r.substrate) continue;
          const x=r.substrate[s], y=r.hardware[h];
          if(x==null||y==null||!isFinite(x)||!isFinite(y)) continue;
          xs.push(x); ys.push(y);
        }
        row.push(xs.length?phaseE_pearson(xs,ys):null);
      }
      matrix.push(row);
    }
    return {substrate_keys:sKeys, hardware_keys:hKeys, values:matrix};
  }

  buildPhaseEBundle(){
    const bundle = {
      phaseE_version:"1.1",
      timestamp:new Date().toISOString(),
      batch_id:"PhaseE_"+Date.now(),
      records:this.records,
      correlation_matrix:this.computeCorrelationMatrix()
    };
    
    // Add SHAI if available
    if (this.SHAI && this.SHAI.records && this.SHAI.records.length > 0) {
      bundle.SHAI = {
        version: "0.1",
        records: this.SHAI.records,
        platforms: this.SHAI.platforms,
        algorithms: this.SHAI.algorithms
      };
    }
    
    return bundle;
  }

  getSummary(){
    return{
      circuits:new Set(this.circuits.map(c=>c.circuit_id)).size,
      platforms:new Set(this.hardwareLogs.map(h=>h.platform)).size,
      records:this.records.length
    };
  }
}

// ============================================================
// ===================  SHAI v0.1 ENGINE  =====================
// ============================================================

/**
 * SHAI v0.1 ‚Äî Substrate‚ÄìHardware Alignment Index
 * Direct prototype extension for PhaseECore
 */

// Canonical metric pairs
const SHAI_PAIRS = [
  ["tau_mean",        "gate_errors"],
  ["tau_slope",       "noise_sensitivity"],
  ["phi_var",         "entropy_peak"],
  ["phi_bandwidth",   "coherence_decay"],
  ["closure_prod",    "fidelity"],
  ["closure_mean",    "gate_errors"],
  ["upi_max",         "readout_error"],
  ["residue_density", "entropy_peak"],
  ["torsion_events",  "coherence_decay"]
];

const SHAI_SUB_KEYS = Array.from(new Set(SHAI_PAIRS.map(p => p[0])));
const SHAI_HW_KEYS  = Array.from(new Set(SHAI_PAIRS.map(p => p[1])));

// Normalisation helpers
function SHAI_initRangeObj(keys) {
  const obj = {};
  keys.forEach(k => {
    obj[k] = { min: +Infinity, max: -Infinity };
  });
  return obj;
}

function SHAI_updateRange(range, key, value) {
  if (value == null || isNaN(value)) return;
  if (!(key in range)) return;
  if (value < range[key].min) range[key].min = value;
  if (value > range[key].max) range[key].max = value;
}

function SHAI_normValue(range, key, value) {
  const r = range[key];
  if (!r || value == null || isNaN(value)) return 0.5;
  const denom = (r.max - r.min);
  if (!isFinite(denom) || Math.abs(denom) < 1e-9) return 0.5;
  let n = (value - r.min) / (denom + 1e-9);
  if (n < 0) n = 0;
  if (n > 1) n = 1;
  return n;
}

// Goodness functions
function SHAI_substrateGoodness(key, norm) {
  switch (key) {
    case "tau_mean":
    case "tau_slope":
    case "phi_var":
    case "phi_bandwidth":
    case "closure_deviation":
    case "upi_max":
    case "upi_integral":
    case "upi_slope":
    case "residue_density":
    case "residue_peak":
    case "torsion_events":
      return 1 - norm;

    case "closure_mean":
    case "closure_prod":
      return norm;

    default:
      return 0.5;
  }
}

function SHAI_hardwareGoodness(key, norm) {
  switch (key) {
    case "fidelity":
    case "t1_mean":
    case "t2_mean":
      return norm;

    case "error_rate":
    case "leakage":
    case "entropy_peak":
    case "entropy_var":
    case "noise_sensitivity":
    case "gate_errors":
    case "readout_error":
    case "coherence_decay":
      return 1 - norm;

    default:
      return 0.5;
  }
}

// Correlation weight lookup
function SHAI_buildIndexMap(keys) {
  const m = {};
  if (!Array.isArray(keys)) return m;
  keys.forEach((k, i) => { m[k] = i; });
  return m;
}

function SHAI_getSHAIWeight(corrMatrix, sKey, hKey) {
  if (!corrMatrix || !corrMatrix.values) return 0;

  const sKeys = corrMatrix.substrate_keys || corrMatrix.substrateKeys || corrMatrix.rowKeys || [];
  const hKeys = corrMatrix.hardware_keys || corrMatrix.hardwareKeys || corrMatrix.colKeys || [];

  const sIndexMap = SHAI_buildIndexMap(sKeys);
  const hIndexMap = SHAI_buildIndexMap(hKeys);

  const i = sIndexMap[sKey];
  const j = hIndexMap[hKey];
  if (i == null || j == null) return 0;

  const row = corrMatrix.values[i];
  if (!row || typeof row[j] !== "number") return 0;

  const corr = row[j];
  const absCorr = Math.abs(corr);

  return (absCorr < 0.20) ? 0 : absCorr;
}

// SHAI computation method
PhaseECore.prototype.computeSHAI = function () {
  console.log("[SHAI] Starting SHAI computation...");
  const core = this;

  const records = core.records || [];
  const corrMatrix = core.computeCorrelationMatrix();

  core.SHAI = {
    records: [],
    platforms: {},
    algorithms: {}
  };

  if (!records.length || !corrMatrix) {
    console.warn("[SHAI] No records or correlation matrix; SHAI not computed.");
    return;
  }

  // Build normalisation ranges
  const subRanges = SHAI_initRangeObj(SHAI_SUB_KEYS);
  const hwRanges  = SHAI_initRangeObj(SHAI_HW_KEYS);

  records.forEach(rec => {
    const s = rec.substrate || {};
    const h = rec.hardware || {};
    SHAI_SUB_KEYS.forEach(k => SHAI_updateRange(subRanges, k, s[k]));
    SHAI_HW_KEYS.forEach(k => SHAI_updateRange(hwRanges,  k, h[k]));
  });

  // Precompute weights
  const pairWeights = {};
  let totalGlobalWeight = 0;
  SHAI_PAIRS.forEach(pair => {
    const [sKey, hKey] = pair;
    const w = SHAI_getSHAIWeight(corrMatrix, sKey, hKey);
    pairWeights[sKey + "|" + hKey] = w;
    totalGlobalWeight += w;
  });

  const globalAllWeightsZero = (totalGlobalWeight === 0);

  // Per-record SHAI
  records.forEach(rec => {
    const s = rec.substrate || {};
    const h = rec.hardware || {};
    const platform   = h.platform || "unknown";
    const circuit_id = rec.circuit_id || rec.algorithm_name || "unknown";

    let num = 0;
    let den = 0;

    SHAI_PAIRS.forEach(pair => {
      const [sKey, hKey] = pair;
      const wGlobal = pairWeights[sKey + "|" + hKey];

      if (!globalAllWeightsZero && wGlobal === 0) return;

      const sVal = s[sKey];
      const hVal = h[hKey];
      if (sVal == null || hVal == null || isNaN(sVal) || isNaN(hVal)) return;

      const sNorm = SHAI_normValue(subRanges, sKey, sVal);
      const hNorm = SHAI_normValue(hwRanges,  hKey, hVal);

      const gS = SHAI_substrateGoodness(sKey, sNorm);
      const gH = SHAI_hardwareGoodness(hKey, hNorm);

      const P = (gS + gH) / 2;

      const w = globalAllWeightsZero ? 1 : wGlobal;
      num += w * P;
      den += w;
    });

    let shai = 0.5;
    if (den > 0) {
      shai = num / den;
    }

    if (shai < 0) shai = 0;
    if (shai > 1) shai = 1;

    rec.SHAI_record = shai;

    core.SHAI.records.push({
      circuit_id: circuit_id,
      platform: platform,
      SHAI_record: shai
    });

    // Accumulate per-platform
    if (!core.SHAI.platforms[platform]) {
      core.SHAI.platforms[platform] = { sum: 0, count: 0 };
    }
    core.SHAI.platforms[platform].sum   += shai;
    core.SHAI.platforms[platform].count += 1;

    // Accumulate per-algorithm
    if (!core.SHAI.algorithms[circuit_id]) {
      core.SHAI.algorithms[circuit_id] = { sum: 0, count: 0 };
    }
    core.SHAI.algorithms[circuit_id].sum   += shai;
    core.SHAI.algorithms[circuit_id].count += 1;
  });

  // Finalise averages + class labels
  function shaiClass(v) {
    if (v >= 0.85) return "A";
    if (v >= 0.70) return "B";
    if (v >= 0.50) return "C";
    return "D";
  }

  Object.keys(core.SHAI.platforms).forEach(p => {
    const obj = core.SHAI.platforms[p];
    const mean = (obj.count > 0) ? (obj.sum / obj.count) : 0.5;
    obj.SHAI_platform = mean;
    obj.class = shaiClass(mean);
  });

  Object.keys(core.SHAI.algorithms).forEach(a => {
    const obj = core.SHAI.algorithms[a];
    const mean = (obj.count > 0) ? (obj.sum / obj.count) : 0.5;
    obj.SHAI_algorithm = mean;
    obj.class = shaiClass(mean);
  });

  console.log("[SHAI] SHAI computation complete.", core.SHAI);
};

// ============================================================
// =====================  PHASE-E UI  ==========================
// ============================================================

class PhaseEUI{
  constructor(chamber,core){
    this.chamber=chamber;
    this.core=core;

    this.statusEl=document.getElementById('phaseEStatus');
    this.countCircuitsEl=document.getElementById('phaseECountCircuits');
    this.countPlatformsEl=document.getElementById('phaseECountPlatforms');
    this.countRecordsEl=document.getElementById('phaseECountRecords');
    this.matrixContainerEl=document.getElementById('phaseECorrMatrixContainer');

    this.btnCircuits=document.getElementById('btnPhaseELoadCircuits');
    this.btnHardware=document.getElementById('btnPhaseEImportHardware');
    this.btnRun=document.getElementById('btnPhaseERun');
    this.btnExport=document.getElementById('btnPhaseEExport');
    this.btnHighlight=document.getElementById('btnHighlightCorr');
    
    this.highlightMode=false;
    this.currentCorrelationMatrix=null;

    this.fileCircuits=document.createElement('input');
    this.fileCircuits.type='file';
    this.fileCircuits.accept='application/json';
    this.fileCircuits.style.display='none';

    this.fileHardware=document.createElement('input');
    this.fileHardware.type='file';
    this.fileHardware.accept='application/json';
    this.fileHardware.style.display='none';

    document.body.appendChild(this.fileCircuits);
    document.body.appendChild(this.fileHardware);

    this._bind();
  }

  _bind(){
    // Hybrid mode: OK = File, Cancel = Paste
    this.btnCircuits.onclick=()=>this._onLoadCircuits();
    this.btnHardware.onclick=()=>this._onLoadHardware();
    this.btnRun.onclick=()=>this._onRun();
    this.btnExport.onclick=()=>this._onExport();
    this.btnHighlight.onclick=()=>this._toggleHighlight();

    this.fileCircuits.onchange=async(e)=>{
      console.log('üìÇ File selected for circuits');
      const f=e.target.files[0];
      if(!f){
        console.log('No file selected');
        return;
      }
      try{
        console.log('Reading file:', f.name);
        const txt=await phaseE_readFileAsText(f);
        console.log('File read, length:', txt.length);
        this.core.loadCircuitsBatch(txt);
        console.log('Circuits loaded:', this.core.circuits.length);
        this._setStatus("Loaded circuits: "+f.name,"success");
        this._updateSummary();
        if(this.core.hardwareLogs.length) this.btnRun.disabled=false;
      }catch(err){
        console.error('‚ùå Error loading circuits:', err);
        this._setStatus("Error: "+err.message,"error");
      }finally{
        this.fileCircuits.value='';
      }
    };

    this.fileHardware.onchange=async(e)=>{
      console.log('üìä File selected for hardware');
      const f=e.target.files[0];
      if(!f){
        console.log('No file selected');
        return;
      }
      try{
        console.log('Reading file:', f.name);
        const txt=await phaseE_readFileAsText(f);
        console.log('File read, length:', txt.length);
        this.core.loadHardwareLogs(txt);
        console.log('Hardware logs loaded:', this.core.hardwareLogs.length);
        this._setStatus("Loaded hardware: "+f.name,"success");
        this._updateSummary();
        if(this.core.circuits.length) this.btnRun.disabled=false;
      }catch(err){
        console.error('‚ùå Error loading hardware:', err);
        this._setStatus("Error: "+err.message,"error");
      }finally{
        this.fileHardware.value='';
      }
    };
  }

  _promptJSON(title){
    const raw=prompt(title+"\nPaste JSON here:");
    if(!raw) return null;
    try{return JSON.parse(raw);}catch(e){alert("JSON error: "+e.message);return null;}
  }

  _onLoadCircuits(){
    // Directly open file picker, with fallback to paste if user cancels
    this.fileCircuits.click();
  }

  _onLoadHardware(){
    const mode=confirm("OK = Load File\nCancel = Paste JSON");
    if(mode){this.fileHardware.click();return;}
    const data=this._promptJSON("Hardware logs JSON");
    if(!data)return;
    this.core.loadHardwareLogs(data);
    this._setStatus("Loaded hardware logs from pasted JSON","success");
    this._updateSummary();
    if(this.core.circuits.length) this.btnRun.disabled=false;
  }

  async _onRun(){
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('‚ñ∂Ô∏è Run Correlation clicked');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('Circuits loaded:', this.core.circuits.length);
    console.log('Hardware logs loaded:', this.core.hardwareLogs.length);
    
    if(!this.core.circuits.length||!this.core.hardwareLogs.length){
      console.warn('‚ö†Ô∏è Missing data - need both circuits and hardware');
      this._setStatus("Need circuits + hardware first","warning");
      return;
    }
    
    this._setStatus("Running Phase-E...","info");
    this.btnRun.disabled=true;
    
    try {
      console.log('Starting diagnostics on all circuits...');
      
      await this.core.runDiagnosticsOnAll(m=>{
        console.log('Progress:', m);
        this._setStatus(m,"info");
      });
      
      console.log('‚úÖ Diagnostics complete');
      console.log('Records generated:', this.core.records.length);

      console.log('Computing correlation matrix...');
      const corr=this.core.computeCorrelationMatrix();
      console.log('‚úÖ Correlation matrix computed');
      console.log('Matrix dimensions:', corr.substrate_keys.length, 'x', corr.hardware_keys.length);
      
      console.log('Rendering matrix...');
      this._renderMatrix(corr);
      console.log('‚úÖ Matrix rendered');
      
      console.log('Generating interpretation panel...');
      generateMatrixInterpretation(corr);
      console.log('‚úÖ Interpretation panel updated');
      
      console.log('Computing SHAI...');
      this.core.computeSHAI();
      console.log('‚úÖ SHAI computed');
      
      console.log('Rendering SHAI panel...');
      this.renderSHAI(this.core);
      console.log('‚úÖ SHAI panel rendered');
      
      this._setStatus("Phase-E finished","success");
      this._updateSummary();
      this.btnExport.disabled=false;
      this.btnRun.disabled=false;
      this.btnHighlight.disabled=false;
      
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('‚úÖ Phase-E Run Complete');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    } catch (error) {
      console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.error('‚ùå Phase-E Run Error');
      console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.error('Error:', error);
      console.error('Stack:', error.stack);
      this._setStatus("Error: " + error.message,"error");
      this.btnRun.disabled=false;
    }
  }

  _onExport(){
    const bundle=this.core.buildPhaseEBundle();
    const fn="PhaseE_"+new Date().toISOString().replace(/[:.]/g,'-')+".json";
    phaseE_downloadJSON(bundle,fn);
    this._setStatus("Exported Phase-E bundle","success");
  }

  _setStatus(msg,tone){
    if(!this.statusEl)return;
    this.statusEl.textContent=msg;
    this.statusEl.className='status '+tone;
    this.statusEl.style.display='block';
  }

  _updateSummary(){
    const s=this.core.getSummary();
    if(this.countCircuitsEl) this.countCircuitsEl.textContent=s.circuits;
    if(this.countPlatformsEl) this.countPlatformsEl.textContent=s.platforms;
    if(this.countRecordsEl) this.countRecordsEl.textContent=s.records;
  }

  _renderMatrix(res){
    if(!this.matrixContainerEl)return;
    this.currentCorrelationMatrix = res; // Store for re-rendering
    const S=res.substrate_keys, H=res.hardware_keys, M=res.values;

    let html='<table class="unns-operator-table phasee-mtx"><tr><th>UNNS \\ HW</th>';
    H.forEach(h=>html+='<th>'+h+'</th>');
    html+='</tr>';

    for(let i=0;i<S.length;i++){
      html+='<tr><td><b>'+S[i]+'</b></td>';
      for(let j=0;j<H.length;j++){
        const v=M[i][j];
        if(v==null){html+='<td class="phasee-none">‚Äî</td>';continue;}
        const r=Math.round(v*100)/100;
        const a = Math.abs(v);
        
        // Cell class with highlight mode support
        let cls='phasee-weak';
        if(!this.highlightMode){
          // Normal mode - soft gradients
          if(v>0.6) cls='phasee-pos-strong';
          else if(v>0.3) cls='phasee-pos';
          else if(v<-0.6) cls='phasee-neg-strong';
          else if(v<-0.3) cls='phasee-neg';
        } else {
          // Highlight mode - sharper thresholds
          if(a < 0.4) cls='phasee-weak';
          else if(v > 0) cls = (a > 0.85) ? 'phasee-pos-strong highlight-mode' : 'phasee-pos highlight-mode';
          else cls = (a > 0.85) ? 'phasee-neg-strong highlight-mode' : 'phasee-neg highlight-mode';
        }
        
        // Tooltip
        const tooltip = 
          `${S[i]} ‚Üî ${H[j]}: ${v.toFixed(3)}\n` +
          (a > 0.85 ? '‚òÖ EPIC correlation ‚Äî strong structural-hardware interaction' :
           a > 0.65 ? '‚ñ≤ Strong correlation ‚Äî pattern worth tracking' :
           a > 0.40 ? '‚óè Moderate correlation' :
           '‚óã Weak correlation');
        
        html+=`<td class="${cls}" title="${tooltip}">${r.toFixed(2)}</td>`;
      }
      html+='</tr>';
    }
    html+='</table>';
    this.matrixContainerEl.innerHTML=html;
  }

  _toggleHighlight(){
    this.highlightMode = !this.highlightMode;
    this.btnHighlight.style.background = this.highlightMode ? '#7a2a4a' : '#556677';
    this.btnHighlight.textContent = this.highlightMode ? 'üéØ Highlighting: ON' : 'üéØ Highlight Strong Correlations';
    
    // Re-render matrix with new mode
    if(this.currentCorrelationMatrix){
      this._renderMatrix(this.currentCorrelationMatrix);
    }
  }

  renderSHAI(core) {
    if (!core || !core.SHAI || !core.SHAI.records || !core.SHAI.records.length) {
      const globalDiv = document.getElementById("shaiGlobal");
      if (globalDiv) {
        globalDiv.textContent = "SHAI not available ‚Äî run Phase-E correlation first.";
      }
      const panel = document.getElementById("shaiPanel");
      if (panel) panel.style.display = 'none';
      return;
    }

    const shaiData = core.SHAI;

    // Helper: class from value
    function shaiClass(v) {
      if (v >= 0.85) return "A";
      if (v >= 0.70) return "B";
      if (v >= 0.50) return "C";
      return "D";
    }

    // Show panel
    const panel = document.getElementById("shaiPanel");
    if (panel) panel.style.display = 'block';

    // Global summary
    let globalMean = 0;
    let cnt = 0;
    shaiData.records.forEach(r => {
      if (typeof r.SHAI_record === "number") {
        globalMean += r.SHAI_record;
        cnt += 1;
      }
    });
    globalMean = (cnt > 0) ? (globalMean / cnt) : 0.5;
    const gClass = shaiClass(globalMean);

    const globalDiv = document.getElementById("shaiGlobal");
    if (globalDiv) {
      globalDiv.innerHTML =
        `Global SHAI across all algorithms and platforms: ` +
        `<span class="shai-badge shai-badge-${gClass}">${globalMean.toFixed(3)} (Class ${gClass})</span>`;
    }

    // Platform table
    const platTable = document.getElementById("shaiPlatformTable");
    if (platTable) {
      platTable.innerHTML = "";
      const header = document.createElement("tr");
      header.innerHTML = `
        <th>Platform</th>
        <th>SHAI</th>
        <th>Class</th>
        <th>Samples</th>`;
      platTable.appendChild(header);

      Object.keys(shaiData.platforms).sort().forEach(p => {
        const obj = shaiData.platforms[p];
        const v = obj.SHAI_platform;
        const c = obj.class || shaiClass(v);
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${p}</td>
          <td>${v.toFixed(3)}</td>
          <td><span class="shai-badge shai-badge-${c}"> ${c} </span></td>
          <td>${obj.count}</td>`;
        platTable.appendChild(tr);
      });
    }

    // Algorithm table
    const algTable = document.getElementById("shaiAlgorithmTable");
    if (algTable) {
      algTable.innerHTML = "";
      const header = document.createElement("tr");
      header.innerHTML = `
        <th>Circuit / Algorithm</th>
        <th>SHAI</th>
        <th>Class</th>
        <th>Samples</th>`;
      algTable.appendChild(header);

      Object.keys(shaiData.algorithms).sort().forEach(a => {
        const obj = shaiData.algorithms[a];
        const v = obj.SHAI_algorithm;
        const c = obj.class || shaiClass(v);
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${a}</td>
          <td>${v.toFixed(3)}</td>
          <td><span class="shai-badge shai-badge-${c}"> ${c} </span></td>
          <td>${obj.count}</td>`;
        algTable.appendChild(tr);
      });
    }

    console.log('[SHAI UI] Rendered SHAI panel');
  }
}

// ============================================================
// ===============  MATRIX INTERPRETATION ENGINE  =============
// ============================================================

function toggleMatrixInterpretation() {
    const body = document.getElementById("matrixInterpretationBody");
    const arrow = document.getElementById("interpArrow");

    body.style.display = 
        (body.style.display === "none" || body.style.display === "") ? "block" : "none";

    arrow.textContent = (body.style.display === "block") ? "‚ñ≤" : "‚ñº";
}

function toggleExtendedGuide() {
    const body = document.getElementById("extendedGuideBody");
    const arrow = document.getElementById("extendedGuideArrow");

    body.style.display = 
        (body.style.display === "none" || body.style.display === "") ? "block" : "none";

    arrow.textContent = (body.style.display === "block") ? "‚ñ≤" : "‚ñº";
}

/* Call this AFTER correlation matrix is computed */
function generateMatrixInterpretation(corrMatrix) {
    
    console.log('üîç Generating matrix interpretation...');
    
    // Convert matrix format to lookup object
    const corr = {};
    const sKeys = corrMatrix.substrate_keys;
    const hKeys = corrMatrix.hardware_keys;
    const values = corrMatrix.values;
    
    for (let i = 0; i < sKeys.length; i++) {
        corr[sKeys[i]] = {};
        for (let j = 0; j < hKeys.length; j++) {
            corr[sKeys[i]][hKeys[j]] = values[i][j];
        }
    }

    //-----------------------------
    // 1. GLOBAL SUMMARY
    //-----------------------------
    document.getElementById("interp_global").innerHTML =
        "The correlation matrix reveals consistent, cross-platform patterns: " +
        "œÑ-curvature tracks noise channels, œÜ-resonance identifies decoherence routes, " +
        "closure stability predicts fidelity, and UPI correlates with measurement fragility.";

    //-----------------------------
    // Helper to check correlation by strength
    //-----------------------------
    function interpret(name, values) {
        let max = 0;
        for (let v of values) {
            if (v !== null && !isNaN(v) && Math.abs(v) > Math.abs(max)) max = v;
        }

        if (Math.abs(max) > 0.75) 
            return `<b>${name}</b> shows <span style="color:#8cffc9;">strong</span> structural‚Äìhardware coupling (|corr| = ${max.toFixed(3)}).`;
        if (Math.abs(max) > 0.45) 
            return `<b>${name}</b> shows <span style="color:#ffe48c;">medium</span> correlation (|corr| = ${max.toFixed(3)}).`;
        return `<b>${name}</b> shows <span style="color:#ff9b9b;">weak</span> correlation (|corr| = ${max.toFixed(3)}).`;
    }

    //-----------------------------
    // 2. œÑ-CURVATURE
    //-----------------------------
    let tauCorrs = [
        corr["tau_max"]?.gate_errors || 0,
        corr["tau_mean"]?.gate_errors || 0,
        corr["tau_slope"]?.noise_sensitivity || 0
    ];

    document.getElementById("interp_tau").innerHTML =
        interpret("œÑ-curvature", tauCorrs) +
        " High œÑ indicates structural strain; strong negative correlations mean unstable hardware magnifies substrate curvature.";

    //-----------------------------
    // 3. œÜ-RESONANCE
    //-----------------------------
    let phiCorrs = [
        corr["phi_var"]?.entropy_peak || 0,
        corr["phi_bandwidth"]?.coherence_decay || 0
    ];

    document.getElementById("interp_phi").innerHTML =
        interpret("œÜ-resonance spectrum", phiCorrs) +
        " œÜ-variance correlates with entropy and decoherence, indicating phase-fragility.";

    //-----------------------------
    // 4. CLOSURE FIELD
    //-----------------------------
    let closureCorrs = [
        corr["closure_mean"]?.gate_errors || 0,
        corr["closure_prod"]?.fidelity || 0
    ];

    document.getElementById("interp_closure").innerHTML =
        interpret("Closure metrics", closureCorrs) +
        " Closure stability shows strong positive correlation with fidelity, acting as a predictor for hardware robustness.";

    //-----------------------------
    // 5. UPI INDEX
    //-----------------------------
    let upiCorrs = [
        corr["upi_max"]?.readout_error || 0,
        corr["upi_integral"]?.readout_error || 0
    ];

    document.getElementById("interp_upi").innerHTML =
        interpret("UPI (Paradox Index)", upiCorrs) +
        " High UPI correlates with measurement collapse pathways and indicates late-stage fragility.";

    //-----------------------------
    // 6. RESIDUE & TORSION
    //-----------------------------
    let residueCorrs = [
        corr["residue_density"]?.entropy_peak || 0,
        corr["torsion_events"]?.coherence_decay || 0
    ];

    document.getElementById("interp_residue").innerHTML =
        interpret("Residue & torsion", residueCorrs) +
        " Residue flow reflects decoherence accumulation, while torsion events correlate with last-layer instability.";
        
    console.log('‚úÖ Matrix interpretation generated');
}

// ============================================================
// ===============  PHASE-E WIRING / ACTIVATION  ==============
// ============================================================

window.addEventListener('DOMContentLoaded', () => {
  setTimeout(() => {
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üî¨ Phase-E Initialization Check');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('window.chamberXXIV exists:', !!window.chamberXXIV);
    console.log('PhaseECore class exists:', typeof PhaseECore);
    console.log('PhaseEUI class exists:', typeof PhaseEUI);
    console.log('PhaseEMetrics exists:', typeof PhaseEMetrics);
    console.log('phaseE_pearson exists:', typeof phaseE_pearson);
    
    if (window.chamberXXIV) {
      console.log('‚úÖ Activating Phase-E Engine...');
      
      try {
        window.chamberXXIV.phaseECore = new PhaseECore(window.chamberXXIV);
        console.log('‚úÖ PhaseECore created');
        
        window.chamberXXIV.phaseEUI = new PhaseEUI(window.chamberXXIV, window.chamberXXIV.phaseECore);
        console.log('‚úÖ PhaseEUI created');
        
        console.log('Button check:', {
          loadCircuits: !!document.getElementById('btnPhaseELoadCircuits'),
          importHardware: !!document.getElementById('btnPhaseEImportHardware'),
          run: !!document.getElementById('btnPhaseERun'),
          export: !!document.getElementById('btnPhaseEExport')
        });
        
        // Show Phase-E panel when button is clicked
        const btnActivate=document.getElementById('btnActivatePhaseE');
        if(btnActivate){
          btnActivate.onclick=()=>{
            console.log('üî¨ Activate Phase-E button clicked');
            const p=document.getElementById('xxivPhaseEPanel');
            if(p) {
              p.style.display='block';
              console.log('‚úÖ Phase-E panel shown');
            } else {
              console.error('‚ùå Phase-E panel not found');
            }
          };
          console.log('‚úÖ Activate button wired');
        } else {
          console.error('‚ùå Activate button not found');
        }
        
        console.log('‚úÖ Phase-E Engine ready');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      } catch (error) {
        console.error('‚ùå Phase-E initialization error:', error);
        console.error('Stack:', error.stack);
      }
    } else {
      console.error('‚ùå window.chamberXXIV not found!');
    }
  }, 150);
});

  </script>
</body>
</html>
