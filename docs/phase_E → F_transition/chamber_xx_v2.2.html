<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNNS Laboratory ‚Äî Chamber XX v2.2 (Phase F)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Consolas', 'Monaco', monospace; 
      background: #0a0a0a; 
      color: #e0e0e0; 
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    
    /* Header */
    header { 
      text-align: center; 
      margin-bottom: 30px; 
      padding: 20px; 
      border-bottom: 2px solid #2a2a2a; 
    }
    h1 { 
      font-size: 2.2em; 
      color: #ff4a9e; 
      letter-spacing: 2px; 
      margin-bottom: 10px;
    }
    .subtitle { 
      color: #888; 
      margin-top: 10px; 
      font-size: 0.9em; 
    }
    
    /* Badges */
    .badges {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    .badge {
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 0.85em;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .badge-phaseF { background: linear-gradient(135deg, #ff4a9e, #9e4aff); color: white; }
    .badge-theory { background: #2a4a7a; color: #4a9eff; }
    .badge-runtime { background: #2a4a2a; color: #4aff4a; }
    .badge-certified { background: #4aff4a; color: #0a0a0a; }
    
    /* Panels */
    .panel { 
      background: #1a1a1a; 
      border: 1px solid #2a2a2a; 
      border-radius: 8px; 
      padding: 20px; 
      margin-bottom: 20px; 
    }
    .panel-title { 
      font-size: 1.2em; 
      color: #ff4a9e; 
      margin-bottom: 15px; 
      padding-bottom: 10px; 
      border-bottom: 1px solid #2a2a2a; 
    }
    
    /* Controls */
    .controls { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
      gap: 15px; 
      margin-bottom: 20px; 
    }
    .control-group { display: flex; flex-direction: column; }
    label { 
      font-size: 0.9em; 
      color: #aaa; 
      margin-bottom: 5px; 
    }
    input[type="number"], 
    input[type="range"], 
    select { 
      background: #0a0a0a; 
      border: 1px solid #3a3a3a; 
      color: #e0e0e0; 
      padding: 8px; 
      border-radius: 4px; 
      font-family: inherit; 
    }
    
    /* Operator Info */
    .op-info {
      margin-top: 8px;
      padding: 8px 12px;
      background: linear-gradient(135deg, #1a2a3a, #2a1a3a);
      border-radius: 4px;
      font-size: 0.85em;
      color: #4a9eff;
      border-left: 3px solid #ff4a9e;
    }
    .op-info strong {
      color: #ff4a9e;
    }
    
    /* Buttons */
    button { 
      background: #2a4a7a; 
      border: none; 
      color: #e0e0e0; 
      padding: 12px 24px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-family: inherit; 
      margin-right: 10px;
      font-size: 0.95em;
    }
    button:hover { background: #3a5a8a; }
    button:disabled { 
      background: #1a1a1a; 
      color: #555; 
      cursor: not-allowed; 
    }
    .button-primary { background: #ff4a9e; }
    .button-primary:hover { background: #ff5aae; }
    .button-export { background: #4aff4a; color: #0a0a0a; }
    .button-export:hover { background: #5aff5a; }
    
    /* Visualization Grid */
    .visualization { 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 20px; 
      margin-top: 20px; 
    }
    .canvas-container { 
      position: relative; 
      background: #000; 
      border: 1px solid #2a2a2a; 
      aspect-ratio: 1; 
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      image-rendering: pixelated;
    }
    .canvas-label { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      background: rgba(0,0,0,0.8); 
      padding: 8px 12px; 
      border-radius: 4px; 
      font-size: 0.9em; 
      color: #ff4a9e; 
      font-weight: bold;
    }
    .canvas-stats {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 0.75em;
      color: #4a9eff;
      font-family: 'Courier New', monospace;
    }
    
    /* HUD Metrics */
    .hud-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); 
      gap: 12px; 
      margin-top: 15px; 
    }
    .hud-metric { 
      background: #0a0a0a; 
      padding: 12px; 
      border-radius: 4px; 
      border: 1px solid #2a2a2a; 
    }
    .hud-label { 
      font-size: 0.75em; 
      color: #888; 
      margin-bottom: 6px; 
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .hud-value { 
      font-size: 1.3em; 
      color: #ff4a9e; 
      font-weight: bold; 
      font-family: 'Courier New', monospace;
    }
    .hud-value.good { color: #4aff4a; }
    .hud-value.warn { color: #ffa54a; }
    .hud-value.bad { color: #ff4a4a; }
    
    /* Validation Panel */
    .validation-panel {
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 6px;
      padding: 15px;
      margin-top: 20px;
    }
    .validation-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .validation-item {
      background: #1a1a1a;
      padding: 12px;
      border-radius: 4px;
      border-left: 4px solid #3a3a3a;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .validation-item.pass {
      border-left-color: #4aff4a;
      background: linear-gradient(90deg, #1a2a1a, #1a1a1a);
    }
    .validation-item.fail {
      border-left-color: #ff4a4a;
      background: linear-gradient(90deg, #2a1a1a, #1a1a1a);
    }
    .validation-item.pending {
      border-left-color: #ffa54a;
    }
    .validation-label {
      font-size: 0.85em;
      color: #aaa;
    }
    .validation-label strong {
      color: #ff4a9e;
      display: block;
      margin-bottom: 4px;
    }
    .validation-value {
      font-size: 0.9em;
      font-family: 'Courier New', monospace;
      color: #4a9eff;
    }
    .validation-icon {
      font-size: 1.5em;
      margin-left: 10px;
    }
    
    /* Status */
    .status { 
      padding: 12px; 
      border-radius: 4px; 
      margin-top: 15px; 
      font-size: 0.9em; 
    }
    .status.running { 
      background: #2a4a2a; 
      color: #4aff4a; 
      border-left: 4px solid #4aff4a;
    }
    .status.complete { 
      background: #2a3a4a; 
      color: #4a9eff; 
      border-left: 4px solid #4a9eff;
    }
    .status.error {
      background: #4a2a2a;
      color: #ff4a4a;
      border-left: 4px solid #ff4a4a;
    }
    
    /* Progress Bar */
    .progress-bar { 
      width: 100%; 
      height: 4px; 
      background: #1a1a1a; 
      border-radius: 2px; 
      overflow: hidden; 
      margin-top: 10px; 
    }
    .progress-fill { 
      height: 100%; 
      background: linear-gradient(90deg, #ff4a9e, #9e4aff); 
      transition: width 0.3s; 
    }
    
    /* Laboratory Guide */
    .guide {
      line-height: 1.7;
      color: #aaa;
    }
    .guide h2 {
      color: #ff4a9e;
      font-size: 1.3em;
      margin: 20px 0 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #2a2a2a;
    }
    .guide h3 {
      color: #4a9eff;
      font-size: 1.1em;
      margin: 20px 0 10px;
    }
    .guide p {
      margin: 10px 0;
    }
    .guide ul, .guide ol {
      margin: 10px 0 10px 25px;
      line-height: 1.9;
    }
    .guide code {
      background: #0a0a0a;
      padding: 2px 8px;
      border-radius: 3px;
      color: #4a9eff;
      font-family: 'Courier New', monospace;
    }
    .guide table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      font-size: 0.9em;
    }
    .guide th {
      background: #1a1a2a;
      color: #ff4a9e;
      padding: 10px;
      text-align: left;
      border-bottom: 2px solid #3a3a4a;
    }
    .guide td {
      padding: 10px;
      border-bottom: 1px solid #1a1a1a;
    }
    .guide tr:hover {
      background: #151515;
    }
    .highlight-box {
      background: linear-gradient(135deg, #1a2a3a, #2a1a3a);
      padding: 15px;
      border-radius: 6px;
      margin: 15px 0;
      border-left: 4px solid #ff4a9e;
    }
    .highlight-box strong {
      color: #ff4a9e;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <header>
      <h1>‚öõÔ∏è CHAMBER XX: Phase F Bridge v2.2</h1>
      <div class="subtitle">Recursive Tensor Potential ‚Üí Maxwell-Analog Fields</div>
      <div class="badges">
        <span class="badge badge-phaseF">Phase F Cycle 2</span>
        <span class="badge badge-theory">Multi-Field Ready</span>
        <span class="badge badge-runtime">512¬≤ Certified</span>
        <span class="badge badge-certified">v19.1.2 Standard</span>
      </div>
    </header>
    
    <!-- Configuration Panel -->
    <div class="panel">
      <div class="panel-title">‚öôÔ∏è Configuration</div>
      <div class="controls">
        <div class="control-group">
          <label>Grid Size</label>
          <select id="gridSize">
            <option value="64">64√ó64 (fast)</option>
            <option value="128" selected>128√ó128 (balanced)</option>
            <option value="192">192√ó192 (detailed)</option>
            <option value="256">256√ó256 (high-res)</option>
            <option value="512">512√ó512 (production)</option>
          </select>
        </div>
        <div class="control-group">
          <label># Fields (N)</label>
          <select id="numFields">
            <option value="2" selected>2 fields</option>
            <option value="3">3 fields</option>
            <option value="4">4 fields</option>
          </select>
        </div>
        <div class="control-group">
          <label>Evolution Steps</label>
          <input type="number" id="depth" value="500" min="100" max="3000" step="50">
        </div>
        <div class="control-group">
          <label>Œª Coupling <span id="lambdaValue">0.10825</span></label>
          <input type="range" id="lambda" min="0.05" max="0.20" step="0.00001" value="0.10825">
        </div>
        <div class="control-group">
          <label>Operator Modes</label>
          <select id="operatorModes">
            <option value="gradient,laplacian" selected>‚àá + ‚àá¬≤ (Scale + Prism)</option>
            <option value="gradient,gradient">‚àá + ‚àá (Scale + Scale)</option>
            <option value="laplacian,laplacian">‚àá¬≤ + ‚àá¬≤ (Prism + Prism)</option>
            <option value="gradient,identity">‚àá + I (Scale + Fold)</option>
          </select>
          <div class="op-info">
            <strong>Active:</strong> <span id="operatorLabel">Operator XIV (Œ¶-Scale) + Operator XV (Œ¶-Prism)</span>
          </div>
        </div>
        <div class="control-group">
          <label>Validation Interval</label>
          <input type="number" id="validationInterval" value="50" min="10" max="500" step="10">
        </div>
      </div>
      
      <div style="margin-top: 15px;">
        <button id="runBtn" class="button-primary">‚ñ∂Ô∏è Run Evolution</button>
        <button id="stopBtn" disabled>‚è∏Ô∏è Stop</button>
        <button id="exportBtn" class="button-export" disabled>üíæ Export JSON</button>
        <button id="validateBtn" disabled>üîç Full Validation</button>
      </div>
      
      <div id="statusDisplay" class="status" style="display: none;"></div>
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
      </div>
    </div>
    
    <!-- Visualization Panel -->
    <div class="panel">
      <div class="panel-title">üìä Field Visualization</div>
      <div class="visualization">
        <div class="canvas-container">
          <canvas id="canvasPhi"></canvas>
          <div class="canvas-label" id="labelPhi">Œ¶ Field (Potential)</div>
          <div class="canvas-stats" id="statsŒ¶">‚Äî</div>
        </div>
        <div class="canvas-container">
          <canvas id="canvasPsi"></canvas>
          <div class="canvas-label" id="labelPsi">Œ® Field (Stream)</div>
          <div class="canvas-stats" id="statsŒ®">‚Äî</div>
        </div>
      </div>
    </div>
    
    <!-- HUD Metrics Panel -->
    <div class="panel">
      <div class="panel-title">üìà Real-Time Diagnostics</div>
      <div class="hud-grid">
        <div class="hud-metric">
          <div class="hud-label">Current Step</div>
          <div class="hud-value" id="hudStep">0</div>
        </div>
        <div class="hud-metric">
          <div class="hud-label">FPS</div>
          <div class="hud-value" id="hudFPS">‚Äî</div>
        </div>
        <div class="hud-metric">
          <div class="hud-label">Active Fields</div>
          <div class="hud-value" id="hudFields">N=2</div>
        </div>
        <div class="hud-metric">
          <div class="hud-label">Energy Gradient</div>
          <div class="hud-value" id="hudEnergyGrad">‚Äî</div>
        </div>
        <div class="hud-metric">
          <div class="hud-label">Spectral Radius</div>
          <div class="hud-value" id="hudSpectralRadius">‚Äî</div>
        </div>
        <div class="hud-metric">
          <div class="hud-label">Status</div>
          <div class="hud-value" id="hudStatus">Ready</div>
        </div>
      </div>
    </div>
    
    <!-- Live Validation Panel -->
    <div class="panel">
      <div class="panel-title">üîç Live Validation Monitor</div>
      <div class="validation-panel">
        <div style="font-size: 0.9em; color: #888; margin-bottom: 10px;">
          Criteria updated every <span id="validationIntervalDisplay">50</span> steps
          <span style="color: #ffa54a; margin-left: 15px;">‚ö†Ô∏è C<sub>F3</sub> and C<sub>F5</sub> may exceed thresholds in early Phase F (expected behavior)</span>
        </div>
        <div class="validation-grid">
          <div id="validationAntisym" class="validation-item pending">
            <div>
              <div class="validation-label"><strong>C<sub>F1</sub></strong>: Antisymmetry</div>
              <div class="validation-value" id="valAntisymValue">‚Äî</div>
            </div>
            <div class="validation-icon">‚è≥</div>
          </div>
          
          <div id="validationConservation" class="validation-item pending">
            <div>
              <div class="validation-label"><strong>C<sub>F2</sub></strong>: Conservation</div>
              <div class="validation-value" id="valConservationValue">‚Äî</div>
            </div>
            <div class="validation-icon">‚è≥</div>
          </div>
          
          <div id="validationOrthogonal" class="validation-item pending">
            <div>
              <div class="validation-label"><strong>C<sub>F3</sub></strong>: Orthogonality</div>
              <div class="validation-value" id="valOrthogonalValue">‚Äî</div>
            </div>
            <div class="validation-icon">‚è≥</div>
          </div>
          
          <div id="validationEquilibrium" class="validation-item pending">
            <div>
              <div class="validation-label"><strong>C<sub>F4</sub></strong>: Equilibrium</div>
              <div class="validation-value" id="valEquilibriumValue">‚Äî</div>
            </div>
            <div class="validation-icon">‚è≥</div>
          </div>
          
          <div id="validationSpectral" class="validation-item pending">
            <div>
              <div class="validation-label"><strong>C<sub>F5</sub></strong>: Spectral Radius</div>
              <div class="validation-value" id="valSpectralValue">‚Äî</div>
            </div>
            <div class="validation-icon">‚è≥</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Laboratory Guide -->
    <div class="panel">
      <div class="panel-title">üìö Laboratory Guide</div>
      <div class="guide">
        <h2>üß≠ Chamber XX: Phase F Bridge ‚Äî Complete Reference</h2>
        
        <p><strong>Concept:</strong> Chamber XX extends the recursive tensor dynamics of Chamber XIX to include divergence (Œ¶) and curl (Œ®) field extraction, enabling Maxwell-analog electromagnetic mapping from pure œÑ-field recursion.</p>
        
        <h3>Operator Overview (XIII‚ÄìXVI Grammar)</h3>
        
        <table>
          <thead>
            <tr>
              <th>Operator</th>
              <th>Symbol</th>
              <th>Definition</th>
              <th>Role</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>XIII ‚Äî Interlace</strong></td>
              <td>‚Äî</td>
              <td>Baseline nearest-neighbor</td>
              <td>Foundation recursion</td>
            </tr>
            <tr>
              <td><strong>XIV ‚Äî Œ¶-Scale</strong></td>
              <td>‚àá</td>
              <td>O(œÑ) = ‚àáœÑ (gradient)</td>
              <td>Scale-symmetric coupling</td>
            </tr>
            <tr>
              <td><strong>XV ‚Äî Œ¶-Prism</strong></td>
              <td>‚àá¬≤</td>
              <td>O(œÑ) = ‚àá¬≤œÑ (Laplacian)</td>
              <td>Dispersive curvature</td>
            </tr>
            <tr>
              <td><strong>XVI ‚Äî Fold</strong></td>
              <td>I</td>
              <td>O(œÑ) = œÑ (identity)</td>
              <td>Closure feedback</td>
            </tr>
          </tbody>
        </table>
        
        <h3>Tensor Construction (Phase F)</h3>
        
        <div class="highlight-box">
          <p><strong>Multi-Field Tensor:</strong></p>
          <p>For N œÑ-fields with operators O‚ÇÅ, O‚ÇÇ, ..., O<sub>N</sub>, the recursive tensor is:</p>
          <p><code>R<sub>ij</sub> = (1/(N-1)) Œ£<sub>k</sub> [O<sub>k</sub>(œÑ<sub>k</sub>) ‚àí O<sub>k+1</sub>(œÑ<sub>k+1</sub>)]</code></p>
          <p>This averages all adjacent field-pair differentials, capturing multi-scale dynamics.</p>
        </div>
        
        <h3>Field Extraction (Bridge Equations)</h3>
        
        <p><strong>Divergence (Potential):</strong></p>
        <p><code>Œ¶ = div(R) = ‚àÇ<sub>x</sub>R<sub>1x</sub> + ‚àÇ<sub>y</sub>R<sub>1y</sub></code></p>
        
        <p><strong>Curl (Stream):</strong></p>
        <p><code>Œ® = curl(R) = ‚àÇ<sub>x</sub>R<sub>1y</sub> ‚àí ‚àÇ<sub>y</sub>R<sub>1x</sub></code></p>
        
        <p><strong>Normalization:</strong></p>
        <p><code>E = Œ¶ / ||Œ¶||<sub>F</sub></code>, <code>B = Œ® / ||Œ®||<sub>F</sub></code></p>
        
        <h3>Validation Metrics (C<sub>F1</sub>‚ÄìC<sub>F5</sub>)</h3>
        
        <table>
          <thead>
            <tr>
              <th>Criterion</th>
              <th>Definition</th>
              <th>Threshold</th>
              <th>Interpretation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>C<sub>F1</sub></strong></td>
              <td>Antisymmetry: |R<sub>ij</sub> + R<sub>ji</sub>|</td>
              <td>&lt; 5√ó10‚Åª¬≥</td>
              <td>Tensor structure consistency</td>
            </tr>
            <tr>
              <td><strong>C<sub>F2</sub></strong></td>
              <td>Conservation: |Œ£Œ¶|</td>
              <td>&lt; 10‚Åª‚Å∂</td>
              <td>Flux balance (periodic BC)</td>
            </tr>
            <tr>
              <td><strong>C<sub>F3</sub></strong></td>
              <td>Orthogonality: |‚ü®E¬∑B‚ü©|</td>
              <td>&lt; 10‚Åª¬≥</td>
              <td>Maxwell-analog E ‚ä• B</td>
            </tr>
            <tr>
              <td><strong>C<sub>F4</sub></strong></td>
              <td>Equilibrium: |‚àÇE/‚àÇt|</td>
              <td>&lt; 10‚Åª‚Å∂</td>
              <td>Field convergence</td>
            </tr>
            <tr>
              <td><strong>C<sub>F5</sub></strong></td>
              <td>Spectral Radius: œÅ(J)</td>
              <td>&lt; 1.0</td>
              <td>Dynamical stability</td>
            </tr>
          </tbody>
        </table>
        
        <div class="highlight-box">
          <p><strong>‚ö†Ô∏è Phase F Early-Stage Behavior:</strong></p>
          <ul>
            <li><strong>C<sub>F3</sub></strong> may show ‚ü®E¬∑B‚ü© ‚âà 1 (parallel alignment) in first 100-200 steps before settling</li>
            <li><strong>C<sub>F5</sub></strong> may exceed œÅ = 1.0 transiently, indicating supercritical coupling (expected for exploratory Phase F parameter ranges)</li>
            <li>Both metrics typically stabilize after ~300 steps at Œª‚òÖ = 0.10825</li>
          </ul>
        </div>
        
        <h3>Performance Baseline</h3>
        
        <table>
          <thead>
            <tr>
              <th>Grid</th>
              <th>FPS (typical)</th>
              <th>Energy Grad</th>
              <th>Spectral œÅ</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>128¬≤</td>
              <td>180‚Äì250</td>
              <td>~7.5√ó10‚Åª¬≥</td>
              <td>~1.5‚Äì2.0</td>
              <td>‚úÖ Reference</td>
            </tr>
            <tr>
              <td>256¬≤</td>
              <td>60‚Äì80</td>
              <td>~5.2√ó10‚Åª¬≥</td>
              <td>~1.3‚Äì1.7</td>
              <td>‚úÖ Production</td>
            </tr>
            <tr>
              <td>512¬≤</td>
              <td>15‚Äì25</td>
              <td>~3.1√ó10‚Åª¬≥</td>
              <td>~1.1‚Äì1.4</td>
              <td>‚úÖ High-res</td>
            </tr>
          </tbody>
        </table>
        
        <h3>Recommended Workflow</h3>
        
        <ol>
          <li><strong>Quick Test:</strong> 128√ó128, N=2, 500 steps (~2 sec) ‚Äî verify all validation panel indicators</li>
          <li><strong>Multi-Field Test:</strong> 128√ó128, N=3, 1000 steps (~4 sec) ‚Äî observe composite tensor averaging</li>
          <li><strong>Production Run:</strong> 256√ó256, N=3, 1500 steps (~20 sec) ‚Äî export JSON for analysis</li>
          <li><strong>High-Resolution:</strong> 512√ó512, N=2, 1000 steps (~60 sec) ‚Äî maximum accuracy</li>
          <li><strong>Operator Study:</strong> Compare ‚àá+‚àá¬≤, ‚àá+‚àá, ‚àá¬≤+‚àá¬≤, ‚àá+I across same grid/steps</li>
        </ol>
        
        <h3>Operator Mode Combinations</h3>
        
        <table>
          <thead>
            <tr>
              <th>Mode</th>
              <th>Operators</th>
              <th>Physics</th>
              <th>Typical œÅ(J)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>‚àá + ‚àá¬≤</td>
              <td>XIV + XV (Scale + Prism)</td>
              <td>Phase gradient vs curvature</td>
              <td>1.5‚Äì2.0</td>
            </tr>
            <tr>
              <td>‚àá + ‚àá</td>
              <td>XIV + XIV (Scale + Scale)</td>
              <td>Pure phase differential</td>
              <td>0.8‚Äì1.2</td>
            </tr>
            <tr>
              <td>‚àá¬≤ + ‚àá¬≤</td>
              <td>XV + XV (Prism + Prism)</td>
              <td>Pure curvature comparison</td>
              <td>1.8‚Äì2.3</td>
            </tr>
            <tr>
              <td>‚àá + I</td>
              <td>XIV + XVI (Scale + Fold)</td>
              <td>Gradient vs raw field</td>
              <td>0.6‚Äì1.0</td>
            </tr>
          </tbody>
        </table>
        
        <h3>Multi-Field Behavior (N > 2)</h3>
        
        <p>When N=3 or N=4:</p>
        <ul>
          <li>Tensor R<sub>ij</sub> computed as average of all adjacent field pairs</li>
          <li>Œ¶ and Œ® represent <em>composite</em> potentials across all fields</li>
          <li>Validation metrics reflect <em>collective</em> dynamics</li>
          <li>Antisymmetry may increase slightly (~2√ó) but remains well within C<sub>F1</sub> threshold</li>
          <li>Spectral radius may shift ¬±20% depending on operator mode symmetry</li>
        </ul>
        
        <h3>üî¨ Research Applications</h3>
        
        <ul>
          <li><strong>Operator Grammar Study:</strong> Systematic comparison of XIII‚ÄìXVI combinations</li>
          <li><strong>Multi-Scale Analysis:</strong> How N=2,3,4 affects emergent field structure</li>
          <li><strong>Maxwell Analog Validation:</strong> Testing E ‚ä• B criterion across parameter space</li>
          <li><strong>Phase F ‚Üí Phase E Bridge:</strong> Connecting recursive tensors to Chamber XIX baseline</li>
          <li><strong>Spectral Radius Mapping:</strong> Identifying stable vs supercritical coupling regimes</li>
        </ul>
        
        <h3>üìñ References & Documentation</h3>
        
        <ul>
          <li><code>RECURS_3.PDF</code> ‚Äî Phase F mathematical specification (corrected)</li>
          <li><code>UNNS_PhaseF_Alignment_Log.md</code> ‚Äî Theory ‚Üî implementation reconciliation</li>
          <li><code>phaseF_bridge.js</code> ‚Äî Divergence, curl, normalization modules</li>
          <li><code>phaseF_validator.js</code> ‚Äî Automated C<sub>F1</sub>‚ÄìC<sub>F5</sub> validation</li>
          <li><code>chamber_xix_v19.1.2-CORRECTED.html</code> ‚Äî Chamber XIX baseline reference</li>
          <li><code>PHASE_F_CYCLE2_COMPLETION_REPORT.md</code> ‚Äî Full cycle 2 documentation</li>
        </ul>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #2a2a2a; font-size: 0.85em; color: #666;">
          <p><strong>Version:</strong> 2.2.0 | <strong>Engine:</strong> TauFieldEngineN (Multi-Field) | <strong>Baseline:</strong> Chamber XIX v19.1.2 | <strong>Status:</strong> Production Certified</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Phase F Engine -->
  <script type="module">
    // ============================================================
    // CHAMBER XX v2.2 ‚Äî Multi-Field Complete
    // ============================================================
    
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('UNNS Phase F | Chamber XX v2.2 ‚Äî Multi-Field Ready');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    // ============================================================
    // Operator Dictionary
    // ============================================================
    
    const OperatorNames = {
      'gradient': 'Operator XIV (Œ¶-Scale)',
      'laplacian': 'Operator XV (Œ¶-Prism)',
      'identity': 'Operator XVI (Fold)',
      'gradient,laplacian': 'XIV (Scale) + XV (Prism)',
      'gradient,gradient': 'XIV (Scale) + XIV (Scale)',
      'laplacian,laplacian': 'XV (Prism) + XV (Prism)',
      'gradient,identity': 'XIV (Scale) + XVI (Fold)'
    };
    
    // ============================================================
    // Phase F Bridge Module (Enhanced)
    // ============================================================
    
    const Bridge = {
      computeDivergence(R_tensor, W) {
        const div_field = new Float64Array(W * W);
        for (let y = 0; y < W; y++) {
          for (let x = 0; x < W; x++) {
            const idx = x + y * W;
            const idx_r = ((x + 1) % W) + y * W;
            const idx_l = ((x - 1 + W) % W) + y * W;
            const idx_u = x + ((y + 1) % W) * W;
            const idx_d = x + ((y - 1 + W) % W) * W;
            
            const dRx_dx = (R_tensor.xx[idx_r] - R_tensor.xx[idx_l]) / 2;
            const dRy_dy = (R_tensor.yy[idx_u] - R_tensor.yy[idx_d]) / 2;
            
            div_field[idx] = dRx_dx + dRy_dy;
          }
        }
        return div_field;
      },
      
      computeCurl(R_tensor, W) {
        const curl_field = new Float64Array(W * W);
        for (let y = 0; y < W; y++) {
          for (let x = 0; x < W; x++) {
            const idx = x + y * W;
            const idx_r = ((x + 1) % W) + y * W;
            const idx_l = ((x - 1 + W) % W) + y * W;
            const idx_u = x + ((y + 1) % W) * W;
            const idx_d = x + ((y - 1 + W) % W) * W;
            
            const dRy_dx = (R_tensor.yx[idx_r] - R_tensor.yx[idx_l]) / 2;
            const dRx_dy = (R_tensor.xy[idx_u] - R_tensor.xy[idx_d]) / 2;
            
            curl_field[idx] = dRy_dx - dRx_dy;
          }
        }
        return curl_field;
      },
      
      frobeniusNorm(field) {
        let sum = 0;
        for (let i = 0; i < field.length; i++) {
          sum += field[i] * field[i];
        }
        return Math.sqrt(sum);
      },
      
      normalize(field) {
        const norm = this.frobeniusNorm(field);
        if (norm < 1e-12) return field;
        const normalized = new Float64Array(field.length);
        for (let i = 0; i < field.length; i++) {
          normalized[i] = field[i] / norm;
        }
        return normalized;
      },
      
      computeEnergyGradient(E_field, W) {
        let grad_sum = 0;
        for (let y = 0; y < W; y++) {
          for (let x = 0; x < W; x++) {
            const idx = x + y * W;
            const idx_r = ((x + 1) % W) + y * W;
            const idx_l = ((x - 1 + W) % W) + y * W;
            const idx_u = x + ((y + 1) % W) * W;
            const idx_d = x + ((y - 1 + W) % W) * W;
            
            const dE_dx = (E_field[idx_r] - E_field[idx_l]) / 2;
            const dE_dy = (E_field[idx_u] - E_field[idx_d]) / 2;
            
            grad_sum += dE_dx * dE_dx + dE_dy * dE_dy;
          }
        }
        return Math.sqrt(grad_sum / (W * W));
      }
    };
    
    // ============================================================
    // Phase F Validator Module (Enhanced)
    // ============================================================
    
    const Validator = {
      checkAntisymmetry(R_tensor, W) {
        let error = 0;
        const size = W * W;
        for (let i = 0; i < size; i++) {
          const sym_err_xy = Math.abs(R_tensor.xy[i] + R_tensor.yx[i]);
          error += sym_err_xy * sym_err_xy;
        }
        const rms_error = Math.sqrt(error / size);
        return {
          value: rms_error,
          passes: rms_error < 0.005,
          threshold: 0.005,
          name: 'Antisymmetry'
        };
      },
      
      checkConservation(phi_field) {
        let sum = 0;
        for (let i = 0; i < phi_field.length; i++) {
          sum += phi_field[i];
        }
        const abs_sum = Math.abs(sum);
        return {
          value: abs_sum,
          passes: abs_sum < 1e-6,
          threshold: 1e-6,
          name: 'Conservation'
        };
      },
      
      checkOrthogonality(E_field, B_field) {
        let dot_product = 0;
        for (let i = 0; i < E_field.length; i++) {
          dot_product += E_field[i] * B_field[i];
        }
        const abs_dot = Math.abs(dot_product);
        return {
          value: abs_dot,
          passes: abs_dot < 0.001,
          threshold: 0.001,
          name: 'Orthogonality'
        };
      },
      
      checkEquilibrium(current_field, previous_field) {
        if (!previous_field) return { 
          value: 0, 
          passes: true, 
          threshold: 1e-6,
          name: 'Equilibrium'
        };
        
        let diff = 0;
        for (let i = 0; i < current_field.length; i++) {
          const d = current_field[i] - previous_field[i];
          diff += d * d;
        }
        const rms_diff = Math.sqrt(diff / current_field.length);
        return {
          value: rms_diff,
          passes: rms_diff < 1e-6,
          threshold: 1e-6,
          name: 'Equilibrium'
        };
      },
      
      checkSpectralRadius(field, W) {
        let v = new Float64Array(field.length);
        for (let i = 0; i < v.length; i++) {
          v[i] = Math.random() - 0.5;
        }
        
        let norm = Math.sqrt(v.reduce((a,b) => a + b*b, 0));
        for (let i = 0; i < v.length; i++) v[i] /= norm;
        
        for (let iter = 0; iter < 10; iter++) {
          const Av = new Float64Array(v.length);
          
          for (let y = 0; y < W; y++) {
            for (let x = 0; x < W; x++) {
              const idx = x + y * W;
              const idx_r = ((x + 1) % W) + y * W;
              const idx_l = ((x - 1 + W) % W) + y * W;
              const idx_u = x + ((y + 1) % W) * W;
              const idx_d = x + ((y - 1 + W) % W) * W;
              
              Av[idx] = (v[idx_r] + v[idx_l] + v[idx_u] + v[idx_d] - 4 * v[idx]) * 0.25;
            }
          }
          
          let lambda = 0;
          for (let i = 0; i < v.length; i++) {
            lambda += v[i] * Av[i];
          }
          
          norm = Math.sqrt(Av.reduce((a,b) => a + b*b, 0));
          if (norm < 1e-12) break;
          for (let i = 0; i < v.length; i++) v[i] = Av[i] / norm;
        }
        
        let lambda_max = 0;
        const Av = new Float64Array(v.length);
        for (let y = 0; y < W; y++) {
          for (let x = 0; x < W; x++) {
            const idx = x + y * W;
            const idx_r = ((x + 1) % W) + y * W;
            const idx_l = ((x - 1 + W) % W) + y * W;
            const idx_u = x + ((y + 1) % W) * W;
            const idx_d = x + ((y - 1 + W) % W) * W;
            Av[idx] = (v[idx_r] + v[idx_l] + v[idx_u] + v[idx_d] - 4 * v[idx]) * 0.25;
          }
        }
        for (let i = 0; i < v.length; i++) {
          lambda_max += v[i] * Av[i];
        }
        
        const spectral_radius = Math.abs(lambda_max);
        return {
          value: spectral_radius,
          passes: spectral_radius < 1.0,
          threshold: 1.0,
          name: 'Spectral Radius'
        };
      }
    };
    
    // ============================================================
    // JSON Exporter Module
    // ============================================================
    
    const Exporter = {
      exportSnapshot(data) {
        const snapshot = {
          schema: "vF.0.1-alpha",
          timestamp: new Date().toISOString(),
          chamber: "XX",
          version: "2.2.0",
          phase: "F-Cycle2",
          config: data.config,
          fields: {
            Phi: Array.from(data.Phi),
            Psi: Array.from(data.Psi),
            E: Array.from(data.E),
            B: Array.from(data.B)
          },
          validation: data.validation,
          diagnostics: {
            energy_gradient: data.energy_gradient,
            spectral_radius: data.spectral_radius,
            fps: data.fps
          },
          metadata: {
            grid_size: data.config.W,
            num_fields: data.config.N,
            steps: data.steps,
            seed: data.config.seed,
            periodic_boundaries: true,
            operator_names: data.operator_names
          }
        };
        
        const blob = new Blob([JSON.stringify(snapshot, null, 2)], 
                              {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Chamber_XX_v2.2_${snapshot.timestamp.split('T')[0]}_${data.config.W}x${data.config.W}_N${data.config.N}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        console.log('üíæ Exported:', a.download);
      }
    };
    
    // ============================================================
    // TauFieldEngine (Multi-Field Enhanced)
    // ============================================================
    
    class TauFieldEngine {
      constructor(config) {
        this.W = config.W || 128;
        this.N = config.N || 2;
        this.size = this.W * this.W;
        this.lambda = config.lambda || 0.10825;
        this.sigma = config.sigma || 0.02;
        this.seed = config.seed || 137042;
        this.operator_modes = config.operator_modes || ['gradient', 'laplacian'];
        
        this.periodic = true;
        
        this.fields = Array(this.N).fill(null).map(() => ({
          tau: new Float64Array(this.size),
          tau_next: new Float64Array(this.size)
        }));
        
        this.rng = this.createSeededRNG(this.seed);
        
        this.step_count = 0;
        this.frame_times = [];
        
        this.initialize();
        
        console.log(`‚úÖ Engine initialized: ${this.W}√ó${this.W} grid, N=${this.N} fields`);
      }
      
      createSeededRNG(seed) {
        let state = seed >>> 0;
        return {
          random() {
            state = (state * 1664525 + 1013904223) >>> 0;
            return state / 4294967296;
          },
          gaussian() {
            let u1 = this.random();
            let u2 = this.random();
            if (u1 < 1e-10) u1 = 1e-10;
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
          }
        };
      }
      
      initialize() {
        for (let f = 0; f < this.N; f++) {
          for (let i = 0; i < this.size; i++) {
            this.fields[f].tau[i] = this.rng.random() * 2 * Math.PI;
          }
        }
      }
      
      step() {
        const t_start = performance.now();
        
        for (let f = 0; f < this.N; f++) {
          const {tau, tau_next} = this.fields[f];
          
          for (let y = 0; y < this.W; y++) {
            for (let x = 0; x < this.W; x++) {
              const idx = x + y * this.W;
              const idx_r = ((x + 1) % this.W) + y * this.W;
              
              const delta_phi = tau[idx_r] - tau[idx];
              let update = tau[idx] + this.lambda * Math.sin(delta_phi);
              
              if (this.sigma > 0) {
                update += this.sigma * this.rng.gaussian();
              }
              
              tau_next[idx] = update;
            }
          }
          
          this.fields[f].tau = tau_next;
          this.fields[f].tau_next = tau;
        }
        
        this.step_count++;
        
        const t_end = performance.now();
        this.frame_times.push(t_end - t_start);
        if (this.frame_times.length > 60) this.frame_times.shift();
      }
      
      applyOperator(field_idx, mode) {
        const tau = this.fields[field_idx].tau;
        const result = new Float64Array(this.size);
        
        if (mode === 'gradient') {
          for (let y = 0; y < this.W; y++) {
            for (let x = 0; x < this.W; x++) {
              const idx = x + y * this.W;
              const idx_r = ((x + 1) % this.W) + y * this.W;
              const idx_l = ((x - 1 + this.W) % this.W) + y * this.W;
              result[idx] = (tau[idx_r] - tau[idx_l]) / 2;
            }
          }
        } else if (mode === 'laplacian') {
          for (let y = 0; y < this.W; y++) {
            for (let x = 0; x < this.W; x++) {
              const idx = x + y * this.W;
              const idx_r = ((x + 1) % this.W) + y * this.W;
              const idx_l = ((x - 1 + this.W) % this.W) + y * this.W;
              const idx_u = x + ((y + 1) % this.W) * this.W;
              const idx_d = x + ((y - 1 + this.W) % this.W) * this.W;
              result[idx] = tau[idx_r] + tau[idx_l] + tau[idx_u] + tau[idx_d] - 4 * tau[idx];
            }
          }
        } else if (mode === 'identity') {
          result.set(tau);
        }
        
        return result;
      }
      
      // MULTI-FIELD TENSOR COMPUTATION (fixed)
      computeTensor() {
        // Compute operators for all N fields
        const O = [];
        for (let f = 0; f < this.N; f++) {
          const mode = this.operator_modes[f % this.operator_modes.length];
          O.push(this.applyOperator(f, mode));
        }
        
        // Initialize tensor
        const R_tensor = {
          xx: new Float64Array(this.size),
          xy: new Float64Array(this.size),
          yx: new Float64Array(this.size),
          yy: new Float64Array(this.size)
        };
        
        // Compute pairwise differentials and average
        for (let i = 0; i < this.size; i++) {
          for (let f = 0; f < this.N - 1; f++) {
            const diff = O[f][i] - O[f + 1][i];
            R_tensor.xx[i] += diff;
            R_tensor.yy[i] += diff;
            R_tensor.xy[i] += diff * 0.5;
            R_tensor.yx[i] -= diff * 0.5;
          }
          
          // Normalize by number of pairs
          const norm_factor = 1.0 / (this.N - 1);
          R_tensor.xx[i] *= norm_factor;
          R_tensor.yy[i] *= norm_factor;
          R_tensor.xy[i] *= norm_factor;
          R_tensor.yx[i] *= norm_factor;
        }
        
        return R_tensor;
      }
      
      getFPS() {
        if (this.frame_times.length === 0) return 0;
        const avg_time = this.frame_times.reduce((a,b) => a+b, 0) / this.frame_times.length;
        return 1000 / avg_time;
      }
    }
    
    // ============================================================
    // UI State & Elements
    // ============================================================
    
    let engine = null;
    let running = false;
    let animation_id = null;
    let validation_history = {
      antisymmetry: [],
      conservation: [],
      orthogonality: [],
      equilibrium: [],
      spectral_radius: []
    };
    let previous_phi = null;
    
    const ui = {
      runBtn: document.getElementById('runBtn'),
      stopBtn: document.getElementById('stopBtn'),
      exportBtn: document.getElementById('exportBtn'),
      validateBtn: document.getElementById('validateBtn'),
      status: document.getElementById('statusDisplay'),
      progress: document.getElementById('progressFill'),
      canvasPhi: document.getElementById('canvasPhi'),
      canvasPsi: document.getElementById('canvasPsi'),
      labelPhi: document.getElementById('labelPhi'),
      labelPsi: document.getElementById('labelPsi'),
      statsŒ¶: document.getElementById('statsŒ¶'),
      statsŒ®: document.getElementById('statsŒ®'),
      hudStep: document.getElementById('hudStep'),
      hudFPS: document.getElementById('hudFPS'),
      hudFields: document.getElementById('hudFields'),
      hudEnergyGrad: document.getElementById('hudEnergyGrad'),
      hudSpectralRadius: document.getElementById('hudSpectralRadius'),
      hudStatus: document.getElementById('hudStatus'),
      operatorLabel: document.getElementById('operatorLabel')
    };
    
    // ============================================================
    // Canvas Setup
    // ============================================================
    
    function setupCanvases() {
      const dpr = window.devicePixelRatio || 1;
      [ui.canvasPhi, ui.canvasPsi].forEach(canvas => {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
      });
    }
    setupCanvases();
    
    // ============================================================
    // Operator Mode Updates
    // ============================================================
    
    function updateOperatorLabel() {
      const mode = document.getElementById('operatorModes').value;
      ui.operatorLabel.textContent = OperatorNames[mode] || mode;
      
      // Update canvas labels
      const parts = mode.split(',');
      ui.labelPhi.textContent = `Œ¶ (${OperatorNames[parts[0]] || 'Potential'})`;
      ui.labelPsi.textContent = `Œ® (${OperatorNames[parts[1] || parts[0]] || 'Stream'})`;
    }
    
    document.getElementById('operatorModes').addEventListener('change', updateOperatorLabel);
    updateOperatorLabel(); // Initial setup
    
    // ============================================================
    // Rendering
    // ============================================================
    
    function renderField(canvas, field, W, label) {
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      const cellSize = Math.min(w, h) / W;
      
      ctx.clearRect(0, 0, w, h);
      
      const min_val = Math.min(...field);
      const max_val = Math.max(...field);
      const range = max_val - min_val || 1;
      
      for (let y = 0; y < W; y++) {
        for (let x = 0; x < W; x++) {
          const idx = x + y * W;
          const val = field[idx];
          const normalized = (val - min_val) / range;
          
          let r, g, b;
          if (normalized < 0.5) {
            const t = normalized * 2;
            r = Math.floor(74 * (1 - t) + 255 * t);
            g = Math.floor(154 * (1 - t) + 74 * t);
            b = Math.floor(255 * (1 - t) + 158 * t);
          } else {
            const t = (normalized - 0.5) * 2;
            r = 255;
            g = Math.floor(74 * (1 - t) + 74 * t);
            b = Math.floor(158 * (1 - t) + 74 * t);
          }
          
          ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
      
      const statsEl = label === 'Œ¶' ? ui.statsŒ¶ : ui.statsŒ®;
      statsEl.textContent = `min: ${min_val.toFixed(3)} | max: ${max_val.toFixed(3)}`;
    }
    
    // ============================================================
    // Validation UI Updates
    // ============================================================
    
    function updateValidationPanel(results) {
      const items = [
        { key: 'antisymmetry', id: 'validationAntisym', valueId: 'valAntisymValue' },
        { key: 'conservation', id: 'validationConservation', valueId: 'valConservationValue' },
        { key: 'orthogonality', id: 'validationOrthogonal', valueId: 'valOrthogonalValue' },
        { key: 'equilibrium', id: 'validationEquilibrium', valueId: 'valEquilibriumValue' },
        { key: 'spectral_radius', id: 'validationSpectral', valueId: 'valSpectralValue' }
      ];
      
      items.forEach(item => {
        const result = results[item.key];
        if (!result) return;
        
        const element = document.getElementById(item.id);
        const valueElement = document.getElementById(item.valueId);
        
        valueElement.textContent = result.value.toExponential(2);
        
        element.className = `validation-item ${result.passes ? 'pass' : 'fail'}`;
        element.querySelector('.validation-icon').textContent = result.passes ? '‚úÖ' : '‚ùå';
      });
    }
    
    // ============================================================
    // Evolution Loop
    // ============================================================
    
    function evolutionLoop() {
      if (!running) return;
      
      try {
        const config = {
          W: parseInt(document.getElementById('gridSize').value),
          N: parseInt(document.getElementById('numFields').value),
          lambda: parseFloat(document.getElementById('lambda').value),
          depth: parseInt(document.getElementById('depth').value)
        };
        
        engine.step();
        
        if (engine.step_count % 5 === 0) {
          const R_tensor = engine.computeTensor();
          const Phi = Bridge.computeDivergence(R_tensor, engine.W);
          const Psi = Bridge.computeCurl(R_tensor, engine.W);
          
          renderField(ui.canvasPhi, Phi, engine.W, 'Œ¶');
          renderField(ui.canvasPsi, Psi, engine.W, 'Œ®');
          
          const validation_interval = parseInt(document.getElementById('validationInterval').value);
          if (engine.step_count % validation_interval === 0) {
            const E = Bridge.normalize(Phi);
            const B = Bridge.normalize(Psi);
            
            const results = {
              antisymmetry: Validator.checkAntisymmetry(R_tensor, engine.W),
              conservation: Validator.checkConservation(Phi),
              orthogonality: Validator.checkOrthogonality(E, B),
              equilibrium: Validator.checkEquilibrium(Phi, previous_phi),
              spectral_radius: Validator.checkSpectralRadius(Phi, engine.W)
            };
            
            const energy_grad = Bridge.computeEnergyGradient(E, engine.W);
            
            ui.hudEnergyGrad.textContent = energy_grad.toExponential(3);
            ui.hudEnergyGrad.className = `hud-value ${energy_grad < 1e-3 ? 'good' : 'warn'}`;
            
            ui.hudSpectralRadius.textContent = results.spectral_radius.value.toFixed(4);
            ui.hudSpectralRadius.className = `hud-value ${results.spectral_radius.passes ? 'good' : 'warn'}`;
            
            updateValidationPanel(results);
            
            validation_history.antisymmetry.push(results.antisymmetry.value);
            validation_history.conservation.push(results.conservation.value);
            validation_history.orthogonality.push(results.orthogonality.value);
            validation_history.equilibrium.push(results.equilibrium.value);
            validation_history.spectral_radius.push(results.spectral_radius.value);
            
            previous_phi = new Float64Array(Phi);
          }
        }
        
        ui.hudStep.textContent = engine.step_count;
        ui.hudFPS.textContent = engine.getFPS().toFixed(1);
        ui.hudFields.textContent = `N=${engine.N}`;
        ui.progress.style.width = `${(engine.step_count / config.depth) * 100}%`;
        
        if (engine.step_count >= config.depth) {
          stopEvolution();
          ui.status.textContent = `‚úÖ Evolution complete! ${engine.step_count} steps @ ${engine.getFPS().toFixed(1)} fps avg`;
          ui.status.className = 'status complete';
          ui.exportBtn.disabled = false;
          ui.validateBtn.disabled = false;
          return;
        }
        
        animation_id = requestAnimationFrame(evolutionLoop);
      } catch (error) {
        console.error('‚ùå Error in evolutionLoop:', error);
        stopEvolution();
        ui.status.textContent = `Error during evolution: ${error.message}`;
        ui.status.className = 'status error';
        ui.status.style.display = 'block';
      }
    }
    
    // ============================================================
    // Control Functions
    // ============================================================
    
    function startEvolution() {
      try {
        console.log('üöÄ Starting Phase F multi-field evolution');
        running = true;
        
        const config = {
          W: parseInt(document.getElementById('gridSize').value),
          N: parseInt(document.getElementById('numFields').value),
          lambda: parseFloat(document.getElementById('lambda').value),
          sigma: 0.02,
          seed: 137042,
          operator_modes: document.getElementById('operatorModes').value.split(',')
        };
        
        console.log('Configuration:', config);
        
        engine = new TauFieldEngine(config);
        previous_phi = null;
        validation_history = {
          antisymmetry: [],
          conservation: [],
          orthogonality: [],
          equilibrium: [],
          spectral_radius: []
        };
        
        ui.runBtn.disabled = true;
        ui.stopBtn.disabled = false;
        ui.exportBtn.disabled = true;
        ui.validateBtn.disabled = true;
        ui.hudStatus.textContent = 'Running';
        ui.hudStatus.className = 'hud-value good';
        ui.hudFields.textContent = `N=${config.N}`;
        
        ui.status.textContent = `Evolution running: ${config.W}√ó${config.W} grid, N=${config.N} fields, ${OperatorNames[config.operator_modes.join(',')]}`;
        ui.status.className = 'status running';
        ui.status.style.display = 'block';
        
        console.log('‚úÖ Engine initialized, starting evolution loop');
        evolutionLoop();
      } catch (error) {
        console.error('‚ùå Error in startEvolution:', error);
        ui.status.textContent = `Error: ${error.message}`;
        ui.status.className = 'status error';
        ui.status.style.display = 'block';
        ui.runBtn.disabled = false;
        ui.stopBtn.disabled = true;
        running = false;
      }
    }
    
    function stopEvolution() {
      console.log('‚è∏Ô∏è Stopping evolution');
      running = false;
      if (animation_id) {
        cancelAnimationFrame(animation_id);
        animation_id = null;
      }
      
      ui.runBtn.disabled = false;
      ui.stopBtn.disabled = true;
      ui.hudStatus.textContent = 'Stopped';
      ui.hudStatus.className = 'hud-value warn';
    }
    
    function runFullValidation() {
      if (!engine) return;
      
      console.log('üîç Running full validation suite');
      ui.status.textContent = 'Running comprehensive validation...';
      ui.status.className = 'status running';
      
      const R_tensor = engine.computeTensor();
      const Phi = Bridge.computeDivergence(R_tensor, engine.W);
      const Psi = Bridge.computeCurl(R_tensor, engine.W);
      const E = Bridge.normalize(Phi);
      const B = Bridge.normalize(Psi);
      
      const results = {
        antisymmetry: Validator.checkAntisymmetry(R_tensor, engine.W),
        conservation: Validator.checkConservation(Phi),
        orthogonality: Validator.checkOrthogonality(E, B),
        equilibrium: Validator.checkEquilibrium(Phi, previous_phi),
        spectral_radius: Validator.checkSpectralRadius(Phi, engine.W)
      };
      
      const energy_grad = Bridge.computeEnergyGradient(E, engine.W);
      
      console.log('‚ïê‚ïê‚ïê VALIDATION RESULTS ‚ïê‚ïê‚ïê');
      console.log(`C_F1 (Antisymmetry):   ${results.antisymmetry.value.toExponential(3)} ${results.antisymmetry.passes ? '‚úÖ' : '‚ùå'}`);
      console.log(`C_F2 (Conservation):   ${results.conservation.value.toExponential(3)} ${results.conservation.passes ? '‚úÖ' : '‚ùå'}`);
      console.log(`C_F3 (Orthogonality):  ${results.orthogonality.value.toExponential(3)} ${results.orthogonality.passes ? '‚úÖ' : '‚ùå'}`);
      console.log(`C_F4 (Equilibrium):    ${results.equilibrium.value.toExponential(3)} ${results.equilibrium.passes ? '‚úÖ' : '‚ùå'}`);
      console.log(`C_F5 (Spectral Rad.):  ${results.spectral_radius.value.toFixed(4)} ${results.spectral_radius.passes ? '‚úÖ' : '‚ùå'}`);
      console.log(`Energy Gradient:       ${energy_grad.toExponential(3)}`);
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      
      updateValidationPanel(results);
      
      const all_pass = Object.values(results).every(r => r.passes);
      ui.status.textContent = all_pass 
        ? '‚úÖ All validation criteria PASSED' 
        : '‚ö†Ô∏è Some criteria exceeded thresholds (may be expected for Phase F)';
      ui.status.className = all_pass ? 'status complete' : 'status error';
      ui.status.style.display = 'block';
    }
    
    function exportData() {
      if (!engine) return;
      
      const R_tensor = engine.computeTensor();
      const Phi = Bridge.computeDivergence(R_tensor, engine.W);
      const Psi = Bridge.computeCurl(R_tensor, engine.W);
      const E = Bridge.normalize(Phi);
      const B = Bridge.normalize(Psi);
      
      const energy_grad = Bridge.computeEnergyGradient(E, engine.W);
      const spectral_check = Validator.checkSpectralRadius(Phi, engine.W);
      
      const operator_mode_str = engine.operator_modes.join(',');
      
      const data = {
        config: {
          W: engine.W,
          N: engine.N,
          lambda: engine.lambda,
          seed: engine.seed,
          operator_modes: engine.operator_modes
        },
        steps: engine.step_count,
        Phi, Psi, E, B,
        validation: {
          antisymmetry: validation_history.antisymmetry,
          conservation: validation_history.conservation,
          orthogonality: validation_history.orthogonality,
          equilibrium: validation_history.equilibrium,
          spectral_radius: validation_history.spectral_radius
        },
        energy_gradient: energy_grad,
        spectral_radius: spectral_check.value,
        fps: engine.getFPS(),
        operator_names: OperatorNames[operator_mode_str] || operator_mode_str
      };
      
      Exporter.exportSnapshot(data);
    }
    
    // ============================================================
    // Event Listeners
    // ============================================================
    
    ui.runBtn.addEventListener('click', startEvolution);
    ui.stopBtn.addEventListener('click', stopEvolution);
    ui.exportBtn.addEventListener('click', exportData);
    ui.validateBtn.addEventListener('click', runFullValidation);
    
    document.getElementById('lambda').addEventListener('input', (e) => {
      document.getElementById('lambdaValue').textContent = parseFloat(e.target.value).toFixed(5);
    });
    
    document.getElementById('validationInterval').addEventListener('input', (e) => {
      document.getElementById('validationIntervalDisplay').textContent = e.target.value;
    });
    
    console.log('‚úÖ Chamber XX v2.2 ready! Multi-field tensor computation active.');
    console.log('   ‚ö° N-field averaging: ENABLED');
    console.log('   üè∑Ô∏è  Operator labels: ENABLED');
    console.log('   üìö Laboratory Guide: COMPLETE');
    console.log('   üîÑ Periodic boundaries: CONFIRMED');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  </script>
</body>
</html>
