<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set Theory ↔ UNNS Interpolation Chamber</title>
</head>
<body>
<div class="unns-chamber-container">
    <style>
        /* Blogger-Safe Isolated Styling */
        .unns-chamber-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at center, #0a0b1e, #02030a);
            color: #e2e8f0;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }
        
        .unns-chamber-container * {
            box-sizing: border-box;
        }
        
        .unns-header {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.7));
            border-bottom: 2px solid #334155;
            backdrop-filter: blur(10px);
        }
        
        .unns-title {
            font-size: 3rem;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0 0 10px 0;
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.4);
            animation: unns-glow 3s ease-in-out infinite alternate;
        }
        
        @keyframes unns-glow {
            0% { filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.3)); }
            100% { filter: drop-shadow(0 0 25px rgba(139, 92, 246, 0.6)); }
        }
        
        .unns-subtitle {
            font-size: 1.2rem;
            color: #94a3b8;
            margin: 0;
            opacity: 0.9;
        }
        
        .unns-mode-selector {
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 20px;
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid #334155;
            flex-wrap: wrap;
        }
        
        .unns-mode-tab {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            background: rgba(30, 41, 59, 0.6);
            color: #94a3b8;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
        }
        
        .unns-mode-tab:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.6s;
        }
        
        .unns-mode-tab:hover:before {
            left: 100%;
        }
        
        .unns-mode-tab.unns-active {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            border-color: #06b6d4;
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
        }
        
        .unns-mode-tab:hover:not(.unns-active) {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border-color: #3b82f6;
            transform: translateY(-1px);
        }
        
        .unns-workspace {
            display: flex;
            height: calc(100vh - 180px);
            position: relative;
        }
        
        .unns-main-viz {
            flex: 1;
            position: relative;
            background: radial-gradient(ellipse at center, rgba(15, 23, 42, 0.4), rgba(2, 3, 10, 0.8));
            overflow: hidden;
        }
        
        .unns-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .unns-research-portals {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .unns-portal {
            position: absolute;
            width: 120px;
            height: 60px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(139, 92, 246, 0.15));
            border: 2px solid rgba(59, 130, 246, 0.4);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.4s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            animation: unns-portal-float 4s ease-in-out infinite;
        }
        
        @keyframes unns-portal-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        
        .unns-portal:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(139, 92, 246, 0.3));
            border-color: #06b6d4;
            box-shadow: 0 12px 30px rgba(59, 130, 246, 0.3);
            transform: scale(1.1) translateY(-5px);
        }
        
        .unns-portal-icon {
            font-size: 1.5rem;
            margin-bottom: 4px;
        }
        
        .unns-portal-text {
            font-size: 0.7rem;
            color: #e2e8f0;
            font-weight: 600;
            text-align: center;
            line-height: 1.2;
        }
        
        .unns-portal-1 { top: 10%; left: 5%; animation-delay: 0s; }
        .unns-portal-2 { top: 15%; right: 8%; animation-delay: 1s; }
        .unns-portal-3 { bottom: 20%; left: 3%; animation-delay: 2s; }
        .unns-portal-4 { bottom: 15%; right: 5%; animation-delay: 0.5s; }
        .unns-portal-5 { top: 45%; left: 2%; animation-delay: 1.5s; }
        
        .unns-control-panel {
            width: 320px;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.9));
            border-left: 2px solid #334155;
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .unns-control-section {
            padding: 25px;
            border-bottom: 1px solid rgba(51, 65, 85, 0.5);
        }
        
        .unns-control-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .unns-control-group {
            margin-bottom: 20px;
        }
        
        .unns-control-label {
            display: block;
            font-size: 0.85rem;
            color: #94a3b8;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .unns-slider-container {
            position: relative;
        }
        
        .unns-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #334155, #475569);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .unns-slider:hover {
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .unns-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.5);
            transition: all 0.3s ease;
        }
        
        .unns-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.7);
        }
        
        .unns-slider-value {
            position: absolute;
            right: 0;
            top: -30px;
            font-size: 0.8rem;
            color: #3b82f6;
            font-weight: bold;
            background: rgba(59, 130, 246, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .unns-animation-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .unns-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .unns-btn-primary {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            border: 2px solid transparent;
        }
        
        .unns-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
            background: linear-gradient(135deg, #2563eb, #7c3aed);
        }
        
        .unns-status-indicators {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .unns-status-indicator {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            animation: unns-status-pulse 2s ease-in-out infinite;
        }
        
        @keyframes unns-status-pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .unns-status-safe { 
            background: rgba(34, 197, 94, 0.2); 
            color: #22c55e; 
            border: 2px solid #22c55e; 
        }
        .unns-status-caution { 
            background: rgba(251, 191, 36, 0.2); 
            color: #fbbf24; 
            border: 2px solid #fbbf24; 
        }
        .unns-status-danger { 
            background: rgba(239, 68, 68, 0.2); 
            color: #ef4444; 
            border: 2px solid #ef4444; 
        }
        
        .unns-constants-monitor {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .unns-constants-grid {
            display: grid;
            gap: 12px;
        }
        
        .unns-constant-item {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.05));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .unns-constant-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #3b82f6, transparent);
            transition: left 2s ease-in-out;
        }
        
        .unns-constant-item:hover:before {
            left: 100%;
        }
        
        .unns-constant-item:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(139, 92, 246, 0.1));
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.2);
        }
        
        .unns-constant-name {
            font-size: 0.85rem;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 6px;
        }
        
        .unns-constant-value {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 6px;
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }
        
        .unns-constant-desc {
            font-size: 0.75rem;
            color: #64748b;
            line-height: 1.4;
        }
        
        /* Responsive Design */
        @media (max-width: 1024px) {
            .unns-control-panel {
                width: 280px;
            }
            
            .unns-title {
                font-size: 2.2rem;
            }
        }
        
        @media (max-width: 768px) {
            .unns-workspace {
                flex-direction: column;
                height: auto;
            }
            
            .unns-control-panel {
                width: 100%;
                height: 300px;
            }
            
            .unns-main-viz {
                height: 500px;
            }
            
            .unns-portal {
                width: 100px;
                height: 50px;
            }
            
            .unns-portal-text {
                font-size: 0.6rem;
            }
            
            .unns-title {
                font-size: 1.8rem;
            }
        }
        
        /* Visual Effect Classes */
        .unns-breathing {
            animation: unns-breathe 4s ease-in-out infinite;
        }
        
        @keyframes unns-breathe {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
        }
        
        .unns-rotating {
            animation: unns-rotate 10s linear infinite;
        }
        
        @keyframes unns-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .unns-pulsing {
            animation: unns-pulse 2s ease-in-out infinite;
        }
        
        @keyframes unns-pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        /* Background Particle Effect */
        .unns-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        
        .unns-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #3b82f6;
            border-radius: 50%;
            opacity: 0.6;
            animation: unns-float-particle 20s linear infinite;
        }
        
        @keyframes unns-float-particle {
            0% {
                transform: translateY(100vh) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateY(-10vh) translateX(100px);
                opacity: 0;
            }
        }
    </style>
    
    <!-- Chamber Header -->
    <div class="unns-header">
        <h1 class="unns-title">Set Theory ↔ UNNS Interpolation Chamber</h1>
        <p class="unns-subtitle">Dynamic overlay revealing deep connections between formal set theory and recursive UNNS patterns</p>
    </div>
    
    <!-- Mode Selector -->
    <div class="unns-mode-selector">
        <button class="unns-mode-tab unns-active" data-mode="set-theory">Set Theory</button>
        <button class="unns-mode-tab" data-mode="unns">UNNS</button>
        <button class="unns-mode-tab" data-mode="overlay">Dynamic Overlay</button>
        <button class="unns-mode-tab" data-mode="constants">Constants Demo</button>
    </div>
    
    <!-- Main Workspace -->
    <div class="unns-workspace">
        <!-- Main Visualization Area -->
        <div class="unns-main-viz">
            <canvas class="unns-canvas" id="unnsCanvas"></canvas>
            
            <!-- Background Particles -->
            <div class="unns-particles" id="unnsParticles"></div>
            
            <!-- Research Portals -->
            <div class="unns-research-portals">
                <a href="https://ukbbi.github.io/UNNS/UNNS_Constants.pdf" target="_blank" class="unns-portal unns-portal-1" title="UNNS Constants">
                    <div class="unns-portal-icon">🌀</div>
                    <div class="unns-portal-text">Constants</div>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/UNNS_Maxwell_FEEC_DEC_upgraded.pdf" target="_blank" class="unns-portal unns-portal-2" title="DEC/FEEC Edge">
                    <div class="unns-portal-icon">⚡</div>
                    <div class="unns-portal-text">DEC/FEEC</div>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/Gödel's Theorem as a UNNS Constant.pdf" target="_blank" class="unns-portal unns-portal-3" title="Gödel's Theorem">
                    <div class="unns-portal-icon">🔮</div>
                    <div class="unns-portal-text">Gödel</div>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/UNNS_Paradox_Index.pdf" target="_blank" class="unns-portal unns-portal-4" title="UNNS Paradox Index">
                    <div class="unns-portal-icon">⚖️</div>
                    <div class="unns-portal-text">UPI</div>
                </a>
                
                <a href="https://ukbbi.github.io/UNNS/Interpolation of Set Theory and the UNNS Discipline.pdf" target="_blank" class="unns-portal unns-portal-5" title="Interpolation Theory">
                    <div class="unns-portal-icon">🌉</div>
                    <div class="unns-portal-text">Theory</div>
                </a>
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="unns-control-panel">
            <div class="unns-control-section">
                <h3 class="unns-control-title">🎛️ Core Parameters</h3>
                
                <div class="unns-control-group">
                    <label class="unns-control-label">Recursion Coefficients (c₁)</label>
                    <div class="unns-slider-container">
                        <input type="range" class="unns-slider" id="unnsC1Slider" min="0.5" max="3" step="0.1" value="1.618">
                        <span class="unns-slider-value" id="unnsC1Value">1.618</span>
                    </div>
                </div>
                
                <div class="unns-control-group">
                    <label class="unns-control-label">Nest Depth (D)</label>
                    <div class="unns-slider-container">
                        <input type="range" class="unns-slider" id="unnsDepthSlider" min="1" max="12" step="1" value="5">
                        <span class="unns-slider-value" id="unnsDepthValue">5</span>
                    </div>
                </div>
                
                <div class="unns-control-group">
                    <label class="unns-control-label">UPI Threshold</label>
                    <div class="unns-slider-container">
                        <input type="range" class="unns-slider" id="unnsUPISlider" min="0.1" max="5" step="0.1" value="1.5">
                        <span class="unns-slider-value" id="unnsUPIValue">1.5</span>
                    </div>
                </div>
                
                <div class="unns-control-group">
                    <label class="unns-control-label">Animation Speed</label>
                    <div class="unns-slider-container">
                        <input type="range" class="unns-slider" id="unnsSpeedSlider" min="0.1" max="3" step="0.1" value="1">
                        <span class="unns-slider-value" id="unnsSpeedValue">1.0</span>
                    </div>
                </div>
            </div>
            
            <div class="unns-control-section">
                <h3 class="unns-control-title">🎮 Animation Controls</h3>
                <div class="unns-animation-controls">
                    <button class="unns-btn unns-btn-primary" id="unnsPlayBtn">Play</button>
                    <button class="unns-btn unns-btn-primary" id="unnsPauseBtn">Pause</button>
                    <button class="unns-btn unns-btn-primary" id="unnsResetBtn">Reset</button>
                </div>
            </div>
            
            <div class="unns-control-section">
                <h3 class="unns-control-title">📊 System Status</h3>
                <div class="unns-status-indicators">
                    <div class="unns-status-indicator unns-status-safe" id="unnsStabilityStatus">SAFE</div>
                    <div class="unns-status-indicator" id="unnsModeStatus">SET THEORY</div>
                </div>
            </div>
            
            <div class="unns-constants-monitor">
                <h3 class="unns-control-title">🔬 Constants Monitor</h3>
                <div class="unns-constants-grid">
                    <div class="unns-constant-item unns-breathing">
                        <div class="unns-constant-name">Limit Ratio (φ)</div>
                        <div class="unns-constant-value" id="unnsPhiValue">1.618034</div>
                        <div class="unns-constant-desc">Golden ratio spiral convergence</div>
                    </div>
                    
                    <div class="unns-constant-item">
                        <div class="unns-constant-name">UPI Index</div>
                        <div class="unns-constant-value" id="unnsUPIDisplay">1.500</div>
                        <div class="unns-constant-desc">Paradox stability measure</div>
                    </div>
                    
                    <div class="unns-constant-item">
                        <div class="unns-constant-name">Nest Depth</div>
                        <div class="unns-constant-value" id="unnsDepthDisplay">5</div>
                        <div class="unns-constant-desc">Recursive layer complexity</div>
                    </div>
                    
                    <div class="unns-constant-item unns-pulsing">
                        <div class="unns-constant-name">Prime Density</div>
                        <div class="unns-constant-value" id="unnsPrimeValue">1/ln(x)</div>
                        <div class="unns-constant-desc">Resonance distribution</div>
                    </div>
                    
                    <div class="unns-constant-item">
                        <div class="unns-constant-name">Gödel Constant</div>
                        <div class="unns-constant-value" id="unnsGodelValue">∞</div>
                        <div class="unns-constant-desc">Undecidable glitches</div>
                    </div>
                    
                    <div class="unns-constant-item">
                        <div class="unns-constant-name">DEC/FEEC Edge</div>
                        <div class="unns-constant-value" id="unnsEdgeValue">Stable</div>
                        <div class="unns-constant-desc">Mesh cohomology</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
    (function() {
        'use strict';
        
        class UNNSChamber {
            constructor() {
                this.canvas = document.getElementById('unnsCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.mode = 'set-theory';
                this.time = 0;
                this.isPlaying = true;
                
                this.params = {
                    c1: 1.618,
                    depth: 5,
                    upi: 1.5,
                    speed: 1.0
                };
                
                this.particles = [];
                this.spirals = [];
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupControls();
                this.setupParticleBackground();
                this.initMathematicalElements();
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            setupControls() {
                // Mode tabs
                document.querySelectorAll('.unns-mode-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.unns-mode-tab').forEach(t => t.classList.remove('unns-active'));
                        tab.classList.add('unns-active');
                        this.mode = tab.dataset.mode;
                        document.getElementById('unnsModeStatus').textContent = this.mode.toUpperCase().replace('-', ' ');
                    });
                });
                
                // Sliders
                const sliders = [
                    {id: 'unnsC1Slider', param: 'c1', display: 'unnsC1Value', decimals: 3},
                    {id: 'unnsDepthSlider', param: 'depth', display: 'unnsDepthValue', decimals: 0},
                    {id: 'unnsUPISlider', param: 'upi', display: 'unnsUPIValue', decimals: 1},
                    {id: 'unnsSpeedSlider', param: 'speed', display: 'unnsSpeedValue', decimals: 1}
                ];
                
                sliders.forEach(({id, param, display, decimals}) => {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(display);
                    
                    if (slider && valueDisplay) {
                        slider.addEventListener('input', () => {
                            const value = parseFloat(slider.value);
                            this.params[param] = value;
                            valueDisplay.textContent = decimals === 0 ? value.toString() : value.toFixed(decimals);
                            this.updateConstants();
                            this.updateStability();
                        });
                    }
                });
                
                // Animation controls
                const playBtn = document.getElementById('unnsPlayBtn');
                const pauseBtn = document.getElementById('unnsPauseBtn');
                const resetBtn = document.getElementById('unnsResetBtn');
                
                if (playBtn) playBtn.addEventListener('click', () => this.isPlaying = true);
                if (pauseBtn) pauseBtn.addEventListener('click', () => this.isPlaying = false);
                if (resetBtn) resetBtn.addEventListener('click', () => {
                    this.time = 0;
                    this.initMathematicalElements();
                });
            }
            
            setupParticleBackground() {
                const particlesContainer = document.getElementById('unnsParticles');
                if (!particlesContainer) return;
                
                // Create floating particles
                for (let i = 0; i < 15; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'unns-particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.animationDelay = Math.random() * 20 + 's';
                    particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                    particlesContainer.appendChild(particle);
                }
            }
            
            initMathematicalElements() {
                this.particles = [];
                this.spirals = [];
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Russell's paradox particles
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    const radius = 80 + Math.random() * 120;
                    this.particles.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        angle: angle,
                        radius: radius,
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.015 + Math.random() * 0.02,
                        size: 2 + Math.random() * 3,
                        color: this.getParticleColor()
                    });
                }
                
                // UNNS spirals
                for (let i = 0; i < 25; i++) {
                    this.spirals.push({
                        x: centerX + (Math.random() - 0.5) * 400,
                        y: centerY + (Math.random() - 0.5) * 300,
                        angle: Math.random() * Math.PI * 2,
                        radius: 15 + Math.random() * 35,
                        speed: 0.01 + Math.random() * 0.02,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
            
            getParticleColor() {
                const colors = [
                    'rgba(59, 130, 246, 0.8)',
                    'rgba(139, 92, 246, 0.8)',
                    'rgba(6, 182, 212, 0.8)',
                    'rgba(251, 191, 36, 0.8)'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            drawSetTheory() {
                const ctx = this.ctx;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Background containment circles
                for (let i = 0; i < 5; i++) {
                    const radius = 60 + i * 40;
                    const intensity = Math.sin(this.time * 0.01 + i * 0.5) * 0.3 + 0.7;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(59, 130, 246, ${intensity * 0.4})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Animated particles
                this.particles.forEach(particle => {
                    particle.phase += particle.speed * this.params.speed;
                    
                    const dynamicRadius = particle.radius + Math.sin(particle.phase) * 25;
                    const x = centerX + Math.cos(particle.angle + particle.phase * 0.3) * dynamicRadius;
                    const y = centerY + Math.sin(particle.angle + particle.phase * 0.3) * dynamicRadius;
                    
                    const pulseSize = particle.size + Math.sin(particle.phase * 2) * 1.5;
                    const alpha = 0.6 + Math.sin(particle.phase * 1.5) * 0.4;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color.replace('0.8', alpha.toString());
                    ctx.fill();
                    
                    // Particle trails
                    for (let trail = 1; trail <= 3; trail++) {
                        const trailPhase = particle.phase - trail * 0.1;
                        const trailRadius = particle.radius + Math.sin(trailPhase) * 25;
                        const trailX = centerX + Math.cos(particle.angle + trailPhase * 0.3) * trailRadius;
                        const trailY = centerY + Math.sin(particle.angle + trailPhase * 0.3) * trailRadius;
                        
                        ctx.beginPath();
                        ctx.arc(trailX, trailY, pulseSize * (1 - trail * 0.2), 0, Math.PI * 2);
                        ctx.fillStyle = particle.color.replace('0.8', (alpha * (1 - trail * 0.3)).toString());
                        ctx.fill();
                    }
                });
                
                // Power set lattice
                this.drawPowerSetLattice(centerX, centerY);
            }
            
            drawPowerSetLattice(centerX, centerY) {
                const ctx = this.ctx;
                const latticePoints = [
                    [centerX - 180, centerY - 120],
                    [centerX, centerY - 180],
                    [centerX + 180, centerY - 120],
                    [centerX - 90, centerY],
                    [centerX + 90, centerY],
                    [centerX, centerY + 120]
                ];
                
                latticePoints.forEach((basePoint, i) => {
                    const floatX = basePoint[0] + Math.sin(this.time * 0.015 + i) * 12;
                    const floatY = basePoint[1] + Math.cos(this.time * 0.012 + i) * 10;
                    const pulseSize = 10 + Math.sin(this.time * 0.025 + i) * 4;
                    
                    // Glow effect
                    const gradient = ctx.createRadialGradient(floatX, floatY, 0, floatX, floatY, pulseSize * 2);
                    gradient.addColorStop(0, 'rgba(59, 130, 246, 0.8)');
                    gradient.addColorStop(1, 'rgba(59, 130, 246, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(floatX, floatY, pulseSize * 2, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(floatX, floatY, pulseSize, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(59, 130, 246, ${0.8 + Math.sin(this.time * 0.02 + i) * 0.2})`;
                    ctx.fill();
                    
                    // Connections
                    if (i > 0) {
                        const connectionIntensity = Math.sin(this.time * 0.008 + i * 0.3) * 0.3 + 0.4;
                        ctx.beginPath();
                        ctx.moveTo(latticePoints[0][0], latticePoints[0][1]);
                        ctx.lineTo(floatX, floatY);
                        ctx.strokeStyle = `rgba(59, 130, 246, ${connectionIntensity})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
            }
            
            drawUNNS() {
                const ctx = this.ctx;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Central UPI dial
                this.drawUPIDial(centerX, centerY);
                
                // Recursive depth layers
                for (let layer = this.params.depth; layer >= 1; layer--) {
                    const radius = (layer / this.params.depth) * 150 + Math.sin(this.time * 0.02 + layer) * 8;
                    const alpha = (layer / this.params.depth) * 0.6 + 0.2;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(139, 92, 246, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Layer indicators
                    const numIndicators = layer * 2;
                    for (let i = 0; i < numIndicators; i++) {
                        const angle = (i / numIndicators) * Math.PI * 2 + this.time * 0.01 * layer;
                        const x = centerX + Math.cos(angle) * (radius + 15);
                        const y = centerY + Math.sin(angle) * (radius + 15);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(139, 92, 246, ${alpha})`;
                        ctx.fill();
                    }
                }
                
                // UNNS spirals
                this.spirals.forEach(spiral => {
                    spiral.phase += spiral.speed * this.params.speed;
                    
                    const x = spiral.x + Math.cos(spiral.angle + spiral.phase) * spiral.radius;
                    const y = spiral.y + Math.sin(spiral.angle + spiral.phase) * spiral.radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(6, 182, 212, ${0.6 + Math.sin(spiral.phase * 2) * 0.4})`;
                    ctx.fill();
                });
            }
            
            drawUPIDial(centerX, centerY) {
                const ctx = this.ctx;
                const radius = 100;
                
                // Background dial
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.3)';
                ctx.lineWidth = 15;
                ctx.stroke();
                
                // UPI arc
                const upiAngle = (this.params.upi / 5) * Math.PI * 2 - Math.PI / 2;
                let color;
                if (this.params.upi < 1) color = '34, 197, 94';
                else if (this.params.upi < 3) color = '251, 191, 36';
                else color = '239, 68, 68';
                
                const intensity = 0.8 + Math.sin(this.time * 0.03) * 0.2;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, -Math.PI / 2, upiAngle);
                ctx.strokeStyle = `rgba(${color}, ${intensity})`;
                ctx.lineWidth = 15;
                ctx.stroke();
                
                // Center value
                ctx.fillStyle = `rgba(${color}, ${intensity})`;
                ctx.font = 'bold 24px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.params.upi.toFixed(1), centerX, centerY);
                
                // Threshold markers
                [1, 3].forEach((threshold, i) => {
                    const angle = (threshold / 5) * Math.PI * 2 - Math.PI / 2;
                    const markerColor = i === 0 ? '#fbbf24' : '#ef4444';
                    
                    ctx.strokeStyle = markerColor;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    
                    const innerR = radius - 20;
                    const outerR = radius + 10;
                    ctx.moveTo(centerX + Math.cos(angle) * innerR, centerY + Math.sin(angle) * innerR);
                    ctx.lineTo(centerX + Math.cos(angle) * outerR, centerY + Math.sin(angle) * outerR);
                    ctx.stroke();
                });
            }
            
            drawOverlay() {
                const ctx = this.ctx;
                
                // Draw both visualizations with transparency
                ctx.globalAlpha = 0.7;
                this.drawSetTheory();
                ctx.globalAlpha = 0.8;
                this.drawUNNS();
                ctx.globalAlpha = 1;
                
                // Interpolation bridges
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const bridgeIntensity = Math.sin(this.time * 0.02) * 0.4 + 0.6;
                
                // Flowing connection lines
                for (let i = 0; i < 5; i++) {
                    const offset = i * 40 - 80;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 200, centerY + offset);
                    ctx.bezierCurveTo(
                        centerX - 100, centerY + offset - 50,
                        centerX + 100, centerY + offset + 50,
                        centerX + 200, centerY + offset
                    );
                    ctx.strokeStyle = `rgba(251, 191, 36, ${bridgeIntensity * (1 - i * 0.15)})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Flowing particles along bridges
                for (let i = 0; i < 8; i++) {
                    const t = (this.time * 0.01 + i * 0.3) % 1;
                    const x = centerX + (t - 0.5) * 400;
                    const y = centerY + Math.sin(t * Math.PI * 2) * 60;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(251, 191, 36, ${1 - Math.abs(t - 0.5) * 2})`;
                    ctx.fill();
                }
            }
            
            drawConstants() {
                const ctx = this.ctx;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Background grid for constants layout
                ctx.fillStyle = 'rgba(15, 23, 42, 0.3)';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Title
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('UNNS Constants Observatory', centerX, 40);
                
                // Calculate grid layout for 8 constants (4x2 grid)
                const cols = 4;
                const rows = 2;
                const cellWidth = this.canvas.width / cols;
                const cellHeight = (this.canvas.height - 80) / rows;
                
                const constants = [
                    { name: 'Limit Ratio (φ)', value: this.params.c1.toFixed(3), color: '#fbbf24' },
                    { name: 'Coefficients', value: 'c₁=' + this.params.c1.toFixed(2), color: '#3b82f6' },
                    { name: 'Ring Extension', value: 'ℤ[φ]', color: '#22c55e' },
                    { name: 'DEC/FEEC Edge', value: 'Stable', color: '#06b6d4' },
                    { name: 'UPI Index', value: this.params.upi.toFixed(2), color: this.params.upi < 1 ? '#22c55e' : this.params.upi < 3 ? '#fbbf24' : '#ef4444' },
                    { name: 'Gödel Constant', value: '∞', color: '#8b5cf6' },
                    { name: 'Prime Density', value: '1/ln(x)', color: '#22c55e' },
                    { name: 'Nest Depth', value: 'D=' + this.params.depth, color: '#3b82f6' }
                ];
                
                constants.forEach((constant, index) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    const x = col * cellWidth + cellWidth / 2;
                    const y = row * cellHeight + cellHeight / 2 + 80;
                    
                    // Draw constant visualization
                    this.drawConstantVisualization(ctx, x, y, cellWidth * 0.8, cellHeight * 0.6, index, constant);
                });
            }
            
            drawConstantVisualization(ctx, centerX, centerY, width, height, index, constant) {
                const radius = Math.min(width, height) * 0.3;
                
                ctx.save();
                
                // Background circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius + 10, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
                ctx.fill();
                ctx.strokeStyle = constant.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                switch(index) {
                    case 0: // Limit Ratio (φ) - Golden Spiral
                        this.drawMiniGoldenSpiral(ctx, centerX, centerY, radius * 0.8);
                        break;
                        
                    case 1: // Coefficients - Sequence Plot  
                        this.drawMiniSequencePlot(ctx, centerX, centerY, radius * 0.8);
                        break;
                        
                    case 2: // Ring Extension - Concentric Rings
                        this.drawMiniRingExtension(ctx, centerX, centerY, radius * 0.8);
                        break;
                        
                    case 3: // DEC/FEEC Edge - Mesh
                        this.drawMiniMesh(ctx, centerX, centerY, radius * 0.8);
                        break;
                        
                    case 4: // UPI Index - Dial
                        this.drawMiniUPIDial(ctx, centerX, centerY, radius * 0.8);
                        break;
                        
                    case 5: // Gödel Constant - Chaos
                        this.drawMiniChaos(ctx, centerX, centerY, radius * 0.8);
                        break;
                        
                    case 6: // Prime Density - Spikes
                        this.drawMiniPrimeSpikes(ctx, centerX, centerY, radius * 0.8);
                        break;
                        
                    case 7: // Nest Depth - Recursive Circles
                        this.drawMiniNestDepth(ctx, centerX, centerY, radius * 0.8);
                        break;
                }
                
                // Constant name
                ctx.fillStyle = constant.color;
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(constant.name, centerX, centerY + radius + 25);
                
                // Constant value
                ctx.fillStyle = '#e2e8f0';
                ctx.font = 'bold 14px monospace';
                ctx.fillText(constant.value, centerX, centerY + radius + 40);
                
                ctx.restore();
            }
            
            drawMiniGoldenSpiral(ctx, centerX, centerY, radius) {
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let angle = this.time * 0.02;
                let r = 3;
                ctx.moveTo(centerX, centerY);
                
                for (let i = 0; i < 40; i++) {
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    ctx.lineTo(x, y);
                    
                    angle += 0.2;
                    r *= 1.05;
                    if (r > radius) break;
                }
                ctx.stroke();
                
                // Central point
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawMiniSequencePlot(ctx, centerX, centerY, radius) {
                // Generate Fibonacci-like sequence
                const values = [1, 1];
                for (let i = 2; i < 12; i++) {
                    values.push(this.params.c1 * values[i-1] + (2 - this.params.c1) * values[i-2]);
                }
                
                const max = Math.max(...values.map(Math.abs));
                if (max === 0) return;
                
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                values.forEach((val, i) => {
                    const x = centerX - radius + (i / (values.length - 1)) * (radius * 2);
                    const y = centerY - (val / max) * radius * 0.6;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    
                    // Points with animation
                    const pulseSize = 2 + Math.sin(this.time * 0.05 + i * 0.3) * 1;
                    ctx.fillStyle = '#3b82f6';
                    ctx.beginPath();
                    ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.stroke();
            }
            
            drawMiniRingExtension(ctx, centerX, centerY, radius) {
                const rings = [radius * 0.3, radius * 0.6, radius * 0.9];
                const colors = ['#22c55e', '#3b82f6', '#8b5cf6'];
                
                rings.forEach((r, i) => {
                    const breathe = 1 + Math.sin(this.time * 0.02 + i) * 0.1;
                    const currentRadius = r * breathe;
                    
                    ctx.strokeStyle = colors[i];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Ring elements
                    const numPoints = (i + 1) * 4;
                    for (let j = 0; j < numPoints; j++) {
                        const angle = (j / numPoints) * Math.PI * 2 + this.time * 0.01 * (i + 1);
                        const x = centerX + Math.cos(angle) * currentRadius;
                        const y = centerY + Math.sin(angle) * currentRadius;
                        
                        ctx.fillStyle = colors[i];
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
            
            drawMiniMesh(ctx, centerX, centerY, radius) {
                const gridSize = radius / 4;
                const distortion = Math.sin(this.time * 0.03) * 3;
                
                ctx.strokeStyle = 'rgba(6, 182, 212, 0.8)';
                ctx.lineWidth = 1;
                
                // Vertical lines
                for (let x = -radius; x <= radius; x += gridSize) {
                    ctx.beginPath();
                    for (let y = -radius; y <= radius; y += 5) {
                        const wave = Math.sin((x + y + this.time * 10) * 0.05) * distortion;
                        const plotX = centerX + x + wave;
                        const plotY = centerY + y;
                        
                        if (y === -radius) ctx.moveTo(plotX, plotY);
                        else ctx.lineTo(plotX, plotY);
                    }
                    ctx.stroke();
                }
                
                // Horizontal lines  
                for (let y = -radius; y <= radius; y += gridSize) {
                    ctx.beginPath();
                    for (let x = -radius; x <= radius; x += 5) {
                        const wave = Math.sin((x + y + this.time * 10) * 0.05) * distortion;
                        const plotX = centerX + x;
                        const plotY = centerY + y + wave;
                        
                        if (x === -radius) ctx.moveTo(plotX, plotY);
                        else ctx.lineTo(plotX, plotY);
                    }
                    ctx.stroke();
                }
            }
            
            drawMiniUPIDial(ctx, centerX, centerY, radius) {
                // Background
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.3)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // UPI arc
                const upiAngle = (this.params.upi / 5) * Math.PI * 2 - Math.PI / 2;
                let color;
                if (this.params.upi < 1) color = '34, 197, 94';
                else if (this.params.upi < 3) color = '251, 191, 36';
                else color = '239, 68, 68';
                
                const intensity = 0.8 + Math.sin(this.time * 0.04) * 0.2;
                
                ctx.strokeStyle = `rgba(${color}, ${intensity})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, -Math.PI / 2, upiAngle);
                ctx.stroke();
                
                // Center value
                ctx.fillStyle = `rgba(${color}, ${intensity})`;
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.params.upi.toFixed(1), centerX, centerY + 3);
            }
            
            drawMiniChaos(ctx, centerX, centerY, radius) {
                // Random chaos particles
                const numParticles = Math.floor(this.params.upi * 5);
                
                for (let i = 0; i < numParticles; i++) {
                    const seed = this.time * 0.05 + i;
                    const x = centerX + Math.sin(seed * 1.7) * radius * 0.8;
                    const y = centerY + Math.sin(seed * 2.3) * radius * 0.8;
                    const size = 2 + Math.sin(seed * 3) * 1.5;
                    
                    const flicker = Math.sin(seed * 4) > 0;
                    if (flicker) {
                        ctx.fillStyle = `rgba(239, 68, 68, ${0.5 + Math.sin(seed * 2) * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Chaos spiral
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let i = 0; i < 30; i++) {
                    const angle = i * 0.3 + this.time * 0.05;
                    const r = i * 1.5 + Math.sin(this.time * 0.07 + i) * 5;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    
                    if (r > radius) break;
                }
                ctx.stroke();
            }
            
            drawMiniPrimeSpikes(ctx, centerX, centerY, radius) {
                // Simple prime visualization
                const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
                const maxHeight = radius * 0.8;
                
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                
                primes.forEach((prime, i) => {
                    const x = centerX - radius + (i / (primes.length - 1)) * radius * 2;
                    const height = (prime / 47) * maxHeight + Math.sin(this.time * 0.03 + i) * 5;
                    const y1 = centerY + radius * 0.3;
                    const y2 = centerY + radius * 0.3 - height;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y1);
                    ctx.lineTo(x, y2);
                    ctx.stroke();
                    
                    // Resonance effect for certain primes
                    if (prime % 6 === 1 || prime % 6 === 5) {
                        const pulseRadius = 3 + Math.sin(this.time * 0.08 + i) * 2;
                        ctx.strokeStyle = 'rgba(168, 85, 247, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(x, y2, pulseRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.strokeStyle = '#22c55e';
                        ctx.lineWidth = 2;
                    }
                });
            }
            
            drawMiniNestDepth(ctx, centerX, centerY, radius) {
                // Recursive depth circles
                for (let layer = this.params.depth; layer >= 1; layer--) {
                    const layerRadius = (layer / this.params.depth) * radius;
                    const breathe = 1 + Math.sin(this.time * 0.02 + layer * 0.5) * 0.05;
                    const currentRadius = layerRadius * breathe;
                    
                    const alpha = (layer / this.params.depth) * 0.8 + 0.2;
                    
                    ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Layer connections
                    if (layer < this.params.depth) {
                        const nextRadius = ((layer + 1) / this.params.depth) * radius * breathe;
                        const numConnections = Math.min(layer * 2, 8);
                        
                        for (let i = 0; i < numConnections; i++) {
                            const angle = (i / numConnections) * Math.PI * 2 + this.time * 0.01 * layer;
                            const x1 = centerX + Math.cos(angle) * currentRadius;
                            const y1 = centerY + Math.sin(angle) * currentRadius;
                            const x2 = centerX + Math.cos(angle) * nextRadius;
                            const y2 = centerY + Math.sin(angle) * nextRadius;
                            
                            ctx.strokeStyle = `rgba(139, 92, 246, ${alpha * 0.4})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                    
                    // Depth indicators
                    const numIndicators = layer;
                    for (let i = 0; i < numIndicators; i++) {
                        const angle = (i / numIndicators) * Math.PI * 2 + this.time * 0.015 * layer;
                        const x = centerX + Math.cos(angle) * (currentRadius + 5);
                        const y = centerY + Math.sin(angle) * (currentRadius + 5);
                        
                        ctx.fillStyle = `rgba(59, 130, 246, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            updateConstants() {
                // Update display values
                const phiEl = document.getElementById('unnsPhiValue');
                const upiEl = document.getElementById('unnsUPIDisplay');
                const depthEl = document.getElementById('unnsDepthDisplay');
                
                if (phiEl) phiEl.textContent = this.params.c1.toFixed(6);
                if (upiEl) upiEl.textContent = this.params.upi.toFixed(3);
                if (depthEl) depthEl.textContent = this.params.depth.toString();
            }
            
            updateStability() {
                const statusEl = document.getElementById('unnsStabilityStatus');
                if (!statusEl) return;
                
                const upi = this.params.upi;
                
                if (upi < 1) {
                    statusEl.textContent = 'SAFE';
                    statusEl.className = 'unns-status-indicator unns-status-safe';
                } else if (upi < 3) {
                    statusEl.textContent = 'CAUTION';
                    statusEl.className = 'unns-status-indicator unns-status-caution';
                } else {
                    statusEl.textContent = 'DANGER';
                    statusEl.className = 'unns-status-indicator unns-status-danger';
                }
            }
            
            drawBackground() {
                const ctx = this.ctx;
                ctx.save();
                ctx.globalAlpha = 0.03;
                ctx.strokeStyle = '#475569';
                ctx.lineWidth = 1;
                
                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.canvas.width, y);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawBackground();
                
                switch (this.mode) {
                    case 'set-theory':
                        this.drawSetTheory();
                        break;
                    case 'unns':
                        this.drawUNNS();
                        break;
                    case 'overlay':
                        this.drawOverlay();
                        break;
                    case 'constants':
                        this.drawConstants();
                        break;
                }
            }
            
            animate() {
                if (this.isPlaying) {
                    this.time += this.params.speed;
                }
                
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new UNNSChamber());
        } else {
            new UNNSChamber();
        }
    })();
    </script>
</div>
</body>
</html>