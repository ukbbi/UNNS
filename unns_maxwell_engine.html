<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS-Maxwell Electromagnetic Module</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            transition: all 0.5s ease;
        }

        body.documentation-mode {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .live-mode h1 {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6, #0288d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(79, 195, 247, 0.5);
        }

        .documentation-mode h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 10px;
        }

        .unns-theory {
            font-size: 0.9rem;
            opacity: 0.7;
            font-style: italic;
        }

        /* Mode Toggle */
        .mode-toggle {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .documentation-mode .mode-toggle {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .toggle-switch {
            display: inline-flex;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 5px;
            margin: 10px 0;
        }

        .documentation-mode .toggle-switch {
            background: rgba(52, 152, 219, 0.2);
        }

        .toggle-btn {
            padding: 12px 24px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            border: none;
            background: transparent;
            color: inherit;
        }

        .toggle-btn.active {
            background: #4fc3f7;
            color: #1a1a2e;
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.4);
        }

        .documentation-mode .toggle-btn.active {
            background: #3498db;
            color: white;
        }

        /* Documentation Mode Styles */
        .documentation-content {
            display: none;
        }

        .documentation-mode .documentation-content {
            display: block;
        }

        .documentation-mode .live-content {
            display: none;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            color: #333;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .mode-btn {
            padding: 15px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .mode-btn:hover {
            background: #ecf0f1;
            transform: translateY(-1px);
        }

        .mode-btn.active {
            background: #3498db;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .control-group input {
            width: 100%;
            padding: 8px;
            border: 2px solid #ecf0f1;
            border-radius: 6px;
            font-size: 14px;
        }

        .value-display {
            margin-top: 5px;
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 500;
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            color: #333;
        }

        .panel h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }

        canvas {
            width: 100%;
            height: 400px;
            border: 2px solid #ecf0f1;
            border-radius: 10px;
            background: #f8f9fa;
        }

        /* Force proper canvas rendering in documentation mode */
        .documentation-mode canvas {
            background: #ffffff !important;
            border: 3px solid #3498db !important;
        }

        /* Live Mode Styles */
        .live-content .field-canvas-container {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .live-content #fieldCanvas {
            background: radial-gradient(circle, #0f0f23 0%, #000011 100%);
            cursor: crosshair;
            border: 2px solid rgba(79, 195, 247, 0.3);
        }

        .live-content .controls-panel {
            display: grid;
            gap: 15px;
        }

        .live-content .mode-selector {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .live-content .mode-selector .mode-btn {
            width: 100%;
            margin: 5px 0;
            background: rgba(79, 195, 247, 0.1);
        }

        .live-content .mode-selector .mode-btn:hover {
            background: rgba(79, 195, 247, 0.2);
            transform: translateX(5px);
        }

        .live-content .mode-selector .mode-btn.active {
            background: #4fc3f7;
            color: #1a1a2e;
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }

        .live-content .control-group {
            background: rgba(255, 255, 255, 0.08);
            border-left: 4px solid #4fc3f7;
            color: #fff;
        }

        .live-content .control-group h3 {
            color: #4fc3f7;
        }

        .live-content .control-group input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
        }

        .live-content .value-display {
            color: #4fc3f7;
        }

        .interactive-hints {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #4fc3f7;
        }

        .field-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #fff;
            min-width: 200px;
        }

        .source-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .btn {
            padding: 8px 15px;
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            border: none;
            border-radius: 5px;
            color: #1a1a2e;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 195, 247, 0.4);
        }

        /* Info sections */
        .info-section {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .documentation-mode .info-section {
            background: white;
            color: #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .info-section h2 {
            color: #4fc3f7;
            margin-bottom: 15px;
            border-bottom: 2px solid #29b6f6;
            padding-bottom: 8px;
        }

        .documentation-mode .info-section h2 {
            color: #2c3e50;
            border-bottom-color: #e74c3c;
        }

        .equation {
            background: rgba(79, 195, 247, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #29b6f6;
            margin: 15px 0;
            font-family: 'Times New Roman', serif;
            text-align: center;
            font-size: 16px;
        }

        .documentation-mode .equation {
            background: #f8f9fa;
            border-left-color: #e74c3c;
            color: #333;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4fc3f7;
        }

        .documentation-mode .info-card {
            background: #f8f9fa;
            color: #333;
            border-left-color: #3498db;
        }

        .info-card h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .documentation-mode .info-card h3 {
            color: #2c3e50;
        }

        .examples {
            background: rgba(40, 167, 69, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            margin-top: 15px;
        }

        .documentation-mode .examples {
            background: #e8f5e8;
        }

        .example-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .documentation-mode .example-item {
            background: white;
            color: #333;
        }

        .example-item h4 {
            color: #28a745;
            margin-bottom: 5px;
        }

        .documentation-mode .example-item h4 {
            color: #155724;
        }

        .tech-notes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .tech-card {
            background: rgba(0, 123, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .documentation-mode .tech-card {
            background: #e7f1ff;
            color: #333;
        }

        .tech-card h3 {
            color: #007bff;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .documentation-mode .tech-card h3 {
            color: #004085;
        }

        .recursion-visualizer {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .documentation-mode .recursion-visualizer {
            background: white;
            color: #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        #recursionCanvas {
            border-radius: 10px;
            background: radial-gradient(circle, #1a1a2e 0%, #0f0f23 100%);
        }

        .documentation-mode #recursionCanvas {
            background: #ecf0f1;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        @media (max-width: 1200px) {
            .main-interface {
                grid-template-columns: 1fr;
            }
            
            .visualization-area {
                grid-template-columns: 1fr;
            }
            
            .mode-buttons {
                grid-template-columns: 1fr 1fr;
            }
            
            .control-panel {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .source-controls {
                grid-template-columns: 1fr;
            }
            
            .toggle-switch {
                flex-direction: column;
                width: 100%;
            }
            
            .toggle-btn {
                width: 100%;
                margin: 2px 0;
            }
        }
    </style>
</head>
<body class="live-mode">
    <div class="container">
        <header>
            <h1>UNNS—Maxwell Electromagnetic Module</h1>
            <div class="subtitle">Interactive visualizations of EM fields via recursive special functions</div>
            <div class="unns-theory">Where Maxwell's equations emerge as nested algebraic extensions over the rationals</div>
        </header>

        <div class="mode-toggle">
            <h3>Select Interface Mode</h3>
            <div class="toggle-switch">
                <button class="toggle-btn" onclick="switchToDocumentation()">Documentation</button>
                <button class="toggle-btn active" onclick="switchToLive()">Live Mode</button>
            </div>
            <p id="modeDescription">Interactive field manipulation with real-time mathematical computation</p>
        </div>

        <!-- Live Interactive Mode -->
        <div class="live-content">
            <div class="main-interface" style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
                <div class="field-canvas-container">
                    <canvas id="fieldCanvas" width="800" height="600"></canvas>
                    <div class="interactive-hints">
                        <div>Click: Add/move sources</div>
                        <div>Drag: Reshape field boundaries</div>
                        <div>Right-click: Toggle source polarity</div>
                    </div>
                    <div class="field-info" id="fieldInfo">
                        <div><strong>Cursor Position:</strong> <span id="cursorPos">(0, 0)</span></div>
                        <div><strong>Field Magnitude:</strong> <span id="fieldMag">0.00</span></div>
                        <div><strong>Function Value:</strong> <span id="funcValue">0.00</span></div>
                        <div><strong>Recursion Depth:</strong> <span id="recursionDepth">3</span></div>
                    </div>
                </div>

                <div class="controls-panel">
                    <div class="mode-selector">
                        <h3>UNNS Function Mode</h3>
                        <button class="mode-btn active" data-mode="legendre">Legendre → Electrostatics</button>
                        <button class="mode-btn" data-mode="bessel">Bessel → Waveguides</button>
                        <button class="mode-btn" data-mode="spherical">Spherical → Radiation</button>
                        <button class="mode-btn" data-mode="hybrid">Hybrid → Induction</button>
                    </div>

                    <div class="control-group">
                        <h3>Recursion Parameters</h3>
                        <label>Order (n, ℓ): <span id="orderVal">3</span></label>
                        <input type="range" id="order" min="0" max="20" value="3">
                        
                        <label>Secondary (m): <span id="secondOrderVal">0</span></label>
                        <input type="range" id="secondOrder" min="-10" max="10" value="0">
                        
                        <label>Field Intensity: <span id="intensityVal">2.0</span></label>
                        <input type="range" id="intensity" min="0.1" max="10.0" value="2.0" step="0.1">
                    </div>

                    <div class="control-group">
                        <h3>Source Management</h3>
                        <div class="source-controls">
                            <button class="btn" id="addPositive">Add Positive Source</button>
                            <button class="btn" id="addNegative">Add Negative Source</button>
                            <button class="btn" id="clearSources">Clear All Sources</button>
                            <button class="btn" id="randomField">Random Field</button>
                        </div>
                        <label>Source Count: <span id="sourceCount">2</span></label>
                    </div>

                    <div class="control-group">
                        <h3>Visualization Settings</h3>
                        <label>Field Lines: <span id="fieldLinesVal">20</span></label>
                        <input type="range" id="fieldLines" min="5" max="50" value="20">
                        
                        <label>Resolution: <span id="resolutionVal">32</span></label>
                        <input type="range" id="resolution" min="16" max="64" value="32">
                    </div>
                </div>
            </div>

            <div class="recursion-visualizer">
                <h3 style="color: #4fc3f7; margin-bottom: 15px;">UNNS Recursive Structure</h3>
                <canvas id="recursionCanvas" width="1200" height="300"></canvas>
            </div>
        </div>

        <!-- Documentation Mode -->
        <div class="documentation-content">
            <div class="controls">
                <h2 style="text-align: center; margin-bottom: 20px; color: #2c3e50;">Visualization Controls</h2>
                
                <div class="mode-buttons">
                    <button class="mode-btn active" onclick="switchDocMode('legendre')">Legendre Polynomials</button>
                    <button class="mode-btn" onclick="switchDocMode('bessel')">Bessel Functions</button>
                    <button class="mode-btn" onclick="switchDocMode('spherical')">Spherical Harmonics</button>
                    <button class="mode-btn" onclick="switchDocMode('hybrid')">Hybrid Interweaving</button>
                </div>

                <div class="status success" id="docStatus">Documentation Mode - Legendre Polynomials Active</div>

                <div class="control-panel">
                    <div class="control-group">
                        <label for="docOrder">Order (n, ℓ)</label>
                        <input type="range" id="docOrder" min="0" max="15" value="3" oninput="updateDocParameter('order', this.value)">
                        <div class="value-display">Value: <span id="docOrderValue">3</span></div>
                    </div>

                    <div class="control-group">
                        <label for="docSecondOrder">Secondary Order (m)</label>
                        <input type="range" id="docSecondOrder" min="-8" max="8" value="0" oninput="updateDocParameter('secondOrder', this.value)">
                        <div class="value-display">Value: <span id="docSecondOrderValue">0</span></div>
                    </div>

                    <div class="control-group">
                        <label for="docIntensity">Field Intensity</label>
                        <input type="range" id="docIntensity" min="0.1" max="5.0" value="1.0" step="0.1" oninput="updateDocParameter('intensity', this.value)">
                        <div class="value-display">Value: <span id="docIntensityValue">1.0</span></div>
                    </div>

                    <div class="control-group">
                        <label for="docAnimationSpeed">Animation Speed</label>
                        <input type="range" id="docAnimationSpeed" min="0.1" max="3.0" value="1.0" step="0.1" oninput="updateDocParameter('animationSpeed', this.value)">
                        <div class="value-display">Value: <span id="docAnimationSpeedValue">1.0</span></div>
                    </div>

                    <div class="control-group">
                        <label for="docResolution">Grid Resolution</label>
                        <input type="range" id="docResolution" min="50" max="200" value="100" step="10" oninput="updateDocParameter('resolution', this.value)">
                        <div class="value-display">Value: <span id="docResolutionValue">100</span></div>
                    </div>

                    <div class="control-group">
                        <label for="docInterweaving">Interweaving Factor</label>
                        <input type="range" id="docInterweaving" min="0.0" max="1.0" value="0.5" step="0.1" oninput="updateDocParameter('interweaving', this.value)">
                        <div class="value-display">Value: <span id="docInterweavingValue">0.5</span></div>
                    </div>
                </div>
            </div>

            <div class="visualization-area">
                <div class="panel">
                    <h2>Physical Field Visualization</h2>
                    <canvas id="docPhysicsCanvas" width="600" height="400"></canvas>
                </div>

                <div class="panel">
                    <h2>Recursive Structure</h2>
                    <canvas id="docRecursionCanvas" width="600" height="400"></canvas>
                </div>
            </div>
        </div>

        <!-- Shared Information Panels -->
        <div class="info-section">
            <h2 id="currentModeTitle">Legendre Polynomials → Electrostatic Fields</h2>
            
            <div id="currentEquation" class="equation">
                P<sub>n</sub>(x) = [(2n-1)xP<sub>n-1</sub>(x) - (n-1)P<sub>n-2</sub>(x)] / n
            </div>

            <div id="currentDescription">
                Through the UNNS framework, Legendre polynomials generate field extensions Q(α) where the dominant root α creates electrostatic multipole patterns. Each recursion level adds algebraic complexity, manifesting as additional field lobes in physical space.
            </div>

            <div class="info-grid">
                <div class="info-card">
                    <h3>Mathematical Foundation</h3>
                    <div id="mathFoundation">
                        Legendre polynomials solve Legendre's differential equation:
                        <br><br>
                        d/dx[(1-x²)dP<sub>n</sub>/dx] + n(n+1)P<sub>n</sub> = 0
                    </div>
                </div>

                <div class="info-card">
                    <h3>Parameter Ranges</h3>
                    <div id="parameterRanges">
                        <ul>
                            <li>Polynomial order n: 0-20</li>
                            <li>Evaluation range: x ∈ [-1, 1]</li>
                            <li>Field intensity: 0.1-5.0</li>
                            <li>Animation speed: 0.1-3.0</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="examples">
                <h3>Usage Examples</h3>
                <div id="usageExamples">
                    <div class="example-item">
                        <h4>Dipole Field (n=1)</h4>
                        <p>Set order to 1 for classic dipole electrostatic field with two-lobe pattern</p>
                    </div>
                    <div class="example-item">
                        <h4>Quadrupole Field (n=2)</h4>
                        <p>Set order to 2 for four-lobe field pattern with alternating positive/negative regions</p>
                    </div>
                    <div class="example-item">
                        <h4>Higher Multipoles (n>2)</h4>
                        <p>Higher orders create complex multi-lobe patterns representing higher-order charge distributions</p>
                    </div>
                </div>
            </div>

            <div style="margin-top: 15px; padding: 10px; background: rgba(79, 195, 247, 0.1); border-radius: 5px;" class="unns-interpretation">
                <strong>UNNS Interpretation:</strong> <span id="unnsInterpretation">
                Electrostatic fields emerge from nested sequences where each polynomial order extends the rational field Q, generating multipole moments through recursive algebraic structures.
                </span>
            </div>
        </div>

        <div class="info-section">
            <h2>Technical Implementation</h2>
            <div class="tech-notes">
                <div class="tech-card">
                    <h3>Computation</h3>
                    <p>Recursive function updates employ forward recursion with coefficient caching to minimize computational overhead. Intermediate values are stored for efficient parameter sweeping and animation rendering.</p>
                </div>
                
                <div class="tech-card">
                    <h3>Rendering</h3>
                    <p>Graphics rendering uses HTML5 Canvas for field line generation and real-time updates. Optimized for smooth animation at 60fps with dynamic parameter changes.</p>
                </div>
                
                <div class="tech-card">
                    <h3>Performance</h3>
                    <p>Optimal performance achieved with recursion orders n ≤ 15 and grid resolutions below 200×200 pixels. Memory usage scales linearly with field resolution.</p>
                </div>
                
                <div class="tech-card">
                    <h3>Mathematical Accuracy</h3>
                    <p>All calculations maintain double-precision floating-point accuracy suitable for display-level visualization. Functions use analytical expressions without empirical fitting.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentInterfaceMode = 'live';
        let currentMode = 'legendre';
        let animationTime = 0;
        let mousePos = { x: 0, y: 0 };
        let dragging = null;
        
        let sources = [
            { x: 0.3, y: 0.5, charge: 1, radius: 15 },
            { x: 0.7, y: 0.5, charge: -1, radius: 15 }
        ];
        
        let params = {
            order: 3,
            secondOrder: 0,
            intensity: 2.0,
            fieldLines: 20,
            resolution: 32,
            animationSpeed: 1.0,
            interweaving: 0.5
        };

        // Documentation mode parameters
        let docParams = {
            order: 3,
            secondOrder: 0,
            intensity: 1.0,
            animationSpeed: 1.0,
            resolution: 100,
            interweaving: 0.5
        };

        // Mode data
        const modeData = {
            legendre: {
                title: 'Legendre Polynomials → Electrostatic Fields',
                equation: 'P<sub>n</sub>(x) = [(2n-1)xP<sub>n-1</sub>(x) - (n-1)P<sub>n-2</sub>(x)] / n',
                description: 'Through the UNNS framework, Legendre polynomials generate field extensions Q(α) where the dominant root α creates electrostatic multipole patterns. Each recursion level adds algebraic complexity, manifesting as additional field lobes in physical space.',
                mathFoundation: 'Legendre polynomials solve Legendre\'s differential equation:<br><br>d/dx[(1-x²)dP<sub>n</sub>/dx] + n(n+1)P<sub>n</sub> = 0',
                parameters: '<ul><li>Polynomial order n: 0-20</li><li>Evaluation range: x ∈ [-1, 1]</li><li>Field intensity: 0.1-5.0</li><li>Animation speed: 0.1-3.0</li></ul>',
                unns: 'Electrostatic fields emerge from nested sequences where each polynomial order extends the rational field Q, generating multipole moments through recursive algebraic structures.',
                examples: [
                    { title: 'Dipole Field (n=1)', desc: 'Set order to 1 for classic dipole electrostatic field with two-lobe pattern' },
                    { title: 'Quadrupole Field (n=2)', desc: 'Set order to 2 for four-lobe field pattern with alternating positive/negative regions' },
                    { title: 'Higher Multipoles (n>2)', desc: 'Higher orders create complex multi-lobe patterns representing higher-order charge distributions' }
                ]
            },
            bessel: {
                title: 'Bessel Functions → Waveguide Modes',
                equation: 'J<sub>n+1</sub>(x) = (2n/x)J<sub>n</sub>(x) - J<sub>n-1</sub>(x)',
                description: 'Bessel functions in UNNS generate transcendental extensions modeling cylindrical wave propagation. The recursive structure creates radial oscillations with zeros corresponding to field extension boundaries.',
                mathFoundation: 'Bessel functions solve Bessel\'s differential equation:<br><br>x²d²J<sub>n</sub>/dx² + x dJ<sub>n</sub>/dx + (x² - n²)J<sub>n</sub> = 0',
                parameters: '<ul><li>Bessel order n: 0-10</li><li>Argument scaling x: 0-50</li><li>Mode type: TE/TM</li><li>Waveguide parameters</li></ul>',
                unns: 'Waveguide modes arise from transcendental UNNS extensions where Bessel recursion generates electromagnetic confinement through algebraic field boundaries.',
                examples: [
                    { title: 'Fundamental Mode (n=0)', desc: 'Set order to 0 for symmetric fundamental mode with maximum on-axis intensity' },
                    { title: 'First-Order Mode (n=1)', desc: 'Set order to 1 for first-order cylindrical mode with characteristic null on-axis' },
                    { title: 'Higher-Order Modes (n>1)', desc: 'Higher orders show complex radial oscillation patterns typical of waveguide modes' }
                ]
            },
            spherical: {
                title: 'Spherical Harmonics → Radiation Patterns',
                equation: 'Y<sub>ℓ</sub><sup>m</sup>(θ,φ) = √[(2ℓ+1)(ℓ-m)!/4π(ℓ+m)!] P<sub>ℓ</sub><sup>m</sup>(cos θ)e<sup>imφ</sup>',
                description: 'Spherical harmonics represent cyclotomic UNNS extensions Q(ζ) modeling angular momentum. Each (ℓ,m) pair generates distinct algebraic orbits manifesting as directional radiation lobes.',
                mathFoundation: 'Spherical harmonics satisfy the angular Laplacian eigenvalue equation:<br><br>∇²<sub>angular</sub>Y<sub>ℓ</sub><sup>m</sup> = -ℓ(ℓ+1)Y<sub>ℓ</sub><sup>m</sup>',
                parameters: '<ul><li>Degree ℓ: 0-8</li><li>Order m: -ℓ ≤ m ≤ ℓ</li><li>Polar angle: θ ∈ [0, π]</li><li>Azimuthal: φ ∈ [0, 2π]</li></ul>',
                unns: 'Radiation patterns emerge from cyclotomic field extensions where angular momentum quantum numbers correspond to algebraic orbit structures in UNNS towers.',
                examples: [
                    { title: 'Dipole Radiation (ℓ=1, m=0)', desc: 'Set degree to 1, order to 0 for classic figure-eight radiation pattern' },
                    { title: 'Quadrupole Radiation (ℓ=2, m=0)', desc: 'Set degree to 2 for four-lobe quadrupole radiation pattern' },
                    { title: 'Complex Multipoles (m≠ 0)', desc: 'Non-zero m values create azimuthally dependent radiation patterns' }
                ]
            },
            hybrid: {
                title: 'Hybrid Interweaving → Electromagnetic Induction',
                equation: 'F<sub>hybrid</sub>(x,t) = Σ α<sub>i</sub>(t) F<sub>i</sub>(x) · R<sub>i</sub>(n)',
                description: 'Hybrid sequences demonstrate UNNS interweaving where multiple recursive functions couple through algebraic morphisms. This models electromagnetic induction as field extension interactions.',
                mathFoundation: 'Time evolution follows Faraday\'s law coupling:<br><br>∇ × E = -∂B/∂t',
                parameters: '<ul><li>Interweaving factor α: 0.0-1.0</li><li>Primary function selection</li><li>Secondary function selection</li><li>Temporal frequency: 0.1-10 Hz</li></ul>',
                unns: 'Electromagnetic induction manifests through UNNS interweavings where coupled recursive sequences generate field transformations via algebraic extension morphisms.',
                examples: [
                    { title: 'Mode Coupling (α=0.5)', desc: 'Set interweaving to 0.5 for balanced coupling showing interference patterns' },
                    { title: 'Induction Dynamics', desc: 'Animate interweaving factor to show time-varying electromagnetic induction' },
                    { title: 'Wave Interference', desc: 'Different function combinations show constructive and destructive interference' }
                ]
            }
        };

        // Interface mode switching
        function switchToDocumentation() {
            currentInterfaceMode = 'documentation';
            document.body.className = 'documentation-mode';
            document.querySelector('.toggle-btn:first-child').classList.add('active');
            document.querySelector('.toggle-btn:last-child').classList.remove('active');
            document.getElementById('modeDescription').textContent = 'Educational content with comprehensive mathematical explanations';
            updateModeInfo();
        }

        function switchToLive() {
            currentInterfaceMode = 'live';
            document.body.className = 'live-mode';
            document.querySelector('.toggle-btn:first-child').classList.remove('active');
            document.querySelector('.toggle-btn:last-child').classList.add('active');
            document.getElementById('modeDescription').textContent = 'Interactive field manipulation with real-time mathematical computation';
            updateModeInfo();
        }

        // Documentation mode controls
        function switchDocMode(mode) {
            document.querySelectorAll('.documentation-content .mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            currentMode = mode;
            updateModeInfo();
            document.getElementById('docStatus').textContent = `Documentation Mode - ${modeData[mode].title.split(' →')[0]} Active`;
        }

        function updateDocParameter(paramName, value) {
            docParams[paramName] = parseFloat(value);
            document.getElementById('doc' + paramName.charAt(0).toUpperCase() + paramName.slice(1) + 'Value').textContent = value;
        }

        // Mathematical functions
        function legendrePolynomial(n, x) {
            if (n === 0) return 1;
            if (n === 1) return x;
            
            let p0 = 1, p1 = x;
            for (let i = 2; i <= n; i++) {
                let pn = ((2 * i - 1) * x * p1 - (i - 1) * p0) / i;
                p0 = p1;
                p1 = pn;
            }
            return p1;
        }

        function besselJ(n, x) {
            if (Math.abs(x) < 1e-8) return n === 0 ? 1 : 0;
            
            let sum = 0;
            for (let k = 0; k < 20; k++) {
                let term = Math.pow(-1, k) * Math.pow(x / 2, 2 * k + n) / (factorial(k) * factorial(k + n));
                sum += term;
                if (Math.abs(term) < 1e-10) break;
            }
            return sum;
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        function sphericalHarmonic(l, m, theta, phi) {
            if (l === 0) return 0.5 * Math.sqrt(1 / Math.PI);
            let legendre = legendrePolynomial(l, Math.cos(theta));
            return legendre * Math.cos(m * phi) * Math.sqrt((2 * l + 1) / (4 * Math.PI));
        }

        // Field computation for live mode
        function computeFieldAt(x, y) {
            let field = { Ex: 0, Ey: 0, magnitude: 0, potential: 0 };
            
            if (currentMode === 'legendre') {
                sources.forEach(source => {
                    let dx = x - source.x;
                    let dy = y - source.y;
                    let dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
                    let cosTheta = dx / dist;
                    
                    for (let n = 0; n <= params.order; n++) {
                        let legendre = legendrePolynomial(n, cosTheta);
                        let contribution = source.charge * legendre / Math.pow(dist, n + 1);
                        field.potential += contribution;
                        
                        let fieldR = -(n + 1) * contribution / dist;
                        field.Ex += fieldR * dx / dist * params.intensity;
                        field.Ey += fieldR * dy / dist * params.intensity;
                    }
                });
            }
            
            field.magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
            return field;
        }

        // Visualization functions
        function drawField(canvasId, paramsObj) {
            let canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            let ctx = canvas.getContext('2d');
            let width = canvas.width;
            let height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Force white background in documentation mode
            if (currentInterfaceMode === 'documentation') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);
                
                // Add visible border for documentation mode
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 4;
                ctx.strokeRect(4, 4, width - 8, height - 8);
            } else {
                // Live mode background
                let gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
                gradient.addColorStop(0, '#0f0f23');
                gradient.addColorStop(1, '#000011');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
            }
            
            // Draw based on current mode
            let centerX = width / 2;
            let centerY = height / 2;
            
            if (currentMode === 'legendre') {
                drawLegendreVisualization(ctx, centerX, centerY, paramsObj, width, height);
            } else if (currentMode === 'bessel') {
                drawBesselVisualization(ctx, centerX, centerY, paramsObj, width, height);
            } else if (currentMode === 'spherical') {
                drawSphericalVisualization(ctx, centerX, centerY, paramsObj, width, height);
            } else if (currentMode === 'hybrid') {
                drawHybridVisualization(ctx, centerX, centerY, paramsObj, width, height);
            }
            
            // Add mode label in documentation mode
            if (currentInterfaceMode === 'documentation') {
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)} Mode Active`, 20, 25);
                
                ctx.font = '14px Arial';
                ctx.fillText(`Order: ${paramsObj.order} | Intensity: ${paramsObj.intensity}`, 20, 50);
            }
            
            // Draw charges in live mode
            if (currentInterfaceMode === 'live' && canvasId === 'fieldCanvas') {
                drawCharges(ctx, width, height);
            }
        }

        function drawLegendreVisualization(ctx, centerX, centerY, paramsObj, width, height) {
            let n = paramsObj.order;
            let intensity = paramsObj.intensity;
            
            if (currentInterfaceMode === 'documentation') {
                // Documentation mode - radial pattern
                for (let angle = 0; angle < 2 * Math.PI; angle += Math.PI / 32) {
                    let x = Math.cos(angle);
                    let legValue = legendrePolynomial(n, x);
                    let radius = 80 + Math.abs(legValue) * 60;
                    
                    let endX = centerX + Math.cos(angle) * radius;
                    let endY = centerY + Math.sin(angle) * radius;
                    
                    ctx.strokeStyle = legValue > 0 ? '#e74c3c' : '#3498db';
                    ctx.lineWidth = 2 + Math.abs(legValue) * 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                
                // Reference circles
                for (let r = 40; r <= 120; r += 20) {
                    ctx.strokeStyle = 'rgba(44, 62, 80, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            } else {
                // Live mode - field lines
                const gridSize = 25;
                for (let x = gridSize; x < width; x += gridSize) {
                    for (let y = gridSize; y < height; y += gridSize) {
                        let field = computeFieldAt(x / width, y / height);
                        let magnitude = field.magnitude;
                        
                        if (magnitude > 0.01) {
                            let nx = field.Ex / magnitude;
                            let ny = field.Ey / magnitude;
                            
                            let alpha = Math.min(magnitude * 15, 1);
                            ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * 0.8})`;
                            ctx.lineWidth = Math.max(alpha * 2, 0.5);
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + nx * 18, y + ny * 18);
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        function drawBesselVisualization(ctx, centerX, centerY, paramsObj, width, height) {
            let n = paramsObj.order % 5;
            
            ctx.strokeStyle = currentInterfaceMode === 'documentation' ? '#3498db' : '#29b6f6';
            ctx.lineWidth = 3;
            
            for (let r = 20; r < 150; r += 15) {
                let bessel = besselJ(n, r / 20);
                let alpha = 0.5 + 0.5 * Math.abs(bessel);
                
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = bessel > 0 ? 
                    (currentInterfaceMode === 'documentation' ? '#e74c3c' : '#29b6f6') : 
                    (currentInterfaceMode === 'documentation' ? '#3498db' : '#ff6b6b');
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function drawSphericalVisualization(ctx, centerX, centerY, paramsObj, width, height) {
            let l = paramsObj.order;
            let m = paramsObj.secondOrder;
            
            for (let i = 0; i < 72; i++) {
                let angle = i * Math.PI / 36;
                let harmonic = sphericalHarmonic(l, m, Math.PI/2, angle);
                let radius = 80 + 40 * Math.abs(harmonic);
                let x = centerX + Math.cos(angle) * radius;
                let y = centerY + Math.sin(angle) * radius;
                
                ctx.fillStyle = harmonic > 0 ? 
                    (currentInterfaceMode === 'documentation' ? '#8e44ad' : '#9b59b6') : 
                    (currentInterfaceMode === 'documentation' ? '#c0392b' : '#e74c3c');
                
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(x, y, 4 + Math.abs(harmonic) * 4, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawHybridVisualization(ctx, centerX, centerY, paramsObj, width, height) {
            let alpha = paramsObj.interweaving;
            let gridSize = 12;
            
            for (let x = gridSize; x < width; x += gridSize) {
                for (let y = gridSize; y < height; y += gridSize) {
                    let dx = x - centerX;
                    let dy = y - centerY;
                    let r = Math.sqrt(dx * dx + dy * dy);
                    
                    if (r < 140) {
                        let wave1 = Math.sin(r * 0.08 + animationTime * paramsObj.animationSpeed * 0.001);
                        let wave2 = Math.cos(r * 0.06 + animationTime * paramsObj.animationSpeed * 0.001 * 1.3);
                        let interference = alpha * wave1 + (1 - alpha) * wave2;
                        
                        let intensity = Math.abs(interference) * 0.8;
                        
                        ctx.fillStyle = interference > 0 ? 
                            (currentInterfaceMode === 'documentation' ? '#e74c3c' : '#4fc3f7') : 
                            (currentInterfaceMode === 'documentation' ? '#3498db' : '#29b6f6');
                        
                        ctx.globalAlpha = 0.4 + intensity * 0.6;
                        ctx.fillRect(x - gridSize/2, y - gridSize/2, gridSize - 1, gridSize - 1);
                    }
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawCharges(ctx, width, height) {
            sources.forEach(source => {
                let x = source.x * width;
                let y = source.y * height;
                let radius = source.radius;
                
                // Glow effect
                let gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
                if (source.charge > 0) {
                    gradient.addColorStop(0, 'rgba(255, 107, 107, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 107, 107, 0.2)');
                } else {
                    gradient.addColorStop(0, 'rgba(116, 185, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(116, 185, 255, 0.2)');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Core charge
                ctx.fillStyle = source.charge > 0 ? '#ff6b6b' : '#74b9ff';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Symbol
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(source.charge > 0 ? '+' : '−', x, y);
            });
        }

        function drawRecursion(canvasId, paramsObj) {
            let canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            let ctx = canvas.getContext('2d');
            let width = canvas.width;
            let height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Background and border for documentation mode
            if (currentInterfaceMode === 'documentation') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);
                
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.strokeRect(3, 3, width - 6, height - 6);
            } else {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, width, height);
            }
            
            let maxOrder = Math.min(paramsObj.order, 15);
            let centerY = height / 2;
            let spacing = width / (maxOrder + 2);
            
            for (let n = 0; n <= maxOrder; n++) {
                let x = (n + 1) * spacing;
                let value = 0;
                
                if (currentMode === 'legendre') {
                    value = legendrePolynomial(n, Math.cos(animationTime * paramsObj.animationSpeed * 0.001));
                } else if (currentMode === 'bessel') {
                    value = besselJ(n, 5);
                } else if (currentMode === 'spherical') {
                    value = sphericalHarmonic(n, paramsObj.secondOrder, Math.PI/2, animationTime * paramsObj.animationSpeed * 0.001);
                } else if (currentMode === 'hybrid') {
                    let leg = legendrePolynomial(n, 0.5);
                    let bes = besselJ(n, 3);
                    value = paramsObj.interweaving * leg + (1 - paramsObj.interweaving) * bes;
                }
                
                let barHeight = Math.abs(value) * height * 0.3;
                let barY = centerY - barHeight / 2;
                
                if (currentInterfaceMode === 'documentation') {
                    ctx.fillStyle = value > 0 ? '#e74c3c' : '#3498db';
                } else {
                    ctx.fillStyle = value > 0 ? '#4fc3f7' : '#ff6b6b';
                }
                
                ctx.fillRect(x - 8, barY, 16, barHeight);
                
                // Labels
                ctx.fillStyle = currentInterfaceMode === 'documentation' ? '#2c3e50' : '#4fc3f7';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`n=${n}`, x, height - 20);
                
                // Values
                ctx.fillStyle = currentInterfaceMode === 'documentation' ? '#333' : '#fff';
                ctx.font = '10px Arial';
                ctx.fillText(value.toFixed(3), x, barY - 10);
            }
            
            // Center line
            ctx.strokeStyle = currentInterfaceMode === 'documentation' ? 
                'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
        }

        function updateModeInfo() {
            let data = modeData[currentMode];
            
            document.getElementById('currentModeTitle').textContent = data.title;
            document.getElementById('currentEquation').innerHTML = data.equation;
            document.getElementById('currentDescription').textContent = data.description;
            document.getElementById('mathFoundation').innerHTML = data.mathFoundation;
            document.getElementById('parameterRanges').innerHTML = data.parameters;
            document.getElementById('unnsInterpretation').textContent = data.unns;
            
            // Update examples
            let examplesContainer = document.getElementById('usageExamples');
            examplesContainer.innerHTML = '';
            data.examples.forEach(example => {
                let div = document.createElement('div');
                div.className = 'example-item';
                div.innerHTML = `<h4>${example.title}</h4><p>${example.desc}</p>`;
                examplesContainer.appendChild(div);
            });
        }

        // Live mode event handlers
        function setupLiveEvents() {
            let canvas = document.getElementById('fieldCanvas');
            if (!canvas) return;
            
            canvas.addEventListener('mousemove', function(e) {
                let rect = canvas.getBoundingClientRect();
                mousePos.x = (e.clientX - rect.left) / rect.width;
                mousePos.y = (e.clientY - rect.top) / rect.height;
                
                if (dragging) {
                    dragging.x = mousePos.x;
                    dragging.y = mousePos.y;
                }
                
                updateFieldInfo();
            });
            
            canvas.addEventListener('mousedown', function(e) {
                let source = findNearestSource(mousePos.x, mousePos.y);
                if (source && distance(source, mousePos) < 0.05) {
                    dragging = source;
                } else {
                    addSource(1);
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                dragging = null;
            });
            
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                let source = findNearestSource(mousePos.x, mousePos.y);
                if (source && distance(source, mousePos) < 0.05) {
                    source.charge *= -1;
                }
            });
            
            // Live mode controls
            document.querySelectorAll('.live-content .mode-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.live-content .mode-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentMode = this.dataset.mode;
                    updateModeInfo();
                });
            });
            
            // Parameter controls
            document.getElementById('order').addEventListener('input', function() {
                params.order = parseInt(this.value);
                document.getElementById('orderVal').textContent = this.value;
            });
            
            document.getElementById('secondOrder').addEventListener('input', function() {
                params.secondOrder = parseInt(this.value);
                document.getElementById('secondOrderVal').textContent = this.value;
            });
            
            document.getElementById('intensity').addEventListener('input', function() {
                params.intensity = parseFloat(this.value);
                document.getElementById('intensityVal').textContent = this.value;
            });
            
            document.getElementById('fieldLines').addEventListener('input', function() {
                params.fieldLines = parseInt(this.value);
                document.getElementById('fieldLinesVal').textContent = this.value;
            });
            
            document.getElementById('resolution').addEventListener('input', function() {
                params.resolution = parseInt(this.value);
                document.getElementById('resolutionVal').textContent = this.value;
            });
            
            // Source management
            document.getElementById('addPositive')?.addEventListener('click', () => addSource(1));
            document.getElementById('addNegative')?.addEventListener('click', () => addSource(-1));
            document.getElementById('clearSources')?.addEventListener('click', () => {
                sources = [];
                updateSourceCount();
            });
            document.getElementById('randomField')?.addEventListener('click', () => {
                sources = [];
                let count = Math.floor(Math.random() * 6) + 2;
                for (let i = 0; i < count; i++) {
                    sources.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        charge: Math.random() > 0.5 ? 1 : -1,
                        radius: 15
                    });
                }
                updateSourceCount();
            });
        }

        function findNearestSource(x, y) {
            return sources.reduce((nearest, source) => {
                let dist = distance(source, { x, y });
                return (!nearest || dist < distance(nearest, { x, y })) ? source : nearest;
            }, null);
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function addSource(charge) {
            if (sources.length < 8) {
                sources.push({
                    x: mousePos.x || Math.random() * 0.6 + 0.2,
                    y: mousePos.y || Math.random() * 0.6 + 0.2,
                    charge: charge,
                    radius: 15
                });
                updateSourceCount();
            }
        }

        function updateSourceCount() {
            let countEl = document.getElementById('sourceCount');
            if (countEl) countEl.textContent = sources.length;
        }

        function updateFieldInfo() {
            if (currentInterfaceMode !== 'live') return;
            
            let field = computeFieldAt(mousePos.x, mousePos.y);
            
            document.getElementById('cursorPos').textContent = 
                `(${(mousePos.x * 100).toFixed(1)}%, ${(mousePos.y * 100).toFixed(1)}%)`;
            document.getElementById('fieldMag').textContent = field.magnitude.toFixed(3);
            
            let funcValue = 0;
            if (currentMode === 'legendre') {
                let normX = (mousePos.x - 0.5) * 2;
                funcValue = legendrePolynomial(params.order, normX);
            }
            
            document.getElementById('funcValue').textContent = funcValue.toFixed(3);
            document.getElementById('recursionDepth').textContent = params.order;
        }

        // Animation loop
        function animate() {
            animationTime += 16;
            
            if (currentInterfaceMode === 'live') {
                drawField('fieldCanvas', params);
                drawRecursion('recursionCanvas', params);
            } else {
                drawField('docPhysicsCanvas', docParams);
                drawRecursion('docRecursionCanvas', docParams);
            }
            
            requestAnimationFrame(animate);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupLiveEvents();
            updateModeInfo();
            updateSourceCount();
            animate();
        });
    </script>
</body>
</html>