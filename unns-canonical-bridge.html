<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNNS ↔ Canonical Math Bridge Chamber</title>
</head>
<body>
<div class="bridge-chamber-container">
    <style>
        .bridge-chamber-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at center, #0a0b1e, #02030a);
            color: #e2e8f0;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }
        
        .bridge-chamber-container * {
            box-sizing: border-box;
        }
        
        .bridge-header {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.7));
            border-bottom: 2px solid #334155;
            backdrop-filter: blur(10px);
        }
        
        .bridge-title {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0 0 10px 0;
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.4);
            animation: bridge-glow 3s ease-in-out infinite alternate;
        }
        
        @keyframes bridge-glow {
            0% { filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.3)); }
            100% { filter: drop-shadow(0 0 25px rgba(139, 92, 246, 0.6)); }
        }
        
        .bridge-subtitle {
            font-size: 1.1rem;
            color: #94a3b8;
            margin: 0 0 15px 0;
            opacity: 0.9;
        }
        
        .bridge-preamble {
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            font-size: 0.95rem;
            line-height: 1.6;
        }
        
        .preamble-title {
            color: #fbbf24;
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }
        
        .mode-toggle-section {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 25px;
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid #334155;
            flex-wrap: wrap;
        }
        
        .toggle-label {
            font-size: 1.1rem;
            font-weight: bold;
            color: #e2e8f0;
        }
        
        .reality-toggle {
            position: relative;
            width: 200px;
            height: 60px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.9));
            border-radius: 30px;
            border: 2px solid #334155;
            cursor: pointer;
            transition: all 0.4s ease;
            overflow: hidden;
        }
        
        .reality-toggle.metaphor-mode {
            border-color: #8b5cf6;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.4);
        }
        
        .reality-toggle.canonical-mode {
            border-color: #3b82f6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
        }
        
        .toggle-slider {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 92px;
            height: 52px;
            border-radius: 26px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .reality-toggle.metaphor-mode .toggle-slider {
            background: linear-gradient(135deg, #8b5cf6, #a855f7);
            transform: translateX(0);
            color: white;
        }
        
        .reality-toggle.canonical-mode .toggle-slider {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            transform: translateX(100px);
            color: white;
        }
        
        .toggle-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 100%;
            padding: 0 15px;
            pointer-events: none;
        }
        
        .toggle-label-text {
            font-size: 0.8rem;
            font-weight: 600;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        
        .reality-toggle.metaphor-mode .metaphor-label {
            opacity: 0;
        }
        
        .reality-toggle.canonical-mode .canonical-label {
            opacity: 0;
        }
        
        .concept-selector {
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 20px;
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid #334155;
            flex-wrap: wrap;
        }
        
        .concept-tab {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: rgba(30, 41, 59, 0.6);
            color: #94a3b8;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .concept-tab.active {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            border-color: #06b6d4;
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3);
        }
        
        .concept-tab:hover:not(.active) {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border-color: #3b82f6;
        }
        
        .main-workspace {
            display: flex;
            height: calc(100vh - 300px);
        }
        
        .visualization-area {
            flex: 1;
            position: relative;
            background: radial-gradient(ellipse at center, rgba(15, 23, 42, 0.4), rgba(2, 3, 10, 0.8));
            overflow: hidden;
        }
        
        .viz-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .mode-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .mode-indicator.metaphor {
            background: rgba(139, 92, 246, 0.2);
            border: 2px solid #8b5cf6;
            color: #a855f7;
        }
        
        .mode-indicator.canonical {
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid #3b82f6;
            color: #3b82f6;
        }
        
        .control-panel {
            width: 300px;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.9));
            border-left: 2px solid #334155;
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .control-section {
            padding: 20px;
            border-bottom: 1px solid rgba(51, 65, 85, 0.5);
        }
        
        .control-title {
            font-size: 1rem;
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .parameter-group {
            margin-bottom: 15px;
        }
        
        .parameter-label {
            display: block;
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 6px;
            font-weight: 500;
        }
        
        .parameter-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #334155, #475569);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        
        .parameter-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }
        
        .parameter-value {
            float: right;
            font-size: 0.75rem;
            color: #3b82f6;
            font-weight: bold;
        }
        
        .explanation-panel {
            background: rgba(30, 41, 59, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            border-left: 4px solid #3b82f6;
        }
        
        .explanation-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 8px;
        }
        
        .explanation-content {
            font-size: 0.8rem;
            color: #cbd5e1;
            line-height: 1.4;
        }
        
        .metaphor-explanation {
            border-left-color: #8b5cf6;
        }
        
        .metaphor-explanation .explanation-title {
            color: #8b5cf6;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .main-workspace {
                flex-direction: column;
                height: auto;
            }
            
            .control-panel {
                width: 100%;
                height: 250px;
            }
            
            .visualization-area {
                height: 400px;
            }
            
            .bridge-title {
                font-size: 1.8rem;
            }
            
            .reality-toggle {
                width: 160px;
                height: 50px;
            }
            
            .toggle-slider {
                width: 76px;
                height: 42px;
            }
        }
        
        /* Animation classes */
        .breathing {
            animation: breathe 4s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.03); opacity: 1; }
        }
        
        .floating {
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
    </style>
    
    <!-- Header -->
    <div class="bridge-header">
        <h1 class="bridge-title">UNNS ↔ Canonical Math Bridge</h1>
        <p class="bridge-subtitle">Dual-mode interface bridging metaphorical intuition and formal mathematics</p>
        
        <div class="bridge-preamble">
            <div class="preamble-title">🌉 About This Bridge Chamber</div>
            <p>This interface lets you explore mathematical concepts through two complementary lenses:</p>
            <p><strong>Metaphor Mode:</strong> UNNS visualizes mathematical ideas through recursive patterns, visual metaphors, and intuitive representations - a creative "visual grammar" for mathematical emergence.</p>
            <p><strong>Canonical Mode:</strong> Traditional mathematical visualizations using established formulas, proofs, and rigorous mathematical structures.</p>
            <p>Toggle between modes to see how intuitive metaphors connect to formal mathematics.</p>
        </div>
    </div>
    
    <!-- Mode Toggle -->
    <div class="mode-toggle-section">
        <span class="toggle-label">Reality Mode:</span>
        <div class="reality-toggle metaphor-mode" id="realityToggle">
            <div class="toggle-slider">Metaphor</div>
            <div class="toggle-labels">
                <span class="toggle-label-text metaphor-label">🌀 Metaphor</span>
                <span class="toggle-label-text canonical-label">📐 Canonical</span>
            </div>
        </div>
    </div>
    
    <!-- Concept Selector -->
    <div class="concept-selector">
        <button class="concept-tab active" data-concept="prime-density">Prime Density</button>
        <button class="concept-tab" data-concept="golden-ratio">Golden Ratio</button>
        <button class="concept-tab" data-concept="cantor-set">Cantor Set</button>
        <button class="concept-tab" data-concept="recursion">Recursion</button>
        <button class="concept-tab" data-concept="infinity">Infinity</button>
    </div>
    
    <!-- Main Workspace -->
    <div class="main-workspace">
        <div class="visualization-area">
            <canvas class="viz-canvas" id="bridgeCanvas"></canvas>
            <div class="mode-indicator metaphor" id="modeIndicator">🌀 Metaphor Mode</div>
        </div>
        
        <div class="control-panel">
            <div class="control-section">
                <h3 class="control-title">🎛️ Parameters</h3>
                
                <div class="parameter-group">
                    <label class="parameter-label">
                        Intensity
                        <span class="parameter-value" id="intensityValue">1.0</span>
                    </label>
                    <input type="range" class="parameter-slider" id="intensitySlider" min="0.1" max="3" step="0.1" value="1">
                </div>
                
                <div class="parameter-group">
                    <label class="parameter-label">
                        Complexity
                        <span class="parameter-value" id="complexityValue">5</span>
                    </label>
                    <input type="range" class="parameter-slider" id="complexitySlider" min="1" max="12" step="1" value="5">
                </div>
                
                <div class="parameter-group">
                    <label class="parameter-label">
                        Speed
                        <span class="parameter-value" id="speedValue">1.0</span>
                    </label>
                    <input type="range" class="parameter-slider" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
                </div>
            </div>
            
            <div class="control-section" id="explanationSection">
                <div class="explanation-panel" id="explanationPanel">
                    <div class="explanation-title" id="explanationTitle">Prime Density - Metaphor View</div>
                    <div class="explanation-content" id="explanationContent">
                        Watch primes as breathing points in the number line, their density thinning as numbers grow larger. The gaps pulse with the rhythm of mathematical uncertainty.
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
    (function() {
        'use strict';
        
        class BridgeChamber {
            constructor() {
                this.canvas = document.getElementById('bridgeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.mode = 'metaphor'; // 'metaphor' or 'canonical'
                this.concept = 'prime-density';
                this.time = 0;
                this.isRunning = true;
                
                this.params = {
                    intensity: 1.0,
                    complexity: 5,
                    speed: 1.0
                };
                
                this.explanations = {
                    'prime-density': {
                        metaphor: {
                            title: 'Prime Density - Metaphor View',
                            content: 'Watch primes as breathing points in the number line, their density thinning as numbers grow larger. The gaps pulse with the rhythm of mathematical uncertainty.'
                        },
                        canonical: {
                            title: 'Prime Number Theorem - Canonical View',
                            content: 'π(x) ≈ x/ln(x) describes prime distribution. As x increases, primes become rarer, with density approximately 1/ln(x). Each spike represents a prime number.'
                        }
                    },
                    'golden-ratio': {
                        metaphor: {
                            title: 'Golden Flow - Metaphor View',
                            content: 'The golden spiral breathes with perfect proportion, each turn containing the memory of all previous turns. Fibonacci sequences dance in recursive harmony.'
                        },
                        canonical: {
                            title: 'Golden Ratio - Canonical View',
                            content: 'φ = (1+√5)/2 ≈ 1.618. The limit of consecutive Fibonacci ratios. Appears in the golden rectangle, pentagon, and logarithmic spiral with growth factor φ.'
                        }
                    },
                    'cantor-set': {
                        metaphor: {
                            title: 'Infinite Removal - Metaphor View',
                            content: 'Watch a line fragment into infinite dust while maintaining uncountable density. Paradox made visible through recursive deletion.'
                        },
                        canonical: {
                            title: 'Cantor Set - Canonical View',
                            content: 'Constructed by repeatedly removing middle thirds: [0,1] → [0,1/3]∪[2/3,1] → ... Result: uncountably infinite but zero measure. A fractal with dimension log(2)/log(3).'
                        }
                    },
                    'recursion': {
                        metaphor: {
                            title: 'Self-Similarity - Metaphor View',
                            content: 'Patterns that contain themselves, breathing in and out through scales. Each layer holds the echo of the whole.'
                        },
                        canonical: {
                            title: 'Mathematical Recursion - Canonical View',
                            content: 'f(n) = g(f(n-1), n) with base case f(0) = c. Examples: factorial n! = n·(n-1)!, Fibonacci F(n) = F(n-1) + F(n-2). Self-referential definitions.'
                        }
                    },
                    'infinity': {
                        metaphor: {
                            title: 'Boundless Horizon - Metaphor View',
                            content: 'Different infinities dance at different scales. Countable dots stretch toward uncountable continuums in endless expansion.'
                        },
                        canonical: {
                            title: 'Mathematical Infinity - Canonical View',
                            content: 'ℵ₀ (aleph-null): cardinality of natural numbers. 2^ℵ₀ = ℵ₁: cardinality of real numbers. Cantor\'s diagonal proof shows ℵ₀ < 2^ℵ₀.'
                        }
                    }
                };
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupControls();
                this.updateExplanation();
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            setupControls() {
                // Reality toggle
                const toggle = document.getElementById('realityToggle');
                toggle.addEventListener('click', () => {
                    this.toggleMode();
                });
                
                // Concept tabs
                document.querySelectorAll('.concept-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.concept-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        this.concept = tab.dataset.concept;
                        this.updateExplanation();
                    });
                });
                
                // Parameter sliders
                const sliders = [
                    {id: 'intensitySlider', param: 'intensity', display: 'intensityValue', decimals: 1},
                    {id: 'complexitySlider', param: 'complexity', display: 'complexityValue', decimals: 0},
                    {id: 'speedSlider', param: 'speed', display: 'speedValue', decimals: 1}
                ];
                
                sliders.forEach(({id, param, display, decimals}) => {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(display);
                    
                    slider.addEventListener('input', () => {
                        const value = parseFloat(slider.value);
                        this.params[param] = value;
                        valueDisplay.textContent = decimals === 0 ? value.toString() : value.toFixed(decimals);
                    });
                });
            }
            
            toggleMode() {
                this.mode = this.mode === 'metaphor' ? 'canonical' : 'metaphor';
                
                const toggle = document.getElementById('realityToggle');
                const indicator = document.getElementById('modeIndicator');
                const explanationPanel = document.getElementById('explanationPanel');
                
                if (this.mode === 'metaphor') {
                    toggle.className = 'reality-toggle metaphor-mode';
                    toggle.querySelector('.toggle-slider').textContent = 'Metaphor';
                    indicator.className = 'mode-indicator metaphor';
                    indicator.textContent = '🌀 Metaphor Mode';
                    explanationPanel.className = 'explanation-panel metaphor-explanation';
                } else {
                    toggle.className = 'reality-toggle canonical-mode';
                    toggle.querySelector('.toggle-slider').textContent = 'Canonical';
                    indicator.className = 'mode-indicator canonical';
                    indicator.textContent = '📐 Canonical Mode';
                    explanationPanel.className = 'explanation-panel';
                }
                
                this.updateExplanation();
            }
            
            updateExplanation() {
                const explanation = this.explanations[this.concept][this.mode];
                document.getElementById('explanationTitle').textContent = explanation.title;
                document.getElementById('explanationContent').textContent = explanation.content;
            }
            
            // Visualization methods for each concept
            drawPrimeDensity() {
                const ctx = this.ctx;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                if (this.mode === 'metaphor') {
                    this.drawPrimeDensityMetaphor(ctx, centerX, centerY);
                } else {
                    this.drawPrimeDensityCanonical(ctx, centerX, centerY);
                }
            }
            
            drawPrimeDensityMetaphor(ctx, centerX, centerY) {
                // Breathing number line with prime "souls"
                const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];
                const lineLength = Math.min(this.canvas.width * 0.8, 800);
                const startX = centerX - lineLength / 2;
                
                // Breathing baseline
                const breathe = 1 + Math.sin(this.time * 0.02 * this.params.speed) * 0.1;
                const baseY = centerY + 50;
                
                // Number line
                ctx.strokeStyle = `rgba(100, 116, 139, ${0.3 * this.params.intensity})`;
                ctx.lineWidth = 3 * breathe;
                ctx.beginPath();
                ctx.moveTo(startX, baseY);
                ctx.lineTo(startX + lineLength, baseY);
                ctx.stroke();
                
                // Prime souls
                primes.forEach((prime, i) => {
                    const x = startX + (prime / 100) * lineLength;
                    if (x > startX + lineLength) return;
                    
                    const soulSize = (8 + Math.sin(this.time * 0.03 + i) * 4) * this.params.intensity;
                    const density = 1 / Math.log(prime);
                    const alpha = (density * 3 + 0.2) * this.params.intensity;
                    
                    // Soul glow
                    const gradient = ctx.createRadialGradient(x, baseY, 0, x, baseY, soulSize * 2);
                    gradient.addColorStop(0, `rgba(139, 92, 246, ${alpha})`);
                    gradient.addColorStop(1, `rgba(139, 92, 246, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, baseY, soulSize * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Soul core
                    ctx.fillStyle = `rgba(139, 92, 246, ${alpha + 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, baseY, soulSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Breathing connections
                    if (i > 0) {
                        const prevPrime = primes[i-1];
                        const prevX = startX + (prevPrime / 100) * lineLength;
                        const gap = prime - prevPrime;
                        const connectionAlpha = Math.max(0.1, (10 - gap) / 10) * this.params.intensity * 0.3;
                        
                        ctx.strokeStyle = `rgba(251, 191, 36, ${connectionAlpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(prevX, baseY - 20);
                        ctx.quadraticCurveTo((prevX + x) / 2, baseY - 40, x, baseY - 20);
                        ctx.stroke();
                    }
                });
                
                // Density visualization as fading particles
                for (let n = 10; n <= 100; n += 5) {
                    const x = startX + (n / 100) * lineLength;
                    const density = n / Math.log(n);
                    const particleCount = Math.floor(density / 8);
                    
                    for (let p = 0; p < particleCount; p++) {
                        const particleX = x + (Math.random() - 0.5) * 30;
                        const particleY = baseY + (Math.random() - 0.5) * 80;
                        const particleAlpha = (Math.random() * 0.3 + 0.1) * this.params.intensity;
                        
                        ctx.fillStyle = `rgba(6, 182, 212, ${particleAlpha})`;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            drawPrimeDensityCanonical(ctx, centerX, centerY) {
                // Mathematical prime counting function π(x) ≈ x/ln(x)
                const maxN = 100;
                const scale = Math.min(this.canvas.width * 0.4, 300);
                const startX = centerX - scale;
                const baseY = centerY + scale / 2;
                
                // Axes
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(startX, baseY);
                ctx.lineTo(startX + scale * 2, baseY);
                ctx.moveTo(startX, baseY);
                ctx.lineTo(startX, baseY - scale);
                ctx.stroke();
                
                // Axis labels
                ctx.fillStyle = '#94a3b8';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('n', startX + scale * 2 + 15, baseY + 5);
                ctx.save();
                ctx.translate(startX - 15, baseY - scale / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('π(n)', 0, 0);
                ctx.restore();
                
                // Prime counting function π(x)
                const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];
                let primeCount = 0;
                
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let n = 2; n <= maxN; n++) {
                    if (primes.includes(n)) {
                        primeCount++;
                        
                        // Mark actual primes
                        const x = startX + (n / maxN) * scale * 2;
                        const y = baseY - (primeCount / 25) * scale;
                        
                        ctx.fillStyle = '#ef4444';
                        ctx.beginPath();
                        ctx.arc(x, y, 3 * this.params.intensity, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    const x = startX + (n / maxN) * scale * 2;
                    const actualY = baseY - (primeCount / 25) * scale;
                    
                    if (n === 2) ctx.moveTo(x, actualY);
                    else ctx.lineTo(x, actualY);
                }
                ctx.stroke();
                
                // Theoretical approximation x/ln(x)
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                for (let n = 2; n <= maxN; n += 2) {
                    const x = startX + (n / maxN) * scale * 2;
                    const approx = n / Math.log(n);
                    const y = baseY - (approx / 25) * scale;
                    
                    if (n === 2) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Legend
                ctx.font = '11px monospace';
                ctx.fillStyle = '#3b82f6';
                ctx.textAlign = 'left';
                ctx.fillText('π(x) - actual count', startX + 10, baseY - scale + 20);
                ctx.fillStyle = '#fbbf24';
                ctx.fillText('x/ln(x) - approximation', startX + 10, baseY - scale + 35);
                ctx.fillStyle = '#ef4444';
                ctx.fillText('• prime numbers', startX + 10, baseY - scale + 50);
            }
            
            drawGoldenRatio() {
                const ctx = this.ctx;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                if (this.mode === 'metaphor') {
                    this.drawGoldenRatioMetaphor(ctx, centerX, centerY);
                } else {
                    this.drawGoldenRatioCanonical(ctx, centerX, centerY);
                }
            }
            
            drawGoldenRatioMetaphor(ctx, centerX, centerY) {
                // Golden spiral that breathes and flows
                const phi = 1.618033988749;
                const breathe = 1 + Math.sin(this.time * 0.02 * this.params.speed) * 0.15;
                
                ctx.strokeStyle = `rgba(251, 191, 36, ${0.8 * this.params.intensity})`;
                ctx.lineWidth = 3 * breathe;
                ctx.beginPath();
                
                let angle = this.time * 0.01 * this.params.speed;
                let radius = 5;
                let x = centerX;
                let y = centerY;
                
                ctx.moveTo(x, y);
                
                for (let i = 0; i < 120; i++) {
                    x = centerX + Math.cos(angle) * radius * breathe;
                    y = centerY + Math.sin(angle) * radius * breathe;
                    ctx.lineTo(x, y);
                    
                    angle += 0.15;
                    radius *= Math.pow(phi, 0.05);
                    
                    if (radius > Math.min(this.canvas.width, this.canvas.height) * 0.4) break;
                }
                ctx.stroke();
                
                // Fibonacci rectangles that pulse
                const fib = [1, 1, 2, 3, 5, 8, 13, 21];
                let rectX = centerX - 50;
                let rectY = centerY - 30;
                let size = 10;
                
                fib.forEach((f, i) => {
                    const pulse = 1 + Math.sin(this.time * 0.03 + i * 0.5) * 0.1;
                    const currentSize = f * size * pulse * (this.params.complexity / 5);
                    
                    if (currentSize > 200) return;
                    
                    ctx.strokeStyle = `rgba(139, 92, 246, ${(0.6 - i * 0.05) * this.params.intensity})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(rectX, rectY, currentSize, currentSize);
                    
                    // Flowing connection
                    const nextSize = i < fib.length - 1 ? fib[i + 1] * size * pulse : 0;
                    if (nextSize && nextSize <= 200) {
                        ctx.strokeStyle = `rgba(6, 182, 212, ${0.4 * this.params.intensity})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(rectX + currentSize / 2, rectY + currentSize / 2);
                        ctx.lineTo(rectX + nextSize / 2, rectY + nextSize / 2);
                        ctx.stroke();
                    }
                    
                    rectX += currentSize * 0.3;
                    rectY += currentSize * 0.2;
                });
                
                // Golden proportion visualization
                const bar1 = 100 * this.params.intensity;
                const bar2 = bar1 / phi;
                const pulsePhase = Math.sin(this.time * 0.025) * 0.2 + 1;
                
                ctx.fillStyle = `rgba(251, 191, 36, ${0.6 * pulsePhase})`;
                ctx.fillRect(centerX - bar1/2, centerY + 150, bar1, 8);
                
                ctx.fillStyle = `rgba(139, 92, 246, ${0.6 * pulsePhase})`;
                ctx.fillRect(centerX - bar1/2, centerY + 165, bar2, 8);
                
                // Ratio display
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`φ = ${phi.toFixed(3)}`, centerX, centerY + 195);
            }
            
            drawGoldenRatioCanonical(ctx, centerX, centerY) {
                // Mathematical golden ratio construction and properties
                const phi = (1 + Math.sqrt(5)) / 2;
                
                // Golden rectangle construction
                const rectWidth = 200;
                const rectHeight = rectWidth / phi;
                const rectX = centerX - rectWidth / 2;
                const rectY = centerY - rectHeight / 2;
                
                // Main rectangle
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
                
                // Square portion
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.strokeRect(rectX, rectY, rectHeight, rectHeight);
                
                // Remaining rectangle
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.strokeRect(rectX + rectHeight, rectY, rectWidth - rectHeight, rectHeight);
                
                // Golden spiral
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                this.drawCanonicalSpiral(ctx, rectX, rectY, rectHeight, 5);
                
                // Labels and measurements
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                
                // φ label
                ctx.fillText('φ', rectX + rectWidth / 2, rectY - 10);
                
                // 1 label
                ctx.fillText('1', rectX + rectHeight / 2, rectY + rectHeight + 20);
                
                // Mathematical definition
                ctx.fillStyle = '#94a3b8';
                ctx.font = '14px monospace';
                ctx.textAlign = 'left';
                const defX = rectX + rectWidth + 30;
                ctx.fillText('φ = (1 + √5) / 2', defX, rectY + 20);
                ctx.fillText(`≈ ${phi.toFixed(6)}`, defX, rectY + 40);
                ctx.fillText('φ² = φ + 1', defX, rectY + 70);
                ctx.fillText('1/φ = φ - 1', defX, rectY + 90);
                
                // Fibonacci sequence convergence
                const fib = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
                ctx.fillStyle = '#8b5cf6';
                ctx.font = '11px monospace';
                ctx.fillText('Fibonacci ratios:', defX, rectY + 120);
                
                for (let i = 1; i < Math.min(6, fib.length); i++) {
                    const ratio = fib[i] / fib[i-1];
                    const error = Math.abs(ratio - phi);
                    ctx.fillText(`F${i+1}/F${i} = ${ratio.toFixed(4)} (ε=${error.toFixed(3)})`, defX, rectY + 135 + i * 15);
                }
            }
            
            drawCanonicalSpiral(ctx, x, y, size, iterations) {
                if (iterations <= 0 || size < 2) return;
                
                const phi = 1.618033988749;
                
                // Draw quarter circle
                ctx.beginPath();
                ctx.arc(x + size, y + size, size, Math.PI, 3 * Math.PI / 2);
                ctx.stroke();
                
                // Next iteration
                const nextSize = size / phi;
                this.drawCanonicalSpiral(ctx, x + size - nextSize, y, nextSize, iterations - 1);
            }
            
            drawCantorSet() {
                const ctx = this.ctx;
                const centerY = this.canvas.height / 2;
                
                if (this.mode === 'metaphor') {
                    this.drawCantorSetMetaphor(ctx, centerY);
                } else {
                    this.drawCantorSetCanonical(ctx, centerY);
                }
            }
            
            drawCantorSetMetaphor(ctx, centerY) {
                // Cantor dust visualization with mystical disappearing effect
                const width = Math.min(this.canvas.width * 0.8, 600);
                const startX = (this.canvas.width - width) / 2;
                const iterations = Math.min(this.params.complexity, 7);
                
                // Background "whole" line that fades
                const wholeness = Math.max(0, 1 - this.time * 0.005);
                ctx.strokeStyle = `rgba(100, 116, 139, ${wholeness * 0.3})`;
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(startX, centerY - 150);
                ctx.lineTo(startX + width, centerY - 150);
                ctx.stroke();
                
                // Iterative removal visualization
                let segments = [[0, 1]];
                
                for (let iteration = 0; iteration < iterations; iteration++) {
                    const y = centerY - 120 + iteration * 35;
                    const fade = Math.sin(this.time * 0.02 + iteration) * 0.3 + 0.7;
                    const thickness = Math.max(1, 6 - iteration);
                    
                    // Draw current segments
                    ctx.strokeStyle = `rgba(251, 191, 36, ${fade * this.params.intensity})`;
                    ctx.lineWidth = thickness;
                    
                    segments.forEach(([start, end]) => {
                        const segStart = startX + start * width;
                        const segEnd = startX + end * width;
                        const breathe = 1 + Math.sin(this.time * 0.03 + start * 10) * 0.05;
                        
                        ctx.beginPath();
                        ctx.moveTo(segStart, y);
                        ctx.lineTo(segEnd, y * breathe);
                        ctx.stroke();
                    });
                    
                    // Generate next iteration
                    const newSegments = [];
                    segments.forEach(([start, end]) => {
                        const third = (end - start) / 3;
                        newSegments.push([start, start + third]);
                        newSegments.push([end - third, end]);
                    });
                    segments = newSegments;
                    
                    // Vanishing particles in removed sections
                    const removedThird = (1 - 0) / Math.pow(3, iteration + 1);
                    for (let i = 0; i < segments.length - 1; i += 2) {
                        if (i + 1 < segments.length) {
                            const gapStart = startX + segments[i][1] * width;
                            const gapEnd = startX + segments[i + 1][0] * width;
                            
                            // Particle dust
                            for (let p = 0; p < 8; p++) {
                                const particleX = gapStart + Math.random() * (gapEnd - gapStart);
                                const particleY = y + (Math.random() - 0.5) * 20;
                                const particleAlpha = Math.random() * 0.4 + 0.1;
                                
                                ctx.fillStyle = `rgba(239, 68, 68, ${particleAlpha * this.params.intensity})`;
                                ctx.beginPath();
                                ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                }
                
                // Final dust cloud
                const finalY = centerY - 120 + iterations * 35 + 50;
                ctx.fillStyle = `rgba(139, 92, 246, ${0.4 * this.params.intensity})`;
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Infinite Dust', this.canvas.width / 2, finalY);
                ctx.font = '11px monospace';
                ctx.fillText('(Uncountably infinite points)', this.canvas.width / 2, finalY + 20);
                ctx.fillText('(Zero total length)', this.canvas.width / 2, finalY + 35);
            }
            
            drawCantorSetCanonical(ctx, centerY) {
                // Mathematical Cantor set construction
                const width = Math.min(this.canvas.width * 0.8, 600);
                const startX = (this.canvas.width - width) / 2;
                const iterations = Math.min(this.params.complexity, 6);
                
                // Title
                ctx.fillStyle = '#3b82f6';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Cantor Set Construction', this.canvas.width / 2, centerY - 180);
                
                // Initial interval [0,1]
                let segments = [[0, 1]];
                
                for (let iteration = 0; iteration <= iterations; iteration++) {
                    const y = centerY - 150 + iteration * 25;
                    
                    // Iteration label
                    ctx.fillStyle = '#94a3b8';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(`C${iteration}`, startX - 30, y + 5);
                    
                    // Draw segments
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 4;
                    
                    segments.forEach(([start, end]) => {
                        const segStart = startX + start * width;
                        const segEnd = startX + end * width;
                        
                        ctx.beginPath();
                        ctx.moveTo(segStart, y);
                        ctx.lineTo(segEnd, y);
                        ctx.stroke();
                        
                        // Endpoint markers
                        ctx.fillStyle = '#ef4444';
                        ctx.beginPath();
                        ctx.arc(segStart, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(segEnd, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Show removed middle thirds
                    if (iteration < iterations) {
                        const newSegments = [];
                        segments.forEach(([start, end]) => {
                            const third = (end - start) / 3;
                            
                            // Mark removed section
                            const removedStart = startX + (start + third) * width;
                            const removedEnd = startX + (end - third) * width;
                            
                            ctx.fillStyle = 'rgba(239, 68, 68, 0.2)';
                            ctx.fillRect(removedStart, y - 8, removedEnd - removedStart, 16);
                            
                            newSegments.push([start, start + third]);
                            newSegments.push([end - third, end]);
                        });
                        segments = newSegments;
                    }
                    
                    // Statistics
                    const totalLength = segments.reduce((sum, [start, end]) => sum + (end - start), 0);
                    const numSegments = segments.length;
                    
                    ctx.fillStyle = '#22c55e';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${numSegments} segments`, startX + width + 80, y - 5);
                    ctx.fillText(`length = ${totalLength.toFixed(4)}`, startX + width + 80, y + 8);
                }
                
                // Properties
                const propsY = centerY + 50;
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'left';
                ctx.fillText('Properties:', startX, propsY);
                
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '11px monospace';
                const props = [
                    '• Fractal dimension = log(2)/log(3) ≈ 0.631',
                    '• Total measure = 0 (zero length)',
                    '• Cardinality = 2^ℵ₀ (uncountably infinite)',
                    '• Perfect set (closed, no isolated points)',
                    '• Self-similar at all scales'
                ];
                
                props.forEach((prop, i) => {
                    ctx.fillText(prop, startX, propsY + 20 + i * 15);
                });
            }
            
            drawRecursion() {
                const ctx = this.ctx;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                if (this.mode === 'metaphor') {
                    this.drawRecursionMetaphor(ctx, centerX, centerY);
                } else {
                    this.drawRecursionCanonical(ctx, centerX, centerY);
                }
            }
            
            drawRecursionMetaphor(ctx, centerX, centerY) {
                // Recursive circles that breathe and contain themselves
                const maxDepth = Math.min(this.params.complexity, 8);
                const baseRadius = Math.min(this.canvas.width, this.canvas.height) * 0.15;
                
                this.drawRecursiveCircle(ctx, centerX, centerY, baseRadius, maxDepth, 0);
                
                // Infinite regression text
                ctx.fillStyle = `rgba(251, 191, 36, ${0.8 * this.params.intensity})`;
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('∞ Self-Similarity ∞', centerX, centerY + baseRadius + 50);
            }
            
            drawRecursiveCircle(ctx, x, y, radius, depth, generation) {
                if (depth <= 0 || radius < 3) return;
                
                const breathe = 1 + Math.sin(this.time * 0.02 * this.params.speed + generation * 0.5) * 0.1;
                const currentRadius = radius * breathe;
                const alpha = Math.max(0.2, 1 - generation * 0.15);
                
                // Main circle
                ctx.strokeStyle = `rgba(139, 92, 246, ${alpha * this.params.intensity})`;
                ctx.lineWidth = Math.max(1, 3 - generation * 0.3);
                ctx.beginPath();
                ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner pattern
                const pattern = 3 + Math.floor(generation * 0.5);
                const innerRadius = currentRadius * 0.4;
                
                for (let i = 0; i < pattern; i++) {
                    const angle = (i / pattern) * Math.PI * 2 + this.time * 0.005 * (generation + 1);
                    const innerX = x + Math.cos(angle) * innerRadius;
                    const innerY = y + Math.sin(angle) * innerRadius;
                    const childRadius = currentRadius * 0.3;
                    
                    this.drawRecursiveCircle(ctx, innerX, innerY, childRadius, depth - 1, generation + 1);
                }
                
                // Central mystery
                if (generation === 0) {
                    ctx.fillStyle = `rgba(251, 191, 36, ${0.6 * this.params.intensity})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 5 * breathe, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            drawRecursionCanonical(ctx, centerX, centerY) {
                // Mathematical recursion examples
                ctx.fillStyle = '#3b82f6';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Mathematical Recursion', centerX, centerY - 180);
                
                // Factorial example
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '12px monospace';
                ctx.textAlign = 'left';
                const leftX = centerX - 250;
                let currentY = centerY - 140;
                
                ctx.fillText('Factorial:', leftX, currentY);
                ctx.fillText('n! = n × (n-1)!', leftX, currentY + 20);
                ctx.fillText('0! = 1 (base case)', leftX, currentY + 35);
                
                // Show calculation
                ctx.fillStyle = '#22c55e';
                ctx.fillText('5! = 5 × 4!', leftX + 20, currentY + 60);
                ctx.fillText('   = 5 × (4 × 3!)', leftX + 20, currentY + 75);
                ctx.fillText('   = 5 × 4 × (3 × 2!)', leftX + 20, currentY + 90);
                ctx.fillText('   = 5 × 4 × 3 × (2 × 1!)', leftX + 20, currentY + 105);
                ctx.fillText('   = 5 × 4 × 3 × 2 × (1 × 0!)', leftX + 20, currentY + 120);
                ctx.fillText('   = 5 × 4 × 3 × 2 × 1 × 1', leftX + 20, currentY + 135);
                ctx.fillText('   = 120', leftX + 20, currentY + 150);
                
                // Fibonacci example
                const rightX = centerX + 50;
                currentY = centerY - 140;
                
                ctx.fillStyle = '#e2e8f0';
                ctx.fillText('Fibonacci:', rightX, currentY);
                ctx.fillText('F(n) = F(n-1) + F(n-2)', rightX, currentY + 20);
                ctx.fillText('F(0) = 0, F(1) = 1', rightX, currentY + 35);
                
                // Show sequence
                const fib = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34];
                ctx.fillStyle = '#fbbf24';
                for (let i = 0; i < fib.length; i++) {
                    ctx.fillText(`F(${i}) = ${fib[i]}`, rightX + 20, currentY + 60 + i * 15);
                }
                
                // Recursive tree visualization
                this.drawRecursionTree(ctx, centerX, centerY + 80, 60, 5);
            }
            
            drawRecursionTree(ctx, x, y, length, depth) {
                if (depth <= 0) return;
                
                const angle1 = -Math.PI / 6;
                const angle2 = Math.PI / 6;
                const reduction = 0.7;
                
                // Draw branches
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = Math.max(1, depth);
                
                const x1 = x + Math.cos(angle1) * length;
                const y1 = y + Math.sin(angle1) * length;
                const x2 = x + Math.cos(angle2) * length;
                const y2 = y + Math.sin(angle2) * length;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x1, y1);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // Recursive calls
                this.drawRecursionTree(ctx, x1, y1, length * reduction, depth - 1);
                this.drawRecursionTree(ctx, x2, y2, length * reduction, depth - 1);
            }
            
            drawInfinity() {
                const ctx = this.ctx;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                if (this.mode === 'metaphor') {
                    this.drawInfinityMetaphor(ctx, centerX, centerY);
                } else {
                    this.drawInfinityCanonical(ctx, centerX, centerY);
                }
            }
            
            drawInfinityMetaphor(ctx, centerX, centerY) {
                // Different scales of infinity dancing together
                const time = this.time * 0.01 * this.params.speed;
                
                // Countable infinity - discrete dots in spiral
                const countableRadius = 80;
                const countableDots = 30;
                
                for (let i = 0; i < countableDots; i++) {
                    const angle = (i / countableDots) * Math.PI * 4 + time;
                    const r = countableRadius * (i / countableDots);
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    const pulse = 1 + Math.sin(time * 3 + i) * 0.3;
                    const size = 3 * pulse * this.params.intensity;
                    
                    ctx.fillStyle = `rgba(59, 130, 246, ${0.8 * this.params.intensity})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Uncountable infinity - continuous flow
                const uncountableRadius = 150;
                const flowDensity = 200;
                
                for (let i = 0; i < flowDensity; i++) {
                    const angle = (i / flowDensity) * Math.PI * 2;
                    const r = uncountableRadius + Math.sin(time * 2 + angle * 3) * 20;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    const alpha = (Math.sin(time + angle * 5) * 0.3 + 0.4) * this.params.intensity;
                    
                    ctx.fillStyle = `rgba(139, 92, 246, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Infinity symbol that breathes
                const infRadius = 60;
                const breathe = 1 + Math.sin(time * 2) * 0.2;
                
                ctx.strokeStyle = `rgba(251, 191, 36, ${0.8 * this.params.intensity})`;
                ctx.lineWidth = 4 * breathe;
                ctx.beginPath();
                
                for (let t = 0; t < Math.PI * 2; t += 0.1) {
                    const x = centerX + infRadius * Math.cos(t) * breathe;
                    const y = centerY + (infRadius / 2) * Math.sin(2 * t) * breathe;
                    
                    if (t === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Hierarchy labels
                ctx.fillStyle = '#3b82f6';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('ℵ₀ (Countable)', centerX, centerY - 120);
                
                ctx.fillStyle = '#8b5cf6';
                ctx.fillText('2^ℵ₀ (Uncountable)', centerX, centerY + 200);
                
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 16px monospace';
                ctx.fillText('∞', centerX, centerY + 20);
            }
            
            drawInfinityCanonical(ctx, centerX, centerY) {
                // Cantor's hierarchy of infinities
                ctx.fillStyle = '#3b82f6';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Hierarchy of Infinities', centerX, centerY - 180);
                
                // Aleph hierarchy
                const alephs = [
                    { symbol: 'ℵ₀', name: 'Aleph-null', description: 'Cardinality of ℕ, ℤ, ℚ', example: 'Natural numbers: 1,2,3,...' },
                    { symbol: '2^ℵ₀', name: 'Continuum', description: 'Cardinality of ℝ, power set of ℕ', example: 'Real numbers [0,1]' },
                    { symbol: 'ℵ₁', name: 'Aleph-one', description: 'Next larger cardinal', example: 'First uncountable ordinal' },
                    { symbol: '2^(2^ℵ₀)', name: 'Power continuum', description: 'Power set of reals', example: 'Set of all functions ℝ→ℝ' }
                ];
                
                alephs.forEach((aleph, i) => {
                    const y = centerY - 120 + i * 60;
                    const boxHeight = 50;
                    const boxWidth = this.canvas.width * 0.7;
                    const boxX = centerX - boxWidth / 2;
                    
                    // Box
                    ctx.strokeStyle = '#334155';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(boxX, y - boxHeight/2, boxWidth, boxHeight);
                    
                    // Fill with appropriate "density"
                    const alpha = 0.1 + i * 0.1;
                    ctx.fillStyle = `rgba(59, 130, 246, ${alpha})`;
                    ctx.fillRect(boxX, y - boxHeight/2, boxWidth, boxHeight);
                    
                    // Symbol
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = 'bold 18px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(aleph.symbol, boxX + 20, y);
                    
                    // Name and description
                    ctx.fillStyle = '#e2e8f0';
                    ctx.font = 'bold 12px monospace';
                    ctx.fillText(aleph.name, boxX + 100, y - 8);
                    
                    ctx.fillStyle = '#cbd5e1';
                    ctx.font = '10px monospace';
                    ctx.fillText(aleph.description, boxX + 100, y + 8);
                    ctx.fillText(aleph.example, boxX + 100, y + 20);
                });
                
                // Cantor's diagonal argument visualization
                this.drawCantorDiagonal(ctx, centerX + 200, centerY - 60);
                
                // Relationships
                ctx.fillStyle = '#22c55e';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                
                const relations = [
                    'ℵ₀ < 2^ℵ₀',
                    '2^ℵ₀ = ℵ₁ ?', 
                    '(Continuum Hypothesis)'
                ];
                
                relations.forEach((rel, i) => {
                    ctx.fillText(rel, centerX - 150, centerY + 120 + i * 20);
                });
            }
            
            drawCantorDiagonal(ctx, startX, startY) {
                // Simplified diagonal argument
                const cellSize = 15;
                const size = 6;
                
                ctx.fillStyle = '#94a3b8';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Cantor\'s Diagonal', startX + size * cellSize / 2, startY - 10);
                
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const x = startX + j * cellSize;
                        const y = startY + i * cellSize;
                        
                        // Diagonal elements
                        if (i === j) {
                            ctx.fillStyle = '#ef4444';
                            ctx.fillRect(x, y, cellSize, cellSize);
                            ctx.fillStyle = '#ffffff';
                            ctx.textAlign = 'center';
                            ctx.fillText('1', x + cellSize/2, y + cellSize/2 + 2);
                        } else {
                            ctx.fillStyle = '#334155';
                            ctx.fillRect(x, y, cellSize, cellSize);
                            ctx.fillStyle = '#94a3b8';
                            ctx.textAlign = 'center';
                            ctx.fillText('0', x + cellSize/2, y + cellSize/2 + 2);
                        }
                        
                        ctx.strokeStyle = '#1e293b';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, cellSize, cellSize);
                    }
                }
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Background grid
                this.drawBackgroundGrid();
                
                // Main visualization based on concept
                switch (this.concept) {
                    case 'prime-density':
                        this.drawPrimeDensity();
                        break;
                    case 'golden-ratio':
                        this.drawGoldenRatio();
                        break;
                    case 'cantor-set':
                        this.drawCantorSet();
                        break;
                    case 'recursion':
                        this.drawRecursion();
                        break;
                    case 'infinity':
                        this.drawInfinity();
                        break;
                }
            }
            
            drawBackgroundGrid() {
                this.ctx.save();
                this.ctx.globalAlpha = 0.02;
                this.ctx.strokeStyle = '#475569';
                this.ctx.lineWidth = 1;
                
                const gridSize = 40;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }
            
            animate() {
                this.time += this.params.speed;
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new BridgeChamber());
        } else {
            new BridgeChamber();
        }
    })();
    </script>
</div>
</body>
</html>